---
title: "Compilation methods for Hamiltonian simulation circuits"
sidebar_label: "Compilation methods for Hamiltonian simulation circuits"
description: "This tutorial provides a comparative overview of three compilation methods in Qiskit for Hamiltonian simulation workloads."
notebook_path: "docs/tutorials/compilation-methods-for-hamiltonian-simulation-circuits.ipynb"
---
{/* doqumentation-source-hash: ff66bde1 */}

<OpenInLabBanner notebookPath="docs/tutorials/compilation-methods-for-hamiltonian-simulation-circuits.ipynb" />



Jeschätzte QPU-Nutzung: et wood nix usjeföhrt en däm Tutorial, well et sech op dä Transpilationsprozess konzentrieht.

{/* cspell:ignore Rustiq, nshuffles, edgecolors, edgecolor, Hamlib, Benchpress, Brugière, Goubault, Martiel, Dubal, Lishman, Ivrii, fontweight, fontsize, textprops, wedgeprops, startangle, autopct */}
## Hintergrund {#background}

Quanteschaltongskompilatschon es ene wichtije Schrett em Quantencomputing-Workflow. Se ömfasst de Transformation vun enem huhreije Quantenalgorithmus en en physische Quanteschaltong, die de Beschränkonge vun dä Ziel-Quantenhardware entsprech. Effektive Kompilatschon kann de Leistong vun Quantenalgorithme erheblich beenflusse, indem se Schaltongsdöppe, Gate-Aanzahl un Usföhrongszick reduzeeht. Dat Tutorial ongersöök drei ongerscheedliche Aansätze zor Quanteschaltongskompilatschon en Qiskit un zeich ehr Stärke un Aanwändunge durch praktische Beispille op.

Dat Ziel vun däm Tutorial es et, de Benotzer beizebränge, wi se drei Kompilierungsmethode en Qiskit aanwände un bewerte: dä SABRE-Transpiler, dä AI-jestötzte Transpiler un et Rustiq-Plugin. De Benotzer liere, wi se jede Methode effektiv ensetze un wi se de Leistong övver verschiedene Quanteschaltunge bovver benchmarke. Am Eng vun däm Tutorial künne de Benotzer en dä Laach sin, Kompilierungsstrategieje ussjewählt op spezifische Optimierungsziele – wi de Reduzierung vun dä Schaltongsdöppe, de Minimierung vun dä Gate-Aanzahl udder de Verbesserung vun dä Laufzick.

### Wat de liere weed {#what-you-will-learn}
- **Wi mer dä Qiskit-Transpiler met SABRE för Layout- un Routing-Optimierung bruche.**
- **Wi mer dä AI-Transpiler för fottjeschreddene, automatiseerde Schaltongoptimierung notze.**
- **Wi mer et Rustiq-Plugin för Schaltunge ensetze, die en präzise Synthese vun Operatione bruche, besönders bei Hamilton-Simulationsopjaave.**

Dat Tutorial brucht drei Beispielschaltunge noh däm [Qiskit Patterns](/guides/intro-to-patterns)-Workflow, öm de Leistong vun jedere Kompilierungsmethode ze veranschauliche. Am Eng vun däm Tutorial künne de Benotzer en dä Laach sin, de jeeignte Kompilierungsstrategie ussjebaseeht op ehr spezifische Aanforderunge un Beschränkonge ze wähle.

### Övverbleck övver Kompilierungsmethode {#compilation-methods-overview}

#### 1. **Qiskit-Transpiler met SABRE** {#1-qiskit-transpiler-with-sabre}
Dä Qiskit-Transpiler brucht dä SABRE (SWAP-based BidiREctional heuristic search)-Algorithmus zor Optimierung vun Schaltongslayout un -routing. SABRE konzentrieht sech op de Minimierung vun SWAP-Gates un dänne ehr Usswerkonge op de Schaltongsdöppe, während Hardware-Konnektivitätsbeschränkonge enjehalte weede. Die Methode es huh vielseitich un för allgemeine Schaltongoptimierung jeeignet un beed en Jleichjewich zwesche Leistong un Rechezigg. Öm de neueste Verbesserunge en SABRE ze notze, die en [\[1\]](https://arxiv.org/abs/2409.08368) detailleeht beschrivve sin, kann mer de Aanzahl vun de Versöök erhöhe (zom Beispill `layout_trials=400, swap_trials=400`). För de Zwecke vun däm Tutorial brauche mer de Standardwäät för de Aanzahl vun de Versöök, öm met däm Standard-Transpiler vun Qiskit ze verjlieche. De Vördeile un Parameter-Exploratijon vun SABRE weede en enem separate [Deep-Dive-Tutorial](/tutorials/transpilation-optimizations-with-sabre) behandelt.

#### 2. **AI-Transpiler**

Dä AI-jestötzte Transpiler en Qiskit brucht maschinelles Liere, öm optimale Transpilatsjonsstrategieje vörherzesaare, indem hä Muster en dä Schaltongstruktur un Hardware-Beschränkonge analyseeht, öm de beste Sequenz vun Optimierunge för en jejovvene Enjaav usszesooke. Die Methode es besönders effektiv för jruuß aanjelegte Quanteschaltunge un beed en huhes Moß aan Automatisierung un Aanpassungsfähichkeit aan diverse Problemtype. Zusätzlich zor allgemeine Schaltongoptimierung kann dä AI-Transpiler met däm `AIPauliNetworkSynthesis`-Pass jebruch weede, dä Pauli-Netzwerkschaltunge – Blöck, die us H-, S-, SX-, CX-, RX-, RY- un RZ-Gates bestonne – aanvisieeht un ene Reinforcement Learning baseerde Syntheseaansatz aanwende. Wiggere Informatijoone zom AI-Transpiler un singe Synthese-Strategieje fingk mer en [\[2\]](https://arxiv.org/abs/2405.13196) un [\[3\]](https://arxiv.org/abs/2503.14448).

#### 3. **Rustiq-Plugin**
Et Rustiq-Plugin föhrt fottjeschreddene Synthesetechnike speziell för `PauliEvolutionGate`-Operatione en, die Pauli-Rotatijoone repräsenteeht, die häufich en trotterisierter Dynamik jebruch weede. Dat Plugin es wätvoll för Schaltunge, die Hamilton-Simulatijon implementeere, wi se en Quantenchemie- un Physikproblemme jebruch weede, bei dänne jenaue Pauli-Rotatijoone för de effektive Simulatijon vun Problem-Hamiltoniäns wesentlich sin. Rustiq beed präzise, neddrich-döppe Schaltongssynthese för diese spezialiseerde Operatione. Wiggere Details zor Implementierung un Leistong vun Rustiq fingk mer en [\[4\]](https://arxiv.org/abs/2404.03280).

Durch de enjehende Ongersöökong vun dänne Kompilierungsmethode beed dat Tutorial de Benotzere de Werkzeuch, öm de Leistong vun ehr Quanteschaltunge ze verbessere un dä Wääch för effizientere un praktischere Quanteberächnonge ze ebne.

## Aanforderunge {#requirements}

Stellt vör däm Aanfang vun däm Tutorial secher, dat Foljendes installeht es:
- Qiskit SDK v1.3 udder hüüher, met Ongerstötzong för [Visualisierung](https://docs.quantum.ibm.com/api/qiskit/visualization)
- Qiskit Runtime v0.28 udder hüüher (`pip install qiskit-ibm-runtime`)
- Qiskit IBM Transpiler (`pip install qiskit-ibm-transpiler`)
- Qiskit AI Transpiler Lokalmodus (`pip install qiskit_ibm_ai_local_transpiler`)
- Networkx-Graphbibliothek (`pip install networkx`)

## Setup {#setup}

```python
# Added by doQumentation — installs packages not in the Binder environment
%pip install -q qiskit-ibm-transpiler
```

```python
from qiskit.circuit import QuantumCircuit
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit.circuit.library import (
    efficient_su2,
    PauliEvolutionGate,
)
from qiskit_ibm_transpiler import generate_ai_pass_manager
from qiskit.quantum_info import SparsePauliOp
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit.transpiler.passes.synthesis.high_level_synthesis import HLSConfig
from collections import Counter
from IPython.display import display
import time
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import json
import requests
import logging

# Suppress noisy loggers
logging.getLogger(
    "qiskit_ibm_transpiler.wrappers.ai_local_synthesis"
).setLevel(logging.ERROR)

seed = 42  # Seed for reproducibility
```

## Deel 1: Efficient SU2-Schaltong {#part-1-efficient-su2-circuit}

### Schrett 1: Klassische Enjaave op en Quanteproblem afbelde {#step-1-map-classical-inputs-to-a-quantum-problem}

En däm Afschnett ongersööke mer de `efficient_su2`-Schaltong, ene hardwareeffiziente Aansatz, dä häufich en variationelle Quantenalgorithme (wi VQE) un Quantum-Machine-Learning-Opjaave jebruch weed. De Schaltong besteiht us wechselnde Schichte vun En-Qubit-Rotatijoone un verschränkende Gates, die en enem kriesförmije Muster aanjeohdnet sin un dovun konzipeeht sin, dä Quantezustandsraum effektiv ze erkonde, während en övverschaubare Döppe beibehalte weed.

Mer fange met dä Konstruktijon vun ener `efficient_su2`-Schaltong aan, öm ze demonstreere, wi verschiedene Kompilierungsmethode verjliche weede. Noh Deel 1 weede mer uns Analyse op ene jrüüßere Satz vun Schaltunge uswiggere, öm ene ömfassende Benchmark zor Bewätong vun dä Leistong verschiedener Kompilierungstechnike ze ermüjjliche.

```python
qubit_size = list(range(10, 101, 10))
qc_su2_list = [
    efficient_su2(n, entanglement="circular", reps=1)
    .decompose()
    .copy(name=f"SU2_{n}")
    for n in qubit_size
]

# Draw the first circuit
qc_su2_list[0].draw(output="mpl")
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/f362cdac-94d8-4cc5-85f4-015c3d9eba3a-0.avif)

### Schrett 2: Problem för de Usföhrong op Quantenhardware optimiere {#step-2-optimize-problem-for-quantum-hardware-execution}

Dä Schrett es dä Hauptfokus vun däm Tutorial. Hee welle mer Quanteschaltunge för de effiziente Usföhrong op echter Quantenhardware optimiere. Uns primäres Ziel es et, Schaltongsdöppe un Gate-Aanzahl ze reduziere, die Schlösselfahtore zor Verbesserung vun dä Usföhrongstreue un zor Minderong vun Hardware-Ruusch sin.

- **SABRE-Transpiler**: Brucht dä Standard-Transpiler vun Qiskit met däm SABRE-Layout- un Routing-Algorithmus.
- **AI-Transpiler (Lokalmodus)**: Dä Standard-AI-jestötzte Transpiler met lokaler Inferenz un dä Standard-Synthesestrategie.
- **Rustiq-Plugin**: E Transpiler-Plugin för neddrich-döppe Kompilatschon, dat op Hamilton-Simulationsopjaave zuejeschnedde es.

Dat Ziel vun däm Schrett es et, de Erjebnisse vun dänne Methode hensiichtlich Döppe un Gate-Aanzahl vun dä transpiliehte Schaltong ze verjlieche. En wiggere wichtije Metrik, die mer berücksichtige, es de Transpilatijonslaufzigg. Durch de Analyse vun dänne Metrike künne mer de relative Stärke vun jedere Methode bewäte un bestömme, welche de effizienteste Schaltong för de Usföhrong op dä ussjesokte Hardware produzeeht.

Henwiis: För et aanfängliche SU2-Schaltongsbeschpill weede mer nor dä SABRE-Transpiler met däm Standard-AI-Transpiler verjlieche. Em aanschleeßende Benchmark met Hamlib-Schaltunge weede mer ävver all drei Transpilatsjoonsmethode verjlieche.

```python
# QiskitRuntimeService.save_account(channel="ibm_quantum_platform", token="<YOUR-API-KEY>", overwrite=True, set_as_default=True)
service = QiskitRuntimeService(channel="ibm_quantum_platform")
backend = service.backend("ibm_torino")
print(f"Using backend: {backend}")
```

```text
qiskit_runtime_service._get_crn_from_instance_name:WARNING:2025-07-30 21:46:30,843: Multiple instances found. Using all matching instances.
```

```text
Using backend: <IBMBackend('ibm_torino')>
```

Qiskit-Transpiler met SABRE:

```python
pm_sabre = generate_preset_pass_manager(
    optimization_level=3, backend=backend, seed_transpiler=seed
)
```

AI-Transpiler:

```python
# Standard AI transpiler pass manager, using the local mode
pm_ai = generate_ai_pass_manager(
    backend=backend, optimization_level=3, ai_optimization_level=3
)
```

Rustiq-Plugin:

```python
hls_config = HLSConfig(
    PauliEvolution=[
        (
            "rustiq",
            {
                "nshuffles": 400,
                "upto_phase": True,
                "fix_clifford": True,
                "preserve_order": False,
                "metric": "depth",
            },
        )
    ]
)
pm_rustiq = generate_preset_pass_manager(
    optimization_level=3,
    backend=backend,
    hls_config=hls_config,
    seed_transpiler=seed,
)
```

#### Transpiliere un Metrike erfasse {#transpile-and-capture-metrics}

Öm de Leistong vun de Kompilierungsmethode ze verjlieche, defineere mer en Funktijon, die de Enjaavschaltong transpiliehrt un relevante Metrike op konsistente Wies erfasst. Dat ömfasst de Jesamtschaltongsdöppe, de Jesamt-Gate-Aanzahl un de Transpilatsjoonszick.

Zusätzlich zo dänne Standardmetrike zeechne mer och de 2-Qubit-Gate-Döppe op, die en besönders wichtije Metrik zor Bewätong vun dä Usföhrong op Quantenhardware es. Em Jejensatz zor Jesamtdöppe, die all Gates enschlüüt, spiejelt de 2-Qubit-Döppe de tatsächliche Usföhrongsdauer vun dä Schaltong op Hardware jenauer widder. Dat litt dovun, dat 2-Qubit-Gates typischerwiis dat Zigg- un Fählerbudget en de miiste Quantejeräte domineere. Doher es de Minimierung vun dä 2-Qubit-Döppe entscheidend för de Verbesserung vun dä Fidelität un de Reduzierung vun Dekohärenzeffekte während dä Usföhrong.

Mer weede die Funktijon bruche, öm de Leistong vun de verschiedene Kompilierungsmethode övver mihhre Schaltunge bovver ze analysiere.

```python
def capture_transpilation_metrics(
    results, pass_manager, circuits, method_name
):
    """
    Capture transpilation metrics for a list of circuits and stores the results in a DataFrame.

    Args:
        results (pd.DataFrame): DataFrame to store the results.
        pass_manager: Pass manager used for transpilation.
        circuits (list): List of quantum circuits to transpile.
        method_name (str): Name of the transpilation method.

    Returns:
        list: List of transpiled circuits.
    """
    transpiled_circuits = []

    for i, qc in enumerate(circuits):
        # Transpile the circuit
        start_time = time.time()
        transpiled_qc = pass_manager.run(qc)
        end_time = time.time()

        # Needed for AI transpiler to be consistent with other methods
        transpiled_qc = transpiled_qc.decompose(gates_to_decompose=["swap"])

        # Collect metrics
        transpilation_time = end_time - start_time
        circuit_depth = transpiled_qc.depth(
            lambda x: x.operation.num_qubits == 2
        )
        circuit_size = transpiled_qc.size()

        # Append results to DataFrame
        results.loc[len(results)] = {
            "method": method_name,
            "qc_name": qc.name,
            "qc_index": i,
            "num_qubits": qc.num_qubits,
            "ops": transpiled_qc.count_ops(),
            "depth": circuit_depth,
            "size": circuit_size,
            "runtime": transpilation_time,
        }
        transpiled_circuits.append(transpiled_qc)
        print(
            f"Transpiled circuit index {i} ({qc.name}) in {transpilation_time:.2f} seconds with method {method_name}, "
            f"depth {circuit_depth}, and size {circuit_size}."
        )

    return transpiled_circuits
```

```python
results_su2 = pd.DataFrame(
    columns=[
        "method",
        "qc_name",
        "qc_index",
        "num_qubits",
        "ops",
        "depth",
        "size",
        "runtime",
    ]
)

tqc_sabre = capture_transpilation_metrics(
    results_su2, pm_sabre, qc_su2_list, "sabre"
)
tqc_ai = capture_transpilation_metrics(results_su2, pm_ai, qc_su2_list, "ai")
```

```text
Transpiled circuit index 0 (SU2_10) in 0.06 seconds with method sabre, depth 13, and size 167.
Transpiled circuit index 1 (SU2_20) in 0.24 seconds with method sabre, depth 20, and size 299.
Transpiled circuit index 2 (SU2_30) in 10.72 seconds with method sabre, depth 72, and size 627.
Transpiled circuit index 3 (SU2_40) in 16.16 seconds with method sabre, depth 40, and size 599.
Transpiled circuit index 4 (SU2_50) in 76.89 seconds with method sabre, depth 77, and size 855.
Transpiled circuit index 5 (SU2_60) in 86.12 seconds with method sabre, depth 60, and size 899.
Transpiled circuit index 6 (SU2_70) in 94.46 seconds with method sabre, depth 79, and size 1085.
Transpiled circuit index 7 (SU2_80) in 69.05 seconds with method sabre, depth 80, and size 1199.
Transpiled circuit index 8 (SU2_90) in 88.25 seconds with method sabre, depth 105, and size 1420.
Transpiled circuit index 9 (SU2_100) in 83.80 seconds with method sabre, depth 100, and size 1499.
Transpiled circuit index 0 (SU2_10) in 0.17 seconds with method ai, depth 10, and size 168.
Transpiled circuit index 1 (SU2_20) in 0.29 seconds with method ai, depth 20, and size 299.
Transpiled circuit index 2 (SU2_30) in 13.56 seconds with method ai, depth 36, and size 548.
Transpiled circuit index 3 (SU2_40) in 15.95 seconds with method ai, depth 40, and size 599.
Transpiled circuit index 4 (SU2_50) in 80.70 seconds with method ai, depth 54, and size 823.
Transpiled circuit index 5 (SU2_60) in 75.99 seconds with method ai, depth 60, and size 899.
Transpiled circuit index 6 (SU2_70) in 64.96 seconds with method ai, depth 74, and size 1087.
Transpiled circuit index 7 (SU2_80) in 68.25 seconds with method ai, depth 80, and size 1199.
Transpiled circuit index 8 (SU2_90) in 75.07 seconds with method ai, depth 90, and size 1404.
Transpiled circuit index 9 (SU2_100) in 63.97 seconds with method ai, depth 100, and size 1499.
```

Zeich de transpiliehte Erjebnisse vun einer vun de Schaltunge aan.

```python
print("Sabre transpilation")
display(tqc_sabre[0].draw("mpl", fold=-1, idle_wires=False))
print("AI transpilation")
display(tqc_ai[0].draw("mpl", fold=-1, idle_wires=False))
```

```text
Sabre transpilation
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/37924fc2-8fb6-451a-b8f9-cd79573f2384-1.avif)

```text
AI transpilation
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/37924fc2-8fb6-451a-b8f9-cd79573f2384-3.avif)

Erjebnistabäll:

```python
summary_su2 = (
    results_su2.groupby("method")[["depth", "size", "runtime"]]
    .mean()
    .round(2)
)
print(summary_su2)

results_su2
```

```text
       depth   size  runtime
method
ai       56.4  852.5    45.89
sabre    64.6  864.9    52.57
```

```text
  method  qc_name  qc_index  num_qubits                                ops  \
0   sabre   SU2_10         0          10     {'rz': 81, 'sx': 70, 'cz': 16}
1   sabre   SU2_20         1          20   {'rz': 160, 'sx': 119, 'cz': 20}
2   sabre   SU2_30         2          30   {'sx': 295, 'rz': 242, 'cz': 90}
3   sabre   SU2_40         3          40   {'rz': 320, 'sx': 239, 'cz': 40}
4   sabre   SU2_50         4          50   {'rz': 402, 'sx': 367, 'cz': 86}
5   sabre   SU2_60         5          60   {'rz': 480, 'sx': 359, 'cz': 60}
6   sabre   SU2_70         6          70   {'rz': 562, 'sx': 441, 'cz': 82}
7   sabre   SU2_80         7          80   {'rz': 640, 'sx': 479, 'cz': 80}
8   sabre   SU2_90         8          90  {'rz': 721, 'sx': 585, 'cz': 114}
9   sabre  SU2_100         9         100  {'rz': 800, 'sx': 599, 'cz': 100}
10     ai   SU2_10         0          10     {'rz': 81, 'sx': 71, 'cz': 16}
11     ai   SU2_20         1          20   {'rz': 160, 'sx': 119, 'cz': 20}
12     ai   SU2_30         2          30   {'sx': 243, 'rz': 242, 'cz': 63}
13     ai   SU2_40         3          40   {'rz': 320, 'sx': 239, 'cz': 40}
14     ai   SU2_50         4          50   {'rz': 403, 'sx': 346, 'cz': 74}
15     ai   SU2_60         5          60   {'rz': 480, 'sx': 359, 'cz': 60}
16     ai   SU2_70         6          70   {'rz': 563, 'sx': 442, 'cz': 82}
17     ai   SU2_80         7          80   {'rz': 640, 'sx': 479, 'cz': 80}
18     ai   SU2_90         8          90  {'rz': 721, 'sx': 575, 'cz': 108}
19     ai  SU2_100         9         100  {'rz': 800, 'sx': 599, 'cz': 100}

    depth  size    runtime
0      13   167   0.058845
1      20   299   0.238217
2      72   627  10.723922
3      40   599  16.159262
4      77   855  76.886604
5      60   899  86.118255
6      79  1085  94.458287
7      80  1199  69.048184
8     105  1420  88.254809
9     100  1499  83.795482
10     10   168   0.171532
11     20   299   0.291691
12     36   548  13.555931
13     40   599  15.952733
14     54   823  80.702141
15     60   899  75.993404
16     74  1087  64.960162
17     80  1199  68.253280
18     90  1404  75.072412
19    100  1499  63.967446
```

#### Erjebnissgraph {#results-graph}

Weil mer en Funktijon defineert han, öm Metrike konsistent ze erfasse, weede mer och eine defineere, öm de Metrike grafisch darzestelle. Hee weede mer de Zwei-Qubit-Döppe, Gate-Aanzahl un Laufzick för jede Kompilierungsmethode övver de Schaltunge bovver darstelle.

```python
def plot_transpilation_metrics(results, overall_title, x_axis="qc_index"):
    """
    Plots transpilation metrics (depth, size, runtime) for different transpilation methods.

    Parameters:
        results (DataFrame): Data containing columns ['num_qubits', 'method', 'depth', 'size', 'runtime']
        overall_title (str): The title of the overall figure.
        x_axis (str): The x-axis label, either 'num_qubits' or 'qc_index'.
    """

    fig, axs = plt.subplots(1, 3, figsize=(24, 6))
    metrics = ["depth", "size", "runtime"]
    titles = ["Circuit Depth", "Circuit Size", "Transpilation Runtime"]
    y_labels = ["Depth", "Size (Gate Count)", "Runtime (s)"]

    methods = results["method"].unique()
    colors = plt.colormaps["tab10"]
    markers = ["o", "^", "s", "D", "P", "*", "X", "v"]
    color_list = [colors(i % colors.N) for i in range(len(methods))]
    color_map = {method: color_list[i] for i, method in enumerate(methods)}
    marker_map = {
        method: markers[i % len(markers)] for i, method in enumerate(methods)
    }
    jitter_factor = 0.1  # Small x-axis jitter for visibility
    handles, labels = [], []  # Unique handles for legend

    # Plot each metric
    for i, metric in enumerate(metrics):
        for method in methods:
            method_data = results[results["method"] == method]

            # Introduce slight jitter to avoid exact overlap
            jitter = np.random.uniform(
                -jitter_factor, jitter_factor, len(method_data)
            )

            scatter = axs[i].scatter(
                method_data[x_axis] + jitter,
                method_data[metric],
                color=color_map[method],
                label=method,
                marker=marker_map[method],
                alpha=0.7,
                edgecolors="black",
                s=80,
            )

            if method not in labels:
                handles.append(scatter)
                labels.append(method)

        axs[i].set_title(titles[i])
        axs[i].set_xlabel(x_axis)
        axs[i].set_ylabel(y_labels[i])
        axs[i].grid(axis="y", linestyle="--", alpha=0.7)
        axs[i].tick_params(axis="x", rotation=45)
        axs[i].set_xticks(sorted(results[x_axis].unique()))

    fig.suptitle(overall_title, fontsize=16)
    fig.legend(
        handles=handles,
        labels=labels,
        loc="upper right",
        bbox_to_anchor=(1.05, 1),
    )

    plt.tight_layout()
    plt.show()
```

```python
plot_transpilation_metrics(
    results_su2, "Transpilation Metrics for SU2 Circuits", x_axis="num_qubits"
)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/7f7b502a-8ed6-45fa-a698-02977149e283-0.avif)

#### Analyse vun de SU2-Schaltongskompilierungserjebnisse {#analysis-of-su2-circuit-compilation-results}

En däm Experiment verjlieche mer zwei Transpilatsjoonsmethode – Qiskits SABRE-Transpiler un dä AI-jestötzte Transpiler – aan enem Satz vun `efficient_su2`-Schaltunge. Weil dänne Schaltunge kein `PauliEvolutionGate`-Operatione han, es et Rustiq-Plugin en däm Verjliich nit enthalte.

Em Durchschnett schniggt dä AI-Transpiler hensiichtlich dä Schaltongsdöppe besser av, met ener Verbesserung vun mih wi 10% övver de jesampte Bandbreite vun de SU2-Schaltunge bovver. För Gate-Aanzahl (Schaltongsjrüüße) un Transpilatsjoonslaufzick erziele beede Methode ensjesamt ähnliche Erjebnisse.

De Inspektijon vun de einzelne Datepönkt offenbaht ävver en deefere Ensich:
- För de miiste Qubit-Jrüüße produzeeht sowohl SABRE wi och AI nahezo identische Erjebnisse, wat drovun hendeut, dat beede Methode en viile Fälle zo ähnlich effiziente Lüsunge konverjeere.
- För bestemmte Schaltongsjrüüße, speziell bei 30, 50, 70 un 90 Qubits, fingk dä AI-Transpiler deutlich flachere Schaltunge wi SABRE. Dat zeich, dat dä liehrbaseerde Aansatz vun AI en dä Laach es, optimalere Layouts udder Routing-Pfahde en Fälle ze entdecke, en dänne de SABRE-Heuristik dat nit deit.

Dat Verhalde hövv en wichtije Erkenntnis herrför:
> Während SABRE un AI off verjliichbare Erjebnisse produzeeht, kann dä AI-Transpiler jelijentlich vill bessere Lüsunge entdecke, besönders hensiichtlich dä Döppe, wat zo deutlich verbesserter Leistong op Hardware föhre kann.

## Deel 2: Hamilton-Simulatijonschaltong {#part-2-hamiltonian-simulation-circuit}

### Schrett 1: Ongersöökong vun Schaltunge met `PauliEvolutionGate` {#step-1-investigate-circuits-with-paulievolutiongate}

En däm Afschnett ongersööke mer Quanteschaltunge, die ongrem Jebruch vun `PauliEvolutionGate` konstrueeht woodte, dat en effiziente Simulatijon vun Hamiltoniäns ermüjjelicht. Mer weede analysiere, wi verschiedene Kompilierungsmethode dänne Schaltunge övver verschiedene Hamiltoniäns bovver optimeeht.

#### En däm Benchmark jebruchte Hamiltoniäns {#hamiltonians-used-in-the-benchmark}

De en däm Benchmark jebruchte Hamiltoniäns beschrieve paarwiise Interaktione zwesche Qubits, enschleeßlich Terme wi $ZZ$, $XX$ un $YY$. Dänne Hamiltoniäns weede häufich en Quantenchemie, Festkörperphysik un Materialwesseschaft jebruch, wo se Systeme vun interajieerende Deelche modelleere.

Als Referenz künne Benotzer ene breitere Satz vun Hamiltoniäns en däm Paper erkonde: [Efficient Hamiltonian Simulation on Noisy Quantum Devices](https://arxiv.org/pdf/2306.13126).

#### Benchmark-Quell: Hamlib un Benchpress {#benchmark-source-hamlib-and-benchpress}

De en däm Benchmark jebruchte Schaltunge stamme us däm [Hamlib-Benchmark-Repository](https://github.com/SRI-International/QC-App-Oriented-Benchmarks/tree/master/hamlib), dat realistisch Hamilton-Simulatijonworkloads enthält.

Dänne jliche Schaltunge woodte vörher met [Benchpress](https://github.com/Qiskit/benchpress) benchmarked, enem Open-Source-Framework zor Bewätong vun dä Quanten-Transpilatsjonsleistong. Durch dä Jebruch vun däm standardisierte Satz vun Schaltunge künne mer de Effektivität verschiedener Kompilierungsstrategieje bei repräsentative Simulatijonsproblemme direkt verjlieche.

Hamilton-Simulatijon es en jrondlegende Opjaav em Quantencomputing met Aanwändunge en Molekülsimulatijoone, Optimierungsproblemme un Quanten-Viildeelchephysik. Dat Verstänndnis, wi verschiedene Kompilierungsmethode dänne Schaltunge optimeeht, kann de Benotzere hellefe, de praktische Usföhrong vun solche Schaltunge op korzfristije Quantejeräte ze verbessere.

```python
# Obtain the Hamiltonian JSON from the benchpress repository
url = "https://raw.githubusercontent.com/Qiskit/benchpress/e7b29ef7be4cc0d70237b8fdc03edbd698908eff/benchpress/hamiltonian/hamlib/100_representative.json"
response = requests.get(url)
response.raise_for_status()  # Raise an error if download failed
ham_records = json.loads(response.text)
# Remove circuits that are too large for the backend
ham_records = [
    h for h in ham_records if h["ham_qubits"] <= backend.num_qubits
]
# Remove the circuits that are large to save transpilation time
ham_records = sorted(ham_records, key=lambda x: x["ham_terms"])[:35]

qc_ham_list = []
for h in ham_records:
    terms = h["ham_hamlib_hamiltonian_terms"]
    coeff = h["ham_hamlib_hamiltonian_coefficients"]
    num_qubits = h["ham_qubits"]
    name = h["ham_problem"]

    evo_gate = PauliEvolutionGate(SparsePauliOp(terms, coeff))

    qc_ham = QuantumCircuit(num_qubits)
    qc_ham.name = name

    qc_ham.append(evo_gate, range(num_qubits))
    qc_ham_list.append(qc_ham)
print(f"Number of Hamiltonian circuits: {len(qc_ham_list)}")

# Draw the first Hamiltonian circuit
qc_ham_list[0].draw("mpl", fold=-1)
```

```text
Number of Hamiltonian circuits: 35
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/66347c00-1607-4405-bb76-610690adf6b8-1.avif)

### Schrett 2: Problem för de Usföhrong op Quantenhardware optimiere {#step-2-optimize-problem-for-quantum-hardware-execution-2}

Wi em vörherije Beschpill bruche mer datselvije Backend, öm Konsistenz en uns Verjlieche secherzestelle. Do de Pass-Manager (`pm_sabre`, `pm_ai` un `pm_rustiq`) ald initialiseeht woodte, künne mer direkt met dä Transpilatschon vun de Hamilton-Schaltunge met jedere Methode fottfahre.

Dä Schrett konzentrieht sech ussschleeßlich op de Durchföhrong vun dä Transpilatschon un de Opzeechnong vun de resulteerende Schaltongmetrike, enschleeßlich Döppe, Gate-Aanzahl un Transpilatsjoonslaufzigg. Durch de Analyse vun dänne Erjebnisse welle mer de Effizienz vun jedere Transpilatsjoonsmethode för dänne Schaltongtyp bestömme.

Transpiliere un Metrike erfasse:

```python
results_ham = pd.DataFrame(
    columns=[
        "method",
        "qc_name",
        "qc_index",
        "num_qubits",
        "ops",
        "depth",
        "size",
        "runtime",
    ]
)

tqc_sabre = capture_transpilation_metrics(
    results_ham, pm_sabre, qc_ham_list, "sabre"
)
tqc_ai = capture_transpilation_metrics(results_ham, pm_ai, qc_ham_list, "ai")
tqc_rustiq = capture_transpilation_metrics(
    results_ham, pm_rustiq, qc_ham_list, "rustiq"
)
```

```text
Transpiled circuit index 0 (all-vib-o3) in 0.02 seconds with method sabre, depth 6, and size 58.
Transpiled circuit index 1 (all-vib-c2h) in 1.10 seconds with method sabre, depth 2, and size 39.
Transpiled circuit index 2 (all-vib-bh) in 0.01 seconds with method sabre, depth 3, and size 30.
Transpiled circuit index 3 (all-vib-c2h) in 0.03 seconds with method sabre, depth 18, and size 115.
Transpiled circuit index 4 (graph-gnp_k-2) in 0.02 seconds with method sabre, depth 24, and size 129.
Transpiled circuit index 5 (all-vib-fccf) in 0.05 seconds with method sabre, depth 14, and size 134.
Transpiled circuit index 6 (all-vib-hno) in 8.39 seconds with method sabre, depth 6, and size 174.
Transpiled circuit index 7 (all-vib-bhf2) in 3.92 seconds with method sabre, depth 22, and size 220.
Transpiled circuit index 8 (LiH) in 0.03 seconds with method sabre, depth 67, and size 290.
Transpiled circuit index 9 (uf20-ham) in 0.04 seconds with method sabre, depth 50, and size 340.
Transpiled circuit index 10 (all-vib-fccf) in 0.62 seconds with method sabre, depth 30, and size 286.
Transpiled circuit index 11 (all-vib-fccf) in 0.04 seconds with method sabre, depth 67, and size 339.
Transpiled circuit index 12 (all-vib-ch2) in 0.04 seconds with method sabre, depth 87, and size 421.
Transpiled circuit index 13 (tfim) in 0.05 seconds with method sabre, depth 36, and size 222.
Transpiled circuit index 14 (all-vib-cyclo_propene) in 9.51 seconds with method sabre, depth 22, and size 345.
Transpiled circuit index 15 (graph-gnp_k-4) in 0.05 seconds with method sabre, depth 128, and size 704.
Transpiled circuit index 16 (all-vib-hc3h2cn) in 13.83 seconds with method sabre, depth 2, and size 242.
Transpiled circuit index 17 (TSP_Ncity-4) in 0.05 seconds with method sabre, depth 106, and size 609.
Transpiled circuit index 18 (tfim) in 0.29 seconds with method sabre, depth 73, and size 399.
Transpiled circuit index 19 (all-vib-h2co) in 21.97 seconds with method sabre, depth 30, and size 572.
Transpiled circuit index 20 (Be2) in 0.09 seconds with method sabre, depth 324, and size 1555.
Transpiled circuit index 21 (graph-complete_bipart) in 0.12 seconds with method sabre, depth 250, and size 1394.
Transpiled circuit index 22 (all-vib-f2) in 0.07 seconds with method sabre, depth 215, and size 1027.
Transpiled circuit index 23 (all-vib-cyclo_propene) in 41.22 seconds with method sabre, depth 30, and size 1144.
Transpiled circuit index 24 (TSP_Ncity-5) in 1.89 seconds with method sabre, depth 175, and size 1933.
Transpiled circuit index 25 (H2) in 0.32 seconds with method sabre, depth 1237, and size 5502.
Transpiled circuit index 26 (uuf100-ham) in 0.20 seconds with method sabre, depth 385, and size 4303.
Transpiled circuit index 27 (ham-graph-gnp_k-5) in 0.20 seconds with method sabre, depth 311, and size 3654.
Transpiled circuit index 28 (tfim) in 0.15 seconds with method sabre, depth 276, and size 3213.
Transpiled circuit index 29 (uuf100-ham) in 0.21 seconds with method sabre, depth 520, and size 5250.
Transpiled circuit index 30 (flat100-ham) in 0.15 seconds with method sabre, depth 131, and size 3157.
Transpiled circuit index 31 (uf100-ham) in 0.24 seconds with method sabre, depth 624, and size 7378.
Transpiled circuit index 32 (OH) in 0.88 seconds with method sabre, depth 2175, and size 9808.
Transpiled circuit index 33 (HF) in 0.66 seconds with method sabre, depth 2206, and size 9417.
Transpiled circuit index 34 (BH) in 0.89 seconds with method sabre, depth 2177, and size 9802.
Transpiled circuit index 0 (all-vib-o3) in 0.02 seconds with method ai, depth 6, and size 58.
Transpiled circuit index 1 (all-vib-c2h) in 1.11 seconds with method ai, depth 2, and size 39.
Transpiled circuit index 2 (all-vib-bh) in 0.01 seconds with method ai, depth 3, and size 30.
Transpiled circuit index 3 (all-vib-c2h) in 0.11 seconds with method ai, depth 18, and size 94.
Transpiled circuit index 4 (graph-gnp_k-2) in 0.11 seconds with method ai, depth 22, and size 129.
Transpiled circuit index 5 (all-vib-fccf) in 0.06 seconds with method ai, depth 22, and size 177.
Transpiled circuit index 6 (all-vib-hno) in 8.62 seconds with method ai, depth 10, and size 198.
Transpiled circuit index 7 (all-vib-bhf2) in 3.71 seconds with method ai, depth 18, and size 195.
Transpiled circuit index 8 (LiH) in 0.19 seconds with method ai, depth 62, and size 267.
Transpiled circuit index 9 (uf20-ham) in 0.22 seconds with method ai, depth 47, and size 321.
Transpiled circuit index 10 (all-vib-fccf) in 0.71 seconds with method ai, depth 38, and size 369.
Transpiled circuit index 11 (all-vib-fccf) in 0.24 seconds with method ai, depth 65, and size 315.
Transpiled circuit index 12 (all-vib-ch2) in 0.24 seconds with method ai, depth 91, and size 430.
Transpiled circuit index 13 (tfim) in 0.15 seconds with method ai, depth 12, and size 251.
Transpiled circuit index 14 (all-vib-cyclo_propene) in 8.50 seconds with method ai, depth 18, and size 311.
Transpiled circuit index 15 (graph-gnp_k-4) in 0.25 seconds with method ai, depth 117, and size 659.
Transpiled circuit index 16 (all-vib-hc3h2cn) in 16.11 seconds with method ai, depth 2, and size 242.
Transpiled circuit index 17 (TSP_Ncity-4) in 0.39 seconds with method ai, depth 98, and size 564.
Transpiled circuit index 18 (tfim) in 0.38 seconds with method ai, depth 23, and size 437.
Transpiled circuit index 19 (all-vib-h2co) in 24.97 seconds with method ai, depth 38, and size 707.
Transpiled circuit index 20 (Be2) in 1.07 seconds with method ai, depth 293, and size 1392.
Transpiled circuit index 21 (graph-complete_bipart) in 0.61 seconds with method ai, depth 229, and size 1437.
Transpiled circuit index 22 (all-vib-f2) in 0.57 seconds with method ai, depth 178, and size 964.
Transpiled circuit index 23 (all-vib-cyclo_propene) in 50.89 seconds with method ai, depth 34, and size 1425.
Transpiled circuit index 24 (TSP_Ncity-5) in 1.61 seconds with method ai, depth 171, and size 2020.
Transpiled circuit index 25 (H2) in 6.39 seconds with method ai, depth 1148, and size 5208.
Transpiled circuit index 26 (uuf100-ham) in 3.97 seconds with method ai, depth 376, and size 5048.
Transpiled circuit index 27 (ham-graph-gnp_k-5) in 3.54 seconds with method ai, depth 357, and size 4451.
Transpiled circuit index 28 (tfim) in 1.72 seconds with method ai, depth 216, and size 3026.
Transpiled circuit index 29 (uuf100-ham) in 4.45 seconds with method ai, depth 426, and size 5399.
Transpiled circuit index 30 (flat100-ham) in 7.02 seconds with method ai, depth 86, and size 3108.
Transpiled circuit index 31 (uf100-ham) in 12.85 seconds with method ai, depth 623, and size 8354.
Transpiled circuit index 32 (OH) in 15.19 seconds with method ai, depth 2084, and size 9543.
Transpiled circuit index 33 (HF) in 17.51 seconds with method ai, depth 2063, and size 9446.
Transpiled circuit index 34 (BH) in 15.33 seconds with method ai, depth 2094, and size 9730.
Transpiled circuit index 0 (all-vib-o3) in 0.02 seconds with method rustiq, depth 13, and size 83.
Transpiled circuit index 1 (all-vib-c2h) in 1.11 seconds with method rustiq, depth 2, and size 39.
Transpiled circuit index 2 (all-vib-bh) in 0.01 seconds with method rustiq, depth 3, and size 30.
Transpiled circuit index 3 (all-vib-c2h) in 0.01 seconds with method rustiq, depth 13, and size 79.
Transpiled circuit index 4 (graph-gnp_k-2) in 0.02 seconds with method rustiq, depth 31, and size 131.
Transpiled circuit index 5 (all-vib-fccf) in 0.04 seconds with method rustiq, depth 50, and size 306.
Transpiled circuit index 6 (all-vib-hno) in 14.03 seconds with method rustiq, depth 22, and size 276.
Transpiled circuit index 7 (all-vib-bhf2) in 3.15 seconds with method rustiq, depth 13, and size 155.
Transpiled circuit index 8 (LiH) in 0.03 seconds with method rustiq, depth 54, and size 270.
Transpiled circuit index 9 (uf20-ham) in 0.04 seconds with method rustiq, depth 65, and size 398.
Transpiled circuit index 10 (all-vib-fccf) in 0.16 seconds with method rustiq, depth 41, and size 516.
Transpiled circuit index 11 (all-vib-fccf) in 0.02 seconds with method rustiq, depth 34, and size 189.
Transpiled circuit index 12 (all-vib-ch2) in 0.03 seconds with method rustiq, depth 49, and size 240.
Transpiled circuit index 13 (tfim) in 0.05 seconds with method rustiq, depth 20, and size 366.
Transpiled circuit index 14 (all-vib-cyclo_propene) in 9.08 seconds with method rustiq, depth 16, and size 277.
Transpiled circuit index 15 (graph-gnp_k-4) in 0.04 seconds with method rustiq, depth 116, and size 612.
Transpiled circuit index 16 (all-vib-hc3h2cn) in 13.89 seconds with method rustiq, depth 2, and size 257.
Transpiled circuit index 17 (TSP_Ncity-4) in 0.05 seconds with method rustiq, depth 133, and size 737.
Transpiled circuit index 18 (tfim) in 0.11 seconds with method rustiq, depth 25, and size 680.
Transpiled circuit index 19 (all-vib-h2co) in 27.19 seconds with method rustiq, depth 66, and size 983.
Transpiled circuit index 20 (Be2) in 0.07 seconds with method rustiq, depth 215, and size 1030.
Transpiled circuit index 21 (graph-complete_bipart) in 0.14 seconds with method rustiq, depth 328, and size 1918.
Transpiled circuit index 22 (all-vib-f2) in 0.05 seconds with method rustiq, depth 114, and size 692.
Transpiled circuit index 23 (all-vib-cyclo_propene) in 62.25 seconds with method rustiq, depth 74, and size 2348.
Transpiled circuit index 24 (TSP_Ncity-5) in 0.20 seconds with method rustiq, depth 436, and size 3605.
Transpiled circuit index 25 (H2) in 0.21 seconds with method rustiq, depth 643, and size 3476.
Transpiled circuit index 26 (uuf100-ham) in 0.24 seconds with method rustiq, depth 678, and size 6120.
Transpiled circuit index 27 (ham-graph-gnp_k-5) in 0.22 seconds with method rustiq, depth 588, and size 5241.
Transpiled circuit index 28 (tfim) in 0.34 seconds with method rustiq, depth 340, and size 5901.
Transpiled circuit index 29 (uuf100-ham) in 0.33 seconds with method rustiq, depth 881, and size 7667.
Transpiled circuit index 30 (flat100-ham) in 0.31 seconds with method rustiq, depth 279, and size 4910.
Transpiled circuit index 31 (uf100-ham) in 0.38 seconds with method rustiq, depth 1138, and size 10607.
Transpiled circuit index 32 (OH) in 0.38 seconds with method rustiq, depth 1148, and size 6512.
Transpiled circuit index 33 (HF) in 0.37 seconds with method rustiq, depth 1090, and size 6256.
Transpiled circuit index 34 (BH) in 0.37 seconds with method rustiq, depth 1148, and size 6501.
```

Erjebnistabäll (Visualisierung weed övversprunge, weil de Ussjaavschaltunge ziemlich jruuß sin):

```python
summary_ham = (
    results_ham.groupby("method")[["depth", "size", "runtime"]]
    .mean()
    .round(2)
)
print(summary_ham)

results_ham
```

```text
        depth     size  runtime
method
ai      316.86  2181.26     5.97
rustiq  281.94  2268.80     3.86
sabre   337.97  2120.14     3.07
```

```text
  method        qc_name  qc_index  num_qubits  \
0     sabre     all-vib-o3         0           4
1     sabre    all-vib-c2h         1           4
2     sabre     all-vib-bh         2           2
3     sabre    all-vib-c2h         3           3
4     sabre  graph-gnp_k-2         4           4
..      ...            ...       ...         ...
100  rustiq    flat100-ham        30          90
101  rustiq      uf100-ham        31          46
102  rustiq             OH        32          10
103  rustiq             HF        33          10
104  rustiq             BH        34          10

                                               ops  depth   size   runtime
0                    {'rz': 28, 'sx': 24, 'cz': 6}      6     58  0.016597
1            {'rz': 17, 'sx': 16, 'cz': 4, 'x': 2}      2     39  1.102089
2                    {'sx': 14, 'rz': 13, 'cz': 3}      3     30  0.011042
3           {'sx': 46, 'rz': 45, 'cz': 18, 'x': 6}     18    115  0.025816
4           {'sx': 49, 'rz': 47, 'cz': 24, 'x': 9}     24    129  0.023077
..                                             ...    ...    ...       ...
100    {'sx': 2709, 'cz': 1379, 'rz': 817, 'x': 5}    279   4910  0.309448
101   {'sx': 6180, 'cz': 3120, 'rz': 1303, 'x': 4}   1138  10607  0.380977
102  {'sx': 3330, 'cz': 1704, 'rz': 1455, 'x': 23}   1148   6512  0.383564
103  {'sx': 3213, 'cz': 1620, 'rz': 1406, 'x': 17}   1090   6256  0.368578
104  {'sx': 3331, 'cz': 1704, 'rz': 1447, 'x': 19}   1148   6501  0.374822

[105 rows x 8 columns]
```

Visualiseeht de Leistong baseeht op däm Schaltongindex:

```python
plot_transpilation_metrics(
    results_ham, "Transpilation Metrics for Hamiltonian Circuits"
)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/4c6b810d-a4cf-4de3-aae6-c6c1cdd83d8f-0.avif)

Visualiseeht dä Prozentsatz vun de Schaltunge, för die jede Methode am beste avjeschnettet.

```python
def analyze_and_plot_best_methods(results, metric):
    """
    Analyze the best-performing methods for a given metric and plot a pie chart.

    Parameters:
        results (DataFrame): The input DataFrame containing method performance data.
        metric (str): The metric to evaluate ("depth" or "size").
    """
    method_counts = Counter()
    for qc_idx, group in results.groupby("qc_index"):
        min_value = group[metric].min()

        # Find all methods that achieved this minimum value
        best_methods = group[group[metric] == min_value]["method"]
        # Update counts for all best methods (handling ties)
        method_counts.update(best_methods)
    best_method_counts = dict(
        sorted(method_counts.items(), key=lambda x: x[1], reverse=True)
    )

    # Print summary
    print(f"Best-performing methods based on {metric}:")
    for method, count in best_method_counts.items():
        print(f"    {method}: {count} circuit(s)")

    # Plot pie chart
    num_methods = len(best_method_counts)
    colors = plt.cm.viridis_r(range(0, 256, 256 // num_methods))
    plt.figure(figsize=(5, 5))
    plt.pie(
        best_method_counts.values(),
        labels=best_method_counts.keys(),
        autopct="%1.1f%%",
        startangle=140,
        wedgeprops={"edgecolor": "black"},
        textprops={"fontsize": 10},
        colors=colors,
    )
    plt.title(
        f"Percentage of Circuits Method Performed Best for {metric.capitalize()}",
        fontsize=12,
        fontweight="bold",
    )
    plt.show()

analyze_and_plot_best_methods(results_ham, "depth")
analyze_and_plot_best_methods(results_ham, "size")
```

```text
Best-performing methods based on depth:
    ai: 16 circuit(s)
    rustiq: 16 circuit(s)
    sabre: 10 circuit(s)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/01b4644e-ac91-483c-944b-924f8b41718d-1.avif)

```text
Best-performing methods based on size:
    sabre: 18 circuit(s)
    rustiq: 14 circuit(s)
    ai: 10 circuit(s)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/01b4644e-ac91-483c-944b-924f8b41718d-3.avif)

#### Analyse vun de Hamilton-Schaltongskompilierungserjebnisse {#analysis-of-hamiltonian-circuit-compilation-results}

En däm Afschnett evaluiere mer de Leistong vun drei Transpilatsjoonsmethode – SABRE, däm AI-jestötzte Transpiler un Rustiq – aan Quanteschaltunge, die met `PauliEvolutionGate` konstrueeht woodte, die häufich en Hamilton-Simulationsopjaave jebruch weede.

Rustiq hätt em Durchschnett am beste en Bezoch op de Schaltongsdöppe avjeschnettet un hätt en öm 20% neddrijere Döppe wi SABRE erreicht. Dat es ze erwatte, weil Rustiq speziell för de Synthese vun `PauliEvolutionGate`-Operatione met optimeerde, neddrich-döppe Zerlejongsstrategieje entweckelt wood. Darövver eruus zeich dat Döppediagramm, dat Rustiq am effektivste skaleeht, wann de Schaltunge aan Jrüüße un Komplexität zoneemme, un en deutlich jeringere Döppe wi sowohl AI wi och SABRE bei jrüüßere Schaltunge beibehalld.

Dä AI-Transpiler hätt starke un konsistente Leistong för de Schaltongsdöppe jezeich un hätt SABRE konsistent övver de miiste Schaltunge bovver övvertroffe. Hä hätt ävver de hühste Laufzigg verursach, besönders bei jrüüßere Schaltunge, wat sing Praktikabilität en zickkritische Workloads enschränke kann. Sing Skalierbarkeit bei dä Laufzigg bleef en Schlösselbeschränkong, obwohl hä solide Verbesserunge bei dä Döppe beed.

SABRE hätt zwar de hühste durchschnettliche Döppe erzielt, ävver de neddrijste durchschnettliche Gate-Aanzahl, dich jefolg vun däm AI-Transpiler. Dat es em Enklang met däm Design vun dä SABRE-Heuristik, die de Minimierung vun dä Gate-Aanzahl direkt prioriséeht. Rustiq hätt trotz singem Stärke bei dä Senkong vun dä Döppe de hühste durchschnettliche Gate-Aanzahl jehatt, wat en bemerkenswäte Kompromiss es, dän mer en Aanwändunge berücksichtige sull, bei dänne Schaltongsjrüüße mih zällt wi Schaltongsdauer.

### Zosammefassong {#summary}

Während dä AI-Transpiler em Allgemeine bessere Erjebnisse wi SABRE liefert, besönders bei dä Schaltongsdöppe, sullt de Schlussfolgörong nit einfach "emmer dä AI-Transpiler bruche" sin. Et jitt wichtije Nuancen ze berücksichtige:

- **AI-Transpiler** es typischerwiis zuverlässich un liefert döppenoptimeerde Schaltunge, brängt ävver Kompromisse bei dä Laufzigg met sech un hätt och ander Beschränkonge, enschleeßlich ongerstötzte Coupling-Maps un Synthese-Fähichkeite. Dänne sin en dä [Qiskit Transpiler Service-Dokumentatschon](/guides/qiskit-transpiler-service) detailleeht beschrivve.

- En manchen Fälle, besönders bei zeemlech jruuße udder hardwarespezifische Schaltunge, es dä AI-Transpiler möjlicherwiis nit esu effektiv. En dänne Fälle bleef dä Standard-SABRE-Transpiler äußerst zuverlässich un kann durch de Aanjpassong singem Parameter wigger optimeeht weede (luur et [SABRE-Optimierongs-Tutorial](/tutorials/transpilation-optimizations-with-sabre)).

- Et es och wichtich, de Schaltongstruktur bei dä Wahl vun ener Methode ze berücksichtige. Zom Beispill es `rustiq` speziell för Schaltunge met `PauliEvolutionGate` konzipeeht un liefert off de beste Leistong för Hamilton-Simulationsproblemme.

**Empfählongs:**
> Et jitt kein Einheitslüsong för de Transpilatsjoonsstrategie. De Benotzer weede ermungert, de Struktur vun ehr Schaltong ze verstohne un mihhre Transpilatsjoonsmethode ze teste – enschleeßlich AI, SABRE un spezialiseerde Tools wi Rustiq – öm de effizienteste Lüsong för singem spezifische Problem un singem Hardware-Beschränkonge ze finge.

### Schrett 3: Usföhrong met Qiskit Primitives {#step-3-execute-using-qiskit-primitives}
Weil sech dat Tutorial op Transpilatschon konzentrieht, weede kein Experimänte op enem Quantejerät usjeföhrt. Dat Ziel es et, de Optimierunge us Schrett 2 ze notze, öm en transpiliehte Schaltong met reduzierter Döppe un Gate-Aanzahl ze krijje.

### Schrett 4: Nohbearbeidong un Rückjaav vun däm Erjebniss em jewönschte klassische Format {#step-4-post-process-and-return-result-in-desired-classical-format}
Do et kein Usföhrong för dat Notebook jitt, jitt et och kein Erjebnisse zor Nohbearbeidong.

## Referänze {#references}

[1] "LightSABRE: A Lightweight and Enhanced SABRE Algorithm". H. Zou, M. Treinish, K. Hartman, A. Ivrii, J. Lishman et al. https://arxiv.org/abs/2409.08368

[2] "Practical and efficient quantum circuit synthesis and transpiling with Reinforcement Learning". D. Kremer, V. Villar, H. Paik, I. Duran, I. Faro, J. Cruz-Benito et al. https://arxiv.org/abs/2405.13196

[3] "Pauli Network Circuit Synthesis with Reinforcement Learning". A. Dubal, D. Kremer, S. Martiel, V. Villar, D. Wang, J. Cruz-Benito et al. https://arxiv.org/abs/2503.14448

[4] "Faster and shorter synthesis of Hamiltonian simulation circuits". T. Goubault de Brugière, S. Martiel et al. https://arxiv.org/abs/2404.03280
