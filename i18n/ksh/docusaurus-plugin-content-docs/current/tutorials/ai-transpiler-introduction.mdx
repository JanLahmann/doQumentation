---
title: "Einführung en der Qiskit KI-jedrevve Transpiler-Service"
sidebar_label: "Einführung en der Qiskit KI-jedrevve Transpiler-Service"
description: "En däm Notebook lure mer uns de wichtichste Vordeile vum Qiskit KI-jedrevve Transpiler-Service aan un wie dä sich met traditionelle Metode vergliche deit."
notebook_path: "docs/tutorials/ai-transpiler-introduction.ipynb"
---

<OpenInLabBanner notebookPath="docs/tutorials/ai-transpiler-introduction.ipynb" />



{/* cspell:ignore fontsize idxmin */}

*Jetze QPU-Nutzung: Nix (OPJEPASS: Dat Tutorial föhrt kein Jobs us, weil et sich op Transpilation konzentriert)*

## Hengergrund {#background}

Dä **Qiskit KI-jedrevve Transpiler-Service (QTS)** brängk maschinelles-Liere-basierte Optimierunge en Routing- un och en Synthesis-Passes eren. Dees KI-Modi sin entwickelt woode, öm de Beschränkunge vun der traditionelle Transpilation aanzejonn, besöngers för jruuße Schaltunge un komplexe Hardware-Topologien.

Ab **Juli 2025** es dä **Transpiler-Service** zur neue IBM Quantum&reg; Plattform migriert woode un es nit mieh verfögbar. För de neuste Updates övver der Status vum Transpiler-Service louret mer op de [Transpiler-Service-Dokumentation](/guides/qiskit-transpiler-service). Ehr künnt dä KI-Transpiler wiggerhin lokal verwende, änlich wie bei der Standard-Qiskit-Transpilation. Ersetz einfach `generate_preset_pass_manager()` durch `generate_ai_pass_manager()`. Die Funktion konstruiert ne Pass-Manager, dä de KI-jedrevve Routing- un Synthesis-Passes direkt en ühr lokale Transpilations-Workflow integriert.

### Hauptmerkmaale vun de KI-Passes {#key-features-of-ai-passes}

- Routing-Passes: KI-jedrevet Routing kann Qubit-Pfäd dynamisch basierend op de spezifische Schaltung un et Backend aanpasse un dä Bedarf aan övvermäßige SWAP-Gates reduziere.
    - `AIRouting`: Layout-Uswahl un Schaltungs-Routing

- Synthesis-Passes: KI-Technike optimiere de Zerlegung vun Multi-Qubit-Gates un minimiere de Aanzahl vun de Zwei-Qubit-Gates, die typischerwiis anfälliger för Fähler sin.
    - `AICliffordSynthesis`: Clifford-Gate-Synthese
    - `AILinearFunctionSynthesis`: Synthese vun Linear-Funktionsschaltunge
    - `AIPermutationSynthesis`: Synthese vun Permutationsschaltunge
    - `AIPauliNetworkSynthesis`: Synthese vun Pauli-Netzwerkschaltunge (nor em Qiskit Transpiler Service verfögbar, nit en der lokale Ömgevung)

- Verglich met traditioneller Transpilation: Dä Standard-Qiskit-Transpiler es e robuus Werkzüch, dat e breet Spektrum vun Quanteschaltunge effektiv handhabe kann. Wann Schaltunge ävver jrüßer wäde oder Hardware-Konfigurationne komplexer wäde, künne KI-Passes zosätzliche Optimierungsgewinn levvere. Durch de Verwendung vun jelierte Modelle för Routing un Synthese verfeinert QTS Schaltungslayouts wigger un reduziert dä Overhead för herausfordernd oder jruuß aanjelaate Quanteaufjaabe.

Dat Tutorial evaluiert de KI-Modi ongerm Verwenden vun Routing- un och vun Synthesis-Passes un verglicht de Ergebnisse met traditioneller Transpilation, öm hervörzetrecke, wo KI Leishtungsvordeile beet.

För mieh Details övver de verfögbare KI-Passes luurt en de [KI-Passes-Dokumentation](/guides/ai-transpiler-passes).

### Woröm KI för Quanteschaltungs-Transpilation verwende? {#why-use-ai-for-quantum-circuit-transpilation}

Wie Quanteschaltunge en Jrüße un Komplexität tonemme, han traditionelle Transpilationsmethode Schwierichkeite, Layouts ze optimiere un Gate-Aanzahle effizient ze reduziere. Jrüßere Schaltunge, besöngers die met Hunderte vun Qubits, stelle erhebliche Herausforderunge aan et Routing un de Synthese dar, wejen Jeräätbeschränkunge, bejränzter Konnektivität un Qubit-Fählerraten.

Do beet de KI-jedrevve Transpilation en potenzielle Lüsung. Durch de Nutzung vun maschinelle Lierntechnike kann dä KI-jedrevve Transpiler en Qiskit klöcher Entscheidunge övver Qubit-Routing un Gate-Synthese treffe, wat zo besserer Optimierung vun jruuß aanjelaate Quanteschaltunge föhrt.

### Koot Benchmarking-Ergebnisse {#brief-benchmarking-results}
![Graph showing AI transpiler performance against Qiskit](/docs/images/tutorials/ai-transpiler-introduction/ai-transpiler-benchmarks.avif)

En Benchmarking-Tests hät dä KI-Transpiler konsistent flachere Schaltunge hüherer Qualität em Verglich zum Standard-Qiskit-Transpiler produziert. För dees Tests han mer de Standard-Pass-Manager-Strategie vun Qiskit verwendet, konfiguriert met [`generate_preset_passmanager`]. Während die Standardstrategie off effektiv es, kann se bei jrüßere oder komplexere Schaltunge Schwierichkeite han. Em Jegensatz dozoe han KI-jedrevve Passes en durchschnittliche Reduzierung vun der Zwei-Qubit-Gate-Aanzahl öm 24% un en Reduzierung vun der Schaltungstiefe öm 36% för jruuße Schaltunge (100+ Qubits) bei der Transpilation op de Heavy-Hex-Topologie vun IBM Quantum Hardware erreicht. Wigger Informationnen övver dees Benchmarks fingkt ehr em [Blog.](https://www.ibm.com/quantum/blog/qiskit-performance)

Dat Tutorial ongersöök de wichtichste Vordeile vun de KI-Passes un wie se sich met traditionelle Metode verglicht.

```python
# Added by doQumentation — installs packages not in the Binder environment
%pip install -q qiskit-ibm-transpiler
```

```python
# This cell is hidden from users;
# it just disables a linting rule.
# ruff: noqa: F811
```

## Aanforderunge {#requirements}

Stellt vür dem Begjenn vum Tutorial sescher, dat ehr Foljends installiert hat:

* Qiskit SDK v1.0 oder hüher, met Ongerstötzung för [Visualisierung](https://docs.quantum.ibm.com/api/qiskit/visualization)
* Qiskit Runtime (`pip install qiskit-ibm-runtime`) v0.22 oder hüher
* Qiskit IBM&reg; Transpiler met KI-Lokalmodus(`pip install 'qiskit-ibm-transpiler[ai-local-mode]'`)

## Setup {#setup}

```python
from qiskit import QuantumCircuit
from qiskit.circuit.library import efficient_su2, PermutationGate
from qiskit.synthesis.qft import synth_qft_full
from qiskit.circuit.random import random_circuit, random_clifford_circuit
from qiskit.transpiler import generate_preset_pass_manager, CouplingMap
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_transpiler import generate_ai_pass_manager
from qiskit.synthesis.permutation import (
    synth_permutation_depth_lnn_kms,
    synth_permutation_basic,
)
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import time
import logging

seed = 42

# Used for generating permutation circuits in part two for comparison
def generate_permutation_circuit(width, pattern):
    circuit = QuantumCircuit(width)
    circuit.append(
        PermutationGate(pattern=pattern),
        qargs=range(width),
    )
    return circuit

# Creates a Bernstein-Vazirani circuit given the number of qubits
def create_bv_circuit(num_qubits):
    qc = QuantumCircuit(num_qubits, num_qubits - 1)
    qc.x(num_qubits - 1)
    qc.h(qc.qubits)
    for i in range(num_qubits - 1):
        qc.cx(i, num_qubits - 1)
    qc.h(qc.qubits[:-1])
    return qc

# Transpile a circuit with a given pass manager and return metrics
def transpile_with_metrics(pass_manager, circuit):
    start = time.time()
    qc_out = pass_manager.run(circuit)
    elapsed = time.time() - start

    depth_2q = qc_out.depth(lambda x: x.operation.num_qubits == 2)
    gate_count = qc_out.size()

    return qc_out, {
        "depth_2q": depth_2q,
        "gate_count": gate_count,
        "time_s": elapsed,
    }

# Used for collecting metrics for part 3 of synthesis methods
def synth_transpile_with_metrics(qc, pm, pattern_id, method):
    start = time.time()
    qc = pm.run(qc)
    elapsed = time.time() - start

    return {
        "Pattern": pattern_id,
        "Method": method,
        "Depth (2Q)": qc.depth(lambda x: x.operation.num_qubits == 2),
        "Gates": qc.size(),
        "Time (s)": elapsed,
    }

# Ignore logs like "INFO:qiskit_ibm_transpiler.wrappers.ai_local_synthesis:Running Linear Functions AI synthesis on local mode"

logging.getLogger(
    "qiskit_ibm_transpiler.wrappers.ai_local_synthesis"
).setLevel(logging.WARNING)
```

# Deel I. Qiskit-Musster {#part-i-qiskit-patterns}

Jetz luure mer uns aan, wie mer dä KI-Transpiler-Service met ener einfache Quanteschaltung ongerm Verwenden vun Qiskit-Musster verwendet. Dä Schlößel es de Erschtellung vun nem `PassManager` met `generate_ai_pass_manager()` anstatt vum Standard `generate_preset_pass_manager()`.

## Schrett 1: Klassische Einjabe op e Quanteproblem afbelde {#step-1-map-classical-inputs-to-a-quantum-problem}

En däm Afschnett teste mer dä KI-Transpiler op der `efficient_su2`-Schaltung, nem wiet verbreide hardwareeffiziente Aansatz. Die Schaltung es besöngers relevant för variationelle Quantealgorithme (för Beispill VQE) un Quantum-Machine-Learning-Aufjaabe, wat se zo nem ideale Testfall för de Bewertung vun der Transpilationsleistung määt.

De `efficient_su2`-Schaltung besteiht us afwechselnde Schichte vun Ein-Qubit-Rotatione un verschränkende Gates wie CNOTs. Die Schichte ermöjliche en flexible Erkundung vum Quantezustandsraum, während de Gate-Tiefe övverschaubar blievt. Durch Optimierung vun dä Schaltung wolle mer de Gate-Aanzahl reduziere, de Fidelität verbessere un Ruusch minimiere. Dat määt se zo nem starke Kandidaat för et Teste vun der Effizienz vum KI-Transpilers.

```python
# For our transpilation, we will use a large circuit of 101 qubits
qc = efficient_su2(90, entanglement="circular", reps=1).decompose()

# Draw a smaller version of the circuit to get a visual representation
qc_small = efficient_su2(5, entanglement="circular", reps=1).decompose()
qc_small.draw(output="mpl")
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/c6e9c2c0-e02c-4276-bae8-d5692e60b6b8-0.avif)

## Schrett 2: Problem för de Usführung op Quantehardware optimiere {#step-2-optimize-problem-for-quantum-hardware-execution}

### E Backend uswähle {#choose-a-backend}

För dat Beispill wähle mer et am wenigste usjelasstete betriebsbereite IBM Quantum Backend, dat kein Simulator es un mindestens 100 Qubits hät:

**Opjepass:** Weil sich et am wenigste usjelasstete Backend em Lauf vun der Zick ändere kann, künne för verschiedene Durchläuf ongerscheidliche Jeräät usgewählt wäde. Jeräät-spezifische Eijenschaffte, wie Coupling-Maps, künne zo Ongerscheid en de transpilierten Schaltunge föhre.

```python
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=100
)
cm = backend.coupling_map
print(f"Using backend: {backend.name}")
```

```text
Using backend: ibm_torino
```

### KI- un traditionelle Pass-Manager erschteile {#create-ai-and-traditional-pass-managers}
Öm de Effektivität vum KI-Transpilers ze bewäärde, föhre mer zwei Transpilationsläuf durch. Zörsch transpiliere mer de Schaltung met däm KI-Transpiler. Dann föhre mer ne Verglich durch, endem mer dieselv Schaltung ohne dä KI-Transpiler met traditionelle Metode transpiliere. Beidse Transpilationsprozesse verwende dieselv Coupling-Map vum jewählte Backend un et Optimierungslevel weed op 3 jesatz, för ne fairen Verglich.

Beidse Metode spiegele dä Standardaansatz zur Erschtellung vun `PassManager`-Instanze zur Transpilation vun Schaltunge en Qiskit wider.

```python
pm_ai = generate_ai_pass_manager(
    optimization_level=3,
    ai_optimization_level=3,
    coupling_map=cm,
    include_ai_synthesis=True,  # used for part 3 when comparing synthesis methods
)

pm_no_ai = generate_preset_pass_manager(
    optimization_level=3,
    coupling_map=cm,
    seed_transpiler=seed,  # note that the AI pass manager does not currently support seeding
)
```

Transpiliert de Schaltunge un zeechent de Zicke op.

```python
# Transpile using standard (non-AI) pass manager
_, metrics_no_ai = transpile_with_metrics(pm_no_ai, qc)
print(
    f"Standard transpilation: Depth (2q) {metrics_no_ai['depth_2q']}, "
    f"Gate count {metrics_no_ai['gate_count']}, Time {metrics_no_ai['time_s']}"
)

# Transpile using AI pass manager
_, metrics_ai = transpile_with_metrics(pm_ai, qc)
print(
    f"AI transpilation      : Depth (2q) {metrics_ai['depth_2q']}, "
    f"Gate count {metrics_ai['gate_count']}, Time {metrics_ai['time_s']}"
)
```

```text
Standard transpilation: Depth (2q) 95, Gate count 458, Time 0.04650712013244629
AI transpilation      : Depth (2q) 90, Gate count 456, Time 0.9342479705810547
```

En däm Test verglieche mer de Leistung vum KI-Transpiler un vun der Standard-Transpilationsmethode op der efficient_su2-Schaltung. Dä KI-Transpiler erreicht en merklich flachere Schaltungstiefe bei änlicher Gate-Aanzahl.

- **Schaltungstiefe:** Dä KI-Transpiler produziert en Schaltung met jeringerer Zwei-Qubit-Tiefe. Dat es ze erwade, weil de KI-Passes drop trainiert sin, de Tiefe ze optimiere, endem se Qubit-Interaktionsmusster liere un Hardware-Konnektivität effektiver als rejel-basierte Heuristike usnutze.

- **Gate-Aanzahl:** De Jesamt-Gate-Aanzahl blievt zwesche de zwei Metode änlich. Dat entsprich de Erwadunge, weil de Standard-SABRE-basierte Transpilation explizit de Swap-Aanzahl minimiert, die dä Gate-Overhead dominiert. Dä KI-Transpiler priorisiert stattdesse de Jesamttiefe un kann jelejentlich e paar zosätzliche Gates för ne köözere Usführungspfad intausche.

- **Transpilationszick:** Dä KI-Transpiler bruch mieh Zick als de Standardmethode. Dat litt aan de zosätzliche Rechekoste för et Oproofe vun jelierte Modelle während vum Routing un der Synthese. Em Jegensatz dozoe es dä SABRE-basierte Transpiler jetz no Neufassung un Optimierung en Rust düütlich schneller un beet huheffizient heuristisch Routing em jruuße Maßstab.

Et es wichtich ze beachte, dat dees Ergebnisse nor op ener Schaltung basiere. Öm e ömfassend Verständnis dodrüvver ze krijje, wie sich dä KI-Transpiler em Verglich zo traditionelle Metode verhält, es et nüdich, en Vielzahl vun Schaltunge ze teste. De Leistung vun QTS kann je no Aat vun der ze optimierende Schaltung stark variiere. För ne breitere Verglich louret mer op de obije Benchmarks oder besök dä [Blog.](https://www.ibm.com/quantum/blog/qiskit-performance)

## Schrett 3: Usführung met Qiskit Primitives {#step-3-execute-using-qiskit-primitives}
Weil sich dat Tutorial op Transpilation konzentriert, wäde kein Experimänte op däm Quantejeräät usjeföhrt. Et Zill es et, de Optimierunge us Schrett 2 ze nutze, öm en transpilierte Schaltung met reduzierter Tiefe oder Gate-Aanzahl ze krijje.

## Schrett 4: Nohbearbeitung un Röckjaab vum Ergebnis em jewönschte klassische Format {#step-4-post-process-and-return-result-in-desired-classical-format}
Weil et kein Usführung för dat Notebook jitt, jitt et kein Ergebnisse zur Nohbearbeitung.

# Deel II. Analyse un Benchmarking vun de transpilierten Schaltunge {#part-ii-analyze-and-benchmark-the-transpiled-circuits}

En däm Afschnett zeije mer, wie mer de transpilierte Schaltung analysiert un detaillierter met der Originalversion verglicht. Mer konzentriere uns op Metrike wie Schaltungstiefe, Gate-Aanzahl un Transpilationszick, öm de Effektivität vun der Optimierung ze bewäärde. Zosätzlich diskutiere mer, wie de Ergebnisse övver verschiedene Schaltungstype henwiech variiere künne, un beede Einbleck en de breider Leistung vum Transpiler övver verschiedene Szenarios henwiech.

```python
# Circuits to benchmark
seed = 42
circuits = [
    {
        "name": "Random",
        "qc": random_circuit(num_qubits=30, depth=10, seed=seed),
    },
    {
        "name": "Clifford",
        "qc": random_clifford_circuit(
            num_qubits=40, num_gates=200, seed=seed
        ),
    },
    {
        "name": "QFT",
        "qc": synth_qft_full(num_qubits=20, do_swaps=False).decompose(),
    },
    {
        "name": "BV",
        "qc": create_bv_circuit(40),
    },
]

results = []

# Run the transpilation for each circuit and store the results
for circuit in circuits:
    qc_no_ai, metrics_no_ai = transpile_with_metrics(pm_no_ai, circuit["qc"])
    qc_ai, metrics_ai = transpile_with_metrics(pm_ai, circuit["qc"])

    print("Completed transpilation for", circuit["name"])

    results.append(
        {
            "Circuit": circuit["name"],
            "Depth 2Q (No AI)": metrics_no_ai["depth_2q"],
            "Gate Count (No AI)": metrics_no_ai["gate_count"],
            "Time (No AI)": metrics_no_ai["time_s"],
            "Depth 2Q (AI)": metrics_ai["depth_2q"],
            "Gate Count (AI)": metrics_ai["gate_count"],
            "Time (AI)": metrics_ai["time_s"],
        }
    )

df = pd.DataFrame(results)
df
```

```text
Completed transpilation for Random
Completed transpilation for Clifford
Completed transpilation for QFT
Completed transpilation for BV
```

```text
Circuit  Depth 2Q (No AI)  Gate Count (No AI)  Time (No AI)  \
0    Random                37                 221      0.039347
1  Clifford                36                 232      0.036633
2       QFT               165                 924      0.077458
3        BV                65                 155      0.024993

   Depth 2Q (AI)  Gate Count (AI)  Time (AI)
0             24              181   0.773718
1             43              267   1.097431
2            130              913   3.660771
3             70              155   0.345522
```

Durchschnittliche prozentuale Reduzierung för jede Metrik. Positive sin Verbesserunge, negative sin Verschlechterunge.

```python
# Average reduction from non-AI to AI transpilation as a percentage
avg_reduction_depth = (
    (df["Depth 2Q (No AI)"] - df["Depth 2Q (AI)"]).mean()
    / df["Depth 2Q (No AI)"].mean()
    * 100
)
avg_reduction_gates = (
    (df["Gate Count (No AI)"] - df["Gate Count (AI)"]).mean()
    / df["Gate Count (No AI)"].mean()
    * 100
)
avg_reduction_time = (
    (df["Time (No AI)"] - df["Time (AI)"]).mean()
    / df["Time (No AI)"].mean()
    * 100
)

print(f"Average reduction in depth: {avg_reduction_depth:.2f}%")
print(f"Average reduction in gate count: {avg_reduction_gates:.2f}%")
print(f"Average reduction in transpilation time: {avg_reduction_time:.2f}%")
```

```text
Average reduction in depth: 11.88%
Average reduction in gate count: 1.04%
Average reduction in transpilation time: -3193.95%
```

```python
fig, axs = plt.subplots(1, 3, figsize=(21, 6))
df.plot(
    x="Circuit",
    y=["Depth 2Q (No AI)", "Depth 2Q (AI)"],
    kind="bar",
    ax=axs[0],
)
axs[0].set_title("Circuit Depth Comparison")
axs[0].set_ylabel("Depth")
axs[0].set_xlabel("Circuit")
axs[0].tick_params(axis="x", rotation=45)
df.plot(
    x="Circuit",
    y=["Gate Count (No AI)", "Gate Count (AI)"],
    kind="bar",
    ax=axs[1],
)
axs[1].set_title("Gate Count Comparison")
axs[1].set_ylabel("Gate Count")
axs[1].set_xlabel("Circuit")
axs[1].tick_params(axis="x", rotation=45)
df.plot(x="Circuit", y=["Time (No AI)", "Time (AI)"], kind="bar", ax=axs[2])
axs[2].set_title("Time Comparison")
axs[2].set_ylabel("Time (seconds)")
axs[2].set_xlabel("Circuit")
axs[2].tick_params(axis="x", rotation=45)
fig.suptitle(
    "Benchmarking AI transpilation vs Non-AI transpilation for various circuits"
)

plt.tight_layout()
plt.show()
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/79b8d5d9-0f9d-42ca-9583-8bec17430014-0.avif)

De Leistung vum KI-Transpilers variiert je no Aat vun der ze optimierende Schaltung erheblich. En mansche Fäll erreicht hä bemerkenswääte Reduzierunge vun der Schaltungstiefe un Gate-Aanzahl em Verglich zum Standard-Transpiler. Dees Verbesserunge jonn ävver off met ener erhebliche Erhöhung vun der Loufzick enher.

För bestemmte Schaltungstype kann dä KI-Transpiler e bessje bessere Ergebnisse bezöglich der Schaltungstiefe erziehle, ävver och zo ener Erhöhung vun der Gate-Aanzahl un ener erhebliche Loufzickstraf föhre. Dees Beobachtunge leje noh, dat de Vordeile vum KI-Transpilers nit bei alle Schaltungstype einheitlich sin. Stattdesse häng singe Effektivität vun de spezifische Eijenschaffte vun der Schaltung af, wat en för mansche Aanwendungsfäll besser jeeignet määt als för angere.

## Wann sollte Benutzer KI-jedrevve Transpilation wähle? {#when-should-users-choose-ai-powered-transpilation}

Dä KI-jedrevve Transpiler en Qiskit glänz en Szenarios, wo traditionelle Transpilationsmethode Schwierichkeite han, besöngers bei jruuß aanjelaate un komplexe Quanteschaltunge. För Schaltunge met Hunderte vun Qubits oder die, die op Hardware met komplizierte Coupling-Maps afziehle, beet dä KI-Transpiler övverlejene Optimierung bezöglich Schaltungstiefe, Gate-Aanzahl un Loufzickeffizienz. En Benchmarking-Tests hät hä traditionelle Metode konsistent övverdroffe un düütlich flachere Schaltunge jelevvert un Gate-Aanzahle reduziert, wat för de Verbesserung vun der Leistung un de Minderung vun Ruusch op echter Quantehardware entscheidend es.

Benutzer sollte KI-jedrevve Transpilation en Betracht trecke, wann se met:
- Jruuße Schaltunge schaffe, wo traditionelle Metode dä Maßstab nit effizient handhabe künne.
- Komplexe Hardware-Topologien, wo Jeräät-konnektivität un Routing-Herausforderunge opträäde.
- Leishtungssensitive Aanwendunge, wo de Reduzierung vun der Schaltungstiefe un de Verbesserung vun der Fidelität vun jrüßter Bedüttung sin.

# Deel III. Erkundung vun der KI-jedrevve Permutationsnetzwerk-Synthese {#part-iii-explore-ai-powered-permutation-network-synthesis}

Permutationsnetzwerke sin grundlejend em Quantencomputing, besöngers för Systeme, die durch beschränkte Topologien beschränkt sin. Dees Netzwerke erliechtern Langstreckeninteraktione, endem se Qubits dynamisch tausche, öm All-to-All-Konnektivität op Hardware met bejränzter Konnektivität nohzeahme. Söllche Transformatione sin för de Implementierung komplexer Quantealgorithme op kurzfristije Jeräät onerlässlich, wo Interaktione off övver nöchste Nohbere henusjohn.

En däm Afschnett hevve mer de Synthese vun Permutationsnetzwerke als övverzüjende Aanwendung för dä KI-jedrevve Transpiler en Qiskit erför. Besöngers nutz dä `AIPermutationSynthesis`-Pass KI-jestüüerte Optimierung, öm effiziente Schaltunge för Qubit-Permutationsaufjaabe ze generiere. Em Jegensatz dozoe han generische Synthese-Aansätz off Schwierichkeite, Gate-Aanzahl un Schaltungstiefe uszebalanciere, besöngers en Szenarios met dichte Qubit-Interaktione oder beim Versök, voll Konnektivität ze erreiche.

Mer wäde e Qiskit-Mussterbeispill durchjonn, dat de Synthese vun nem Permutationsnetzwerk zeich, öm All-to-All-Konnektivität för ne Satz vun Qubits ze erreiche. Mer wäde de Leistung vun `AIPermutationSynthesis` met de Standard-Synthesemethode en Qiskit verglieche. Dat Beispill weed zeije, wie dä KI-Transpiler för jeringere Schaltungstiefe un Gate-Aanzahl optimiert un sing Vordeile en praktische Quanten-Workflows ervörhevt. Öm dä KI-Synthese-Pass ze aktiviere, verwende mer de Funktion `generate_ai_pass_manager()` met däm Parameter `include_ai_synthesis` op `True` jesatz.

## Schrett 1: Klassische Einjabe op e Quanteproblem afbelde {#step-1-map-classical-inputs-to-a-quantum-problem-2}

Öm e klassisch Permutationsproblem op nem Quantencomputer darzestelle, fange mer met der Definition vun der Struktur vun de Quanteschaltunge aan. För dat Beispill:

1. Quanteschaltungs-Initialisierung:
   Mer weise 27 Qubits zo, öm zum Backend ze passe, dat mer verwende wäde, dat 27 Qubits hät.

2. Permutatione aanwende:
   Mer generiere zehn zofellige Permutationsmusster (`pattern_1` bes `pattern_10`) ongerm Verwenden vun nem feste Seed för Reproduzierbarkeit. Jedet Permutationsmuster weed op en separate Quanteschaltung aanjewendet (`qc_1` bes `qc_10`).

3. Schaltungszerlegung:
   Jede Permutationsoperation weed en native Gate-Sets zerlaat, die met der Zihl-Quantehardware kompatibel sin. Mer analysiere de Tiefe un de Aanzahl vun de Zwei-Qubit-Gates (nichtlokale Gates) för jede zerlaate Schaltung.

De Ergebnissejevve Einbleck en de Komplexität vun der Darstellung klassischer Permutationsprobleme op nem Quantejeräät un demonstriere de Ressourceaanforderunge för verschiedene Permutationsmusster.

```python
# Parameters
width = 27
num_circuits = 10

# Set random seed
np.random.seed(seed)

# Generate random patterns and circuits
patterns = [
    np.random.permutation(width).tolist() for _ in range(num_circuits)
]
circuits = {
    f"qc_{i}": generate_permutation_circuit(width, pattern)
    for i, pattern in enumerate(patterns, start=1)
}

# Display one of the circuits
circuits["qc_1"].decompose(reps=3).draw(output="mpl", fold=-1)
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/76a3e847-0808-4413-bd0c-c760cd2df3f4-0.avif)

## Schrett 2: Problem för de Usführung op Quantehardware optimiere {#step-2-optimize-problem-for-quantum-hardware-execution-2}
En däm Schrett fahre mer met der Optimierung ongerm Verwenden vun de KI-Synthese-Passes fott.

För de KI-Synthese-Passes bruch dä `PassManager` nor de Coupling-Map vum Backend. Et es ävver wichtich ze beachte, dat nit all Coupling-Maps kompatibel sin; nor diejenige, op dänne dä `AIPermutationSynthesis`-Pass trainiert woode es, wäde funktioniere. Aktuell ongerstötz dä `AIPermutationSynthesis`-Pass Blöck vun de Jrüße 65, 33 un 27 Qubits. För dat Beispill verwende mer en 27-Qubit-QPU.

För Verglich wäde mer de Leistung vun der KI-Synthese jejent generische Permutations-Synthesemethode en Qiskit evaluiere, inklusive:

- `synth_permutation_depth_lnn_kms`: Die Methode synthetisiert en Permutationsschaltung för en linear Nöchste-Nohber-(LNN)-Architektur ongerm Verwenden vum Kutin-, Moulton- un Smithline-(KMS)-Algorithmus. Se jarantiert en Schaltung met ener Tiefe vun hüchstens $ n $ un ener Jrüße vun hüchstens $ n(n-1)/2 $, wobei sowohl Tiefe als och Jrüße en Bezoch op SWAP-Gates jemesse wäde.

- `synth_permutation_basic`: Dat es en einfache Implementierung, die Permutationsschaltunge synthetisiert, ohne Beschränkunge för Konnektivität oder Optimierung för spezifische Architekturen opzeerleje. Se dient als Basislinie för dä Verglich vun der Leistung met fortjeschreddene Metode.

Jede vun dä Metode repräsentiert ne eijene Aansatz zur Synthese vun Permutationsnetzwerke un beet ne ömfassende Benchmark jejent de KI-jedrevve Metode.

Wigger Details övver Synthesemethode en Qiskit fingkt ehr en der [Qiskit-API-Dokumentation](https://docs.quantum.ibm.com/api/qiskit/synthesis).

Definiert de Coupling-Map, die de 27-Qubit-QPU repräsentiert.

```python
coupling_map = [
    [1, 0],
    [2, 1],
    [3, 2],
    [3, 5],
    [4, 1],
    [6, 7],
    [7, 4],
    [7, 10],
    [8, 5],
    [8, 9],
    [8, 11],
    [11, 14],
    [12, 10],
    [12, 13],
    [12, 15],
    [13, 14],
    [16, 14],
    [17, 18],
    [18, 15],
    [18, 21],
    [19, 16],
    [19, 22],
    [20, 19],
    [21, 23],
    [23, 24],
    [25, 22],
    [25, 24],
    [26, 25],
]
CouplingMap(coupling_map).draw()
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/84dff2c2-a496-4828-bb8e-08d373816a36-0.avif)

Transpiliert jede vun de Permutationsschaltunge ongerm Verwenden vun de KI-Synthese-Passes un generische Synthesemethode.

```python
results = []
pm_no_ai_synth = generate_preset_pass_manager(
    coupling_map=cm,
    optimization_level=1,  # set to 1 since we are using the synthesis methods
)

# Transpile and analyze all circuits
for i, (qc_name, qc) in enumerate(circuits.items(), start=1):
    pattern = patterns[i - 1]  # Get the corresponding pattern

    qc_depth_lnn_kms = synth_permutation_depth_lnn_kms(pattern)
    qc_basic = synth_permutation_basic(pattern)

    # AI synthesis
    results.append(
        synth_transpile_with_metrics(
            qc.decompose(reps=3),
            pm_ai,
            qc_name,
            "AI",
        )
    )

    # Depth-LNN-KMS Method
    results.append(
        synth_transpile_with_metrics(
            qc_depth_lnn_kms.decompose(reps=3),
            pm_no_ai_synth,
            qc_name,
            "Depth-LNN-KMS",
        )
    )

    # Basic Method
    results.append(
        synth_transpile_with_metrics(
            qc_basic.decompose(reps=3),
            pm_no_ai_synth,
            qc_name,
            "Basic",
        )
    )

results_df = pd.DataFrame(results)
```

Zeechent de Metrike (Tiefe, Gate-Aanzahl, Zick) för jede Schaltung no der Transpilation op.

```python
# Calculate averages for each metric
average_metrics = results_df.groupby("Method")[
    ["Depth (2Q)", "Gates", "Time (s)"]
].mean()
average_metrics = average_metrics.round(3)  # Round to two decimal places
print("\n=== Average Metrics ===")
print(average_metrics)

# Identify the best non-AI method based on least average depth
non_ai_methods = [
    method for method in results_df["Method"].unique() if method != "AI"
]
best_non_ai_method = average_metrics.loc[non_ai_methods][
    "Depth (2Q)"
].idxmin()
print(
    f"\nBest Non-AI Method (based on least average depth): {best_non_ai_method}"
)

# Compare AI to the best non-AI method
ai_metrics = average_metrics.loc["AI"]
best_non_ai_metrics = average_metrics.loc[best_non_ai_method]

comparison = {
    "Metric": ["Depth (2Q)", "Gates", "Time (s)"],
    "AI": [
        ai_metrics["Depth (2Q)"],
        ai_metrics["Gates"],
        ai_metrics["Time (s)"],
    ],
    best_non_ai_method: [
        best_non_ai_metrics["Depth (2Q)"],
        best_non_ai_metrics["Gates"],
        best_non_ai_metrics["Time (s)"],
    ],
    "Improvement (AI vs Best Non-AI)": [
        ai_metrics["Depth (2Q)"] - best_non_ai_metrics["Depth (2Q)"],
        ai_metrics["Gates"] - best_non_ai_metrics["Gates"],
        ai_metrics["Time (s)"] - best_non_ai_metrics["Time (s)"],
    ],
}

comparison_df = pd.DataFrame(comparison)
print("\n=== Comparison of AI vs Best Non-AI Method ===")
comparison_df
```

```text
=== Average Metrics ===
               Depth (2Q)  Gates  Time (s)
Method
AI                   23.9   82.8     0.248
Basic                29.8   91.0     0.012
Depth-LNN-KMS        70.8  531.6     0.017

Best Non-AI Method (based on least average depth): Basic

=== Comparison of AI vs Best Non-AI Method ===
```

```text
Metric      AI   Basic  Improvement (AI vs Best Non-AI)
0  Depth (2Q)  23.900  29.800                           -5.900
1       Gates  82.800  91.000                           -8.200
2    Time (s)   0.248   0.012                            0.236
```

De Ergebnisse demonstriere, dat dä KI-Transpiler all ander Qiskit-Synthesemethode för dä Satz zofellicher Permutationsschaltunge övverdrefft. Wichtiche Erkenntnisse ömfasse:

1. Tiefe: Dä KI-Transpiler erreicht de niedrigste durchschnittliche Tiefe, wat op övverlejene Optimierung vun Schaltungslayouts henwiis.
2. Gate-Aanzahl: Hä reduziert de Aanzahl vun de Gates em Verglich zo angere Metode erheblich un verbessert de Usführungs-Fidelität un -Effizienz.
3. Transpilationszick: All Metode loufe op dä Skala sehr flöck, wat se praktisch ensetzbar määt. Dä KI-Transpiler hät ävver en bemerkenswääte Loufzickerhöhung em Verglich zo traditionelle Metode wejen der Komplexität vun de verwendete KI-Modelle.

Dees Ergebnisse etabliere dä KI-Transpiler als dä effektivste Aansatz för dä Benchmark, besöngers för Tiefen- un Gate-Aanzahl-Optimierung.

Stellt de Ergebnisse dar, öm de Leistung vun de KI-Synthese-Passes met de generische Synthesemethode ze verglieche.

```python
methods = results_df["Method"].unique()

fig, axs = plt.subplots(1, 3, figsize=(18, 5))

# Pivot the DataFrame and reorder columns to ensure AI is first
pivot_depth = results_df.pivot(
    index="Pattern", columns="Method", values="Depth (2Q)"
)[["AI", "Depth-LNN-KMS", "Basic"]]
pivot_gates = results_df.pivot(
    index="Pattern", columns="Method", values="Gates"
)[["AI", "Depth-LNN-KMS", "Basic"]]
pivot_time = results_df.pivot(
    index="Pattern", columns="Method", values="Time (s)"
)[["AI", "Depth-LNN-KMS", "Basic"]]

pivot_depth.plot(kind="bar", ax=axs[0], legend=False)
axs[0].set_title("Circuit Depth Comparison")
axs[0].set_ylabel("Depth")
axs[0].set_xlabel("Pattern")
axs[0].tick_params(axis="x", rotation=45)
pivot_gates.plot(kind="bar", ax=axs[1], legend=False)
axs[1].set_title("2Q Gate Count Comparison")
axs[1].set_ylabel("Number of 2Q Gates")
axs[1].set_xlabel("Pattern")
axs[1].tick_params(axis="x", rotation=45)
pivot_time.plot(
    kind="bar", ax=axs[2], legend=True, title="Legend"
)  # Show legend on the last plot
axs[2].set_title("Time Comparison")
axs[2].set_ylabel("Time (seconds)")
axs[2].set_xlabel("Pattern")
axs[2].tick_params(axis="x", rotation=45)
fig.suptitle(
    "Benchmarking AI Synthesis Methods vs Non-AI Synthesis Methods For Random Permutations Circuits",
    fontsize=16,
    y=1,
)

plt.tight_layout()
plt.show()
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/a326f268-0115-442c-8563-968676b66670-0.avif)

Dat Diagramm hevt de individuellen Ergebnisse för jede Schaltung (`qc_1` bes `qc_10`) övver verschiedene Synthesemethode henwiech erför:

Während dees Ergebnisse de Effektivität vum KI-Transpilers för Permutationsschaltunge ongerstreeche, es et wichtich, sing Beschränkunge ze beachte. De KI-Synthesemethode es aktuell nor för bestemmte Coupling-Maps verfögbar, wat ehr breider Aanwendbarkeit beschränke kann. Die Beschränkung sollt bei der Bewärtung vun erer Verwendung en verschiedene Szenarios berücksichticht wääde.

Insjesamp zeich dä KI-Transpiler versprechende Verbesserunge en der Tiefen- un Gate-Aanzahl-Optimierung för dees spezifische Schaltunge bei verglichbare Transpilationszicke.

## Schrett 3: Usführung met Qiskit Primitives {#step-3-execute-using-qiskit-primitives-2}
Weil sich dat Tutorial op Transpilation konzentriert, wäde kein Experimänte op däm Quantejeräät usjeföhrt. Et Zill es et, de Optimierunge us Schrett 2 ze nutze, öm en transpilierte Schaltung met reduzierter Tiefe oder Gate-Aanzahl ze krijje.

## Schrett 4: Nohbearbeitung un Röckjaab vum Ergebnis em jewönschte klassische Format {#step-4-post-process-and-return-result-in-desired-classical-format-2}
Weil et kein Usführung för dat Notebook jitt, jitt et kein Ergebnisse zur Nohbearbeitung.

## Tutorial-Ömfraach {#tutorial-survey}

Bett määt bei dä koote Ömfraach met, öm Feedback zo däm Tutorial ze jevve. Ühr Erkenntnisse helfe uns, uns Inhaltsaanjebot un uns Benutzererfahrung ze verbessere.

[Link zur Ömfraach](https://your.feedback.ibm.com/jfe/form/SV_0igXMtMCQfApgDI)
