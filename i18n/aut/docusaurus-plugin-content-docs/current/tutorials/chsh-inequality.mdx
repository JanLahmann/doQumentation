---
title: "CHSH-Ungleichung"
sidebar_label: "CHSH-Ungleichung"
description: "Führen mir a Experiment auf'n Quantenrechner durch, um de Verletzung vo da CHSH-Ungleichung mit'n Estimator-Primitiv zum zeign."
notebook_path: "docs/tutorials/chsh-inequality.ipynb"
---
{/* doqumentation-source-hash: 05263e84 */}

<OpenInLabBanner notebookPath="docs/tutorials/chsh-inequality.ipynb" />



{/* cspell:ignore zorder */}

*Nutzungsschätzung: Zwoa Minuten auf'n Heron r2-Prozessor (HINWEIS: Des is nur a Schätzung. Dei Laufzeit kau variieren.)*
## Hintergrund {#background}

In dem Tutorial führen mir a Experiment auf'n Quantenrechner durch, um de Verletzung vo da CHSH-Ungleichung mit'n Estimator-Primitiv zum zeign.

De CHSH-Ungleichung, benannt noch de Autoren Clauser, Horne, Shimony und Holt, wird verwendet, um Bells Theorem (1969) experimentell zum beweis'n. Des Theorem sogt aus, dass lokale Theorien mit verborgene Variabeln net olle Konsequenzen vo da Verschränkung in da Quantenmechanik erklären kennan. De Verletzung vo da CHSH-Ungleichung wird verwendet, um zum zeign, dass de Quantenmechanik mit lokale Theorien mit verborgene Variabeln net vereinbar is. Des is a wichtigs Experiment fürs Verständnis vo de Grundlagen vo da Quantenmechanik.

Da Nobelpreis für Physik 2022 is an Alain Aspect, John Clauser und Anton Zeilinger vergeben worn, unter anderem für ihre Pionierarbeit in da Quanteninformationswissenschaft und bsonders für ihre Experimente mit verschränkte Photonen, de de Verletzung vo de Bellschen Ungleichungen demonstriert ham.
## Anforderungen {#requirements}

Bevor du mit dem Tutorial anfangst, stell' sicher, dass du Folgendes installiert hast:

* Qiskit SDK v1.0 oda neuer, mit [visualization](https://docs.quantum.ibm.com/api/qiskit/visualization)-Unterstützung
* Qiskit Runtime (`pip install qiskit-ibm-runtime`) v0.22 oda neuer
## Einrichtung {#setup}

```python
# General
import numpy as np

# Qiskit imports
from qiskit import QuantumCircuit
from qiskit.circuit import Parameter
from qiskit.quantum_info import SparsePauliOp
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

# Qiskit Runtime imports
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_runtime import EstimatorV2 as Estimator

# Plotting routines
import matplotlib.pyplot as plt
import matplotlib.ticker as tck
```

## Schritt 1: Klassische Eingaben auf a Quantenproblem obbilden {#step-1-map-classical-inputs-to-a-quantum-problem}
Für des Experiment machen mir a verschränktes Paar, wo mir jedes Qubit auf zwoa verschiedene Basen messen. Mir kennzeichnen de Basen für's erste Qubit mit $A$ und $a$ und de Basen für's zweite Qubit mit $B$ und $b$. Des erlaubt's uns, de CHSH-Größe $S_1$ zum berechnen:

$$
S_1 = A(B-b) + a(B+b).
$$

Jede Observable is entweder $+1$ oda $-1$. Klar is, dass oana vo de Terme $B\pm b$ gleich $0$ sei muaß und da andere $\pm 2$ sei muaß. Deshalb is $S_1 = \pm 2$. Da Durchschnittswert vo $S_1$ muaß de Ungleichung erfüllen:

$$
|\langle S_1 \rangle|\leq 2.
$$

Wann ma $S_1$ in Bezug auf $A$, $a$, $B$ und $b$ ausentwickelt, kriegen mir:

$$
|\langle S_1 \rangle| = |\langle AB \rangle - \langle Ab \rangle + \langle aB \rangle + \langle ab \rangle| \leq 2
$$

Du kennst no a weitere CHSH-Größe $S_2$ definieren:

$$
S_2 = A(B+b) - a(B-b),
$$

Des führt zu ana weiteren Ungleichung:

$$
|\langle S_2 \rangle| = |\langle AB \rangle + \langle Ab \rangle - \langle aB \rangle + \langle ab \rangle| \leq 2
$$

Wann de Quantenmechanik durch lokale Theorien mit verborgene Variabeln beschriebn wern kau, müassen de vorherigen Ungleichungen wahr sei. Aba wia in dem Tutorial gzeigt wird, kennan diese Ungleichungen auf'n Quantenrechner verletzt wern. Deshalb is de Quantenmechanik net mit lokale Theorien mit verborgene Variabeln vereinbar.
Falls du mehr Theorie lernen wüllst, schaun dir [Entanglement in Action](/learning/courses/basics-of-quantum-information/entanglement-in-action/chsh-game) mit'n John Watrous au.
Mir machen a verschränktes Paar zwischn zwoa Qubits in an Quantenrechner, indem mir'n Bell-Zustand $|\Phi^+\rangle = \frac{|00\rangle + |11\rangle}{\sqrt{2}}$ erzeugen. Mit'n Estimator-Primitiv kennst du direkt de nötigen Erwartungswerte ($\langle AB \rangle, \langle Ab \rangle, \langle aB \rangle$ und $\langle ab \rangle$) kriegen, um de Erwartungswerte vo de beiden CHSH-Größen $\langle S_1\rangle$ und $\langle S_2\rangle$ zum berechnen. Vor da Einführung vom Estimator-Primitiv hättest du de Erwartungswerte aus de Messergebnisse konstruieren müassen.

Mir messen des zweite Qubit in de $Z$- und $X$-Basen. Des erste Qubit wird a in orthogonale Basen gmessen, aba mit an Winkel bezüglich vom zweiten Qubit, den mir zwischn $0$ und $2\pi$ variieren wern. Wia du sehn wirst, macht des Estimator-Primitiv des Ausführen vo parametrisierten Schaltkreisen sehr einfach. Anstatt a Reihe vo CHSH-Schaltkreisen zum erstellen, muasst du bloß *oanen* CHSH-Schaltkreis mit an Parameter erstellen, der'n Messwinkel angibt, und a Reihe vo Phasenwerte für'n Parameter.

Schlussendlich wern mir de Ergebnisse analysieren und gegen Messwinkel auftragen. Du wirst sehn, dass für'n bestimmten Bereich vo Messwinkeln de Erwartungswerte vo de CHSH-Größen $|\langle S_1\rangle| > 2$ oda $|\langle S_2\rangle| > 2$ san, was de Verletzung vo da CHSH-Ungleichung demonstriert.

```python
# To run on hardware, select the backend with the fewest number of jobs in the queue
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=127
)
backend.name
```

```text
'ibm_kingston'
```

### An parametrisierten CHSH-Schaltkreis erstellen {#create-a-parameterized-chsh-circuit}

Zuerscht schreiben mir'n Schaltkreis mit'n Parameter $\theta$, den mir `theta` nennan. Des [`Estimator`-Primitiv](https://docs.quantum-computing.ibm.com/api/qiskit-ibm-runtime/qiskit_ibm_runtime.EstimatorV2) kau'n Schaltkreisaufbau und de Ausgabeanalyse enorm vereinfachen, indem's direkt Erwartungswerte vo Observablen liefert. Vüle interessante Probleme, bsonders für kurzfristige Anwendungen auf verrauschte Systeme, kennan in Form vo Erwartungswerte formuliert wern. Des `Estimator` (V2)-Primitiv kau automatisch de Messbasis basierend auf da bereitgstellten Observable ändern.

```python
theta = Parameter("$\\theta$")

chsh_circuit = QuantumCircuit(2)
chsh_circuit.h(0)
chsh_circuit.cx(0, 1)
chsh_circuit.ry(theta, 0)
chsh_circuit.draw(output="mpl", idle_wires=False, style="iqp")
```

![Output of the previous code cell](/docs/images/tutorials/chsh-inequality/extracted-outputs/6c77e40a-0.avif)

### A Liste vo Phasenwerte erstellen, de später zugewiesen wern {#create-a-list-of-phase-values-to-be-assigned-later}

Nochdems du'n parametrisierten CHSH-Schaltkreis erstellt hast, erstell' a Liste vo Phasenwerte, de dem Schaltkreis im nächsten Schritt zugewiesen wern. Du kennst'n folgenden Code verwenden, um a Liste vo 21 Phasenwerte im Bereich vo $0$ bis $2 \pi$ mit gleichem Abstand zum erstellen, also $0$, $0.1 \pi$, $0.2 \pi$, ..., $1.9 \pi$, $2 \pi$.

```python
number_of_phases = 21
phases = np.linspace(0, 2 * np.pi, number_of_phases)
# Phases need to be expressed as list of lists in order to work
individual_phases = [[ph] for ph in phases]
```

### Observablen {#observables}

Jetzt brauchen mir Observablen, aus denen mir de Erwartungswerte berechnen kennan. In unserm Fall betrachten mir orthogonale Basen für jedes Qubit, wobei de parametrisierte $Y$-Rotation für's erste Qubit de Messbasis beinahe kontinuierlich bezüglich vo da Basis vom zweiten Qubit variiert. Mir wählen deshalb de Observablen $ZZ$, $ZX$, $XZ$ und $XX$.

```python
# <CHSH1> = <AB> - <Ab> + <aB> + <ab> -> <ZZ> - <ZX> + <XZ> + <XX>
observable1 = SparsePauliOp.from_list(
    [("ZZ", 1), ("ZX", -1), ("XZ", 1), ("XX", 1)]
)

# <CHSH2> = <AB> + <Ab> - <aB> + <ab> -> <ZZ> + <ZX> - <XZ> + <XX>
observable2 = SparsePauliOp.from_list(
    [("ZZ", 1), ("ZX", 1), ("XZ", -1), ("XX", 1)]
)
```

## Schritt 2: Problem für de Ausführung auf Quantenhardware optimieren {#step-2-optimize-problem-for-quantum-hardware-execution}
Um de Gesamtausführungszeit vom Job zum reduzieren, akzeptieren V2-Primitive bloß Schaltkreise und Observablen, de de vom Zielsystem unterstützten Anweisungen und de Konnektivität entsprechen (bezeichnet als Instruction Set Architecture (ISA)-Schaltkreise und -Observablen).
### ISA-Schaltkreis {#isa-circuit}

```python
target = backend.target
pm = generate_preset_pass_manager(target=target, optimization_level=3)

chsh_isa_circuit = pm.run(chsh_circuit)
chsh_isa_circuit.draw(output="mpl", idle_wires=False, style="iqp")
```

![Output of the previous code cell](/docs/images/tutorials/chsh-inequality/extracted-outputs/9a5561eb-0.avif)

### ISA-Observablen {#isa-observables}
Ebenso müassen mir de Observablen transformieren, um's backend-kompatibel zum machen, bevor mir Jobs mit [`Runtime Estimator V2`](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/estimator-v2#run) ausführen. Mir kennan de Transformation mit da `apply_layout`-Methode vom `SparsePauliOp`-Objekt durchführen.

```python
isa_observable1 = observable1.apply_layout(layout=chsh_isa_circuit.layout)
isa_observable2 = observable2.apply_layout(layout=chsh_isa_circuit.layout)
```

## Schritt 3: Ausführen mit Qiskit-Primitiven {#step-3-execute-using-qiskit-primitives}

Um des gesamte Experiment in oam einzigen Aufruf vom [`Estimator`](https://docs.quantum-computing.ibm.com/api/qiskit-ibm-runtime/qiskit_ibm_runtime.EstimatorV2) auszuführen.
Mir kennan a [Qiskit Runtime `Estimator`](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/estimator-v2)-Primitiv erstellen, um unsre Erwartungswerte zum berechnen. De `EstimatorV2.run()`-Methode nimmt a Iterable vo `primitive unified blocs (PUBs)`. Jedes PUB is a Iterable im Format `(circuit, observables, parameter_values: Optional, precision: Optional)`.

```python
# To run on a local simulator:
# Use the StatevectorEstimator from qiskit.primitives instead.

estimator = Estimator(mode=backend)

pub = (
    chsh_isa_circuit,  # ISA circuit
    [[isa_observable1], [isa_observable2]],  # ISA Observables
    individual_phases,  # Parameter values
)

job_result = estimator.run(pubs=[pub]).result()
```

## Schritt 4: Nachbearbeitung und Rückgabe vom Ergebnis im gewünschten klassischen Format {#step-4-post-process-and-return-result-in-desired-classical-format}

Da Estimator gibt Erwartungswerte für beide Observablen zurück, $\langle ZZ \rangle - \langle ZX \rangle + \langle XZ \rangle + \langle XX \rangle$ und $\langle ZZ \rangle + \langle ZX \rangle - \langle XZ \rangle + \langle XX \rangle$.

```python
chsh1_est = job_result[0].data.evs[0]
chsh2_est = job_result[0].data.evs[1]
```

```python
fig, ax = plt.subplots(figsize=(10, 6))

# results from hardware
ax.plot(phases / np.pi, chsh1_est, "o-", label="CHSH1", zorder=3)
ax.plot(phases / np.pi, chsh2_est, "o-", label="CHSH2", zorder=3)

# classical bound +-2
ax.axhline(y=2, color="0.9", linestyle="--")
ax.axhline(y=-2, color="0.9", linestyle="--")

# quantum bound, +-2√2
ax.axhline(y=np.sqrt(2) * 2, color="0.9", linestyle="-.")
ax.axhline(y=-np.sqrt(2) * 2, color="0.9", linestyle="-.")
ax.fill_between(phases / np.pi, 2, 2 * np.sqrt(2), color="0.6", alpha=0.7)
ax.fill_between(phases / np.pi, -2, -2 * np.sqrt(2), color="0.6", alpha=0.7)

# set x tick labels to the unit of pi
ax.xaxis.set_major_formatter(tck.FormatStrFormatter("%g $\\pi$"))
ax.xaxis.set_major_locator(tck.MultipleLocator(base=0.5))

# set labels, and legend
plt.xlabel("Theta")
plt.ylabel("CHSH witness")
plt.legend()
plt.show()
```

![Output of the previous code cell](/docs/images/tutorials/chsh-inequality/extracted-outputs/f6267448-0.avif)

In da Abbildung grenzen de Linien und grauen Bereiche de Grenzen ab; de äußersten (strich-punktierten) Linien begrenzen de Quantengrenzen ($\pm 2$), während de inneren (gestrichelten) Linien de klassischen Grenzen ($\pm 2\sqrt{2}$) begrenzen. Du kennst sehn, dass's Bereiche gibt, wo de CHSH-Zeugengröße de klassischen Grenzen überschreitet. Herzlichen Glückwunsch! Du hast erfolgreich de Verletzung vo da CHSH-Ungleichung in an echten Quantensystem demonstriert!
## Tutorial-Umfrage {#tutorial-survey}

Bitte nimm an dieser kurzen Umfrage teil, um Feedback zu dem Tutorial zum geben. Deine Erkenntnisse helfen uns, unsre Inhaltsangebote und Benutzererfahrung zum verbessern.

[Link zur Umfrage](https://your.feedback.ibm.com/jfe/form/SV_3xxAgm1SF1wGp9k)
