---
title: "Einführung in'n Qiskit AI-gestützten Transpiler-Service"
sidebar_label: "Einführung in'n Qiskit AI-gestützten Transpiler-Service"
description: "In dem Notebook schauen ma uns de wichtigsten Vorteile vom Qiskit AI-gestützten Transpiler-Service an und wie er sich mit traditionellen Methoden vergleicht."
notebook_path: "docs/tutorials/ai-transpiler-introduction.ipynb"
---
{/* doqumentation-source-hash: 3bc5a35e */}

<OpenInLabBanner notebookPath="docs/tutorials/ai-transpiler-introduction.ipynb" />



{/* cspell:ignore fontsize idxmin */}

*Geschätzte QPU-Nutzung: Keine (HINWEIS: In dem Tutorial werden keine Jobs ausgeführt, weil's sich auf Transpilation konzentriert)*

## Hintergrund {#background}

Da **Qiskit AI-gestützte Transpiler-Service (QTS)** führt auf maschinellem Lernen basierende Optimierungen in Routing- und Synthese-Passes ein. Diese KI-Modi wurden entwickelt, um de Einschränkungen von der traditionellen Transpilation anzugehen, insbesondere bei groß angelegten Schaltkreisen und komplexen Hardware-Topologien.

Ab **Juli 2025** wurde da **Transpiler Service** auf de neue IBM Quantum&reg; Plattform migriert und ist net mehr verfügbar. Für die neuesten Updates zum Status vom Transpiler Service schau dir bitte de [Transpiler-Service-Dokumentation](/guides/qiskit-transpiler-service) an. Du kannst den KI-Transpiler nach wie vor lokal verwenden, ähnlich wie de Standard-Qiskit-Transpilation. Ersetze einfach `generate_preset_pass_manager()` durch `generate_ai_pass_manager()`. Diese Funktion baut a'n Pass Manager, der de KI-gestützten Routing- und Synthese-Passes direkt in deinen lokalen Transpilations-Workflow integriert.

### Wichtigste Funktionen von den KI-Passes {#key-features-of-ai-passes}

- Routing-Passes: KI-gestütztes Routing kann Qubit-Pfade dynamisch anpassen, je nach'm spezifischen Schaltkreis und Backend, was de Notwendigkeit für übermäßig viele SWAP-Gates reduziert.
    - `AIRouting`: Layout-Auswahl und Schaltkreis-Routing

- Synthese-Passes: KI-Techniken optimieren de Zerlegung von Multi-Qubit-Gates und minimieren dabei de Anzahl von Zwei-Qubit-Gates, die typischerweise fehleranfälliger san.
    - `AICliffordSynthesis`: Clifford-Gate-Synthese
    - `AILinearFunctionSynthesis`: Synthese von linearen Funktionsschaltkreisen
    - `AIPermutationSynthesis`: Permutationsschaltkreis-Synthese
    - `AIPauliNetworkSynthesis`: Pauli-Netzwerk-Schaltkreis-Synthese (nur im Qiskit Transpiler Service verfügbar, net in der lokalen Umgebung)

- Vergleich mit traditioneller Transpilation: Da Standard-Qiskit-Transpiler is a robustes Werkzeug, das a breites Spektrum an Quantenschaltkreisen effektiv verarbeiten kann. Wenn aber Schaltkreise größer werden oder Hardware-Konfigurationen komplexer, können KI-Passes zusätzliche Optimierungsgewinne liefern. Durch den Einsatz von gelernten Modellen für Routing und Synthese verfeinert QTS Schaltkreis-Layouts weiter und reduziert den Overhead bei anspruchsvollen oder groß angelegten Quantenaufgaben.

In dem Tutorial werden die KI-Modi mit sowohl Routing- als auch Synthese-Passes evaluiert, wobei de Ergebnisse mit traditioneller Transpilation verglichen werden, um zu zeigen, wo KI Leistungsgewinne bringt.

Für mehr Details zu den verfügbaren KI-Passes schau dir de [KI-Passes-Dokumentation](/guides/ai-transpiler-passes) an.

### Warum KI für die Transpilation von Quantenschaltkreisen verwenden? {#why-use-ai-for-quantum-circuit-transpilation}

Wenn Quantenschaltkreise in Größe und Komplexität wachsen, haben traditionelle Transpilationsmethoden Schwierigkeiten, Layouts zu optimieren und Gate-Anzahlen effizient zu reduzieren. Größere Schaltkreise, insbesondere solche mit Hunderten von Qubits, stellen beim Routing und bei der Synthese erhebliche Herausforderungen dar, wegen Geräte-Beschränkungen, begrenzter Konnektivität und Qubit-Fehlerraten.

Genau da bietet KI-gestützte Transpilation a potenzielle Lösung. Durch den Einsatz von Techniken des maschinellen Lernens kann da KI-gestützte Transpiler in Qiskit klügere Entscheidungen beim Qubit-Routing und bei der Gate-Synthese treffen, was zu besserer Optimierung von groß angelegten Quantenschaltkreisen führt.

### Kurze Benchmarking-Ergebnisse {#brief-benchmarking-results}
![Graph der die KI-Transpiler-Performance gegen Qiskit zeigt](/docs/images/tutorials/ai-transpiler-introduction/ai-transpiler-benchmarks.avif)

In Benchmarking-Tests hat da KI-Transpiler konsistent flachere, qualitativ hochwertigere Schaltkreise produziert als da Standard-Qiskit-Transpiler. Für diese Tests wurde Qiskits Standard-Pass-Manager-Strategie verwendet, konfiguriert mit [`generate_preset_passmanager`]. Obwohl diese Standard-Strategie oft effektiv is, kann sie bei größeren oder komplexeren Schaltkreisen an ihre Grenzen stoßen. Im Vergleich dazu haben KI-gestützte Passes a durchschnittliche Reduzierung von 24 % bei Zwei-Qubit-Gate-Anzahlen und a Reduzierung von 36 % bei der Schaltkreistiefe für große Schaltkreise (100+ Qubits) erreicht, wenn zur Heavy-Hex-Topologie von IBM Quantum Hardware transpiliert wurde. Für mehr Infos zu diesen Benchmarks schau dir diesen [Blog-Beitrag](https://www.ibm.com/quantum/blog/qiskit-performance) an.

In dem Tutorial werden de wichtigsten Vorteile von KI-Passes und ihr Vergleich mit traditionellen Methoden erkundet.

```python
# Added by doQumentation — installs packages not in the Binder environment
%pip install -q qiskit-ibm-transpiler
```

```python
# This cell is hidden from users;
# it just disables a linting rule.
# ruff: noqa: F811
```

## Voraussetzungen {#requirements}

Bevor du mit dem Tutorial anfängst, stell sicher, dass du folgendes installiert hast:

* Qiskit SDK v1.0 oder neuer, mit Unterstützung für [Visualisierung](https://docs.quantum.ibm.com/api/qiskit/visualization)
* Qiskit Runtime (`pip install qiskit-ibm-runtime`) v0.22 oder neuer
* Qiskit IBM&reg; Transpiler mit KI-Lokalmodus (`pip install 'qiskit-ibm-transpiler[ai-local-mode]'`)
## Setup {#setup}

```python
from qiskit import QuantumCircuit
from qiskit.circuit.library import efficient_su2, PermutationGate
from qiskit.synthesis.qft import synth_qft_full
from qiskit.circuit.random import random_circuit, random_clifford_circuit
from qiskit.transpiler import generate_preset_pass_manager, CouplingMap
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_transpiler import generate_ai_pass_manager
from qiskit.synthesis.permutation import (
    synth_permutation_depth_lnn_kms,
    synth_permutation_basic,
)
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import time
import logging

seed = 42

# Used for generating permutation circuits in part two for comparison
def generate_permutation_circuit(width, pattern):
    circuit = QuantumCircuit(width)
    circuit.append(
        PermutationGate(pattern=pattern),
        qargs=range(width),
    )
    return circuit

# Creates a Bernstein-Vazirani circuit given the number of qubits
def create_bv_circuit(num_qubits):
    qc = QuantumCircuit(num_qubits, num_qubits - 1)
    qc.x(num_qubits - 1)
    qc.h(qc.qubits)
    for i in range(num_qubits - 1):
        qc.cx(i, num_qubits - 1)
    qc.h(qc.qubits[:-1])
    return qc

# Transpile a circuit with a given pass manager and return metrics
def transpile_with_metrics(pass_manager, circuit):
    start = time.time()
    qc_out = pass_manager.run(circuit)
    elapsed = time.time() - start

    depth_2q = qc_out.depth(lambda x: x.operation.num_qubits == 2)
    gate_count = qc_out.size()

    return qc_out, {
        "depth_2q": depth_2q,
        "gate_count": gate_count,
        "time_s": elapsed,
    }

# Used for collecting metrics for part 3 of synthesis methods
def synth_transpile_with_metrics(qc, pm, pattern_id, method):
    start = time.time()
    qc = pm.run(qc)
    elapsed = time.time() - start

    return {
        "Pattern": pattern_id,
        "Method": method,
        "Depth (2Q)": qc.depth(lambda x: x.operation.num_qubits == 2),
        "Gates": qc.size(),
        "Time (s)": elapsed,
    }

# Ignore logs like "INFO:qiskit_ibm_transpiler.wrappers.ai_local_synthesis:Running Linear Functions AI synthesis on local mode"

logging.getLogger(
    "qiskit_ibm_transpiler.wrappers.ai_local_synthesis"
).setLevel(logging.WARNING)
```

# Teil I. Qiskit-Patterns {#part-i-qiskit-patterns}

Schauen ma uns jetzt an, wie ma'n KI-Transpiler-Service mit a'm einfachen Quantenschaltkreis verwendet, mithilfe von Qiskit-Patterns. Da Schlüssel is a'n `PassManager` mit `generate_ai_pass_manager()` zu erstellen, anstatt den Standard-`generate_preset_pass_manager()`.
## Schritt 1: Klassische Eingaben auf a Quantenproblem abbilden {#step-1-map-classical-inputs-to-a-quantum-problem}

In dem Abschnitt testen ma'n KI-Transpiler auf dem `efficient_su2`-Schaltkreis, a'n weit verbreiteten hardware-effizienten Ansatz. Da Schaltkreis is besonders relevant für variationelle Quantenalgorithmen (zum Beispiel VQE) und Quantenmaschinenlern-Aufgaben, was ihn zu a'm idealen Testfall für die Bewertung der Transpilationsleistung macht.

Da `efficient_su2`-Schaltkreis besteht aus abwechselnden Schichten von Einzelqubit-Rotationen und verschränkenden Gates wie CNOTs. Diese Schichten ermöglichen a flexible Erkundung des Quantenzustandsraums, während die Gate-Tiefe überschaubar bleibt. Durch das Optimieren von dem Schaltkreis wollen ma Gate-Anzahl reduzieren, Fidelity verbessern und Rauschen minimieren. Das macht ihn zu a'm starken Kandidaten für's Testen der Effizienz des KI-Transpilers.

```python
# For our transpilation, we will use a large circuit of 101 qubits
qc = efficient_su2(90, entanglement="circular", reps=1).decompose()

# Draw a smaller version of the circuit to get a visual representation
qc_small = efficient_su2(5, entanglement="circular", reps=1).decompose()
qc_small.draw(output="mpl")
```

![Ausgabe der vorherigen Code-Zelle](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/c6e9c2c0-e02c-4276-bae8-d5692e60b6b8-0.avif)

## Schritt 2: Problem für die Ausführung auf Quantenhardware optimieren {#step-2-optimize-problem-for-quantum-hardware-execution}

### A Backend auswählen {#choose-a-backend}

Für dieses Beispiel wählen ma das am wenigsten ausgelastete betriebsbereite IBM Quantum Backend, das kein Simulator is und mindestens 100 Qubits hat:

**Hinweis:** Da das am wenigsten ausgelastete Backend sich im Laufe der Zeit ändern kann, könnten bei verschiedenen Durchläufen unterschiedliche Geräte ausgewählt werden. Gerätespezifische Eigenschaften, wie Coupling Maps, können zu Unterschieden in den transpilierten Schaltkreisen führen.

```python
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=100
)
cm = backend.coupling_map
print(f"Using backend: {backend.name}")
```

```text
Using backend: ibm_torino
```

### KI- und traditionelle Pass Manager erstellen {#create-ai-and-traditional-pass-managers}
Um die Wirksamkeit des KI-Transpilers zu evaluieren, führen ma zwei Transpilationsdurchläufe durch. Zuerst transpilieren ma'n Schaltkreis mit dem KI-Transpiler. Dann machen ma a'n Vergleich, indem ma denselben Schaltkreis ohne den KI-Transpiler transpilieren, mit traditionellen Methoden. Beide Transpilationsprozesse verwenden dieselbe Coupling Map vom gewählten Backend und den Optimierungsgrad 3 für a'n fairen Vergleich.

Beide Methoden spiegeln den Standardansatz wider, um `PassManager`-Instanzen zu erstellen und Schaltkreise in Qiskit zu transpilieren.

```python
pm_ai = generate_ai_pass_manager(
    optimization_level=3,
    ai_optimization_level=3,
    coupling_map=cm,
    include_ai_synthesis=True,  # used for part 3 when comparing synthesis methods
)

pm_no_ai = generate_preset_pass_manager(
    optimization_level=3,
    coupling_map=cm,
    seed_transpiler=seed,  # note that the AI pass manager does not currently support seeding
)
```

Die Schaltkreise transpilieren und die Zeiten aufzeichnen.

```python
# Transpile using standard (non-AI) pass manager
_, metrics_no_ai = transpile_with_metrics(pm_no_ai, qc)
print(
    f"Standard transpilation: Depth (2q) {metrics_no_ai['depth_2q']}, "
    f"Gate count {metrics_no_ai['gate_count']}, Time {metrics_no_ai['time_s']}"
)

# Transpile using AI pass manager
_, metrics_ai = transpile_with_metrics(pm_ai, qc)
print(
    f"AI transpilation      : Depth (2q) {metrics_ai['depth_2q']}, "
    f"Gate count {metrics_ai['gate_count']}, Time {metrics_ai['time_s']}"
)
```

```text
Standard transpilation: Depth (2q) 95, Gate count 458, Time 0.04650712013244629
AI transpilation      : Depth (2q) 90, Gate count 456, Time 0.9342479705810547
```

In dem Test vergleichen ma de Leistung vom KI-Transpiler und der Standard-Transpilationsmethode auf dem efficient_su2-Schaltkreis. Da KI-Transpiler erreicht a merklich flachere Schaltkreistiefe bei ähnlicher Gate-Anzahl.

- **Schaltkreistiefe:** Da KI-Transpiler produziert a'n Schaltkreis mit niedrigerer Zwei-Qubit-Tiefe. Das is zu erwarten, da de KI-Passes darauf trainiert san, die Tiefe zu optimieren, indem sie Qubit-Interaktionsmuster lernen und die Hardware-Konnektivität effektiver ausnutzen als regelbasierte Heuristiken.

- **Gate-Anzahl:** De Gesamtzahl der Gates bleibt bei beiden Methoden ähnlich. Das stimmt mit den Erwartungen überein, da de Standard-SABRE-basierte Transpilation explizit de Swap-Anzahl minimiert, die den Gate-Overhead dominiert. Da KI-Transpiler priorisiert stattdessen die Gesamttiefe und kann manchmal a paar zusätzliche Gates für a'n kürzeren Ausführungspfad in Kauf nehmen.

- **Transpilationszeit:** Da KI-Transpiler braucht länger als die Standard-Methode. Das liegt an den zusätzlichen Rechenkosten durch das Aufrufen von gelernten Modellen während Routing und Synthese. Im Vergleich dazu is da SABRE-basierte Transpiler nach seiner Neuschreibung und Optimierung in Rust deutlich schneller geworden und bietet hocheffizientes heuristisches Routing in großem Maßstab.

Wichtig is zu beachten, dass diese Ergebnisse auf nur a'm Schaltkreis basieren. Um a'n umfassendes Verständnis davon zu bekommen, wie der KI-Transpiler mit traditionellen Methoden verglichen werden kann, is es notwendig, a Vielzahl von Schaltkreisen zu testen. Die Leistung von QTS kann je nach Art des zu optimierenden Schaltkreises stark variieren. Für a'n umfassenderen Vergleich schau dir de Benchmarks weiter oben an oder besuch den [Blog-Beitrag.](https://www.ibm.com/quantum/blog/qiskit-performance)
## Schritt 3: Mit Qiskit-Primitiven ausführen {#step-3-execute-using-qiskit-primitives}
Da sich dieses Tutorial auf Transpilation konzentriert, werden keine Experimente auf dem Quantengerät ausgeführt. Das Ziel is, de Optimierungen aus Schritt 2 zu nutzen, um a'n transpilierten Schaltkreis mit reduzierter Tiefe oder Gate-Anzahl zu erhalten.
## Schritt 4: Nachbearbeiten und Ergebnis im gewünschten klassischen Format zurückgeben {#step-4-post-process-and-return-result-in-desired-classical-format}
Da für dieses Notebook keine Ausführung stattfindet, gibt's keine Ergebnisse zum Nachbearbeiten.
# Teil II. Transpilierte Schaltkreise analysieren und benchmarken {#part-ii-analyze-and-benchmark-the-transpiled-circuits}

In dem Abschnitt zeigen ma, wie ma'n transpilierten Schaltkreis analysiert und ihn detaillierter gegen die Originalversion benchmarkt. Ma konzentrieren uns auf Metriken wie Schaltkreistiefe, Gate-Anzahl und Transpilationszeit, um die Effektivität der Optimierung zu beurteilen. Außerdem besprechen ma, wie de Ergebnisse bei verschiedenen Schaltkreistypen unterschiedlich sein können, was Einblicke in die breitere Leistung des Transpilers in verschiedenen Szenarien bietet.

```python
# Circuits to benchmark
seed = 42
circuits = [
    {
        "name": "Random",
        "qc": random_circuit(num_qubits=30, depth=10, seed=seed),
    },
    {
        "name": "Clifford",
        "qc": random_clifford_circuit(
            num_qubits=40, num_gates=200, seed=seed
        ),
    },
    {
        "name": "QFT",
        "qc": synth_qft_full(num_qubits=20, do_swaps=False).decompose(),
    },
    {
        "name": "BV",
        "qc": create_bv_circuit(40),
    },
]

results = []

# Run the transpilation for each circuit and store the results
for circuit in circuits:
    qc_no_ai, metrics_no_ai = transpile_with_metrics(pm_no_ai, circuit["qc"])
    qc_ai, metrics_ai = transpile_with_metrics(pm_ai, circuit["qc"])

    print("Completed transpilation for", circuit["name"])

    results.append(
        {
            "Circuit": circuit["name"],
            "Depth 2Q (No AI)": metrics_no_ai["depth_2q"],
            "Gate Count (No AI)": metrics_no_ai["gate_count"],
            "Time (No AI)": metrics_no_ai["time_s"],
            "Depth 2Q (AI)": metrics_ai["depth_2q"],
            "Gate Count (AI)": metrics_ai["gate_count"],
            "Time (AI)": metrics_ai["time_s"],
        }
    )

df = pd.DataFrame(results)
df
```

```text
Completed transpilation for Random
Completed transpilation for Clifford
Completed transpilation for QFT
Completed transpilation for BV
```

```text
Circuit  Depth 2Q (No AI)  Gate Count (No AI)  Time (No AI)  \
0    Random                37                 221      0.039347
1  Clifford                36                 232      0.036633
2       QFT               165                 924      0.077458
3        BV                65                 155      0.024993

   Depth 2Q (AI)  Gate Count (AI)  Time (AI)
0             24              181   0.773718
1             43              267   1.097431
2            130              913   3.660771
3             70              155   0.345522
```

Durchschnittliche prozentuale Reduzierung für jede Metrik. Positive Werte san Verbesserungen, negative san Verschlechterungen.

```python
# Average reduction from non-AI to AI transpilation as a percentage
avg_reduction_depth = (
    (df["Depth 2Q (No AI)"] - df["Depth 2Q (AI)"]).mean()
    / df["Depth 2Q (No AI)"].mean()
    * 100
)
avg_reduction_gates = (
    (df["Gate Count (No AI)"] - df["Gate Count (AI)"]).mean()
    / df["Gate Count (No AI)"].mean()
    * 100
)
avg_reduction_time = (
    (df["Time (No AI)"] - df["Time (AI)"]).mean()
    / df["Time (No AI)"].mean()
    * 100
)

print(f"Average reduction in depth: {avg_reduction_depth:.2f}%")
print(f"Average reduction in gate count: {avg_reduction_gates:.2f}%")
print(f"Average reduction in transpilation time: {avg_reduction_time:.2f}%")
```

```text
Average reduction in depth: 11.88%
Average reduction in gate count: 1.04%
Average reduction in transpilation time: -3193.95%
```

```python
fig, axs = plt.subplots(1, 3, figsize=(21, 6))
df.plot(
    x="Circuit",
    y=["Depth 2Q (No AI)", "Depth 2Q (AI)"],
    kind="bar",
    ax=axs[0],
)
axs[0].set_title("Circuit Depth Comparison")
axs[0].set_ylabel("Depth")
axs[0].set_xlabel("Circuit")
axs[0].tick_params(axis="x", rotation=45)
df.plot(
    x="Circuit",
    y=["Gate Count (No AI)", "Gate Count (AI)"],
    kind="bar",
    ax=axs[1],
)
axs[1].set_title("Gate Count Comparison")
axs[1].set_ylabel("Gate Count")
axs[1].set_xlabel("Circuit")
axs[1].tick_params(axis="x", rotation=45)
df.plot(x="Circuit", y=["Time (No AI)", "Time (AI)"], kind="bar", ax=axs[2])
axs[2].set_title("Time Comparison")
axs[2].set_ylabel("Time (seconds)")
axs[2].set_xlabel("Circuit")
axs[2].tick_params(axis="x", rotation=45)
fig.suptitle(
    "Benchmarking AI transpilation vs Non-AI transpilation for various circuits"
)

plt.tight_layout()
plt.show()
```

![Ausgabe der vorherigen Code-Zelle](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/79b8d5d9-0f9d-42ca-9583-8bec17430014-0.avif)

De Leistung des KI-Transpilers variiert je nach Art des zu optimierenden Schaltkreises erheblich. In manchen Fällen erzielt er bemerkenswerte Reduzierungen in der Schaltkreistiefe und Gate-Anzahl im Vergleich zum Standard-Transpiler. Diese Verbesserungen gehen aber oft mit a'm erheblichen Anstieg der Laufzeit einher.

Bei bestimmten Schaltkreistypen kann da KI-Transpiler a bissl bessere Ergebnisse in Bezug auf Schaltkreistiefe erzielen, aber auch zu a'm Anstieg der Gate-Anzahl und zu a'm deutlichen Laufzeit-Nachteil führen. Diese Beobachtungen legen nahe, dass de Vorteile des KI-Transpilers net für alle Schaltkreistypen einheitlich san. Stattdessen hängt seine Wirksamkeit von den spezifischen Eigenschaften des Schaltkreises ab, was ihn für manche Anwendungsfälle besser geeignet macht als für andere.
## Wann sollte ma KI-gestützte Transpilation verwenden? {#when-should-users-choose-ai-powered-transpilation}

Da KI-gestützte Transpiler in Qiskit glänzt in Szenarien, wo traditionelle Transpilationsmethoden Schwierigkeiten haben, insbesondere bei groß angelegten und komplexen Quantenschaltkreisen. Für Schaltkreise mit Hunderten von Qubits oder solche, die auf Hardware mit komplizierten Coupling Maps abzielen, bietet da KI-Transpiler überlegene Optimierung in Bezug auf Schaltkreistiefe, Gate-Anzahl und Laufzeiteffizienz. In Benchmarking-Tests hat er traditionelle Methoden konsistent übertroffen und deutlich flachere Schaltkreise und reduzierte Gate-Anzahlen geliefert, die entscheidend san, um die Leistung zu verbessern und Rauschen auf echter Quantenhardware zu reduzieren.

Du solltest KI-gestützte Transpilation in Betracht ziehen, wenn du arbeitest mit:
- Großen Schaltkreisen, wo traditionelle Methoden mit dem Umfang net effizient umgehen können.
- Komplexen Hardware-Topologien, wo Herausforderungen bei der Gerätekonnektivität und beim Routing auftreten.
- Leistungskritischen Anwendungen, wo de Reduzierung der Schaltkreistiefe und die Verbesserung der Fidelity entscheidend san.
# Teil III. KI-gestützte Permutationsnetzwerk-Synthese erkunden {#part-iii-explore-ai-powered-permutation-network-synthesis}

Permutationsnetzwerke san fundamental im Quantencomputing, insbesondere für Systeme, die durch eingeschränkte Topologien beschränkt san. Diese Netzwerke ermöglichen weitreichende Interaktionen, indem sie Qubits dynamisch tauschen, um Allzu-Alle-Konnektivität auf Hardware mit begrenzter Konnektivität zu simulieren. Solche Transformationen san essenziell für die Implementierung komplexer Quantenalgorithmen auf Near-Term-Geräten, wo Interaktionen oft über nächste Nachbarn hinausgehen.

In dem Abschnitt heben ma die Synthese von Permutationsnetzwerken als a'n überzeugenden Anwendungsfall für den KI-gestützten Transpiler in Qiskit hervor. Konkret nutzt da `AIPermutationSynthesis`-Pass KI-gestützte Optimierung, um effiziente Schaltkreise für Qubit-Permutationsaufgaben zu generieren. Im Vergleich dazu haben generische Syntheseansätze oft Schwierigkeiten, Gate-Anzahl und Schaltkreistiefe in Einklang zu bringen, insbesondere in Szenarien mit dichten Qubit-Interaktionen oder beim Versuch, vollständige Konnektivität zu erreichen.

Ma gehen a Qiskit-Patterns-Beispiel durch, das de Synthese eines Permutationsnetzwerks zeigt, um Allzu-Alle-Konnektivität für a Menge von Qubits zu erreichen. Ma vergleichen de Leistung von `AIPermutationSynthesis` mit den Standard-Synthesemethoden in Qiskit. Dieses Beispiel zeigt, wie da KI-Transpiler für niedrigere Schaltkreistiefe und Gate-Anzahl optimiert und hebt seine Vorteile in praktischen Quantenworkflows hervor. Um den KI-Synthese-Pass zu aktivieren, verwenden ma die `generate_ai_pass_manager()`-Funktion mit dem Parameter `include_ai_synthesis` auf `True` gesetzt.
## Schritt 1: Klassische Eingaben auf a Quantenproblem abbilden {#step-1-map-classical-inputs-to-a-quantum-problem-2}

Um a klassisches Permutationsproblem auf a'm Quantencomputer darzustellen, fangen ma mit der Definition der Struktur der Quantenschaltkreise an. Für dieses Beispiel:

1. Quantenschaltkreis-Initialisierung:
   Ma weisen 27 Qubits zu, um mit dem Backend übereinzustimmen, das 27 Qubits hat.

2. Permutationen anwenden:
   Ma generieren zehn zufällige Permutationsmuster (`pattern_1` bis `pattern_10`) mit a'm fixen Seed für Reproduzierbarkeit. Jedes Permutationsmuster wird auf a'n separaten Quantenschaltkreis angewendet (`qc_1` bis `qc_10`).

3. Schaltkreis-Zerlegung:
   Jede Permutationsoperation wird in native Gate-Sets zerlegt, die mit der Ziel-Quantenhardware kompatibel san. Ma analysieren die Tiefe und die Anzahl von Zwei-Qubit-Gates (nichtlokale Gates) für jeden zerlegten Schaltkreis.

Die Ergebnisse geben Einblick in die Komplexität der Darstellung von klassischen Permutationsproblemen auf a'm Quantengerät und demonstrieren die Ressourcenanforderungen für verschiedene Permutationsmuster.

```python
# Parameters
width = 27
num_circuits = 10

# Set random seed
np.random.seed(seed)

# Generate random patterns and circuits
patterns = [
    np.random.permutation(width).tolist() for _ in range(num_circuits)
]
circuits = {
    f"qc_{i}": generate_permutation_circuit(width, pattern)
    for i, pattern in enumerate(patterns, start=1)
}

# Display one of the circuits
circuits["qc_1"].decompose(reps=3).draw(output="mpl", fold=-1)
```

![Ausgabe der vorherigen Code-Zelle](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/76a3e847-0808-4413-bd0c-c760cd2df3f4-0.avif)

## Schritt 2: Problem für die Ausführung auf Quantenhardware optimieren {#step-2-optimize-problem-for-quantum-hardware-execution-2}
In dem Schritt gehen ma mit der Optimierung mithilfe der KI-Synthese-Passes weiter.

Für de KI-Synthese-Passes benötigt da `PassManager` nur de Coupling Map des Backends. Wichtig is dabei zu beachten, dass net alle Coupling Maps kompatibel san; nur jene, auf denen da `AIPermutationSynthesis`-Pass trainiert wurde, funktionieren. Derzeit unterstützt da `AIPermutationSynthesis`-Pass Blöcke der Größen 65, 33 und 27 Qubits. Für dieses Beispiel verwenden ma a 27-Qubit-QPU.

Zum Vergleich evaluieren ma die Leistung der KI-Synthese gegen generische Permutationssynthese-Methoden in Qiskit, darunter:

- `synth_permutation_depth_lnn_kms`: Diese Methode synthetisiert a'n Permutationsschaltkreis für a'n Linear-Nearest-Neighbor-(LNN-)Architektur mit dem Kutin-Moulton-Smithline-(KMS-)Algorithmus. Sie garantiert a'n Schaltkreis mit a'r Tiefe von maximal $ n $ und a'r Größe von maximal $ n(n-1)/2 $, wobei sowohl Tiefe als auch Größe in SWAP-Gates gemessen werden.

- `synth_permutation_basic`: Das is a'ne unkomplizierte Implementierung, die Permutationsschaltkreise synthetisiert, ohne Beschränkungen an Konnektivität oder Optimierung für spezifische Architekturen aufzuerlegen. Sie dient als Basislinie für den Leistungsvergleich mit fortgeschritteneren Methoden.

Jede dieser Methoden stellt a'n eigenen Ansatz zur Synthese von Permutationsnetzwerken dar und bietet a'n umfassenden Benchmark gegen de KI-gestützten Methoden.

Für mehr Details zu Synthesemethoden in Qiskit schau dir de [Qiskit-API-Dokumentation](https://docs.quantum.ibm.com/api/qiskit/synthesis) an.
De Coupling Map, die de 27-Qubit-QPU repräsentiert, definieren.

```python
coupling_map = [
    [1, 0],
    [2, 1],
    [3, 2],
    [3, 5],
    [4, 1],
    [6, 7],
    [7, 4],
    [7, 10],
    [8, 5],
    [8, 9],
    [8, 11],
    [11, 14],
    [12, 10],
    [12, 13],
    [12, 15],
    [13, 14],
    [16, 14],
    [17, 18],
    [18, 15],
    [18, 21],
    [19, 16],
    [19, 22],
    [20, 19],
    [21, 23],
    [23, 24],
    [25, 22],
    [25, 24],
    [26, 25],
]
CouplingMap(coupling_map).draw()
```

![Ausgabe der vorherigen Code-Zelle](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/84dff2c2-a496-4828-bb8e-08d373816a36-0.avif)

Jeden der Permutationsschaltkreise mit den KI-Synthese-Passes und generischen Synthesemethoden transpilieren.

```python
results = []
pm_no_ai_synth = generate_preset_pass_manager(
    coupling_map=cm,
    optimization_level=1,  # set to 1 since we are using the synthesis methods
)

# Transpile and analyze all circuits
for i, (qc_name, qc) in enumerate(circuits.items(), start=1):
    pattern = patterns[i - 1]  # Get the corresponding pattern

    qc_depth_lnn_kms = synth_permutation_depth_lnn_kms(pattern)
    qc_basic = synth_permutation_basic(pattern)

    # AI synthesis
    results.append(
        synth_transpile_with_metrics(
            qc.decompose(reps=3),
            pm_ai,
            qc_name,
            "AI",
        )
    )

    # Depth-LNN-KMS Method
    results.append(
        synth_transpile_with_metrics(
            qc_depth_lnn_kms.decompose(reps=3),
            pm_no_ai_synth,
            qc_name,
            "Depth-LNN-KMS",
        )
    )

    # Basic Method
    results.append(
        synth_transpile_with_metrics(
            qc_basic.decompose(reps=3),
            pm_no_ai_synth,
            qc_name,
            "Basic",
        )
    )

results_df = pd.DataFrame(results)
```

Die Metriken (Tiefe, Gate-Anzahl, Zeit) für jeden Schaltkreis nach der Transpilation aufzeichnen.

```python
# Calculate averages for each metric
average_metrics = results_df.groupby("Method")[
    ["Depth (2Q)", "Gates", "Time (s)"]
].mean()
average_metrics = average_metrics.round(3)  # Round to two decimal places
print("\n=== Average Metrics ===")
print(average_metrics)

# Identify the best non-AI method based on least average depth
non_ai_methods = [
    method for method in results_df["Method"].unique() if method != "AI"
]
best_non_ai_method = average_metrics.loc[non_ai_methods][
    "Depth (2Q)"
].idxmin()
print(
    f"\nBest Non-AI Method (based on least average depth): {best_non_ai_method}"
)

# Compare AI to the best non-AI method
ai_metrics = average_metrics.loc["AI"]
best_non_ai_metrics = average_metrics.loc[best_non_ai_method]

comparison = {
    "Metric": ["Depth (2Q)", "Gates", "Time (s)"],
    "AI": [
        ai_metrics["Depth (2Q)"],
        ai_metrics["Gates"],
        ai_metrics["Time (s)"],
    ],
    best_non_ai_method: [
        best_non_ai_metrics["Depth (2Q)"],
        best_non_ai_metrics["Gates"],
        best_non_ai_metrics["Time (s)"],
    ],
    "Improvement (AI vs Best Non-AI)": [
        ai_metrics["Depth (2Q)"] - best_non_ai_metrics["Depth (2Q)"],
        ai_metrics["Gates"] - best_non_ai_metrics["Gates"],
        ai_metrics["Time (s)"] - best_non_ai_metrics["Time (s)"],
    ],
}

comparison_df = pd.DataFrame(comparison)
print("\n=== Comparison of AI vs Best Non-AI Method ===")
comparison_df
```

```text
=== Average Metrics ===
               Depth (2Q)  Gates  Time (s)
Method
AI                   23.9   82.8     0.248
Basic                29.8   91.0     0.012
Depth-LNN-KMS        70.8  531.6     0.017

Best Non-AI Method (based on least average depth): Basic

=== Comparison of AI vs Best Non-AI Method ===
```

```text
Metric      AI   Basic  Improvement (AI vs Best Non-AI)
0  Depth (2Q)  23.900  29.800                           -5.900
1       Gates  82.800  91.000                           -8.200
2    Time (s)   0.248   0.012                            0.236
```

De Ergebnisse zeigen, dass da KI-Transpiler alle anderen Qiskit-Synthesemethoden für diesen Satz von zufälligen Permutationsschaltkreisen übertrifft. Wichtigste Erkenntnisse:

1. Tiefe: Da KI-Transpiler erreicht de niedrigste durchschnittliche Tiefe, was auf überlegene Optimierung der Schaltkreis-Layouts hinweist.
2. Gate-Anzahl: Er reduziert die Anzahl der Gates im Vergleich zu anderen Methoden erheblich, was die Ausführungsfidelity und Effizienz verbessert.
3. Transpilationszeit: Alle Methoden laufen bei diesem Maßstab sehr schnell, was sie für den Einsatz praktisch macht. Da KI-Transpiler hat aber a'n nennenswerten Laufzeitanstieg im Vergleich zu traditionellen Methoden, wegen der Komplexität der verwendeten KI-Modelle.

Diese Ergebnisse etablieren den KI-Transpiler als den effektivsten Ansatz für diesen Benchmark, insbesondere für Tiefe und Gate-Anzahl-Optimierung.
Die Ergebnisse plotten, um de Leistung der KI-Synthese-Passes gegen die generischen Synthesemethoden zu vergleichen.

```python
methods = results_df["Method"].unique()

fig, axs = plt.subplots(1, 3, figsize=(18, 5))

# Pivot the DataFrame and reorder columns to ensure AI is first
pivot_depth = results_df.pivot(
    index="Pattern", columns="Method", values="Depth (2Q)"
)[["AI", "Depth-LNN-KMS", "Basic"]]
pivot_gates = results_df.pivot(
    index="Pattern", columns="Method", values="Gates"
)[["AI", "Depth-LNN-KMS", "Basic"]]
pivot_time = results_df.pivot(
    index="Pattern", columns="Method", values="Time (s)"
)[["AI", "Depth-LNN-KMS", "Basic"]]

pivot_depth.plot(kind="bar", ax=axs[0], legend=False)
axs[0].set_title("Circuit Depth Comparison")
axs[0].set_ylabel("Depth")
axs[0].set_xlabel("Pattern")
axs[0].tick_params(axis="x", rotation=45)
pivot_gates.plot(kind="bar", ax=axs[1], legend=False)
axs[1].set_title("2Q Gate Count Comparison")
axs[1].set_ylabel("Number of 2Q Gates")
axs[1].set_xlabel("Pattern")
axs[1].tick_params(axis="x", rotation=45)
pivot_time.plot(
    kind="bar", ax=axs[2], legend=True, title="Legend"
)  # Show legend on the last plot
axs[2].set_title("Time Comparison")
axs[2].set_ylabel("Time (seconds)")
axs[2].set_xlabel("Pattern")
axs[2].tick_params(axis="x", rotation=45)
fig.suptitle(
    "Benchmarking AI Synthesis Methods vs Non-AI Synthesis Methods For Random Permutations Circuits",
    fontsize=16,
    y=1,
)

plt.tight_layout()
plt.show()
```

![Ausgabe der vorherigen Code-Zelle](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/a326f268-0115-442c-8563-968676b66670-0.avif)

Da Graph hebt die einzelnen Ergebnisse für jeden Schaltkreis (`qc_1` bis `qc_10`) über verschiedene Synthesemethoden hervor:

Obwohl diese Ergebnisse de Effektivität des KI-Transpilers für Permutationsschaltkreise unterstreichen, is es wichtig, seine Einschränkungen zu beachten. Die KI-Synthesemethode is derzeit nur für bestimmte Coupling Maps verfügbar, was ihre breitere Anwendbarkeit einschränken kann. Diese Einschränkung sollte berücksichtigt werden, wenn man ihren Einsatz in verschiedenen Szenarien bewertet.

Insgesamt demonstriert da KI-Transpiler vielversprechende Verbesserungen bei der Tiefe und Gate-Anzahl-Optimierung für diese spezifischen Schaltkreise, während er vergleichbare Transpilationszeiten beibehält.
## Schritt 3: Mit Qiskit-Primitiven ausführen {#step-3-execute-using-qiskit-primitives-2}
Da sich dieses Tutorial auf Transpilation konzentriert, werden keine Experimente auf dem Quantengerät ausgeführt. Das Ziel is, de Optimierungen aus Schritt 2 zu nutzen, um a'n transpilierten Schaltkreis mit reduzierter Tiefe oder Gate-Anzahl zu erhalten.
## Schritt 4: Nachbearbeiten und Ergebnis im gewünschten klassischen Format zurückgeben {#step-4-post-process-and-return-result-in-desired-classical-format-2}
Da für dieses Notebook keine Ausführung stattfindet, gibt's keine Ergebnisse zum Nachbearbeiten.
## Tutorial-Umfrage {#tutorial-survey}

Nimm bitte an dieser kurzen Umfrage teil, um Feedback zu dem Tutorial zu geben. Deine Einblicke helfen uns, unsere Inhalte und die Nutzererfahrung zu verbessern.

[Link zur Umfrage](https://your.feedback.ibm.com/jfe/form/SV_0igXMtMCQfApgDI)
