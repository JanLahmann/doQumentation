---
title: Tutorials
sidebar_label: Übersicht
sidebar_position: 1
description: Schau dir de IBM Quantum Tutorials an — laufen lassen auf'm RasQberry, über Binder oder auf dein'm eigenen Jupyter-Server.
---
{/* doqumentation-source-hash: e0b80945 */}

# Tutorials {#tutorials}

Verwend die Tutorials, um zu lernen, wie ma Qiskit für gängige Anwendungsfälle im Quantencomputing verwendet.

- Fang mit de Tutorials im Abschnitt [Einstieg](#einstieg) an, wenn's für dich 's erste Mal is, dass du Code auf'm Quantencomputer ausführst.
- Da Abschnitt über [Workflows in Richtung Vorteil](#workflows-in-richtung-vorteil-erkunden) enthält durchgehende Beispiele, wie ma'n Quantencomputer zum Lösen von echten Problemen verwendet. Die Tutorials konzentrieren sich auf Algorithmen, die vielversprechende Kandidaten san, um'n Rechenvorteil vom Quantencomputer gegenüber'm klassischen Computer zu erreichen.
- Da Abschnitt über [Qiskit-Funktionalitäten](#qiskit-funktionalitäten-nutzen) enthält Beispiele, die die neuesten und fortgeschrittensten Techniken im Qiskit-Ökosystem verwenden, um'n Teil oder'n ganzen Ablauf von'm bestimmten Workflow zu verbessern.

## Einstieg {#get-started}

Die Tutorials san für Anfänger gemacht, die bereit san, 's Ausführen von Quantenalgorithmen auf'm Quantencomputer zu erkunden.

* [CHSH-Ungleichung](/tutorials/chsh-inequality)

## Workflows in Richtung Vorteil erkunden {#explore-workflows-toward-advantage}

De Tutorials in dem Abschnitt behandeln groß angelegte Demonstrationen von Quantenalgorithmen.

<details>
  <summary>**Verifizierbare Sampling-Algorithmen**</summary>

De Algorithmen in der Kategorie konzentrieren sich auf Quantenschaltkreise, wo ihre Ausgabeverteilungen Lösungen für strukturierte Probleme mit verifizierbarer Ausgabe verschlüsseln. Verifizierbarkeit bedeutet, dass du de Konsistenz zwischen de gemessenen Daten überprüfen kannst, entweder durch 's Auswerten von der gewählten Bitfolge oder durch 's Wissen, dass koane Falsch-Positive vorkommen.

De Tutorials heben Techniken hervor, wo wiederholtes Sampling 's Schätzen von problemspezifischen Größen ermöglicht (zum Beispiel Kostenfunktionswerte oder spektrale Gewichte). Die Methoden san besonders wichtig für Optimierungs- und Simulationsaufgaben mit Symmetrie.

* [Sample-basierte Quantendiagonalisierung von'm Chemie-Hamiltonian](/tutorials/sample-based-quantum-diagonalization)

* [Sample-basierte Krylov-Quantendiagonalisierung von'm fermionischen Gittermodell](/tutorials/sample-based-krylov-quantum-diagonalization)

* [Quantum Approximate Optimization Algorithm](/tutorials/quantum-approximate-optimization-algorithm)

* [Fortgeschrittene Techniken für QAOA](/tutorials/advanced-techniques-for-qaoa)

* [Pauli-Korrelations-Codierung zur Reduzierung von Maxcut-Anforderungen](/tutorials/pauli-correlation-encoding-for-qaoa)

</details>

<details>
  <summary>**Schätzung von Observablen**</summary>

Die Tutorials konzentrieren sich aufs Schätzen von physikalisch bedeutsamen Größen, wie Energie oder Korrelationswerte, durch 's Vorbereiten von Quantenzuständen und 's Messen von Observablen. Zu de Techniken gehören sowohl variationelle als auch Trotterisierte Schaltkreis-Ansätze, die de Ausdrucksstärke vom Schaltkreis mit der Effizienz von der Schaltkreistiefe in Einklang bringen. Da Schwerpunkt liegt auf Workflows, die de Anforderungen an Quantenressourcen verringern und gleichzeitig de Genauigkeit behalten, und die 's praktische Schätzen von Observablen in chemischen und physikalischen Systemen ermöglichen.

* [Krylov-Quantendiagonalisierung von Gitter-Hamiltonians](/tutorials/krylov-quantum-diagonalization)

* [Nishimori-Phasenübergang](/tutorials/nishimori-phase-transition)

* [Grundzustandsenergieschätzung von der Heisenberg-Kette mit VQE](/tutorials/spin-chain-vqe)

* [Quantum Kernel Training](/tutorials/quantum-kernel-training)

* [Verbesserung von der Merkmalklassifizierung mit projizierten Quantenkernels](/tutorials/projected-quantum-kernels)

* [CHSH-Ungleichung](/tutorials/chsh-inequality)

</details>

<details>
  <summary>**Fehlertolerante Algorithmen**</summary>

Da Abschnitt enthält Algorithmen mit klar definierten theoretischen Garantien, die für 's Ausführen auf zukünftiger fehlerkorrigierter Quantenhardware entwickelt worden san. De Schaltkreise oder da Sampling-Overhead für die Algorithmen skalieren so, dass s' net tiefeneffizient san, und demonstrieren darum eher'n Quantenvorteil, wenn fehlertolerante Quantencomputer existieren. Die Tutorials zeigen, wie de Methoden in idealisierten Umgebungen funktionieren, und demonstrieren Beispiele im kleinen Maßstab.

* [Shors Algorithmus](/tutorials/shors-algorithm)
* [Grovers Algorithmus](/tutorials/grovers-algorithm)

</details>

## Qiskit-Funktionalitäten nutzen {#leverage-qiskit-capabilities}

Da Abschnitt stellt fortgeschrittene Funktionalitäten im Qiskit-Ökosystem vor, die de Leistung, Zuverlässigkeit und Geschwindigkeit bei der Ausführung von Quantenalgorithmen verbessern.

<details>
  <summary>**Workload-Optimierung**</summary>

De Workload-Optimierung konzentriert sich entweder auf de effiziente Orchestrierung von klassischen und Quantenressourcen oder auf maßgeschneiderte Methoden zur Verbesserung von der Manipulation von Quantenschaltkreisen.

* [Benchmark für dynamische Schaltkreise mit geschnittenen Bell-Paaren](/tutorials/edc-cut-bell-pair-benchmarking)

* [Einführung in Fractional Gates](/tutorials/fractional-gates)

* [Einführung in'n Qiskit AI-gestützten Transpiler-Service](/tutorials/ai-transpiler-introduction)

* [Transpilations-Optimierungen mit SABRE](/tutorials/transpilation-optimizations-with-sabre)

* [Kompilierungsmethoden für Hamiltonian-Simulations-Schaltkreise](/tutorials/compilation-methods-for-hamiltonian-simulation-circuits)

* [Weitreichende Verschränkung mit dynamischen Schaltkreisen](/tutorials/long-range-entanglement)

* [Simulation vom Kicked-Ising-Hamiltonian mit dynamischen Schaltkreisen](/tutorials/dc-hex-ising)

</details>

<details>
<summary>**Qiskit Functions**</summary>

Qiskit Functions san a Sammlung von vorgefertigten Fehlerverwaltungs- und Anwendungswerkzeugen, die 's einfach machen, groß angelegte Experimente mit Schaltkreisen, Molekülen, QUBOs und mehr zu entwerfen.

- Entwickle neue Algorithmen mit **Circuit Functions** -- mit vorgefertigten Pipelines für Transpilation, Fehlerunterdrückung und Fehlerminderung.

  * [Fehlerminderung mit der IBM Circuit Function](/tutorials/error-mitigation-with-qiskit-functions)

  * [Transverse-Field Ising-Modell mit Q-CTRLs Performance Management](/tutorials/transverse-field-ising-model)

  * [Quantum Phase Estimation mit Q-CTRLs Qiskit Functions](/tutorials/quantum-phase-estimation-qctrl)

  * [Simulation vom 2D-Tilted-Field-Ising mit der QESEM-Funktion](/tutorials/qedma-2d-ising-with-qesem)

- Experimentier mit domänenspezifischen Problemen mit **Application Functions** -- mit vertrauten Ein- und Ausgaben für klassische Solver.

  * [Quantum Portfolio Optimizer - A Qiskit Function von Global Data Quantum](/tutorials/global-data-quantum-optimizer)

  * [Binäre Optimierung höherer Ordnung mit Q-CTRLs Optimization Solver](/tutorials/solve-higher-order-binary-optimization-problems-with-q-ctrls-optimization-solver)

  * [Modellierung von aner strömenden nicht-viskosen Flüssigkeit mit QUICK-PDE](/tutorials/colibritd-pde)

  * [Dissoziations-PES-Kurven mit Qunova HiVQE](/tutorials/qunova-hivqe)

  * [Hybride quantengestützte Ensemble-Klassifikation (Grid-Stabilitäts-Workflow)](/tutorials/sml-classification)

  * [Lösung vom Market-Split-Problem mit Kipu Quantums Iskay Quantum Optimizer](/tutorials/solve-market-split-problem-with-iskay-quantum-optimizer)

</details>

<details>
  <summary>**Qiskit Addons**</summary>

Addons ermöglichen fortgeschrittene Schaltkreis-Manipulation, wie 's Schneiden, 's Rückpropagieren von Observablen oder 's Approximieren von Schaltkreisen, die 's dem Benutzer ermöglichen, Hardware-Beschränkungen zu umgehen, auf Kosten von mehr klassischem Rechenaufwand.

* [Multi-Produkt-Formeln zur Reduzierung vom Trotter-Fehler](/tutorials/multi-product-formula)

* [Approximative Quantenkompilierung für Zeitentwicklungs-Schaltkreise](/tutorials/approximate-quantum-compilation-for-time-evolution)

* [Operator-Backpropagation (OBP) zur Schätzung von Erwartungswerten](/tutorials/operator-back-propagation)

* [Wire-Cutting zur Schätzung von Erwartungswerten](/tutorials/wire-cutting)

* [Circuit-Cutting für periodische Randbedingungen](/tutorials/periodic-boundary-conditions-with-circuit-cutting)

* [Circuit-Cutting zur Tiefenreduzierung](/tutorials/depth-reduction-with-circuit-cutting)

* [Readout-Fehlerminderung für 's Sampler-Primitive mit M3](/tutorials/readout-error-mitigation-sampler)

</details>

<details>
  <summary>**Fehlerminderung**</summary>

Fehlerminderung adressiert de Herausforderung von Rauschen ohne vollständige Fehlertoleranz, indem genaue Erwartungswerte durch kontrollierte Schaltkreis-Manipulation und Nachbearbeitung wiederhergestellt werden.

* [Utility-Scale-Fehlerminderung mit probabilistischer Fehlerverstärkung](/tutorials/probabilistic-error-amplification)

* [Kombinierung von Fehlerminderungs-Optionen mit'm Estimator-Primitive](/tutorials/combine-error-mitigation-techniques)

* [Echtzeit-Benchmarking zur Qubit-Auswahl](/tutorials/real-time-benchmarking-for-qubit-selection)

</details>

<details>
  <summary>**Fehlererkennung**</summary>

Fehlererkennung identifiziert fehlerhafte Operationen, um durch Nachbearbeitung rauschfreie Ergebnisse Shot-für-Shot zurückzuliefern.

* [Repetition Codes](/tutorials/repetition-codes)

* [Fehlererkennung mit wenig Overhead durch Raumzeit-Codes](/tutorials/ghz-spacetime-codes)

</details>
