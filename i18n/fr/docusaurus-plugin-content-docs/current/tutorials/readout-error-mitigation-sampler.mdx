---
title: "Att√©nuation des erreurs de lecture pour la primitive Sampler avec M3"
sidebar_label: "Att√©nuation des erreurs de lecture pour la primitive Sampler avec M3"
description: "Utiliser l'addon de mitigation de lecture M3 avec la primitive Sampler"
notebook_path: "docs/tutorials/readout-error-mitigation-sampler.ipynb"
---

<OpenInLabBanner notebookPath="docs/tutorials/readout-error-mitigation-sampler.ipynb" />



{/* cspell:ignore braket, Zgrm, newcommand, probs, quasis, topten */}

*Estimation d'utilisation : moins d'une minute sur un processeur Heron r2 (REMARQUE : il s'agit uniquement d'une estimation. Votre temps d'ex√©cution peut varier.)*

## Contexte {#background}

Contrairement √† la primitive Estimator, la primitive Sampler ne dispose pas d'un support int√©gr√© pour l'att√©nuation des erreurs.
Plusieurs des m√©thodes prises en charge par l'Estimator sont sp√©cifiquement con√ßues pour les valeurs d'esp√©rance, et ne sont donc pas applicables √† la primitive Sampler. Une exception est l'att√©nuation des erreurs de lecture, qui est une m√©thode tr√®s efficace √©galement applicable √† la primitive Sampler.

L'[addon Qiskit M3](https://qiskit.github.io/qiskit-addon-mthree/) impl√©mente une m√©thode efficace pour l'att√©nuation des erreurs de lecture. Ce tutoriel explique comment utiliser l'addon Qiskit M3 pour att√©nuer les erreurs de lecture de la primitive Sampler.

### Qu'est-ce qu'une erreur de lecture ? {#what-is-readout-error}

Imm√©diatement avant la mesure, l'√©tat d'un registre de qubits est
d√©crit par une superposition d'√©tats de base computationnels,
ou par une matrice densit√©.
La mesure du registre de qubits dans un registre de bits classiques se d√©roule alors en deux √©tapes.
Premi√®rement, la mesure quantique proprement dite est effectu√©e.
Cela signifie que l'√©tat du registre de qubits
est projet√© sur un unique √©tat de base caract√©ris√©
par une cha√Æne de $1$ et de $0$.
La seconde √©tape consiste √† lire la cha√Æne de bits caract√©risant cet √©tat de base
et √† l'√©crire dans la m√©moire d'un ordinateur classique.
Nous appelons cette √©tape la *lecture* (readout).
Il s'av√®re que la seconde √©tape (lecture) engendre plus d'erreurs que la premi√®re √©tape (projection sur les √©tats de base).
Cela s'explique ais√©ment si vous vous rappelez que la lecture n√©cessite de d√©tecter un √©tat
quantique microscopique et de l'amplifier au niveau macroscopique. Un r√©sonateur de lecture est coupl√©
au qubit (transmon), subissant ainsi un tr√®s faible d√©calage de fr√©quence. Une impulsion micro-onde
est alors r√©fl√©chie par le r√©sonateur, subissant √† son tour de petites modifications de ses
caract√©ristiques. L'impulsion r√©fl√©chie est ensuite amplifi√©e et analys√©e. Il s'agit d'un processus
d√©licat sujet √† de nombreuses erreurs.

Le point important est que, bien que la mesure quantique et la lecture soient toutes deux sujettes √† des erreurs, cette
derni√®re engendre l'erreur dominante, appel√©e erreur de lecture, qui est l'objet de ce tutoriel.
### Contexte th√©orique {#theoretical-background}

Si la cha√Æne de bits √©chantillonn√©e (stock√©e dans la m√©moire classique) diff√®re de la cha√Æne de bits caract√©risant
l'√©tat quantique projet√©, nous disons qu'une erreur de lecture s'est produite.
Ces erreurs sont observ√©es comme √©tant al√©atoires et non corr√©l√©es d'un √©chantillon √† l'autre.
Il s'est av√©r√© utile de mod√©liser l'erreur de lecture comme un _canal classique bruit√©_.
C'est-√†-dire que pour chaque paire de
cha√Ænes de bits $i$ et $j$, il existe une probabilit√© fixe que la vraie valeur $j$ soit
incorrectement lue comme $i$.

Plus pr√©cis√©ment, pour chaque paire de cha√Ænes de bits $(i, j)$, il existe une probabilit√© (conditionnelle) ${M}_{i,j}$
que $i$ soit lu, √©tant donn√© que la vraie valeur est $j.$
C'est-√†-dire,
$$
    {M}_{i,j} =  \Pr(\text{readout value is } i | \text{true value is } j)
    \text{ for } i,j \in (0,...,2^n - 1), \tag{1}
$$
o√π $n$ est le nombre de bits dans le registre de lecture.
Pour √™tre concret, nous supposons que $i$ est un entier d√©cimal dont la repr√©sentation binaire est
la cha√Æne de bits qui √©tiquette les √©tats de base computationnels.
Nous appelons la matrice $2^n \times 2^n$ ${M}$ la _matrice d'assignation_.
Pour une valeur vraie $j$ fix√©e, la somme de la probabilit√© sur tous les r√©sultats bruit√©s $i$ doit donner $1$. C'est-√†-dire
$$
    \sum_{i=0}^{2^n - 1} {M}_{i,j} = 1 \text{ for all } j
$$
Une matrice sans entr√©es n√©gatives qui satisfait (1) est dite
_stochastique √† gauche_.
Une matrice stochastique √† gauche est aussi appel√©e _stochastique par colonnes_ car chacune de ses colonnes somme √† $1$.
Nous d√©terminons exp√©rimentalement les valeurs approximatives de chaque √©l√©ment ${M}_{i,j}$ en
pr√©parant de mani√®re r√©p√©t√©e chaque √©tat de base $|j \rangle$ puis en calculant les fr√©quences
d'occurrence des cha√Ænes de bits √©chantillonn√©es.

Si une exp√©rience consiste √† estimer une distribution de probabilit√© sur les cha√Ænes de bits de sortie par √©chantillonnage r√©p√©t√©,
alors nous pouvons utiliser ${M}$ pour att√©nuer l'erreur de lecture au niveau de la distribution.
La premi√®re √©tape consiste √† r√©p√©ter un circuit fixe d'int√©r√™t de nombreuses fois,
cr√©ant un histogramme des cha√Ænes de bits √©chantillonn√©es.
L'histogramme normalis√© est la distribution de probabilit√© mesur√©e sur
les $2^n$ cha√Ænes de bits possibles, que nous notons ${\tilde{p}} \in \mathbb{R}^{2^n}$.
La probabilit√© (estim√©e) ${{\tilde{p}}}_i$ d'√©chantillonner la cha√Æne de bits $i$
est √©gale √† la somme sur toutes les vraies cha√Ænes de bits $j$, chacune pond√©r√©e par
la probabilit√© qu'elle soit confondue avec $i$.
Cette relation sous forme matricielle est
$$
    {\tilde{p}} = {M} {\vec{p}}, \tag{2},
$$
o√π ${\vec{p}}$ est la distribution vraie. En d'autres termes, l'erreur de lecture a pour effet de multiplier
la distribution id√©ale sur les cha√Ænes de bits ${\vec{p}}$ par la matrice d'assignation ${M}$ pour
produire la distribution observ√©e ${\tilde{p}}$.
Nous avons mesur√© ${\tilde{p}}$ et ${M}$, mais n'avons pas d'acc√®s direct √† ${\vec{p}}$. En principe, nous obtiendrons
la vraie distribution de cha√Ænes de bits pour notre circuit
en r√©solvant num√©riquement l'√©quation (2) pour ${\vec{p}}$.

Avant de poursuivre, il convient de noter quelques caract√©ristiques importantes de cette approche na√Øve.

- En pratique, l'√©quation (2) n'est pas r√©solue en inversant ${M}$. Les routines
  d'alg√®bre lin√©aire des biblioth√®ques logicielles emploient des m√©thodes plus stables, pr√©cises et efficaces.
- Lors de l'estimation de ${M}$, nous avons suppos√© que seules des erreurs de lecture se produisaient. En particulier,
  nous supposons qu'il n'y avait pas d'erreurs de pr√©paration d'√©tat ni de mesure quantique ‚Äî
  ou du moins qu'elles √©taient att√©nu√©es par ailleurs.
  Dans la mesure o√π cette hypoth√®se est valide, ${M}$ repr√©sente r√©ellement
  uniquement l'erreur de lecture. Mais lorsque nous _utilisons_ ${M}$ pour corriger une distribution mesur√©e
  sur les cha√Ænes de bits, nous ne faisons pas une telle hypoth√®se. En fait, nous nous attendons √† ce qu'un circuit
  int√©ressant introduise du bruit, par exemple des erreurs de portes. La ¬´ vraie ¬ª distribution
  inclut toujours les effets de toutes les erreurs qui ne sont pas att√©nu√©es par ailleurs.

Cette m√©thode, bien qu'utile dans certaines circonstances, souffre de quelques limitations.

Les ressources en espace et en temps n√©cessaires pour estimer ${M}$ croissent exponentiellement en $n$ :
- L'estimation de ${M}$ et ${\tilde{p}}$ est sujette √† une erreur statistique due √† l'√©chantillonnage fini.
  Ce bruit peut √™tre rendu aussi petit que souhait√©
  au prix de plus de shots (jusqu'√† l'√©chelle de temps de d√©rive des param√®tres mat√©riels
  qui entra√Ænent des erreurs syst√©matiques dans ${M}$).
  Cependant, si aucune hypoth√®se n'est faite sur les cha√Ænes de bits observ√©es
  lors de l'att√©nuation, le nombre de shots requis pour estimer ${M}$ cro√Æt
  au moins exponentiellement en $n$.
- ${M}$ est une matrice $2^n \times 2^n$.
  Quand $n>10$, la quantit√© de m√©moire requise pour stocker ${M}$ est
  sup√©rieure √† la m√©moire disponible sur un ordinateur portable puissant.

Les limitations suppl√©mentaires sont :

- La distribution r√©cup√©r√©e ${\vec{p}}$ peut avoir une
  ou plusieurs probabilit√©s n√©gatives (tout en sommant √† un). Une solution
  consiste √† minimiser $||{M} {\vec{p}} - {\tilde{p}}||^2$ sous la contrainte que
  chaque entr√©e de ${\vec{p}}$ soit non n√©gative. Cependant, le temps d'ex√©cution d'une telle
  m√©thode est de plusieurs ordres de grandeur sup√©rieur √† la r√©solution directe de l'√©quation (2).
- Cette proc√©dure d'att√©nuation fonctionne au niveau d'une distribution de probabilit√©
  sur les cha√Ænes de bits. En particulier, elle ne peut pas corriger une erreur dans une
  cha√Æne de bits observ√©e individuellement.
### Addon Qiskit M3 : passage √† l'√©chelle pour des cha√Ænes de bits plus longues {#qiskit-m3-addon-scaling-to-longer-bitstrings}

La r√©solution de l'√©quation (2) √† l'aide de routines standard d'alg√®bre lin√©aire num√©rique est limit√©e √† des cha√Ænes de bits de longueur maximale d'environ 10 bits. M3, cependant, peut traiter des cha√Ænes de bits beaucoup plus longues. Deux propri√©t√©s cl√©s de M3 rendent cela possible :
- Les corr√©lations d'ordre trois et sup√©rieur dans les erreurs de lecture entre collections de bits
  sont suppos√©es n√©gligeables et sont ignor√©es. En principe, au prix de plus de shots,
  on pourrait estimer √©galement les corr√©lations d'ordre sup√©rieur.
- Plut√¥t que de construire ${M}$ explicitement, nous utilisons une matrice effective beaucoup plus petite qui enregistre
  les probabilit√©s uniquement pour les cha√Ænes de bits collect√©es lors de la construction de ${\tilde{p}}$.

√Ä un niveau √©lev√©, la proc√©dure fonctionne comme suit.

Premi√®rement, nous construisons des blocs √©l√©mentaires √† partir desquels nous pouvons construire une description simplifi√©e et effective de ${M}$.
Ensuite, nous ex√©cutons le circuit d'int√©r√™t de mani√®re r√©p√©t√©e et collectons les cha√Ænes de bits que nous utilisons pour construire
√† la fois ${\tilde{p}}$ et, √† l'aide des blocs √©l√©mentaires, une matrice ${M}$ effective.

Plus pr√©cis√©ment,
- Les matrices d'assignation √† un seul qubit sont estim√©es pour chaque qubit. Pour ce faire, nous pr√©parons
  de mani√®re r√©p√©t√©e le registre de qubits dans l'√©tat tout-z√©ro $|0 ... 0 \rangle$ puis dans l'√©tat
  tout-un $|1 ... 1 \rangle$, et nous enregistrons la probabilit√© pour chaque qubit d'√™tre lu
  incorrectement.
- Les corr√©lations d'ordre trois et sup√©rieur sont suppos√©es n√©gligeables et sont ignor√©es.

  Au lieu de cela, nous construisons un nombre $n$ de matrices d'assignation
  √† un seul qubit de taille $2 \times 2$, et un nombre $n(n-1)/2$ de matrices d'assignation √† deux qubits
  de taille $4 \times 4$. Ces matrices d'assignation √† un et deux qubits sont stock√©es pour une utilisation
  ult√©rieure.
- Apr√®s avoir √©chantillonn√© un circuit de mani√®re r√©p√©t√©e pour construire ${\tilde{p}}$,
  nous construisons une approximation effective de ${M}$ en utilisant uniquement
  les cha√Ænes de bits √©chantillonn√©es lors de la construction de ${\tilde{p}}$. Cette matrice effective
  est construite √† l'aide des matrices √† un et deux qubits d√©crites dans le point pr√©c√©dent.
  La dimension lin√©aire de cette matrice est au plus de l'ordre du nombre
  de shots utilis√©s dans la construction de ${\tilde{p}}$, ce qui est bien inf√©rieur √†
  la dimension $2^n$ de la matrice d'assignation compl√®te ${M}$.

Pour les d√©tails techniques sur M3, vous pouvez consulter [*Scalable Mitigation of Measurement Errors on Quantum Computers*](https://journals.aps.org/prxquantum/abstract/10.1103/PRXQuantum.2.040326).
### Application de M3 √† un algorithme quantique {#application-of-m3-to-a-quantum-algorithm}
Nous appliquerons l'att√©nuation de lecture de M3 au probl√®me du d√©calage cach√©. Le probl√®me du d√©calage cach√©, et les probl√®mes √©troitement li√©s tels que le [probl√®me du sous-groupe cach√©](https://en.wikipedia.org/wiki/Hidden_subgroup_problem), ont √©t√© initialement con√ßus dans un contexte tol√©rant aux fautes (plus pr√©cis√©ment, avant qu'il ne soit prouv√© que les QPU tol√©rants aux fautes √©taient possibles !). Mais ils sont √©galement √©tudi√©s avec les processeurs disponibles. Un exemple d'acc√©l√©ration algorithmique exponentielle obtenue pour une variante du probl√®me du d√©calage cach√© sur des QPU IBM&reg; de 127 qubits peut √™tre trouv√© dans [cet article](https://journals.aps.org/prx/accepted/a9074K06A8e1590147da9c69f8c4b64c28247be5a) ([version arXiv](https://arxiv.org/abs/2401.07934)).

Dans ce qui suit, toute l'arithm√©tique est bool√©enne.
C'est-√†-dire que pour $a, b \in \mathbb{Z}_2 = \{0, 1\}$, l'addition $a + b$ est la fonction OU exclusif (XOR) logique.
De plus, la multiplication $a \times b$ (ou $a b$) est la fonction ET (AND) logique. Pour $x, y \in \{0, 1\}^n$,
$x + y$ est d√©fini par application bit √† bit du XOR.
Le produit scalaire $\cdot: {\mathbb{Z}_2^n} \rightarrow \mathbb{Z}_2$ est d√©fini
par $x \cdot y = \sum_i x_i y_i$.
#### Op√©rateur de Hadamard et transform√©e de Fourier {#hadamard-operator-and-fourier-transform}

Dans l'impl√©mentation d'algorithmes quantiques, il est tr√®s courant d'utiliser l'op√©rateur de Hadamard comme transform√©e de Fourier.
Les √©tats de base computationnels sont parfois appel√©s _√©tats classiques_. Ils sont en
correspondance biunivoque avec les cha√Ænes de bits classiques.
L'op√©rateur de Hadamard √† $n$ qubits sur les √©tats classiques peut √™tre vu comme une transform√©e de Fourier sur l'hypercube bool√©en :
$$
H^{\otimes n} =  \frac{1}{\sqrt{2^n}} \sum_{x,y \in {\mathbb{Z}_2^n}} (-1)^{x \cdot y} {|{y}\rangle}{\langle{x}|}.
$$
Consid√©rons un √©tat ${|{s}\rangle}$ correspondant √† une cha√Æne de bits fixe $s$.
En appliquant $H^{\otimes n}$, et en utilisant ${\langle {x}|{s}\rangle} = \delta_{x,s}$,
nous voyons que la transform√©e de Fourier de ${|{s}\rangle}$ peut s'√©crire
$$
   H^{\otimes n} {|{s}\rangle} =  \frac{1}{\sqrt{2^n}} \sum_{y \in {\mathbb{Z}_2^n}} (-1)^{s \cdot y} {|{y}\rangle}.
$$

L'op√©rateur de Hadamard est son propre inverse, c'est-√†-dire
 $H^{\otimes n} H^{\otimes n} = (H H)^{\otimes n} = I^{\otimes n}$.
Ainsi, la transform√©e de Fourier inverse est le m√™me op√©rateur, $H^{\otimes n}$.
Explicitement, nous avons,
$$
  {|{s}\rangle} =  H^{\otimes n} H^{\otimes n} {|{s}\rangle}  =  H^{\otimes n} \frac{1}{\sqrt{2^n}} \sum_{y \in {\mathbb{Z}_2^n}} (-1)^{s \cdot y} {|{y}\rangle}.
$$
#### Le probl√®me du d√©calage cach√© {#the-hidden-shift-problem}

Nous consid√©rons un exemple simple d'un _probl√®me de d√©calage cach√©_.
Le probl√®me consiste √† identifier un d√©calage constant dans l'entr√©e d'une fonction.
La fonction que nous consid√©rons est le produit scalaire. C'est le membre le plus simple
d'une grande classe de fonctions qui admettent une acc√©l√©ration quantique pour le probl√®me du d√©calage
cach√© via des techniques similaires √† celles pr√©sent√©es ci-dessous.

Soient $x,y \in {\mathbb{Z}_2^m}$ des cha√Ænes de bits de longueur $m$.
Nous d√©finissons ${f}: {\mathbb{Z}_2^m} \times {\mathbb{Z}_2^m} \rightarrow \{-1,1\}$ par
$$
  {f}(x, y) = (-1)^{x \cdot y}.
$$
  Soient $a,b \in {\mathbb{Z}_2^m}$ des cha√Ænes de bits fix√©es de longueur $m$.
  Nous d√©finissons de plus $g: {\mathbb{Z}_2^m} \times {\mathbb{Z}_2^m} \rightarrow \{-1,1\}$ par
$$
  g(x, y) = {f}(x+a, y+b) = (-1)^{(x+a) \cdot (y+b)},
  $$
  o√π $a$ et $b$ sont des param√®tres (cach√©s).
  On nous donne deux bo√Ætes noires, l'une impl√©mentant $f$, et l'autre $g$.
  Nous supposons que nous savons qu'elles calculent les fonctions d√©finies ci-dessus, sauf que nous ne connaissons
  ni $a$ ni $b$. Le jeu consiste √† d√©terminer les cha√Ænes de bits cach√©es (d√©calages)
  $a$ et $b$ en effectuant des requ√™tes √† $f$ et $g$. Il est clair que si nous jouons le jeu de mani√®re classique,
  nous avons besoin de $O(2m)$ requ√™tes pour d√©terminer $a$ et $b$. Par exemple, nous pouvons interroger $g$ avec toutes les paires de cha√Ænes telles que l'un des √©l√©ments de la paire est enti√®rement nul, et l'autre √©l√©ment a exactement un bit mis √† $1$.
  √Ä chaque requ√™te, nous apprenons un √©l√©ment de $a$ ou de $b$.
  Cependant, nous verrons que, si les bo√Ætes noires sont impl√©ment√©es comme des circuits quantiques, nous pouvons
  d√©terminer $a$ et $b$ avec une seule requ√™te √† chacune de $f$ et $g$.

  Dans le contexte de la complexit√© algorithmique, une bo√Æte noire est appel√©e un _oracle_.
  En plus d'√™tre opaque, un oracle a la propri√©t√© de consommer l'entr√©e et de
  produire la sortie instantan√©ment, n'ajoutant rien au budget de complexit√© de l'algorithme
  dans lequel il est int√©gr√©. En fait, dans le cas pr√©sent, les oracles impl√©mentant $f$ et
  $g$ se r√©v√©leront √™tre efficaces.
#### Circuits quantiques pour $f$ et $g$ {#quantum-circuits-for-f-and-g}

Nous avons besoin des ingr√©dients suivants pour impl√©menter $f$ et $g$ comme circuits quantiques.

Pour des √©tats classiques √† un seul qubit ${|{x_1}\rangle}, {|{y_1}\rangle}$, avec $x_1,y_1 \in \mathbb{Z}_2$,
la porte $Z$ contr√¥l√©e ${CZ}$ peut s'√©crire
$$
{CZ} {|{x_1}\rangle}{|{y_1}\rangle}{x_1} = (-1)^{x_1 y_1} {|{x_1}\rangle}{x_1}{|{y_1}\rangle}.
$$
Nous op√©rerons avec $m$ portes CZ, une sur $(x_1, y_1)$, une sur $(x_2, y_2)$, et ainsi de suite jusqu'√† $(x_m, y_m)$.
Nous appelons cet op√©rateur ${CZ}_{x,y}$.

$U_f = {CZ}_{x,y}$ est une version quantique de ${f} = {f}(x,y)$ :
$$
%\CZ_{x,y} {|#1\rangle}{z} =
U_f {|{x}\rangle}{|{y}\rangle} = {CZ}_{x,y} {|{x}\rangle}{|{y}\rangle} = (-1)^{x \cdot y}  {|{x}\rangle}{|{y}\rangle}.
$$

Nous devons √©galement impl√©menter un d√©calage de cha√Æne de bits.
Nous notons l'op√©rateur sur le registre $x$ $X^{a_1}\cdots X^{a_m}$ par $X_a$
et de m√™me sur le registre $y$ $X_b =  X^{b_1}\cdots X^{b_m}$.
Ces op√©rateurs appliquent $X$ partout o√π un bit individuel est $1$, et l'identit√© $I$ partout o√π il est $0$.
Nous avons alors
$$
 X_a X_b  {|{x}\rangle}{|{y}\rangle} = {|{x+a}\rangle}{|{y+b}\rangle}.
$$

La seconde bo√Æte noire $g$ est impl√©ment√©e par l'unitaire $U_g$, donn√© par
$$
%U_g {|{x}\rangle}{|{y}\rangle} = X_aX_b \CZ_{x,y} X_aX_b {|{x}\rangle}{|{y}\rangle}.
U_g = X_aX_b {CZ}_{x,y} X_aX_b.
$$
Pour le voir, nous appliquons les op√©rateurs de droite √† gauche sur l'√©tat ${|{x}\rangle}{|{y}\rangle}$.
Premi√®rement

$$
 X_a X_b  {|{x}\rangle}{|{y}\rangle} = {|{x+a}\rangle}{|{y+b}\rangle}.
$$

Puis,
$$
  {CZ}_{x,y}  {|{x+a}\rangle}{|{y+b}\rangle} = (-1)^{(x+a)\cdot (y+b)} {|{x+a}\rangle}{|{y+b}\rangle}.
$$

Enfin,

$$
  X^a X^b (-1)^{(x+a)\cdot (y+b)} {|{x+a}\rangle}{|{y+b}\rangle} = (-1)^{(x+a)\cdot (y+b)} {|{x}\rangle}{|{y}\rangle},
$$

ce qui est bien la version quantique de $f(x+a, y+b)$.
#### L'algorithme du d√©calage cach√© {#the-hidden-shift-algorithm}

Maintenant nous assemblons les pi√®ces pour r√©soudre le probl√®me du d√©calage cach√©.
Nous commen√ßons par appliquer des portes de Hadamard aux registres initialis√©s √† l'√©tat tout-z√©ro.
$$
H^{\otimes 2m} = H^{\otimes m} \otimes H^{\otimes m} {{|{0}\rangle}^{\otimes m}}{{|{0}\rangle}^{\otimes m}} = \frac{1}{\sqrt{2^{2m}}} \sum_{x, y \in {\mathbb{Z}_2^m}} (-1)^{x \cdot y} {|{x}\rangle}{|{y}\rangle}.
$$

Ensuite, nous interrogeons l'oracle $g$ pour obtenir
$$
U_g H^{\otimes 2m} {{|{0}\rangle}^{\otimes m}}{{|{0}\rangle}^{\otimes m}}
= \frac{1}{\sqrt{2^{2m}}} \sum_{x, y \in {\mathbb{Z}_2^m}} (-1)^{(x+a) \cdot (y+b)} {|{x}\rangle}{|{y}\rangle}
$$
$$
\approx \frac{1}{\sqrt{2^{2m}}} \sum_{x, y \in {\mathbb{Z}_2^m}} (-1)^{x \cdot y + x \cdot b + y \cdot a} {|{x}\rangle}{|{y}\rangle}.
$$
Dans la derni√®re ligne, nous avons omis le facteur de phase globale constant $(-1)^{a \cdot b}$,
et notons l'√©galit√© √† une phase pr√®s par $\approx$.
Ensuite, l'application de l'oracle $f$ introduit un autre facteur $(-1)^{x \cdot y}$, annulant celui d√©j√†
pr√©sent. Nous avons alors :
$$
U_f U_g H^{\otimes 2m} {{|{0}\rangle}^{\otimes m}}{{|{0}\rangle}^{\otimes m}}
\approx \frac{1}{\sqrt{2^{2m}}} \sum_{x, y \in {\mathbb{Z}_2^m}} (-1)^{x \cdot b + y \cdot a} {|{x}\rangle}{|{y}\rangle}.
$$
L'√©tape finale consiste √† appliquer la transform√©e de Fourier inverse, $H^{\otimes 2m} = H^{\otimes m} \otimes H^{\otimes m}$,
donnant
$$
H^{\otimes 2m} U_f U_g  H^{\otimes 2m} {{|{0}\rangle}^{\otimes m}}{{|{0}\rangle}^{\otimes m}}
\approx {|{b}\rangle}{|{a}\rangle}.
$$
Le circuit est termin√©. En l'absence de bruit, l'√©chantillonnage des registres quantiques
renverra les cha√Ænes de bits $b, a$ avec une probabilit√© de $1$.

Le produit scalaire bool√©en est un exemple de ce qu'on appelle les fonctions courbes (bent functions).
Nous ne d√©finirons pas les fonctions courbes ici,
mais nous notons simplement qu'elles
¬´ r√©sistent au maximum aux attaques qui cherchent √† exploiter une d√©pendance
des sorties par rapport √† un sous-espace lin√©aire des entr√©es. ¬ª
Cette citation provient de l'article [_Quantum algorithms for highly non-linear Boolean functions_](https://arxiv.org/abs/0811.3208), qui
propose des algorithmes de d√©calage cach√© efficaces pour plusieurs classes de fonctions courbes.
L'algorithme de ce tutoriel appara√Æt dans la Section 3.1 de cet article.

Dans le cas plus g√©n√©ral, le circuit pour trouver un d√©calage cach√© $s \in \mathbb{Z}^n$ est
$$
 H^{\otimes n} U_{\tilde{f}}  H^{\otimes n} U_g  H^{\otimes n} {|{0}\rangle}^{\otimes n} = {|{s}\rangle}.
$$
 Dans le cas g√©n√©ral, $f$ et $g$ sont des fonctions d'une seule variable.
 Notre exemple du produit scalaire a cette forme si nous posons $f(x, y) \to f(z)$,
 avec $z$ √©gal √† la concat√©nation de $x$ et $y$, et $s$ √©gal √† la concat√©nation
 de $a$ et $b$.
 Le cas g√©n√©ral n√©cessite exactement deux oracles : un oracle pour $g$ et un pour $\tilde{f}$,
 o√π ce dernier est une fonction connue sous le nom de _duale_ de la fonction courbe $f$.
 La fonction produit scalaire poss√®de la propri√©t√© d'auto-dualit√© $\tilde{f}=f$.

 Dans notre circuit pour le d√©calage cach√© sur le produit scalaire, nous avons omis la couche interm√©diaire
 de portes de Hadamard qui appara√Æt dans le circuit du cas g√©n√©ral. Alors que dans le cas g√©n√©ral
 cette couche est n√©cessaire, nous avons gagn√© un peu de profondeur en l'omettant, au prix d'un peu
 de post-traitement car la sortie est ${|{b}\rangle}{|{a}\rangle}$ au lieu du ${|{a}\rangle}{|{b}\rangle}$ souhait√©.
## Pr√©requis {#requirements}

Avant de commencer ce tutoriel, assurez-vous d'avoir install√© les √©l√©ments suivants :

- Qiskit SDK v2.1 ou ult√©rieur, avec le support de [visualisation](https://docs.quantum.ibm.com/api/qiskit/visualization)
- Qiskit Runtime v0.41 ou ult√©rieur (`pip install qiskit-ibm-runtime`)
- Addon Qiskit M3 v3.0 (`pip install mthree`)
## Configuration {#setup}

```python
# Added by doQumentation ‚Äî installs packages not in the Binder environment
%pip install -q mthree
```

```python
from collections.abc import Iterator, Sequence
from random import Random
from qiskit.circuit import (
    CircuitInstruction,
    QuantumCircuit,
    QuantumRegister,
    Qubit,
)
from qiskit.circuit.library import CZGate, HGate, XGate
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit_ibm_runtime import QiskitRuntimeService
import timeit
import matplotlib.pyplot as plt
from qiskit_ibm_runtime import SamplerV2 as Sampler
import mthree
```

## √âtape 1 : Transposer les entr√©es classiques en un probl√®me quantique {#step-1-map-classical-inputs-to-a-quantum-problem}
Tout d'abord, nous √©crivons les fonctions pour impl√©menter le probl√®me du d√©calage cach√© sous forme de `QuantumCircuit`.

```python
def apply_hadamards(qubits: Sequence[Qubit]) -> Iterator[CircuitInstruction]:
    """Apply a Hadamard gate to every qubit."""
    for q in qubits:
        yield CircuitInstruction(HGate(), [q], [])

def apply_shift(
    qubits: Sequence[Qubit], shift: int
) -> Iterator[CircuitInstruction]:
    """Apply X gates where the bits of the shift are equal to 1."""
    for i, q in zip(range(shift.bit_length()), qubits):
        if shift >> i & 1:
            yield CircuitInstruction(XGate(), [q], [])

def oracle_f(qubits: Sequence[Qubit]) -> Iterator[CircuitInstruction]:
    """Apply the f oracle."""
    for i in range(0, len(qubits) - 1, 2):
        yield CircuitInstruction(CZGate(), [qubits[i], qubits[i + 1]])

def oracle_g(
    qubits: Sequence[Qubit], shift: int
) -> Iterator[CircuitInstruction]:
    """Apply the g oracle."""
    yield from apply_shift(qubits, shift)
    yield from oracle_f(qubits)
    yield from apply_shift(qubits, shift)

def determine_hidden_shift(
    qubits: Sequence[Qubit], shift: int
) -> Iterator[CircuitInstruction]:
    """Determine the hidden shift."""
    yield from apply_hadamards(qubits)
    yield from oracle_g(qubits, shift)
    # We omit this layer in exchange for post processing
    # yield from apply_hadamards(qubits)
    yield from oracle_f(qubits)
    yield from apply_hadamards(qubits)

def run_hidden_shift_circuit(n_qubits, rng):
    hidden_shift = rng.getrandbits(n_qubits)

    qubits = QuantumRegister(n_qubits, name="q")
    circuit = QuantumCircuit.from_instructions(
        determine_hidden_shift(qubits, hidden_shift), qubits=qubits
    )
    circuit.measure_all()
    # Format the hidden shift as a string.
    hidden_shift_string = format(hidden_shift, f"0{n_qubits}b")
    return (circuit, hidden_shift, hidden_shift_string)

def display_circuit(circuit):
    return circuit.remove_final_measurements(inplace=False).draw(
        "mpl", idle_wires=False, scale=0.5, fold=-1
    )
```

Nous commencerons par un petit exemple :

```python
n_qubits = 6
random_seed = 12345
rng = Random(random_seed)
circuit, hidden_shift, hidden_shift_string = run_hidden_shift_circuit(
    n_qubits, rng
)

print(f"Hidden shift string {hidden_shift_string}")

display_circuit(circuit)
```

```text
Hidden shift string 011010
```

![Output of the previous code cell](/docs/images/tutorials/readout-error-mitigation-sampler/extracted-outputs/8297843e-00c3-4bb5-9d33-a7e558d1698c-1.avif)

## √âtape 2 : Optimiser les circuits pour l'ex√©cution sur du mat√©riel quantique {#step-2-optimize-circuits-for-quantum-hardware-execution}

```python
job_tags = [
    f"shift {hidden_shift_string}",
    f"n_qubits {n_qubits}",
    f"seed = {random_seed}",
]
job_tags
```

```text
['shift 011010', 'n_qubits 6', 'seed = 12345']
```

```python
# Uncomment this to run the circuits on a quantum computer on IBMCloud.
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=100
)

# from qiskit_ibm_runtime.fake_provider import FakeMelbourneV2
# backend = FakeMelbourneV2()
# backend.refresh(service)

print(f"Using backend {backend.name}")

def get_isa_circuit(circuit, backend):
    pass_manager = generate_preset_pass_manager(
        optimization_level=3, backend=backend, seed_transpiler=1234
    )
    isa_circuit = pass_manager.run(circuit)
    return isa_circuit

isa_circuit = get_isa_circuit(circuit, backend)
display_circuit(isa_circuit)
```

```text
Using backend ibm_kingston
```

![Output of the previous code cell](/docs/images/tutorials/readout-error-mitigation-sampler/extracted-outputs/f2b77d93-c34a-43a4-b436-e7a25024a94a-1.avif)

## √âtape 3 : Ex√©cuter les circuits √† l'aide des primitives Qiskit {#step-3-execute-circuits-using-qiskit-primitives}

```python
# submit job for solving the hidden shift problem using the Sampler primitive
NUM_SHOTS = 50_000

def run_sampler(backend, isa_circuit, num_shots):
    sampler = Sampler(mode=backend)
    sampler.options.environment.job_tags
    pubs = [(isa_circuit, None, NUM_SHOTS)]
    job = sampler.run(pubs)
    return job

def setup_mthree_mitigation(isa_circuit, backend):
    # retrieve the final qubit mapping so mthree knows which qubits to calibrate
    qubit_mapping = mthree.utils.final_measurement_mapping(isa_circuit)

    # submit jobs for readout error calibration
    mit = mthree.M3Mitigation(backend)
    mit.cals_from_system(qubit_mapping, rep_delay=None)

    return mit, qubit_mapping
```

```python
job = run_sampler(backend, isa_circuit, NUM_SHOTS)
mit, qubit_mapping = setup_mthree_mitigation(isa_circuit, backend)
```

## √âtape 4 : Post-traiter et renvoyer les r√©sultats au format classique {#step-4-post-process-and-return-results-in-classical-format}

Dans la discussion th√©orique ci-dessus, nous avons d√©termin√© que pour l'entr√©e $ab$, nous attendons la sortie $ba$.
Une complication suppl√©mentaire est que, afin d'avoir un circuit plus simple (avant transpilation), nous avons ins√©r√© les portes CZ requises entre
des paires de qubits voisins. Cela revient √† entrelacer les cha√Ænes de bits $a$ et $b$ sous la forme $a1 b1 a2 b2 \ldots$.
La cha√Æne de sortie $ba$ sera entrelac√©e de mani√®re similaire : $b1 a1 b2 a2 \ldots$. La fonction `unscramble` ci-dessous
transforme la cha√Æne de sortie de $b1 a1 b2 a2 \ldots$ en $a1 b1 a2 b2 \ldots$ afin que les cha√Ænes d'entr√©e et de sortie puissent √™tre compar√©es directement.

```python
# retrieve bitstring counts
def get_bitstring_counts(job):
    result = job.result()
    pub_result = result[0]
    counts = pub_result.data.meas.get_counts()
    return counts, pub_result
```

```python
counts, pub_result = get_bitstring_counts(job)
```

La distance de Hamming entre deux cha√Ænes de bits est le nombre d'indices auxquels les bits diff√®rent.

```python
def hamming_distance(s1, s2):
    weight = 0
    for c1, c2 in zip(s1, s2):
        (c1, c2) = (int(c1), int(c2))
        if (c1 == 1 and c2 == 1) or (c1 == 0 and c2 == 0):
            weight += 1

    return weight
```

```python
# Replace string of form a1b1a2b2... with b1a1b2a1...
# That is, reverse order of successive pairs of bits.
def unscramble(bitstring):
    ps = [bitstring[i : i + 2][::-1] for i in range(0, len(bitstring), 2)]
    return "".join(ps)

def find_hidden_shift_bitstring(counts, hidden_shift_string):
    # convert counts to probabilities
    probs = {
        unscramble(bitstring): count / NUM_SHOTS
        for bitstring, count in counts.items()
    }

    # Retrieve the most probable bitstring.
    most_probable = max(probs, key=lambda x: probs[x])

    print(f"Expected hidden shift string: {hidden_shift_string}")
    if most_probable == hidden_shift_string:
        print("Most probable bitstring matches hidden shift üòä.")
    else:
        print("Most probable bitstring didn't match hidden shift ‚òπÔ∏è.")
    print("Top 10 bitstrings and their probabilities:")
    display(
        {
            k: (v, hamming_distance(hidden_shift_string, k))
            for k, v in sorted(
                probs.items(), key=lambda x: x[1], reverse=True
            )[:10]
        }
    )

    return probs, most_probable
```

```python
probs, most_probable = find_hidden_shift_bitstring(
    counts, hidden_shift_string
)
```

```text
Expected hidden shift string: 011010
Most probable bitstring matches hidden shift üòä.
Top 10 bitstrings and their probabilities:
```

```text
{'011010': (0.9743, 6),
 '001010': (0.00812, 5),
 '010010': (0.0063, 5),
 '011000': (0.00554, 5),
 '011011': (0.00492, 5),
 '011110': (0.00044, 5),
 '001000': (0.00012, 4),
 '010000': (8e-05, 4),
 '001011': (6e-05, 4),
 '000010': (6e-05, 4)}
```

Enregistrons la probabilit√© de la cha√Æne de bits la plus probable avant d'appliquer l'att√©nuation des erreurs de lecture avec M3.

```python
max_probability_before_M3 = probs[most_probable]
max_probability_before_M3
```

```text
0.9743
```

Maintenant, nous appliquons la correction de lecture apprise par M3 aux comptages.
La fonction `apply_corrections` renvoie une distribution de quasi-probabilit√©. Il s'agit d'une liste d'objets `float` dont la somme est $1$. Cependant, certaines valeurs peuvent √™tre n√©gatives.

```python
def perform_mitigation(mit, counts, qubit_mapping):
    # mitigate readout error
    quasis = mit.apply_correction(counts, qubit_mapping)

    # print results
    most_probable_after_m3 = unscramble(max(quasis, key=lambda x: quasis[x]))

    is_hidden_shift_identified = most_probable_after_m3 == hidden_shift_string
    if is_hidden_shift_identified:
        print("Most probable bitstring matches hidden shift üòä.")
    else:
        print("Most probable bitstring didn't match hidden shift ‚òπÔ∏è.")
    print("Top 10 bitstrings and their quasi-probabilities:")
    topten = {
        unscramble(k): f"{v:.2e}"
        for k, v in sorted(quasis.items(), key=lambda x: x[1], reverse=True)[
            :10
        ]
    }
    max_probability_after_M3 = float(topten[most_probable_after_m3])
    display(topten)

    return max_probability_after_M3, is_hidden_shift_identified
```

```python
print(f"Expected hidden shift string: {hidden_shift_string}")
max_probability_after_M3, is_hidden_shift_identified = perform_mitigation(
    mit, counts, qubit_mapping
)
```

```text
Expected hidden shift string: 011010
Most probable bitstring matches hidden shift üòä.
Top 10 bitstrings and their quasi-probabilities:
```

```text
{'011010': '1.01e+00',
 '001010': '8.75e-04',
 '001000': '7.38e-05',
 '010000': '4.51e-05',
 '111000': '2.18e-05',
 '001011': '1.74e-05',
 '000010': '6.42e-06',
 '011001': '-7.18e-06',
 '011000': '-4.53e-04',
 '010010': '-1.28e-03'}
```

#### Comparer l'identification de la cha√Æne de bits du d√©calage cach√© avant et apr√®s l'application de la correction M3 {#compare-identifying-the-hidden-shift-string-before-and-after-applying-m3-correction}

```python
def compare_before_and_after_M3(
    max_probability_before_M3,
    max_probability_after_M3,
    is_hidden_shift_identified,
):
    is_probability_improved = (
        max_probability_after_M3 > max_probability_before_M3
    )
    print(f"Most probable probability before M3: {max_probability_before_M3}")
    print(f"Most probable probability after M3: {max_probability_after_M3}")
    if is_hidden_shift_identified and is_probability_improved:
        print("Readout error mitigation effective! üòä")
    else:
        print("Readout error mitigation not effective. ‚òπÔ∏è")
```

```python
compare_before_and_after_M3(
    max_probability_before_M3,
    max_probability_after_M3,
    is_hidden_shift_identified,
)
```

```text
Most probable probability before M3: 0.9743
Most probable probability after M3: 1.01
Readout error mitigation effective! üòä
```

### Tracer l'√©volution du temps CPU requis par M3 en fonction du nombre de shots {#plot-how-cpu-time-required-by-m3-scales-with-shots}

```python
# Collect samples for numbers of shots varying from 5000 to 25000.
shots_range = range(5000, NUM_SHOTS + 1, 2500)
times = []
for shots in shots_range:
    print(f"Applying M3 correction to {shots} shots...")
    t0 = timeit.default_timer()
    _ = mit.apply_correction(
        pub_result.data.meas.slice_shots(range(shots)).get_counts(),
        qubit_mapping,
    )
    t1 = timeit.default_timer()
    print(f"\tDone in {t1 - t0} seconds.")
    times.append(t1 - t0)

fig, ax = plt.subplots()
ax.plot(shots_range, times, "o--")
ax.set_xlabel("Shots")
ax.set_ylabel("Time (s)")
ax.set_title("Time to apply M3 correction")
```

```text
Applying M3 correction to 5000 shots...
	Done in 0.003321983851492405 seconds.
Applying M3 correction to 7500 shots...
	Done in 0.004425413906574249 seconds.
Applying M3 correction to 10000 shots...
	Done in 0.006366567220538855 seconds.
Applying M3 correction to 12500 shots...
	Done in 0.0071477219462394714 seconds.
Applying M3 correction to 15000 shots...
	Done in 0.00860048783943057 seconds.
Applying M3 correction to 17500 shots...
	Done in 0.010026784148067236 seconds.
Applying M3 correction to 20000 shots...
	Done in 0.011459112167358398 seconds.
Applying M3 correction to 22500 shots...
	Done in 0.012727141845971346 seconds.
Applying M3 correction to 25000 shots...
	Done in 0.01406092382967472 seconds.
Applying M3 correction to 27500 shots...
	Done in 0.01546052098274231 seconds.
Applying M3 correction to 30000 shots...
	Done in 0.016769016161561012 seconds.
Applying M3 correction to 32500 shots...
	Done in 0.019537431187927723 seconds.
Applying M3 correction to 35000 shots...
	Done in 0.019739801064133644 seconds.
Applying M3 correction to 37500 shots...
	Done in 0.021093040239065886 seconds.
Applying M3 correction to 40000 shots...
	Done in 0.022840639110654593 seconds.
Applying M3 correction to 42500 shots...
	Done in 0.023974396288394928 seconds.
Applying M3 correction to 45000 shots...
	Done in 0.026412792038172483 seconds.
Applying M3 correction to 47500 shots...
	Done in 0.026364430785179138 seconds.
Applying M3 correction to 50000 shots...
	Done in 0.02820305060595274 seconds.
```

```text
Text(0.5, 1.0, 'Time to apply M3 correction')
```

![Output of the previous code cell](/docs/images/tutorials/readout-error-mitigation-sampler/extracted-outputs/33addc38-f738-48ed-a29d-9790f446c036-2.avif)

#### Interpr√©tation du graphique {#interpreting-the-plot}

Le graphique ci-dessus montre que le temps requis pour appliquer la correction M3 cro√Æt lin√©airement avec le nombre de shots.
## Passage √† l'√©chelle {#scaling-up}

```python
n_qubits = 80
rng = Random(12345)
circuit, hidden_shift, hidden_shift_string = run_hidden_shift_circuit(
    n_qubits, rng
)

print(f"Hidden shift string {hidden_shift_string}")
```

```text
Hidden shift string 00000010100110101011101110010001010000110011101001101010101001111001100110000111
```

```python
isa_circuit = get_isa_circuit(circuit, backend)
```

```python
job = run_sampler(backend, isa_circuit, NUM_SHOTS)
mit, qubit_mapping = setup_mthree_mitigation(isa_circuit, backend)
```

```python
counts, pub_result = get_bitstring_counts(job)
```

```python
probs, most_probable = find_hidden_shift_bitstring(
    counts, hidden_shift_string
)
```

```text
Expected hidden shift string: 00000010100110101011101110010001010000110011101001101010101001111001100110000111
Most probable bitstring matches hidden shift üòä.
Top 10 bitstrings and their probabilities:
```

```text
{'00000010100110101011101110010001010000110011101001101010101001111001100110000111': (0.50402,
  80),
 '00000010100110101011101110010001010000110011100001101010101001111001100110000111': (0.0396,
  79),
 '00000010100110101011101110010001010000110011101001101010101001111001100100000111': (0.0323,
  79),
 '00000010100110101011101110010001010000110011101001101010101001101001100110000111': (0.01936,
  79),
 '00000010100110101011101110010011010000110011101001101010101001111001100110000111': (0.01432,
  79),
 '00000010100110101011101110010001010000110011101001101010101001011001100110000111': (0.0101,
  79),
 '00000010100110101011101110010001010000110011101001101010101001110001100110000111': (0.00924,
  79),
 '00000010100110101011101110010001010000010011101001101010101001111001100110000111': (0.00908,
  79),
 '00000010100110101011101110010001010000110011101001101010101001111001100110000111': (0.00888,
  79),
 '00000010100110101011101110010001010000110011101001100010101001111001100110000111': (0.0082,
  79)}
```

Nous voyons que la bonne cha√Æne de bits du d√©calage cach√© est trouv√©e. De plus, les neuf cha√Ænes de bits suivantes les plus probables ne diff√®rent que d'une seule position.
Enregistrons la probabilit√© la plus √©lev√©e :

```python
max_probability_before_M3 = probs[most_probable]
max_probability_before_M3
```

```text
0.50402
```

```python
print(f"Expected hidden shift string: {hidden_shift_string}")
max_probability_after_M3, is_hidden_shift_identified = perform_mitigation(
    mit, counts, qubit_mapping
)
```

```text
Expected hidden shift string: 00000010100110101011101110010001010000110011101001101010101001111001100110000111
Most probable bitstring matches hidden shift üòä.
Top 10 bitstrings and their quasi-probabilities:
```

```text
{'00000010100110101011101110010001010000110011101001101010101001111001100110000111': '9.85e-01',
 '00000010100110101011101110010001010000110011100001101010101001111001100110000111': '6.84e-03',
 '00000010100110101011100110010001010000110011101001101010101001111001100110000111': '3.87e-03',
 '00000010100110101011101110010011010000110011101001101010101001111001100110000111': '3.42e-03',
 '00000010100110101011101110010001010000110011101001101010101001111001100100000111': '3.30e-03',
 '00000010100110101011101110010001010000110011101001101010101001110001100110000111': '3.28e-03',
 '00000010100010101011101110010001010000110011101001101010101001111001100110000111': '2.62e-03',
 '00000010100110101011101110010001010000110011101001101010101001101001100110000111': '2.43e-03',
 '00000010100110101011101110010000010000110011101001101010101001111001100110000111': '1.73e-03',
 '00000010100110101011101110010001010000110011101001101010101001111001000110000111': '1.63e-03'}
```

```python
compare_before_and_after_M3(
    max_probability_before_M3,
    max_probability_after_M3,
    is_hidden_shift_identified,
)
```

```text
Most probable probability before M3: 0.54348
Most probable probability after M3: 0.99
Readout error mitigation effective! üòä
```

Les r√©sultats montrent que l'erreur de lecture √©tait la source d'erreur dominante et que l'att√©nuation M3 a √©t√© efficace.
