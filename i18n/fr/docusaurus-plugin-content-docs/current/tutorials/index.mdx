---
title: Tutoriels
sidebar_label: Vue d'ensemble
sidebar_position: 1
description: Parcourez les tutoriels IBM Quantum — exécutables sur RasQberry, via Binder ou sur votre propre serveur Jupyter.
---
{/* doqumentation-source-hash: e0b80945 */}

# Tutoriels {#tutorials}

Utilisez ces tutoriels pour apprendre à appliquer Qiskit aux cas d'utilisation courants de l'informatique quantique.

- Commencez par l'ensemble de tutoriels de la section [Premiers pas](#premiers-pas) si c'est la première fois que vous exécutez du code sur un ordinateur quantique.
- La section sur les [flux de travail vers l'avantage quantique](#explorer-les-flux-de-travail-vers-lavantage-quantique) contient des exemples de bout en bout d'utilisation d'un ordinateur quantique pour résoudre des problèmes concrets. Ces tutoriels se concentrent sur les algorithmes qui sont des candidats prometteurs pour atteindre un avantage computationnel d'un ordinateur quantique par rapport à un ordinateur classique.
- La section sur les [capacités de Qiskit](#exploiter-les-capacités-de-qiskit) contient des exemples qui utilisent les techniques les plus récentes et les plus avancées de l'écosystème Qiskit pour améliorer une partie ou l'ensemble d'un flux de travail particulier.

## Premiers pas {#get-started}

Ces tutoriels sont destinés aux débutants qui sont prêts à explorer l'exécution d'algorithmes quantiques sur un ordinateur quantique.

* [Inégalité de CHSH](/tutorials/chsh-inequality)

## Explorer les flux de travail vers l'avantage quantique {#explore-workflows-toward-advantage}

Les tutoriels de cette section couvrent des démonstrations à grande échelle d'algorithmes quantiques.

<details>
  <summary>**Algorithmes d'échantillonnage vérifiables**</summary>

Les algorithmes de cette catégorie se concentrent sur les circuits quantiques dont les distributions de sortie encodent des solutions à des problèmes structurés avec une sortie vérifiable. La vérifiabilité signifie que vous pouvez vérifier la cohérence entre les données mesurées, soit en évaluant la chaîne de bits choisie, soit en sachant que les faux positifs ne se produisent pas.

Les tutoriels mettent en évidence des techniques où l'échantillonnage répété permet l'estimation de quantités spécifiques au problème (par exemple, les valeurs de la fonction de coût ou les poids spectraux). Ces méthodes sont particulièrement pertinentes pour les tâches d'optimisation et de simulation présentant des symétries.

* [Diagonalisation quantique par échantillonnage d'un hamiltonien de chimie](/tutorials/sample-based-quantum-diagonalization)

* [Diagonalisation quantique de Krylov par échantillonnage d'un modèle de réseau fermionique](/tutorials/sample-based-krylov-quantum-diagonalization)

* [Algorithme d'optimisation approchée quantique](/tutorials/quantum-approximate-optimization-algorithm)

* [Techniques avancées pour QAOA](/tutorials/advanced-techniques-for-qaoa)

* [Encodage par corrélation de Pauli pour réduire les exigences de Maxcut](/tutorials/pauli-correlation-encoding-for-qaoa)

</details>

<details>
  <summary>**Estimation d'observables**</summary>

Ces tutoriels se concentrent sur l'estimation de quantités physiquement significatives, telles que l'énergie ou les valeurs de corrélation, en préparant des états quantiques et en mesurant des observables. Les techniques incluent des approches de circuits variationnels et trotterisés qui équilibrent l'expressivité du circuit avec l'efficacité en profondeur de circuit. L'accent est mis sur les flux de travail qui réduisent les exigences en ressources quantiques tout en maintenant la précision, et permettant une estimation pratique des observables dans les systèmes chimiques et physiques.

* [Diagonalisation quantique de Krylov des hamiltoniens de réseau](/tutorials/krylov-quantum-diagonalization)

* [Transition de phase de Nishimori](/tutorials/nishimori-phase-transition)

* [Estimation de l'énergie de l'état fondamental de la chaîne de Heisenberg avec VQE](/tutorials/spin-chain-vqe)

* [Entraînement de noyaux quantiques](/tutorials/quantum-kernel-training)

* [Améliorer la classification de caractéristiques à l'aide de noyaux quantiques projetés](/tutorials/projected-quantum-kernels)

* [Inégalité de CHSH](/tutorials/chsh-inequality)

</details>

<details>
  <summary>**Algorithmes tolérants aux fautes**</summary>

Cette section présente des algorithmes avec des garanties théoriques bien définies, conçus pour fonctionner sur du matériel quantique futur à correction d'erreurs. Les circuits ou la surcharge d'échantillonnage de ces algorithmes évoluent d'une manière qui n'est pas efficace en profondeur et sont donc plus susceptibles de démontrer un avantage quantique lorsque des ordinateurs quantiques tolérants aux fautes existeront. Ces tutoriels illustrent le fonctionnement de ces méthodes dans des conditions idéalisées et présentent des exemples à petite échelle.

* [Algorithme de Shor](/tutorials/shors-algorithm)
* [Algorithme de Grover](/tutorials/grovers-algorithm)

</details>

## Exploiter les capacités de Qiskit {#leverage-qiskit-capabilities}

Cette section présente les capacités avancées de l'écosystème Qiskit qui améliorent les performances, la fiabilité et la vitesse lors de l'exécution d'algorithmes quantiques.

<details>
  <summary>**Optimisation de la charge de travail**</summary>

L'optimisation de la charge de travail se concentre soit sur l'orchestration efficace des ressources classiques et quantiques, soit sur des méthodes adaptées pour améliorer la manipulation des circuits quantiques.

* [Évaluer les circuits dynamiques avec des paires de Bell coupées](/tutorials/edc-cut-bell-pair-benchmarking)

* [Introduction aux portes fractionnaires](/tutorials/fractional-gates)

* [Introduction au service de transpilation assistée par IA de Qiskit](/tutorials/ai-transpiler-introduction)

* [Optimisations de transpilation avec SABRE](/tutorials/transpilation-optimizations-with-sabre)

* [Méthodes de compilation pour les circuits de simulation hamiltonienne](/tutorials/compilation-methods-for-hamiltonian-simulation-circuits)

* [Intrication à longue portée avec des circuits dynamiques](/tutorials/long-range-entanglement)

* [Simulation de l'hamiltonien d'Ising perturbé avec des circuits dynamiques](/tutorials/dc-hex-ising)

</details>

<details>
<summary>**Qiskit Functions**</summary>

Les Qiskit Functions sont une collection d'outils pré-packagés de gestion des erreurs et d'applications, facilitant la conception d'expériences à grande échelle avec des circuits, des molécules, des QUBO, et plus encore.

- Concevez de nouveaux algorithmes avec les **fonctions de circuit** — avec des pipelines de transpilation, de suppression d'erreurs et d'atténuation d'erreurs pré-construits.

  * [Atténuation d'erreurs avec la fonction IBM Circuit](/tutorials/error-mitigation-with-qiskit-functions)

  * [Modèle d'Ising à champ transverse avec la gestion des performances de Q-CTRL](/tutorials/transverse-field-ising-model)

  * [Estimation de phase quantique avec les Qiskit Functions de Q-CTRL](/tutorials/quantum-phase-estimation-qctrl)

  * [Simuler le modèle d'Ising 2D à champ incliné avec la fonction QESEM](/tutorials/qedma-2d-ising-with-qesem)

- Expérimentez avec des problèmes spécifiques à un domaine avec les **fonctions d'application** — avec des entrées et sorties familières pour les solveurs classiques.

  * [Quantum Portfolio Optimizer - Une fonction Qiskit par Global Data Quantum](/tutorials/global-data-quantum-optimizer)

  * [Optimisation binaire d'ordre supérieur avec le solveur d'optimisation de Q-CTRL](/tutorials/solve-higher-order-binary-optimization-problems-with-q-ctrls-optimization-solver)

  * [Modéliser un fluide non visqueux en écoulement avec QUICK-PDE](/tutorials/colibritd-pde)

  * [Courbes PES de dissociation avec Qunova HiVQE](/tutorials/qunova-hivqe)

  * [Classification par ensemble hybride à amélioration quantique (flux de travail de stabilité du réseau)](/tutorials/sml-classification)

  * [Résoudre le problème de répartition de marché avec l'optimiseur quantique Iskay de Kipu Quantum](/tutorials/solve-market-split-problem-with-iskay-quantum-optimizer)

</details>

<details>
  <summary>**Extensions Qiskit (addons)**</summary>

Les extensions permettent une manipulation avancée des circuits, comme la découpe, la rétropropagation d'observables ou l'approximation de circuits, qui permettent aux utilisateurs de contourner les limitations matérielles au prix d'une surcharge accrue de calcul classique.

* [Formules multi-produits pour réduire l'erreur de Trotter](/tutorials/multi-product-formula)

* [Compilation quantique approchée pour les circuits d'évolution temporelle](/tutorials/approximate-quantum-compilation-for-time-evolution)

* [Rétropropagation d'opérateurs (OBP) pour l'estimation des valeurs d'espérance](/tutorials/operator-back-propagation)

* [Découpe de fils pour l'estimation des valeurs d'espérance](/tutorials/wire-cutting)

* [Découpe de circuits pour les conditions aux limites périodiques](/tutorials/periodic-boundary-conditions-with-circuit-cutting)

* [Découpe de circuits pour la réduction de profondeur](/tutorials/depth-reduction-with-circuit-cutting)

* [Atténuation des erreurs de lecture pour la primitive Sampler avec M3](/tutorials/readout-error-mitigation-sampler)

</details>

<details>
  <summary>**Atténuation d'erreurs**</summary>

L'atténuation d'erreurs relève le défi du bruit sans tolérance aux fautes complète en récupérant des valeurs d'espérance précises grâce à une manipulation contrôlée des circuits et un post-traitement.

* [Atténuation d'erreurs à l'échelle utilitaire avec l'amplification probabiliste d'erreurs](/tutorials/probabilistic-error-amplification)

* [Combiner les options d'atténuation d'erreurs avec la primitive Estimator](/tutorials/combine-error-mitigation-techniques)

* [Évaluation en temps réel pour la sélection de qubits](/tutorials/real-time-benchmarking-for-qubit-selection)

</details>

<details>
  <summary>**Détection d'erreurs**</summary>

La détection d'erreurs identifie les opérations défectueuses pour renvoyer des résultats sans bruit tir par tir grâce au post-traitement.

* [Codes de répétition](/tutorials/repetition-codes)

* [Détection d'erreurs à faible surcharge avec les codes spatio-temporels](/tutorials/ghz-spacetime-codes)

</details>
