---
title: "Algorithme de Grover"
sidebar_label: "Algorithme de Grover"
description: "Apprenez les bases de l'informatique quantique et comment utiliser les services et QPU d'IBM Quantum pour résoudre des problèmes concrets."
notebook_path: "docs/tutorials/grovers-algorithm.ipynb"
---
{/* doqumentation-source-hash: c9ea0aa0 */}

<OpenInLabBanner notebookPath="docs/tutorials/grovers-algorithm.ipynb" />



*Estimation d'utilisation : moins d'une minute sur un processeur Eagle r3 (REMARQUE : il ne s'agit que d'une estimation. Votre temps d'exécution peut varier.)*
## Contexte {#background}

L'amplification d'amplitude est un algorithme quantique, ou sous-routine, à usage général qui peut être utilisé pour obtenir une accélération quadratique par rapport à plusieurs algorithmes classiques. [L'algorithme de Grover](https://arxiv.org/abs/quant-ph/9605043) a été le premier à démontrer cette accélération sur des problèmes de recherche non structurés. La formulation d'un problème de recherche de Grover nécessite une fonction oracle qui marque un ou plusieurs états de base computationnels comme étant les états que nous souhaitons trouver, ainsi qu'un circuit d'amplification qui augmente l'amplitude des états marqués, supprimant par conséquent les états restants.

Nous montrons ici comment construire des oracles de Grover et utiliser [`grover_operator()`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.grover_operator) de la bibliothèque de circuits Qiskit pour configurer facilement une instance de recherche de Grover. La primitive `Sampler` du runtime permet une exécution fluide des circuits de Grover.
## Prérequis {#requirements}

Avant de commencer ce tutoriel, assurez-vous d'avoir installé les éléments suivants :

* Qiskit SDK v1.4 ou ultérieur, avec le support de [visualisation](https://docs.quantum.ibm.com/api/qiskit/visualization)
* Qiskit Runtime (`pip install qiskit-ibm-runtime`) v0.36 ou ultérieur
## Configuration {#setup}

```python
# Built-in modules
import math

# Imports from Qiskit
from qiskit import QuantumCircuit
from qiskit.circuit.library import grover_operator, MCMTGate, ZGate
from qiskit.visualization import plot_distribution
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

# Imports from Qiskit Runtime
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_runtime import SamplerV2 as Sampler

def grover_oracle(marked_states):
    """Build a Grover oracle for multiple marked states

    Here we assume all input marked states have the same number of bits

    Parameters:
        marked_states (str or list): Marked states of oracle

    Returns:
        QuantumCircuit: Quantum circuit representing Grover oracle
    """
    if not isinstance(marked_states, list):
        marked_states = [marked_states]
    # Compute the number of qubits in circuit
    num_qubits = len(marked_states[0])

    qc = QuantumCircuit(num_qubits)
    # Mark each target state in the input list
    for target in marked_states:
        # Flip target bit-string to match Qiskit bit-ordering
        rev_target = target[::-1]
        # Find the indices of all the '0' elements in bit-string
        zero_inds = [
            ind
            for ind in range(num_qubits)
            if rev_target.startswith("0", ind)
        ]
        # Add a multi-controlled Z-gate with pre- and post-applied X-gates (open-controls)
        # where the target bit-string has a '0' entry
        if zero_inds:
            qc.x(zero_inds)
        qc.compose(MCMTGate(ZGate(), num_qubits - 1, 1), inplace=True)
        if zero_inds:
            qc.x(zero_inds)
    return qc
```

## Étape 1 : Transposer les entrées classiques en un problème quantique {#step-1-map-classical-inputs-to-a-quantum-problem}

L'algorithme de Grover nécessite un [oracle](/learning/courses/fundamentals-of-quantum-algorithms/grover-algorithm/introduction) qui spécifie un ou plusieurs états de base computationnels marqués, où « marqué » signifie un état avec une phase de -1. Une porte Z contrôlée, ou sa généralisation multi-contrôlée sur $N$ qubits, marque l'état $2^{N}-1$ (chaîne de bits `'1'`*$N$). Marquer des états de base comportant un ou plusieurs `'0'` dans la représentation binaire nécessite l'application de portes X sur les qubits correspondants avant et après la porte Z contrôlée ; ce qui équivaut à avoir un contrôle ouvert sur ce qubit. Dans le code suivant, nous définissons un oracle qui fait exactement cela, en marquant un ou plusieurs états de base d'entrée définis par leur représentation en chaîne de bits. La porte `MCMT` est utilisée pour implémenter la porte Z multi-contrôlée.

```python
# To run on hardware, select the backend with the fewest number of jobs in the queue
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=127
)
backend.name
```

```text
'ibm_brisbane'
```

### Instance spécifique de Grover {#specific-grovers-instance}

Maintenant que nous disposons de la fonction oracle, nous pouvons définir une instance spécifique de la recherche de Grover. Dans cet exemple, nous allons marquer deux états computationnels parmi les huit disponibles dans un espace computationnel à trois qubits :

```python
marked_states = ["011", "100"]

oracle = grover_oracle(marked_states)
oracle.draw(output="mpl", style="iqp")
```

![Output of the previous code cell](/docs/images/tutorials/grovers-algorithm/extracted-outputs/c150298f-0.avif)

```python
marked_states = ["011", "100"]

oracle = grover_oracle(marked_states)
oracle.draw(output="mpl", style="iqp")
```

![Output of the previous code cell](/docs/images/tutorials/grovers-algorithm/extracted-outputs/7baca7e2-99fc-4089-b5d8-30da56816a6a-0.avif)

```python
marked_states = ["011", "100"]

oracle = grover_oracle(marked_states)
oracle.draw(output="mpl", style="iqp")
```

![Output of the previous code cell](/docs/images/tutorials/grovers-algorithm/extracted-outputs/d3a26fc9-9090-4527-a749-a412661260b6-0.avif)

### Opérateur de Grover {#grover-operator}

La fonction `grover_operator()` intégrée à Qiskit prend un circuit oracle et renvoie un circuit composé du circuit oracle lui-même et d'un circuit qui amplifie les états marqués par l'oracle. Ici, nous utilisons la méthode `decompose()` du circuit pour visualiser les portes au sein de l'opérateur :

```python
grover_op = grover_operator(oracle)
grover_op.decompose().draw(output="mpl", style="iqp")
```

![Output of the previous code cell](/docs/images/tutorials/grovers-algorithm/extracted-outputs/283d5265-0.avif)

Les applications répétées de ce circuit `grover_op` amplifient les états marqués, en faisant les chaînes de bits les plus probables dans la distribution de sortie du circuit. Il existe un nombre optimal de telles applications, déterminé par le rapport entre les états marqués et le nombre total d'états computationnels possibles :

```python
optimal_num_iterations = math.floor(
    math.pi
    / (4 * math.asin(math.sqrt(len(marked_states) / 2**grover_op.num_qubits)))
)
```

### Circuit de Grover complet {#full-grover-circuit}

Une expérience de Grover complète commence par une porte Hadamard sur chaque qubit, créant une superposition uniforme de tous les états de base computationnels, suivie de l'opérateur de Grover (`grover_op`) répété le nombre optimal de fois. Nous utilisons ici la méthode `QuantumCircuit.power(INT)` pour appliquer l'opérateur de Grover de manière répétée.

```python
qc = QuantumCircuit(grover_op.num_qubits)
# Create even superposition of all basis states
qc.h(range(grover_op.num_qubits))
# Apply Grover operator the optimal number of times
qc.compose(grover_op.power(optimal_num_iterations), inplace=True)
# Measure all qubits
qc.measure_all()
qc.draw(output="mpl", style="iqp")
```

![Output of the previous code cell](/docs/images/tutorials/grovers-algorithm/extracted-outputs/4933ae44-0.avif)

## Étape 2 : Optimiser le problème pour l'exécution sur matériel quantique {#step-2-optimize-problem-for-quantum-hardware-execution}

```python
target = backend.target
pm = generate_preset_pass_manager(target=target, optimization_level=3)

circuit_isa = pm.run(qc)
circuit_isa.draw(output="mpl", idle_wires=False, style="iqp")
```

![Output of the previous code cell](/docs/images/tutorials/grovers-algorithm/extracted-outputs/c9a3020e-0.avif)

## Étape 3 : Exécuter à l'aide des primitives Qiskit {#step-3-execute-using-qiskit-primitives}

L'amplification d'amplitude est un problème d'échantillonnage adapté à l'exécution avec la primitive de runtime [`Sampler`](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/sampler-v2).

Notez que la méthode `run()` de [`SamplerV2` de Qiskit Runtime](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/sampler-v2) prend en entrée un itérable de `primitive unified blocks (PUBs)`. Pour le sampler, chaque PUB est un itérable au format `(circuit, parameter_values)`. Toutefois, au minimum, il suffit de fournir une liste de circuit(s) quantique(s).

```python
# To run on local simulator:
#   1. Use the StatevectorSampler from qiskit.primitives instead
sampler = Sampler(mode=backend)
sampler.options.default_shots = 10_000
result = sampler.run([circuit_isa]).result()
dist = result[0].data.meas.get_counts()
```

## Étape 4 : Post-traiter et renvoyer le résultat dans le format classique souhaité {#step-4-post-process-and-return-result-in-desired-classical-format}

```python
plot_distribution(dist)
```

![Output of the previous code cell](/docs/images/tutorials/grovers-algorithm/extracted-outputs/a5ef9913-0.avif)

## Enquête sur le tutoriel {#tutorial-survey}

Veuillez répondre à cette courte enquête afin de nous faire part de vos commentaires sur ce tutoriel. Vos retours nous aideront à améliorer nos contenus et l'expérience utilisateur.

[Lien vers l'enquête](https://your.feedback.ibm.com/jfe/form/SV_0j1SlLPkooyeFJY)