---
title: "Get backend information with Qiskit"
sidebar_label: "Get backend information with Qiskit"
description: "Find and filter available backends, get configuration and calibration data programmatically."
notebook_path: "docs/guides/get-qpu-information.ipynb"
---
{/* doqumentation-untranslated-fallback */}

:::note[טרם תורגם]
דף זה טרם תורגם. התוכן מוצג באנגלית.
:::



<OpenInLabBanner notebookPath="docs/guides/get-qpu-information.ipynb" />



{/*
  DO NOT EDIT THIS CELL!!!
  This cell's content is generated automatically by a script. Anything you add
  here will be removed next time the notebook is run. To add new content, create
  a new cell before or after this one.
*/}

<details>
<summary><b>Package versions</b></summary>

The code on this page was developed using the following requirements.
We recommend using these versions or newer.

```
qiskit-ibm-runtime~=0.43.1
```
</details>
This page explains how to use Qiskit to find information about your available backends.
## List backends

To view the backends you have access to, you can either view a list on the [Compute resources page,](https://quantum.cloud.ibm.com/computers) or you can use the [`QiskitRuntimeService.backends()`](../api/qiskit-ibm-runtime/qiskit-runtime-service#backends) method. This method returns a list of [`IBMBackend`](../api/qiskit-ibm-runtime/ibm-backend) instances:

<Admonition type="note" title="Notes">
- If you are logged in to a specific instance or region, or if you initialized the service with a specific instance or region by using `QiskitRuntimeService()`, only the backends available to you on that instance or region are returned.  Otherwise, all backends available to you on any instance and in any region are returned.
- The list of backends returned might not be the same as those shown on the IBM Quantum Platform [Compute resources](https://quantum.cloud.ibm.com/computers) page.  The list on the Compute resources page is always filtered by the region selected at the top of the page.
</Admonition>
To run the following code, be sure you have already authenticated to the service. See [Set up your IBM Cloud account](/guides/cloud-setup) for more details.

```python
# Initialize your account
from qiskit_ibm_runtime import QiskitRuntimeService

service = QiskitRuntimeService()

service.backends()
```

```text
[<IBMBackend('ibm_pittsburgh')>,
 <IBMBackend('ibm_boston')>,
 <IBMBackend('ibm_fez')>,
 <IBMBackend('ibm_miami')>,
 <IBMBackend('ibm_marrakesh')>,
 <IBMBackend('ibm_torino')>,
 <IBMBackend('ibm_kingston')>]
```

The [`QiskitRuntimeService.backend()`](../api/qiskit-ibm-runtime/qiskit-runtime-service#backend) method (note that this is singular: *backend*) takes the name of the backend as the input parameter and returns an [`IBMBackend`](../api/qiskit-ibm-runtime/ibm-backend) instance representing that particular backend:

```python
service.backend("ibm_fez")
```

```text
<IBMBackend('ibm_fez')>
```

## Filter backends

You can also filter the available backends by their properties. For more general filters, set the `filters` argument to a function that accepts a backend object and returns `True` if it meets your criteria. Refer to the [API documentation](../api/qiskit-ibm-runtime/qiskit-runtime-service#backends) for more details.

The following code returns only backends that fit these criteria and are available to you _on your currently selected instance_:

*   Are real quantum devices (`simulator=False`)
*   Are currently operational (`operational=True`)
*   Have at least 5 qubits (`min_num_qubits=5`)

```python
# Optionally pass in an instance, region, or both, to
# further filter the backends.
service = QiskitRuntimeService()

service.backends(simulator=False, operational=True, min_num_qubits=5)
```

```text
[<IBMBackend('ibm_pittsburgh')>,
 <IBMBackend('ibm_boston')>,
 <IBMBackend('ibm_fez')>,
 <IBMBackend('ibm_miami')>,
 <IBMBackend('ibm_marrakesh')>,
 <IBMBackend('ibm_torino')>,
 <IBMBackend('ibm_kingston')>]
```

Use these keyword arguments to filter by any attribute in backend configuration ([JSON schema](https://github.com/Qiskit/ibm-quantum-schemas/blob/main/schemas/backend_configuration_schema.json)) or status ([JSON schema](https://github.com/Qiskit/ibm-quantum-schemas/blob/main/schemas/backend_status_schema.json)). A similar method is [`QiskitRuntimeService.least_busy()`](../api/qiskit-ibm-runtime/qiskit-runtime-service#least_busy), which takes the same filters as `backends()` but returns the backend that matches the filters and has the least number of jobs pending in the queue:

```python
service.least_busy(operational=True, min_num_qubits=5)
```

```text
<IBMBackend('ibm_torino')>
```

## Static backend information

Some information about a backend does not change regularly, such as its name, version, the number of qubits it has, and the types of features it supports. This information is available as attributes of the `backend` object.

The following cell builds a description of a backend.

```python
backend = service.backend("ibm_fez")

print(
    f"Name: {backend.name}\n"
    f"Version: {backend.version}\n"
    f"No. of qubits: {backend.num_qubits}\n"
)
```

```text
Name: ibm_fez
Version: 2
No. of qubits: 156
```

For a full list of attributes, see the [`IBMBackend` API documentation](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/ibm-backend).
## Native gates and operations

Each [processor family](/guides/processor-types) has a native gate set. By default, the QPUs in each family only support running the gates and operations in the native gate set. Thus, every gate in the circuit must be translated (by the transpiler) to the elements of this set.

You can view the native gates and operations for a QPU either [with Qiskit](#native-gates-with-qiskit), or on the IBM Quantum&reg; Platform [Compute resources page](/guides/qpu-information#native-gates-on-platform).

<span id="native-gates-with-qiskit"></span>
```python

from qiskit_ibm_runtime import QiskitRuntimeService

service = QiskitRuntimeService()

for backend in service.backends():
    config = backend.configuration()
    if "simulator" in config.backend_name:
        continue
    print(f"Backend: {config.backend_name}")
    print(f"    Processor type: {config.processor_type}")
    print(f"    Supported instructions:")
    for instruction in config.supported_instructions:
        print(f"        {instruction}")
    print()
```
## Dynamic backend information

Backends can also have properties that change whenever the backed is calibrated, such as qubit frequency and operation error rates. Backends are usually calibrated every 24 hours, and their properties update after the calibration sequence completes. These properties can be used when optimizing quantum circuits or to construct noise models for a classical simulator.

### Qubit properties

The `backend.properties().qubit_property()` returns information about the qubits' physical attributes. It contains a dictionary of various properties of the qubit, each paired with its value and the timestamp of the last calibration.

- `T1 (Relaxation Time)`: The T1 time represents the average duration a qubit remains in its excited state $|1\rangle$ before decaying to its ground state $|0\rangle$ due to energy relaxation. This parameter is used to characterize the qubit's energy relaxation behavior, and is expressed in units of seconds (s).

- `T2 (Dephasing Time)`: The T2 time denotes the timescale over which a qubit maintains phase coherence of a superposition between the $|0\rangle$ and $|1\rangle$ states. It accounts for both energy relaxation and pure dephasing processes, providing insight into the qubit's coherence properties.

- `frequency`: This parameter specifies the resonant frequency of the qubit, indicating the energy difference between the $|0\rangle$ and $|1\rangle$ states, expressed in hertz (Hz).

- `anharmonicity`: Anharmonicity is the difference in energy between the first and second excited states of the qubit, also expressed in hertz (Hz).

- `readout_error`: The readout error quantifies the average probability of incorrectly measuring a qubit's state. It is commonly calculated as the mean of prob_meas0_prep1 and prob_meas1_prep0, providing a single metric for measurement fidelity.

- `prob_meas0_prep1`: This parameter indicates the probability of measuring a qubit in the 0 state when it was intended to be prepared in the $|1\rangle$ state, denoted as $P(0 | 1)$. It reflects errors in state preparation and measurement (SPAM), particularly measurement errors in superconducting qubits.

- `prob_meas1_prep0`: Similarly, this parameter represents the probability of measuring a qubit in the 1 state when it was intended to be prepared in the $|0\rangle$ state, denoted as $P(1 | 0)$. Like prob_meas0_prep1, it reflects SPAM errors, with measurement errors being the predominant contributor in superconducting qubits.

- `readout_length`: The readout_length specifies the duration of the readout operation for a qubit. It measures the time from the initiation of the measurement pulse to the completion of signal digitization, after which the system is ready for the next operation. Understanding this parameter is crucial for optimizing circuit execution, especially when incorporating mid-circuit measurements.

```python
# fundamental physical properties of qubit 1
backend.qubit_properties(1)
```

```text
QubitProperties(t1=0.00023160183954439313, t2=0.0002759670226087048, frequency=None)
```

```python
# calibration data with detailed properties of qubit 0
backend.properties().qubit_property(0)
```

```text
{'T1': (5.199156952582205e-05,
  datetime.datetime(2026, 1, 14, 16, 18, 26, tzinfo=tzlocal())),
 'T2': (2.253552085985709e-05,
  datetime.datetime(2026, 1, 14, 16, 19, 6, tzinfo=tzlocal())),
 'readout_error': (0.013916015625,
  datetime.datetime(2026, 1, 14, 21, 38, 31, tzinfo=tzlocal())),
 'prob_meas0_prep1': (0.026123046875,
  datetime.datetime(2026, 1, 14, 21, 38, 31, tzinfo=tzlocal())),
 'prob_meas1_prep0': (0.001708984375,
  datetime.datetime(2026, 1, 14, 21, 38, 31, tzinfo=tzlocal())),
 'readout_length': (1.56e-06,
  datetime.datetime(2026, 1, 14, 21, 38, 31, tzinfo=tzlocal()))}
```

```python
# Retrieve qubit properties
qubit_index = 126  # Replace with your qubit index
qubit_props = backend.properties().qubit_property(qubit_index)

# Access specific properties
t1 = qubit_props.get("T1", (None,))[0]
t2 = qubit_props.get("T2", (None,))[0]
frequency = qubit_props.get("frequency", (None,))[0]
anharmonicity = qubit_props.get("anharmonicity", (None,))[0]
readout_error = qubit_props.get("readout_error", (None,))[0]
prob_meas0_prep1 = qubit_props.get("prob_meas0_prep1", (None,))[0]
prob_meas1_prep0 = qubit_props.get("prob_meas1_prep0", (None,))[0]
readout_length = qubit_props.get("readout_length", (None,))[0]

print(f"Qubit {qubit_index} Properties:")
print(f"  T1: {t1} seconds")
print(f"  T2: {t2} seconds")
print(f"  Frequency: {frequency} Hz")
print(f"  Anharmonicity: {anharmonicity} Hz")
print(f"  Readout Error: {readout_error}")
print(f"  P(0 | 1): {prob_meas0_prep1}")
print(f"  P(1 | 0): {prob_meas1_prep0}")
print(f"  Readout Length: {readout_length} seconds")
```

```text
Qubit 126 Properties:
  T1: 9.563335658857979e-05 seconds
  T2: 6.570556299807121e-05 seconds
  Frequency: None Hz
  Anharmonicity: None Hz
  Readout Error: 0.006591796875
  P(0 | 1): 0.009765625
  P(1 | 0): 0.00341796875
  Readout Length: 1.56e-06 seconds
```

### Instruction properties

The `backend.target` attribute is a `qiskit.transpiler.Target` object: an object that contains all the information needed to transpile a circuit for that backend. This includes instruction errors and durations. For example, the following cell gets the properties for a [`cz` gate](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.CZGate) acting between qubits 1 and 0.

```python
backend.target["cz"][(1, 0)]
```

```text
InstructionProperties(duration=6.8e-08, error=0.007831625819164134)
```

The following cell shows the properties for a measurement operation (including the readout error) on qubit 0.

```python
backend.target["measure"][(0,)]
```

```text
InstructionProperties(duration=1.56e-06, error=0.013916015625)
```

## Next steps

<Admonition type="tip" title="Recommendations">
    - Try the [Grover's algorithm](/tutorials/grovers-algorithm) tutorial.
    - Review the [QiskitRuntime backend API](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/qiskit-runtime-service#backend) reference.
</Admonition>