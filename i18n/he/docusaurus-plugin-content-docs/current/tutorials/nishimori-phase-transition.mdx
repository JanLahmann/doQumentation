---
title: "מעבר פאזה של Nishimori"
sidebar_label: "מעבר פאזה של Nishimori"
description: "מדריך זה מדגים כיצד להגשים מעבר פאזה של Nishimori על מעבד קוונטי של IBM."
notebook_path: "docs/tutorials/nishimori-phase-transition.ipynb"
---

<OpenInLabBanner notebookPath="docs/tutorials/nishimori-phase-transition.ipynb" />



*הערכת שימוש: 3 דקות על מעבד Heron r2 (הערה: זוהי הערכה בלבד. זמן הריצה שלך עשוי להשתנות.)*
## רקע {#background}
מדריך זה מדגים כיצד להגשים מעבר פאזה של Nishimori על מעבד קוונטי של IBM&reg;. ניסוי זה תואר במקור במאמר [*Realizing the Nishimori transition across the error threshold for constant-depth quantum circuits*](https://arxiv.org/abs/2309.02863).

מעבר הפאזה של Nishimori מתייחס למעבר בין פאזות מסודרות בטווח קצר לטווח ארוך במודל Ising עם קשרים אקראיים. במחשב קוונטי, הפאזה המסודרת בטווח ארוך באה לידי ביטוי במצב בו קיוביטים משולבים קוונטית על פני כל המכשיר. מצב משולב קוונטית זה מוכן באמצעות פרוטוקול *generation of entanglement by measurement* (GEM). באמצעות מדידות אמצע-מעגל, פרוטוקול GEM מסוגל לשלב קוונטית קיוביטים על פני כל המכשיר באמצעות מעגלים בעומק קבוע בלבד. מדריך זה משתמש במימוש של פרוטוקול GEM מחבילת התוכנה [GEM Suite](https://github.com/qiskit-community/gem-suite).
## דרישות {#requirements}
לפני שתתחילו במדריך זה, ודאו שיש לכם את התוכנות הבאות מותקנות:

- Qiskit SDK v1.0 ומעלה, עם תמיכה ב-[visualization](https://docs.quantum.ibm.com/api/qiskit/visualization)
- Qiskit Runtime v0.22 ומעלה ( `pip install qiskit-ibm-runtime` )
- GEM Suite ( `pip install gem-suite` )
## הכנה {#setup}

```python
# Added by doQumentation — installs packages not in the Binder environment
%pip install -q gem-suite
```

```python
import matplotlib.pyplot as plt

from collections import defaultdict

from qiskit_ibm_runtime import QiskitRuntimeService

from qiskit.transpiler import generate_preset_pass_manager

from gem_suite import PlaquetteLattice
from gem_suite.experiments import GemExperiment
```

## שלב 1: מיפוי קלטים קלאסיים לבעיה קוונטית {#step-1-map-classical-inputs-to-a-quantum-problem}

פרוטוקול GEM פועל על מעבד קוונטי עם קישוריות קיוביטים המתוארת על ידי סריג. מעבדים קוונטיים של IBM כיום משתמשים ב-[heavy hex lattice](https://www.ibm.com/quantum/blog/heavy-hex-lattice). הקיוביטים של המעבד מקובצים ל-*פלאקטות* (plaquettes) על בסיס תא היחידה של הסריג בו הם שוכנים. מכיוון שקיוביט עשוי להופיע ביותר מתא יחידה אחד, הפלאקטות אינן זרות. בסריג heavy hex, פלאקט מכיל 12 קיוביטים. הפלאקטות עצמן גם יוצרות סריג, שבו שתי פלאקטות מחוברות אם הן חולקות קיוביטים כלשהם. בסריג heavy hex, פלאקטות שכנות חולקות 3 קיוביטים.

בחבילת התוכנה GEM Suite, המחלקה הבסיסית למימוש פרוטוקול GEM היא `PlaquetteLattice`, המייצגת את סריג הפלאקטות (שונה מסריג heavy hex). ניתן לאתחל `PlaquetteLattice` ממפת צימוד קיוביטים. כרגע, רק מפות צימוד heavy hex נתמכות.

תא הקוד הבא מאתחל סריג פלאקטות ממפת הצימוד של מעבד קוונטי של IBM. סריג הפלאקטות לא תמיד מקיף את כל החומרה. לדוגמה, ל-`ibm_torino` יש 133 קיוביטים בסך הכל, אך סריג הפלאקטות הגדול ביותר שמתאים למכשיר משתמש רק ב-125 מהם, ומכיל סך של 18 פלאקטות. דבר דומה ניתן לראות גם במכשירי IBM Quantum&reg; עם ספירות קיוביטים שונות.

```python
# QiskitRuntimeService.save_account(channel="ibm_quantum", token="<YOUR_API_KEYN>", overwrite=True, set_as_default=True)
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=127
)
plaquette_lattice = PlaquetteLattice.from_coupling_map(backend.coupling_map)

print(f"Number of qubits in backend: {backend.num_qubits}")
print(
    f"Number of qubits in plaquette lattice: {len(list(plaquette_lattice.qubits()))}"
)
print(f"Number of plaquettes: {len(list(plaquette_lattice.plaquettes()))}")
```

```text
Number of qubits in backend: 133
Number of qubits in plaquette lattice: 125
Number of plaquettes: 18
```

ניתן לדמיין את סריג הפלאקטות על ידי יצירת דיאגרמה של ייצוג הגרף שלו. בדיאגרמה, הפלאקטות מיוצגות על ידי משושים מסומנים, ושתי פלאקטות מחוברות בקצה אם הן חולקות קיוביטים.

```python
plaquette_lattice.draw_plaquettes()
```

![Output of the previous code cell](/docs/images/tutorials/nishimori-phase-transition/extracted-outputs/625882a4-faeb-4d96-b441-c989f43c4dea-0.avif)

ניתן לאחזר מידע על פלאקטות בודדות, כגון הקיוביטים שהן מכילות, באמצעות המתודה `plaquettes`.

```python
# Get a list of the plaquettes
plaquettes = list(plaquette_lattice.plaquettes())
# Display information about plaquette 0
plaquettes[0]
```

```text
PyPlaquette(index=0, qubits=[0, 1, 2, 3, 4, 15, 16, 19, 20, 21, 22, 23], neighbors=[3, 1])
```

ניתן גם לייצר דיאגרמה של הקיוביטים הבסיסיים שיוצרים את סריג הפלאקטות.

```python
plaquette_lattice.draw_qubits()
```

![Output of the previous code cell](/docs/images/tutorials/nishimori-phase-transition/extracted-outputs/a19d63ce-3572-4081-a008-c1332fbbe303-0.avif)

בנוסף לתוויות הקיוביטים והקצוות המציינים אילו קיוביטים מחוברים, הדיאגרמה מכילה שלושה פיסות מידע נוספות הרלוונטיות לפרוטוקול GEM:
- כל קיוביט הוא מוצל (אפור) או לא מוצל. הקיוביטים המוצללים הם קיוביטי "אתר" (site) המייצגים את האתרים של מודל Ising, והקיוביטים הלא מוצללים הם קיוביטי "קשר" (bond) המשמשים לתיווך אינטראקציות בין קיוביטי האתר.
- כל קיוביט אתר מסומן כ-(A) או (B), המציין אחד משני תפקידים שקיוביט אתר יכול למלא בפרוטוקול GEM (התפקידים מוסברים מאוחר יותר).
- כל קצה צבוע באחד משישה צבעים, ובכך מחלק את הקצוות לשש קבוצות. חלוקה זו קובעת כיצד ניתן לבצע שערים דו-קיוביטיים במקביל, כמו גם תבניות תזמון שונות שסביר שיגרמו לכמויות שונות של שגיאה על מעבד קוונטי רועש. מכיוון שקצוות בקבוצה זרים, ניתן להחיל שכבת שערים דו-קיוביטיים על אותם קצוות בו-זמנית. למעשה, ניתן לחלק את ששת הצבעים לשלוש קבוצות של שני צבעים כך שהאיחוד של כל קבוצה של שני צבעים עדיין זר. לכן, יש צורך רק בשלוש שכבות של שערים דו-קיוביטיים כדי להפעיל כל קצה. ישנן 12 דרכים לחלק את ששת הצבעים כך, וכל חלוקה כזו מניבה לוח זמנים שונה של 3 שכבות שערים.

כעת לאחר שיצרתם סריג פלאקטות, השלב הבא הוא לאתחל אובייקט `GemExperiment`, תוך העברת סריג הפלאקטות וה-backend שבו אתם מתכננים להריץ את הניסוי. המחלקה `GemExperiment` מנהלת את המימוש בפועל של פרוטוקול GEM, כולל יצירת מעגלים, הגשת עבודות וניתוח הנתונים. תא הקוד הבא מאתחל את מחלקה הניסוי תוך הגבלת סריג הפלאקטות לשתיים בלבד מהפלאקטות (21 קיוביטים), מצמצם את גודל הניסוי כדי להבטיח שהרעש בחומרה לא יעלה על האות.

```python
gem_exp = GemExperiment(plaquette_lattice.filter([9, 12]), backend=backend)

# visualize the plaquette lattice after filtering
plaquette_lattice.filter([9, 12]).draw_qubits()
```

![Output of the previous code cell](/docs/images/tutorials/nishimori-phase-transition/extracted-outputs/02357c6e-5c83-4ac0-811d-22602d9f33d5-0.avif)

מעגל פרוטוקול GEM נבנה באמצעות השלבים הבאים:
1. הכנת מצב all-$|+\rangle$ על ידי החלת שער Hadamard על כל קיוביט.
2. החלת שער $R_{ZZ}$ בין כל זוג קיוביטים מחוברים. ניתן להשיג זאת באמצעות 3 שכבות של שערים. כל שער $R_{ZZ}$ פועל על קיוביט אתר וקיוביט קשר. אם קיוביט האתר מסומן (B), אז הזווית קבועה ל-$\frac{\pi}{2}$. אם קיוביט האתר מסומן (A), אז הזווית מורשית להשתנות, מייצרת מעגלים שונים. כברירת מחדל, טווח הזוויות מוגדר ל-21 נקודות מרווחות שווה בין $0$ ל-$\frac{\pi}{2}$, כולל.
3. מדידת כל קיוביט קשר בבסיס Pauli $X$. מכיוון שקיוביטים נמדדים בבסיס Pauli $Z$, ניתן לבצע זאת על ידי החלת שער Hadamard לפני מדידת הקיוביט.

שימו לב שהמאמר המצוטט בהקדמה למדריך זה משתמש באמנה שונה לזווית $R_{ZZ}$, השונה מהאמנה המשמשת במדריך זה בפקטור של 2.

בשלב 3, רק קיוביטי הקשר נמדדים. כדי להבין באיזה מצב נשארים קיוביטי האתר, מועיל לשקול את המקרה שבו זווית $R_{ZZ}$ המוחלת על קיוביטי אתר (A) בשלב 2 שווה ל-$\frac{\pi}{2}$. במקרה זה, קיוביטי האתר נשארים במצב משולב קוונטית מאוד הדומה למצב GHZ,

$$
\lvert \text{GHZ} \rangle = \lvert 00 \cdots 00 \rangle + \lvert 11 \cdots 11 \rangle.
$$

בשל האקראיות בתוצאות המדידה, המצב בפועל של קיוביטי האתר עשוי להיות מצב שונה עם סדר ארוך טווח, לדוגמה, $\lvert 00110 \rangle + \lvert 11001 \rangle$. עם זאת, ניתן לשחזר את מצב GHZ על ידי החלת פעולת פענוח המבוססת על תוצאות המדידה. כאשר זווית $R_{ZZ}$ מכוונת כלפי מטה מ-$\frac{\pi}{2}$, ניתן עדיין לשחזר את הסדר ארוך הטווח עד לזווית קריטית, שבהיעדר רעש, היא בקירוב $0.3 \pi$. מתחת לזווית זו, המצב המתקבל כבר אינו מציג שזירה ארוכת טווח. מעבר זה בין נוכחות והיעדר סדר ארוך טווח הוא מעבר הפאזה של Nishimori.

בתיאור לעיל, קיוביטי האתר נותרו ללא מדידה, וניתן לבצע את פעולת הפענוח על ידי החלת שערים קוונטיים. בניסוי כפי שמיושם בחבילת GEM, שמדריך זה עוקב אחריו, קיוביטי האתר נמדדים למעשה, ופעולת הפענוח מוחלת בשלב עיבוד קלאסי לאחר מכן.

בתיאור לעיל, ניתן לבצע את פעולת הפענוח על ידי החלת שערים קוונטיים על קיוביטי האתר כדי לשחזר את המצב הקוונטי. עם זאת, אם המטרה היא למדוד מיד את המצב, לדוגמה למטרות אפיון, אז קיוביטי האתר נמדדים יחד עם קיוביטי הקשר, וניתן להחיל את פעולת הפענוח בשלב עיבוד קלאסי לאחר מכן. כך מיושם הניסוי בחבילת GEM, שמדריך זה עוקב אחריו.

בנוסף להיותו תלוי בזווית $R_{ZZ}$ בשלב 2, שכברירת מחדל סוקרת 21 ערכים, מעגל פרוטוקול GEM תלוי גם בתבנית התזמון המשמשת ליישום 3 השכבות של שערי $R_{ZZ}$. כפי שנדון קודם לכן, ישנן 12 תבניות תזמון כאלה. לכן, המספר הכולל של מעגלים בניסוי הוא $21 \times 12 = 252$.

ניתן ליצור את המעגלים של הניסוי באמצעות המתודה `circuits` של המחלקה `GemExperiment`.

```python
circuits = gem_exp.circuits()
print(f"Total number of circuits: {len(circuits)}")
```

```text
Total number of circuits: 252
```

למטרות מדריך זה, מספיק לשקול רק תבנית תזמון בודדת. תא הקוד הבא מגביל את הניסוי לתבנית התזמון הראשונה. כתוצאה מכך, לניסוי יש רק 21 מעגלים, אחד לכל זווית $R_{ZZ}$ שעליה מעבירים.

```python
# Restrict experiment to the first scheduling pattern
gem_exp.set_experiment_options(schedule_idx=0)

# There are less circuits now
circuits = gem_exp.circuits()
print(f"Total number of circuits: {len(circuits)}")

# Print the RZZ angles swept over
print(f"RZZ angles:\n{gem_exp.parameters()}")
```

```text
Total number of circuits: 21
RZZ angles:
[0.         0.07853982 0.15707963 0.23561945 0.31415927 0.39269908
 0.4712389  0.54977871 0.62831853 0.70685835 0.78539816 0.86393798
 0.9424778  1.02101761 1.09955743 1.17809725 1.25663706 1.33517688
 1.41371669 1.49225651 1.57079633]
```

תא הקוד הבא מצייר דיאגרמה של המעגל באינדקס 5. כדי לצמצם את גודל הדיאגרמה, שערי המדידה בסוף המעגל מוסרים.

```python
# Get the circuit at index 5
circuit = circuits[5]
# Remove the final measurements to ease visualization
circuit.remove_final_measurements()
# Draw the circuit
circuit.draw("mpl", fold=-1, scale=0.5)
```

![Output of the previous code cell](/docs/images/tutorials/nishimori-phase-transition/extracted-outputs/fd57d483-c70b-4ad5-b309-15750ad38bac-0.avif)

## שלב 2: אופטימיזציה של הבעיה עבור הרצה על חומרת קוונטית {#step-2-optimize-problem-for-quantum-hardware-execution}

Transpiling של מעגלים קוונטיים להרצה על חומרה בדרך כלל כרוך [במספר שלבים](/guides/transpiler-stages). בדרך כלל, השלבים הכרוכים בעומס חישובי רב ביותר הם בחירת פריסת הקיוביטים, ניתוב השערים הדו-קיוביטיים כדי להתאים לקישוריות הקיוביטים של החומרה, ואופטימיזציה של המעגל כדי למזער את ספירת השערים והעומק שלו. בפרוטוקול GEM, שלבי הפריסה והניתוב אינם נחוצים מכיוון שהקישוריות של החומרה כבר משולבת בעיצוב הפרוטוקול. למעגלים כבר יש פריסת קיוביטים, והשערים הדו-קיוביטיים כבר ממופים על חיבורים מקוריים. יותר מכך, כדי לשמר את המבנה של המעגל בזמן ששינוי זווית $R_{ZZ}$, יש לבצע רק אופטימיזציה מאוד בסיסית של המעגל.

המחלקה `GemExperiment` מבצעת transpile במעגלים בשקיפות בזמן ביצוע הניסוי. שלבי הפריסה והניתוב כבר מוחלפים כברירת מחדל כך שלא יעשו דבר, ואופטימיזציה של המעגל מבוצעת ברמה שמטפלת רק בשערים חד-קיוביטיים. עם זאת, ניתן לעקוף או להעביר אפשרויות נוספות באמצעות המתודה `set_transpile_options`. למטרות הדמיה, תא הקוד הבא מבצע transpile ידני למעגל שהוצג קודם לכן, ומצייר את המעגל ה-transpiled.

```python
# Demonstrate setting transpile options
gem_exp.set_transpile_options(
    optimization_level=1  # This is the default optimization level
)
pass_manager = generate_preset_pass_manager(
    backend=backend,
    initial_layout=list(gem_exp.physical_qubits),
    **dict(gem_exp.transpile_options),
)
transpiled = pass_manager.run(circuit)
transpiled.draw("mpl", idle_wires=False, fold=-1, scale=0.5)
```

![Output of the previous code cell](/docs/images/tutorials/nishimori-phase-transition/extracted-outputs/e9b99d48-8d33-46b5-bff5-480ab1c1c1f2-0.avif)

## שלב 3: הרצה באמצעות Qiskit primitives {#step-3-execute-using-qiskit-primitives}

כדי להריץ את מעגלי פרוטוקול GEM על החומרה, קראו למתודה `run` של אובייקט `GemExperiment`. ניתן לציין את מספר ה-shots שברצונכם לדגום מכל מעגל. המתודה `run` מחזירה אובייקט [ExperimentData](https://qiskit-community.github.io/qiskit-experiments/stubs/qiskit_experiments.framework.ExperimentData.html) שכדאי לשמור במשתנה. שימו לב שהמתודה `run` רק מגישה עבודות מבלי לחכות שהן יסתיימו, ולכן זוהי קריאה לא חוסמת.

```python
exp_data = gem_exp.run(shots=10_000)
```

כדי לחכות לתוצאות, קראו למתודה `block_for_results` של אובייקט `ExperimentData`. קריאה זו תגרום למפרש להיתלות עד שהעבודות יסתיימו.

```python
exp_data.block_for_results()
```

```text
ExperimentData(GemExperiment, d0d5880a-34c1-4aab-a7b6-c4f58516bc03, job_ids=['cwg12ptmptp00082khhg'], metadata=<5 items>, figure_names=['two_point_correlation.svg', 'normalized_variance.svg', 'plaquette_ops.svg', 'bond_ops.svg'])
```

## שלב 4: עיבוד לאחר והחזרת תוצאה בפורמט קלאסי רצוי {#step-4-post-process-and-return-result-in-desired-classical-format}

בזווית $R_{ZZ}$ של $\frac{\pi}{2}$, המצב המפוענח יהיה מצב GHZ בהיעדר רעש. ניתן לדמיין את הסדר ארוך הטווח של מצב GHZ על ידי שרטוט המגנטיזציה של מחרוזות הביטים הנמדדות. המגנטיזציה $M$ מוגדרת כסכום של אופרטורי Pauli $Z$ חד-קיוביטיים,
$$
M = \sum_{j=1}^N Z_j,
$$
כאשר $N$ הוא מספר קיוביטי האתר. הערך שלה עבור מחרוזת ביטים שווה להפרש בין מספר האפסים ומספר האחדים. מדידת מצב GHZ מניבה את מצב כל האפסים או את מצב כל האחדים בהסתברות שווה, כך שהמגנטיזציה תהיה $+N$ מחצית מהזמן ו-$-N$ את המחצית האחרת של הזמן. בנוכחות שגיאות עקב רעש, ערכים אחרים יופיעו גם כן, אך אם הרעש אינו גדול מדי, ההתפלגות עדיין תהיה מרוכזת ליד $+N$ ו-$-N$.

עבור מחרוזות הביטים הגולמיות לפני הפענוח, התפלגות המגנטיזציה תהיה שווה ערך לזו של מחרוזות ביטים אקראיות אחידות, בהיעדר רעש.

תא הקוד הבא מצייר את המגנטיזציה של מחרוזות הביטים הגולמיות ומחרוזות הביטים המפוענחות בזווית $R_{ZZ}$ של $\frac{\pi}{2}$.

```python
def magnetization_distribution(
    counts_dict: dict[str, int],
) -> dict[str, float]:
    """Compute magnetization distribution from counts dictionary."""
    # Construct dictionary from magnetization to count
    mag_dist = defaultdict(float)
    for bitstring, count in counts_dict.items():
        mag = bitstring.count("0") - bitstring.count("1")
        mag_dist[mag] += count
    # Normalize
    shots = sum(counts_dict.values())
    for mag in mag_dist:
        mag_dist[mag] /= shots
    return mag_dist

# Get counts dictionaries with and without decoding
data = exp_data.data()
# Get the last data point, which is at the angle for the GHZ state
raw_counts = data[-1]["counts"]
# Without decoding
site_indices = [
    i for i, q in enumerate(gem_exp.plaquettes.qubits()) if q.role == "Site"
]
site_raw_counts = defaultdict(int)
for key, val in raw_counts.items():
    site_str = "".join(key[-1 - i] for i in site_indices)
    site_raw_counts[site_str] += val
# With decoding
_, site_decoded_counts = gem_exp.plaquettes.decode_outcomes(
    raw_counts, return_counts=True
)

# Compute magnetization distribution
raw_magnetization = magnetization_distribution(site_raw_counts)
decoded_magnetization = magnetization_distribution(site_decoded_counts)

# Plot
plt.bar(*zip(*raw_magnetization.items()), label="raw")
plt.bar(*zip(*decoded_magnetization.items()), label="decoded", width=0.3)
plt.legend()
plt.xlabel("Magnetization")
plt.ylabel("Frequency")
plt.title("Magnetization distribution with and without decoding")
```

```text
Text(0.5, 1.0, 'Magnetization distribution with and without decoding')
```

![Output of the previous code cell](/docs/images/tutorials/nishimori-phase-transition/extracted-outputs/8ead3582-16df-4616-836c-bdce867ad6b8-1.avif)

כדי לאפיין בצורה קפדנית יותר את הסדר ארוך הטווח, ניתן לבחון את קורלציית שתי הנקודות הממוצעת $f$, המוגדרת כ-
$$
f = \frac{1}{N^2} \left(\langle M^2 \rangle - \langle M \rangle ^2\right).
$$
ערך גבוה יותר מצביע על דרגת שזירה גדולה יותר. המחלקה `GemExperiment` מחשבת אוטומטית ערך זה עבור מחרוזות הביטים המפוענחות כחלק מעיבוד נתוני הניסוי. היא מאחסנת תמונה שניתן לגשת אליה דרך המתודה `figure` של מחלקת נתוני הניסוי. במקרה זה, שם התמונה הוא `two_point_correlation`.

```python
exp_data.figure("two_point_correlation")
```

![Output of the previous code cell](/docs/images/tutorials/nishimori-phase-transition/extracted-outputs/4ecb25c8-e572-49af-a879-9943039db131-0.avif)

כדי לקבוע את הנקודה הקריטית של מעבר הפאזה של Nishimori, ניתן להסתכל על השונות המנורמלת של $M^2 / N$, המוגדרת כ-
$$
g = \frac{1}{N^3} \left(\langle M^4 \rangle - \langle M^2 \rangle^2\right),
$$
שמכמתת את כמות התנודה במגנטיזציה בריבוע. ערך זה ממוקסם בנקודה הקריטית של מעבר הפאזה של Nishimori. בהיעדר רעש, הנקודה הקריטית מתרחשת בקירוב $0.3 \pi$. בנוכחות רעש, הנקודה הקריטית נדחפת גבוה יותר, אך מעבר הפאזה עדיין נצפה כל עוד הנקודה הקריטית מתרחשת מתחת ל-$0.5 \pi$.

```python
exp_data.figure("normalized_variance")
```

![Output of the previous code cell](/docs/images/tutorials/nishimori-phase-transition/extracted-outputs/2b351d68-3924-445a-94ef-047b16214e8a-0.avif)

## הגדלת הניסוי {#scale-up-the-experiment}

תאי הקוד הבאים מריצים את הניסוי עבור שש פלאקטות (49 קיוביטים) ועבור 12 הפלאקטות המלאות (125 קיוביטים) ומצייר את השונות המנורמלת. ככל שהניסוי מתרחב לגדלים גדולים יותר, כמות הרעש הגדולה יותר מזיזה את הנקודה הקריטית ימינה.

```python
gem_exp = GemExperiment(
    plaquette_lattice.filter(range(3, 9)), backend=backend
)
gem_exp.set_experiment_options(schedule_idx=0)
exp_data = gem_exp.run(shots=10_000)
exp_data.block_for_results()
exp_data.figure("normalized_variance")
```

![Output of the previous code cell](/docs/images/tutorials/nishimori-phase-transition/extracted-outputs/08581c09-a6a5-4a56-9fc4-abf22b063c6a-0.avif)

```python
gem_exp = GemExperiment(plaquette_lattice, backend=backend)
gem_exp.set_experiment_options(schedule_idx=0)
exp_data = gem_exp.run(shots=10_000)
exp_data.block_for_results()
exp_data.figure("normalized_variance")
```

![Output of the previous code cell](/docs/images/tutorials/nishimori-phase-transition/extracted-outputs/37e9a4cd-6efb-4ade-ad09-8139db9d58e9-0.avif)

## סיכום {#conclusion}

במדריך זה, הגשמתם מעבר פאזה של Nishimori על מעבד קוונטי באמצעות פרוטוקול GEM. המדדים שבדקתם במהלך העיבוד לאחר מכן, במיוחד קורלציית שתי הנקודות והשונות המנורמלת, משמשים כמדדי ייחוס של יכולת המכשיר ליצור מצבים משולבים קוונטית ארוכי טווח. מדדי ייחוס אלו מרחיבים את התועלת של פרוטוקול GEM מעבר לחקר פיזיקה מעניינת. כחלק מהפרוטוקול, שזרתם קוונטית קיוביטים על פני כל המכשיר באמצעות מעגלים בעומק קבוע בלבד. הישג זה אפשרי רק בשל השימוש של הפרוטוקול במדידות אמצע-מעגל. בניסוי זה, המצב המשולב קוונטית נמדד מיד, אך אפיק מעניין לחקור יהיה להמשיך להשתמש במצב בעיבוד קוונטי נוסף!
## סקר מדריך {#tutorial-survey}

אנא השתתפו בסקר הקצר הזה כדי לספק משוב על מדריך זה. התובנות שלכם יעזרו לנו לשפר את הצעות התוכן שלנו וחוויית המשתמש.

[קישור לסקר](https://your.feedback.ibm.com/jfe/form/SV_bsCKQkgzuQUQ7ky)
