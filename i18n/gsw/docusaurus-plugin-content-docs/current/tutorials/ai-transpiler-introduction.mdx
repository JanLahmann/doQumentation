---
title: "Iifüerig i de Qiskit KI-gstützt Transpiler-Service"
sidebar_label: "Iifüerig i de Qiskit KI-gstützt Transpiler-Service"
description: "I däm Notebook luege mir üs die wichtigste Vorteile vom Qiskit KI-gstützte Transpiler-Service aa und wie er sich mit traditionelle Methode vergliched."
notebook_path: "docs/tutorials/ai-transpiler-introduction.ipynb"
---
{/* doqumentation-source-hash: 3bc5a35e */}

<OpenInLabBanner notebookPath="docs/tutorials/ai-transpiler-introduction.ipynb" />



{/* cspell:ignore fontsize idxmin */}

*Gschätzte QPU-Nutzung: Kei (HIIWIS: Das Tutorial füert kei Jobs uus, will's sich uf Transpilation konzentriert)*

## Hintergrund {#background}

De **Qiskit KI-gstützt Transpiler-Service (QTS)** füert maschinells-Lerne-basierti Optimierige sowohl i Routing- als au i Synthese-Passes ii. Dää KI-Modi sind entwicklet worde, zum d'Iischränkige vo de traditionelle Transpilation aagaa, bsunders für grossi Schaltige und komplexe Hardware-Topologie.

Ab **Juli 2025** isch de **Transpiler-Service** zur neue IBM Quantum&reg; Plattform migriert worde und isch nümme verfüegbar. Für die neueschte Updates zum Status vom Transpiler-Service lueg id [Transpiler-Service-Dokumentation](/guides/qiskit-transpiler-service). Du chasch de KI-Transpiler wiiterhin lokal verwende, ähnlich wie bi de Standard-Qiskit-Transpilation. Ersetz eifach `generate_preset_pass_manager()` dur `generate_ai_pass_manager()`. Die Funktion konstruiert en Pass-Manager, wo d'KI-gstützte Routing- und Synthese-Passes direkt i dis lokale Transpilations-Workflow integriert.

### Hauptmerkmale vo de KI-Passes {#key-features-of-ai-passes}

- Routing-Passes: KI-gstützts Routing chan Qubit-Pfäd dynamisch basierend uf de spezifischi Schaltig und s'Backend aapasse und de Bedarf a übermässige SWAP-Gates reduziere.
    - `AIRouting`: Layout-Uuswahl und Schaltig-Routing

- Synthese-Passes: KI-Technike optimiere d'Zerlëgig vo Multi-Qubit-Gates und minimiere d'Aazahl vo de Zwei-Qubit-Gates, wo typischerwiis afälliger für Fähler sind.
    - `AICliffordSynthesis`: Clifford-Gate-Synthese
    - `AILinearFunctionSynthesis`: Synthese vo Linear-Funktionsschaltige
    - `AIPermutationSynthesis`: Synthese vo Permutationsschaltige
    - `AIPauliNetworkSynthesis`: Synthese vo Pauli-Netzwerkschaltige (nume im Qiskit Transpiler Service verfüegbar, nöd i de lokale Umgëbig)

- Vergliich mit traditioneller Transpilation: De Standard-Qiskit-Transpiler isch es robustes Wärkzüüg, wo es breits Spektrum vo Quanteschaltige effektiv hanthabe chan. Wenn Schaltige aber grösser wärde oder Hardware-Konfiguratione komplexer wärde, chöi KI-Passes zuesätzlichi Optimiergsgewinne liefere. Dur d'Verwendig vo glehrte Modell für Routing und Synthese verfeineret QTS Schaltigslayouts wiiter und reduziert de Overhead für useforderendi oder gross aaleiti Quanteufgabe.

Das Tutorial evaluiert d'KI-Modi under Verwendig vo Routing- und ou vo Synthese-Passes und verglicht d'Ergebnis mit traditioneller Transpilation, zum hervörhebe, wo KI Leistigsvordel bietet.

Für wiitri Details zu de verfüegbare KI-Passes lueg id [KI-Passes-Dokumentation](/guides/ai-transpiler-passes).

### Worum KI für Quanteschaltig-Transpilation verwände? {#why-use-ai-for-quantum-circuit-transpilation}

Wil Quanteschaltige i Grössi und Komplexität zuenemme, hend traditionelli Transpilationsmethode Schwiirigkeite, Layouts z'optimiere und Gate-Aazahle effizient z'reduziere. Grösseri Schaltige, bsunders die mit Hunderte vo Qubits, stelle erhebliche Usefordrige a s'Routing und d'Synthese dar, wëge Gerätebschränkige, begränzter Konnektivität und Qubit-Fählerrate.

Daa bietet d'KI-gstützt Transpilation e potenzielli Lösig. Dur d'Nutzig vo maschinelle Lehrntechnike chan de KI-gstützt Transpiler i Qiskit gschider Entscheidige über Qubit-Routing und Gate-Synthese träffe, was zu besserer Optimierig vo gross aaleite Quanteschaltige füert.

### Churzi Benchmarking-Ergebnis {#brief-benchmarking-results}
![Graph showing AI transpiler performance against Qiskit](/docs/images/tutorials/ai-transpiler-introduction/ai-transpiler-benchmarks.avif)

I Benchmarking-Tests het de KI-Transpiler konsistent flacheri Schaltige höcherer Qualität im Vergliich zum Standard-Qiskit-Transpiler produziert. Für dää Tests hend mir d'Standard-Pass-Manager-Strategie vo Qiskit verwändet, konfiguriert mit [`generate_preset_passmanager`]. Während die Standardstrategie oft effektiv isch, chan sie bi grössere oder komplexere Schaltige Schwiirigkeite haa. Im Gëgesatz dezue hend KI-gstützti Passes e durchschnittlichi Reduzierig vo de Zwei-Qubit-Gate-Aazahl um 24% und e Reduzierig vo de Schaltigstieffi um 36% für grossi Schaltige (100+ Qubits) bi de Transpilation uf d'Heavy-Hex-Topologie vo IBM Quantum Hardware erreicht. Wiitri Informatione zu däne Benchmarks findsch im [Blog.](https://www.ibm.com/quantum/blog/qiskit-performance)

Das Tutorial underschuecht d'wichtigste Vordel vo de KI-Passes und wie sie sich mit traditionelle Methode vergliche.

```python
# Added by doQumentation — installs packages not in the Binder environment
%pip install -q qiskit-ibm-transpiler
```

```python
# This cell is hidden from users;
# it just disables a linting rule.
# ruff: noqa: F811
```

## Aaforderige {#requirements}

Stell vor em Aafang vo däm Tutorial sicher, dass du Folgendes installiert hesch:

* Qiskit SDK v1.0 oder höcher, mit Understützig für [Visualisierig](https://docs.quantum.ibm.com/api/qiskit/visualization)
* Qiskit Runtime (`pip install qiskit-ibm-runtime`) v0.22 oder höcher
* Qiskit IBM&reg; Transpiler mit KI-Lokalmodus(`pip install 'qiskit-ibm-transpiler[ai-local-mode]'`)

## Setup {#setup}

```python
from qiskit import QuantumCircuit
from qiskit.circuit.library import efficient_su2, PermutationGate
from qiskit.synthesis.qft import synth_qft_full
from qiskit.circuit.random import random_circuit, random_clifford_circuit
from qiskit.transpiler import generate_preset_pass_manager, CouplingMap
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_transpiler import generate_ai_pass_manager
from qiskit.synthesis.permutation import (
    synth_permutation_depth_lnn_kms,
    synth_permutation_basic,
)
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import time
import logging

seed = 42

# Used for generating permutation circuits in part two for comparison
def generate_permutation_circuit(width, pattern):
    circuit = QuantumCircuit(width)
    circuit.append(
        PermutationGate(pattern=pattern),
        qargs=range(width),
    )
    return circuit

# Creates a Bernstein-Vazirani circuit given the number of qubits
def create_bv_circuit(num_qubits):
    qc = QuantumCircuit(num_qubits, num_qubits - 1)
    qc.x(num_qubits - 1)
    qc.h(qc.qubits)
    for i in range(num_qubits - 1):
        qc.cx(i, num_qubits - 1)
    qc.h(qc.qubits[:-1])
    return qc

# Transpile a circuit with a given pass manager and return metrics
def transpile_with_metrics(pass_manager, circuit):
    start = time.time()
    qc_out = pass_manager.run(circuit)
    elapsed = time.time() - start

    depth_2q = qc_out.depth(lambda x: x.operation.num_qubits == 2)
    gate_count = qc_out.size()

    return qc_out, {
        "depth_2q": depth_2q,
        "gate_count": gate_count,
        "time_s": elapsed,
    }

# Used for collecting metrics for part 3 of synthesis methods
def synth_transpile_with_metrics(qc, pm, pattern_id, method):
    start = time.time()
    qc = pm.run(qc)
    elapsed = time.time() - start

    return {
        "Pattern": pattern_id,
        "Method": method,
        "Depth (2Q)": qc.depth(lambda x: x.operation.num_qubits == 2),
        "Gates": qc.size(),
        "Time (s)": elapsed,
    }

# Ignore logs like "INFO:qiskit_ibm_transpiler.wrappers.ai_local_synthesis:Running Linear Functions AI synthesis on local mode"

logging.getLogger(
    "qiskit_ibm_transpiler.wrappers.ai_local_synthesis"
).setLevel(logging.WARNING)
```

# Teil I. Qiskit-Muster {#part-i-qiskit-patterns}

Jetzt luege mir üs aa, wie mer de KI-Transpiler-Service mit ere einfache Quanteschaltig under Verwendig vo Qiskit-Muster verwände. De Schlüssel isch d'Erstellig vo eme `PassManager` mit `generate_ai_pass_manager()` anstatt vom Standard `generate_preset_pass_manager()`.

## Schritt 1: Klassischi Iigabe uf es Quanteproblem abilde {#step-1-map-classical-inputs-to-a-quantum-problem}

I däm Abschnitt teste mir de KI-Transpiler uf de `efficient_su2`-Schaltig, eme wiit verbreitete hardwareeffiziente Aasatz. Dää Schaltig isch bsunders relevant für variationelli Quantealgorithme (zum Biischpil VQE) und Quantum-Machine-Learning-Ufgabe, was sie zu eme ideale Testfall für d'Bewertig vo de Transpilationslöschtig macht.

D'`efficient_su2`-Schaltig beschtoot uus abwëchslende Schichte vo Ein-Qubit-Rotatione und verschränkende Gates wie CNOTs. Dää Schichte ermögliche e flexibli Erkundig vom Quantezuestandsruum, während d'Gate-Tieffi überschaubar blibt. Dur Optimierig vo dere Schaltig wänd mir d'Gate-Aazahl reduziere, d'Fidelität verbessere und Ruusche minimiere. Das macht sie zu eme starke Kandidat für s'Teschte vo de Effiziänz vom KI-Transpiler.

```python
# For our transpilation, we will use a large circuit of 101 qubits
qc = efficient_su2(90, entanglement="circular", reps=1).decompose()

# Draw a smaller version of the circuit to get a visual representation
qc_small = efficient_su2(5, entanglement="circular", reps=1).decompose()
qc_small.draw(output="mpl")
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/c6e9c2c0-e02c-4276-bae8-d5692e60b6b8-0.avif)

## Schritt 2: Problem für d'Usführig uf Quantehardware optimiere {#step-2-optimize-problem-for-quantum-hardware-execution}

### Es Backend uuswähle {#choose-a-backend}

Für das Biischpil wähle mir s'am wenigschte usglaschtet betriebsbereit IBM Quantum Backend, wo kei Simulator isch und mindëschtens 100 Qubits het:

**Hiiwis:** Wil sich s'am wenigschte usglaschtet Backend im Lauf vo de Ziit chönti ändere, chöi für verschideni Durchläuf underschidlichi Gerät uusgwählt wärde. Gerät-spezifischi Eigeschafte, wie Coupling-Maps, chöi zu Underschid i de transpilierte Schaltige füere.

```python
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=100
)
cm = backend.coupling_map
print(f"Using backend: {backend.name}")
```

```text
Using backend: ibm_torino
```

### KI- und traditionelli Pass-Manager ersch stelle {#create-ai-and-traditional-pass-managers}
Zum d'Effektivität vom KI-Transpiler z'bewärte, füere mir zwei Transpilationslööf dur. Zersch transpiliere mir d'Schaltig mit em KI-Transpiler. Denn füere mir e Vergliich dur, indem mir dëselbi Schaltig ohni de KI-Transpiler mit traditionelle Methode transpiliere. Beidi Transpilationsprozess verwände dëselbi Coupling-Map vom gwählte Backend und s'Optimierigslevel wird uf 3 gsetzt, für e faire Vergliich.

Beidi Methode spiegele de Standardaasatz zur Erstellig vo `PassManager`-Instanze zur Transpilation vo Schaltige i Qiskit wider.

```python
pm_ai = generate_ai_pass_manager(
    optimization_level=3,
    ai_optimization_level=3,
    coupling_map=cm,
    include_ai_synthesis=True,  # used for part 3 when comparing synthesis methods
)

pm_no_ai = generate_preset_pass_manager(
    optimization_level=3,
    coupling_map=cm,
    seed_transpiler=seed,  # note that the AI pass manager does not currently support seeding
)
```

Transpilier d'Schaltige und zeichne d'Ziite uf.

```python
# Transpile using standard (non-AI) pass manager
_, metrics_no_ai = transpile_with_metrics(pm_no_ai, qc)
print(
    f"Standard transpilation: Depth (2q) {metrics_no_ai['depth_2q']}, "
    f"Gate count {metrics_no_ai['gate_count']}, Time {metrics_no_ai['time_s']}"
)

# Transpile using AI pass manager
_, metrics_ai = transpile_with_metrics(pm_ai, qc)
print(
    f"AI transpilation      : Depth (2q) {metrics_ai['depth_2q']}, "
    f"Gate count {metrics_ai['gate_count']}, Time {metrics_ai['time_s']}"
)
```

```text
Standard transpilation: Depth (2q) 95, Gate count 458, Time 0.04650712013244629
AI transpilation      : Depth (2q) 90, Gate count 456, Time 0.9342479705810547
```

I däm Tescht vergliche mir d'Leistig vom KI-Transpiler und vo de Standard-Transpilationsmethode uf de efficient_su2-Schaltig. De KI-Transpiler erreicht e merklich flacheri Schaltigstieffi bi ähnlicher Gate-Aazahl.

- **Schaltigstieffi:** De KI-Transpiler produziert e Schaltig mit geringerer Zwei-Qubit-Tieffi. Das isch z'erwarte, wil d'KI-Passes druuf trainiert sind, d'Tieffi z'optimiere, indem sie Qubit-Interaktionsmuster lehre und Hardware-Konnektivität effektiver als regelbasierti Heuristike uusnutze.

- **Gate-Aazahl:** D'Gsammt-Gate-Aazahl blibt zwüsche de zwei Methode ähnlich. Das entspricht de Erwartige, wil d'Standard-SABRE-basierti Transpilation explizit d'Swap-Aazahl minimiert, wo de Gate-Overhead dominiert. De KI-Transpiler priorisiert stattdesse d'Gsammttieffi und chan gelägetlich e paar zuesätzlichi Gates für e chürzere Usführigspfad itausche.

- **Transpilationsziit:** De KI-Transpiler bruucht meh Ziit als d'Standardmethode. Das ligt a de zuesätzliche Rechekoschte für s'Ufruefe vo glehrte Modell während em Routing und de Synthese. Im Gëgesatz dezue isch de SABRE-basiert Transpiler jetzt no Neugstaltig und Optimierig i Rust düütlich schnäller und bietet hocheffizient heuristischs Routing im grosse Maassstab.

'S isch wichtig z'beachte, dass dää Ergebnis nume uf einere Schaltig basiere. Zum es umfassends Verständnis devoo z'übercho, wie sich de KI-Transpiler im Vergliich zu traditionelle Methode verhält, isch es nötig, e Vielzahl vo Schaltige z'teschte. D'Leistig vo QTS chan je no Art vo de z'optimierende Schaltig stark variiere. Für e breitere Vergliich lueg bi de obige Benchmarks oder bsueche de [Blog.](https://www.ibm.com/quantum/blog/qiskit-performance)

## Schritt 3: Usführig mit Qiskit Primitives {#step-3-execute-using-qiskit-primitives}
Wil sich das Tutorial uf Transpilation konzentriert, wärde kei Experimänt uf em Quantegerät uusgfüert. S'Ziil isch es, d'Optimierige uus Schritt 2 z'nutze, zum e transpilierti Schaltig mit reduzierter Tieffi oder Gate-Aazahl z'übercho.

## Schritt 4: Nohbearbeitig und Rückgab vom Ergebnis im gwünschte klassische Format {#step-4-post-process-and-return-result-in-desired-classical-format}
Wil's kei Usführig für das Notebook git, git's kei Ergebnis zur Nohbearbeitig.

# Teil II. Analyse und Benchmarking vo de transpilierte Schaltige {#part-ii-analyze-and-benchmark-the-transpiled-circuits}

I däm Abschnitt zeige mir, wie mer d'transpilierti Schaltig analysiert und detaillierter mit de Originalversion vergliche. Mir konzentriere üs uf Metrike wie Schaltigstieffi, Gate-Aazahl und Transpilationsziit, zum d'Effektivität vo de Optimierig z'bewärte. Zuesätzlich diskutiere mir, wie d'Ergebnis über verschideni Schaltigstype hinwëg variiere chöi, und biete Iblick i d'breiteri Leistig vom Transpiler über verschideni Szenarios hinwëg.

```python
# Circuits to benchmark
seed = 42
circuits = [
    {
        "name": "Random",
        "qc": random_circuit(num_qubits=30, depth=10, seed=seed),
    },
    {
        "name": "Clifford",
        "qc": random_clifford_circuit(
            num_qubits=40, num_gates=200, seed=seed
        ),
    },
    {
        "name": "QFT",
        "qc": synth_qft_full(num_qubits=20, do_swaps=False).decompose(),
    },
    {
        "name": "BV",
        "qc": create_bv_circuit(40),
    },
]

results = []

# Run the transpilation for each circuit and store the results
for circuit in circuits:
    qc_no_ai, metrics_no_ai = transpile_with_metrics(pm_no_ai, circuit["qc"])
    qc_ai, metrics_ai = transpile_with_metrics(pm_ai, circuit["qc"])

    print("Completed transpilation for", circuit["name"])

    results.append(
        {
            "Circuit": circuit["name"],
            "Depth 2Q (No AI)": metrics_no_ai["depth_2q"],
            "Gate Count (No AI)": metrics_no_ai["gate_count"],
            "Time (No AI)": metrics_no_ai["time_s"],
            "Depth 2Q (AI)": metrics_ai["depth_2q"],
            "Gate Count (AI)": metrics_ai["gate_count"],
            "Time (AI)": metrics_ai["time_s"],
        }
    )

df = pd.DataFrame(results)
df
```

```text
Completed transpilation for Random
Completed transpilation for Clifford
Completed transpilation for QFT
Completed transpilation for BV
```

```text
Circuit  Depth 2Q (No AI)  Gate Count (No AI)  Time (No AI)  \
0    Random                37                 221      0.039347
1  Clifford                36                 232      0.036633
2       QFT               165                 924      0.077458
3        BV                65                 155      0.024993

   Depth 2Q (AI)  Gate Count (AI)  Time (AI)
0             24              181   0.773718
1             43              267   1.097431
2            130              913   3.660771
3             70              155   0.345522
```

Durchschnittlichi prozäntuali Reduzierig für jedi Metrik. Positivi sind Verbesserige, negativi sind Verschlechterige.

```python
# Average reduction from non-AI to AI transpilation as a percentage
avg_reduction_depth = (
    (df["Depth 2Q (No AI)"] - df["Depth 2Q (AI)"]).mean()
    / df["Depth 2Q (No AI)"].mean()
    * 100
)
avg_reduction_gates = (
    (df["Gate Count (No AI)"] - df["Gate Count (AI)"]).mean()
    / df["Gate Count (No AI)"].mean()
    * 100
)
avg_reduction_time = (
    (df["Time (No AI)"] - df["Time (AI)"]).mean()
    / df["Time (No AI)"].mean()
    * 100
)

print(f"Average reduction in depth: {avg_reduction_depth:.2f}%")
print(f"Average reduction in gate count: {avg_reduction_gates:.2f}%")
print(f"Average reduction in transpilation time: {avg_reduction_time:.2f}%")
```

```text
Average reduction in depth: 11.88%
Average reduction in gate count: 1.04%
Average reduction in transpilation time: -3193.95%
```

```python
fig, axs = plt.subplots(1, 3, figsize=(21, 6))
df.plot(
    x="Circuit",
    y=["Depth 2Q (No AI)", "Depth 2Q (AI)"],
    kind="bar",
    ax=axs[0],
)
axs[0].set_title("Circuit Depth Comparison")
axs[0].set_ylabel("Depth")
axs[0].set_xlabel("Circuit")
axs[0].tick_params(axis="x", rotation=45)
df.plot(
    x="Circuit",
    y=["Gate Count (No AI)", "Gate Count (AI)"],
    kind="bar",
    ax=axs[1],
)
axs[1].set_title("Gate Count Comparison")
axs[1].set_ylabel("Gate Count")
axs[1].set_xlabel("Circuit")
axs[1].tick_params(axis="x", rotation=45)
df.plot(x="Circuit", y=["Time (No AI)", "Time (AI)"], kind="bar", ax=axs[2])
axs[2].set_title("Time Comparison")
axs[2].set_ylabel("Time (seconds)")
axs[2].set_xlabel("Circuit")
axs[2].tick_params(axis="x", rotation=45)
fig.suptitle(
    "Benchmarking AI transpilation vs Non-AI transpilation for various circuits"
)

plt.tight_layout()
plt.show()
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/79b8d5d9-0f9d-42ca-9583-8bec17430014-0.avif)

D'Leistig vom KI-Transpiler variiert je no Art vo de z'optimierende Schaltig erheblich. I einzelne Fäll erreicht er bemarkenswärti Reduzierige vo de Schaltigstieffi und Gate-Aazahl im Vergliich zum Standard-Transpiler. Dää Verbesserige gönd aber oft mit ere erhebliche Erhöhig vo de Loufziit iher.

Für bestimmti Schaltigstype chan de KI-Transpiler e bizzli besseri Ergebnis bezüglich de Schaltigstieffi erziehle, aber ou zu ere Erhöhig vo de Gate-Aazahl und ere erhebliche Loufziitschtroof füehre. Dää Beobachtige lege noh, dass d'Vortel vom KI-Transpiler nöd bi allne Schaltigstype einheitlich sind. Stattdesse hängt siini Effektivität vo de spezifische Eigeschafte vo de Schaltig ab, was en für gwüssi Aawändigsfäll besser geignet macht als für anderi.

## Wänn sölled Benutzer KI-gstützti Transpilation wähle? {#when-should-users-choose-ai-powered-transpilation}

De KI-gstützt Transpiler i Qiskit glänzt i Szenarios, wo traditionelli Transpilationsmethode Schwiirigkeite hend, bsunders bi gross aaleite und komplexe Quanteschaltige. Für Schaltige mit Hunderte vo Qubits oder die, wo uf Hardware mit komplizierte Coupling-Maps abziehle, bietet de KI-Transpiler überlëgeni Optimierig bezüglich Schaltigstieffi, Gate-Aazahl und Loufziiteffizïänz. I Benchmarking-Teschts het er traditionelli Methode konsischtent übertroffe und düütlich flacheri Schaltige glieferet und Gate-Aazahle reduziert, was für d'Verbesserig vo de Leistig und d'Minderig vo Ruusche uf echter Quantehardware entscheidend isch.

Benutzer sölled KI-gstützti Transpilation i Betracht zieh, wänn sie mit:
- Grosse Schaltige schaffe, wo traditionelli Methode de Maassstab nöd effizient hanthabe chöi.
- Komplexe Hardware-Topologie, wo Gerät-konnektivität und Routing-Usefordrige uftrete.
- Leistigssensitivi Aawändige, wo d'Reduzierig vo de Schaltigstieffi und d'Verbesserig vo de Fidelität vo gröschter Bedütig sind.

# Teil III. Erkundig vo de KI-gstützte Permutationsnetzwärk-Synthese {#part-iii-explore-ai-powered-permutation-network-synthesis}

Permutationsnetzwärk sind grundlegend im Quantecomputing, bsunders für Systeme, wo dur iigschränkti Topologie beschränkt sind. Dää Netzwärk erliichtere Langschtreckèinteraktione, indem sie Qubits dynamisch tausche, zum All-to-All-Konnektivität uf Hardware mit begränzter Konnektivität nohzbauè. Sölchi Transformatione sind für d'Implementierig komplexer Quantealgorithme uf churzfrischtigi Gerät unerlässlich, wo Interaktione oft über nöchschti Nohbere uusegönd.

I däm Abschnitt hebe mir d'Synthese vo Permutationsnetzwärk als überzüügendi Aawändig für de KI-gstützt Transpiler i Qiskit füre. Bsunders nutzt de `AIPermutationSynthesis`-Pass KI-gstüürti Optimierig, zum effizïänti Schaltige für Qubit-Permutationsufgabe z'generiere. Im Gëgesatz dezue hend generischi Synthese-Aasätz oft Schwiirigkeite, Gate-Aazahl und Schaltigstieffi uuszbalanziere, bsunders i Szenarios mit dichtte Qubit-Interaktione oder bim Versuech, volli Konnektivität z'erreiche.

Mir wärde es Qiskit-Musterbiischpil durgöh, wo d'Synthese vo eme Permutationsnetzwärk zeigt, zum All-to-All-Konnektivität für e Satz vo Qubits z'erreiche. Mir wärde d'Leistig vo `AIPermutationSynthesis` mit de Standard-Synthesemethode i Qiskit vergliche. Das Biischpil wird zeige, wie de KI-Transpiler für geringeri Schaltigstieffi und Gate-Aazahl optimiert und siini Vorteil i praktische Quante-Workflows fürevöhebe. Zum de KI-Synthese-Pass z'aktiviere, verwände mir d'Funktion `generate_ai_pass_manager()` mit em Parameter `include_ai_synthesis` uf `True` gsetzt.

## Schritt 1: Klassischi Iigabe uf es Quanteproblem abilde {#step-1-map-classical-inputs-to-a-quantum-problem-2}

Zum es klassischs Permutationsproblem uf eme Quantecomputer darzustellè, fange mir mit de Definition vo de Struktur vo de Quanteschaltige aa. Für das Biischpil:

1. Quanteschaltig-Initialisierig:
   Mir weise 27 Qubits zue, zum zum Backend z'passe, wo mir verwände wärde, wo 27 Qubits het.

2. Permutatione aawände:
   Mir generiere zehn zufälligi Permutationsmuster (`pattern_1` bis `pattern_10`) under Verwendig vo eme feschte Seed für Reproduzierbarkeit. Jedes Permutationsmuster wird uf e separati Quanteschaltig aagwändet (`qc_1` bis `qc_10`).

3. Schaltigszerlëgig:
   Jedi Permutationsoperation wird i nativi Gate-Sets zerleit, wo mit de Ziil-Quantehardware kompatibel sind. Mir analysiere d'Tieffi und d'Aazahl vo de Zwei-Qubit-Gates (nöd-lokali Gates) für jedi zerleiti Schaltig.

D'Ergebnis gäbe Iblick i d'Komplexität vo de Darstellig klassischi Permutationsproblem uf eme Quantegerät und demonstriere d'Ressourceaaforderige für verschideni Permutationsmuster.

```python
# Parameters
width = 27
num_circuits = 10

# Set random seed
np.random.seed(seed)

# Generate random patterns and circuits
patterns = [
    np.random.permutation(width).tolist() for _ in range(num_circuits)
]
circuits = {
    f"qc_{i}": generate_permutation_circuit(width, pattern)
    for i, pattern in enumerate(patterns, start=1)
}

# Display one of the circuits
circuits["qc_1"].decompose(reps=3).draw(output="mpl", fold=-1)
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/76a3e847-0808-4413-bd0c-c760cd2df3f4-0.avif)

## Schritt 2: Problem für d'Usführig uf Quantehardware optimiere {#step-2-optimize-problem-for-quantum-hardware-execution-2}
I däm Schritt fahre mir mit de Optimierig under Verwendig vo de KI-Synthese-Passes fort.

Für d'KI-Synthese-Passes bruucht de `PassManager` nume d'Coupling-Map vom Backend. 'S isch aber wichtig z'beachte, dass nöd alli Coupling-Maps kompatibel sind; nume die, uf däne de `AIPermutationSynthesis`-Pass trainiert worde isch, wärde funkzioniere. Aktuell underschützt de `AIPermutationSynthesis`-Pass Blöck vo de Grössi 65, 33 und 27 Qubits. Für das Biischpil verwände mir e 27-Qubit-QPU.

Für Vergliich wärde mir d'Leistig vo de KI-Synthese gëge generischi Permutatione-Synthesemethode i Qiskit evaluiere, iischliesslich:

- `synth_permutation_depth_lnn_kms`: Dää Methode synthesiert e Permutationsschaltig für e lineari Nöchschti-Nohber-(LNN)-Architektur under Verwendig vom Kutin-, Moulton- und Smithline-(KMS)-Algorithmus. Sie garantiert e Schaltig mit ere Tieffi vo höchschtens $ n $ und ere Grössi vo höchschtens $ n(n-1)/2 $, wobei sowohl Tieffi als ou Grössi i Bezug uf SWAP-Gates gmësse wärde.

- `synth_permutation_basic`: Das isch e eifachi Implementierig, wo Permutationsschaltige synthesiert, ohni Iischränkige für Konnektivität oder Optimierig für spezifischi Architekture ufz'erlege. Sie dient als Basislinie für de Vergliich vo de Leistig mit fortgschrittnere Methode.

Jedi vo däne Methode representerrt e eigene Aasatz zur Synthese vo Permutationsnetzwärk und bietet e umfassends Benchmark gëge d'KI-gstützte Methode.

Wiitri Details zu Synthesemethode i Qiskit findsch i de [Qiskit-API-Dokumentation](https://docs.quantum.ibm.com/api/qiskit/synthesis).

Definier d'Coupling-Map, wo d'27-Qubit-QPU representerrt.

```python
coupling_map = [
    [1, 0],
    [2, 1],
    [3, 2],
    [3, 5],
    [4, 1],
    [6, 7],
    [7, 4],
    [7, 10],
    [8, 5],
    [8, 9],
    [8, 11],
    [11, 14],
    [12, 10],
    [12, 13],
    [12, 15],
    [13, 14],
    [16, 14],
    [17, 18],
    [18, 15],
    [18, 21],
    [19, 16],
    [19, 22],
    [20, 19],
    [21, 23],
    [23, 24],
    [25, 22],
    [25, 24],
    [26, 25],
]
CouplingMap(coupling_map).draw()
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/84dff2c2-a496-4828-bb8e-08d373816a36-0.avif)

Transpilier jedi vo de Permutationsschaltige under Verwendig vo de KI-Synthese-Passes und generische Synthesemethode.

```python
results = []
pm_no_ai_synth = generate_preset_pass_manager(
    coupling_map=cm,
    optimization_level=1,  # set to 1 since we are using the synthesis methods
)

# Transpile and analyze all circuits
for i, (qc_name, qc) in enumerate(circuits.items(), start=1):
    pattern = patterns[i - 1]  # Get the corresponding pattern

    qc_depth_lnn_kms = synth_permutation_depth_lnn_kms(pattern)
    qc_basic = synth_permutation_basic(pattern)

    # AI synthesis
    results.append(
        synth_transpile_with_metrics(
            qc.decompose(reps=3),
            pm_ai,
            qc_name,
            "AI",
        )
    )

    # Depth-LNN-KMS Method
    results.append(
        synth_transpile_with_metrics(
            qc_depth_lnn_kms.decompose(reps=3),
            pm_no_ai_synth,
            qc_name,
            "Depth-LNN-KMS",
        )
    )

    # Basic Method
    results.append(
        synth_transpile_with_metrics(
            qc_basic.decompose(reps=3),
            pm_no_ai_synth,
            qc_name,
            "Basic",
        )
    )

results_df = pd.DataFrame(results)
```

Zeichne d'Metrike (Tieffi, Gate-Aazahl, Ziit) für jedi Schaltig no de Transpilation uf.

```python
# Calculate averages for each metric
average_metrics = results_df.groupby("Method")[
    ["Depth (2Q)", "Gates", "Time (s)"]
].mean()
average_metrics = average_metrics.round(3)  # Round to two decimal places
print("\n=== Average Metrics ===")
print(average_metrics)

# Identify the best non-AI method based on least average depth
non_ai_methods = [
    method for method in results_df["Method"].unique() if method != "AI"
]
best_non_ai_method = average_metrics.loc[non_ai_methods][
    "Depth (2Q)"
].idxmin()
print(
    f"\nBest Non-AI Method (based on least average depth): {best_non_ai_method}"
)

# Compare AI to the best non-AI method
ai_metrics = average_metrics.loc["AI"]
best_non_ai_metrics = average_metrics.loc[best_non_ai_method]

comparison = {
    "Metric": ["Depth (2Q)", "Gates", "Time (s)"],
    "AI": [
        ai_metrics["Depth (2Q)"],
        ai_metrics["Gates"],
        ai_metrics["Time (s)"],
    ],
    best_non_ai_method: [
        best_non_ai_metrics["Depth (2Q)"],
        best_non_ai_metrics["Gates"],
        best_non_ai_metrics["Time (s)"],
    ],
    "Improvement (AI vs Best Non-AI)": [
        ai_metrics["Depth (2Q)"] - best_non_ai_metrics["Depth (2Q)"],
        ai_metrics["Gates"] - best_non_ai_metrics["Gates"],
        ai_metrics["Time (s)"] - best_non_ai_metrics["Time (s)"],
    ],
}

comparison_df = pd.DataFrame(comparison)
print("\n=== Comparison of AI vs Best Non-AI Method ===")
comparison_df
```

```text
=== Average Metrics ===
               Depth (2Q)  Gates  Time (s)
Method
AI                   23.9   82.8     0.248
Basic                29.8   91.0     0.012
Depth-LNN-KMS        70.8  531.6     0.017

Best Non-AI Method (based on least average depth): Basic

=== Comparison of AI vs Best Non-AI Method ===
```

```text
Metric      AI   Basic  Improvement (AI vs Best Non-AI)
0  Depth (2Q)  23.900  29.800                           -5.900
1       Gates  82.800  91.000                           -8.200
2    Time (s)   0.248   0.012                            0.236
```

D'Ergebnis demonstriere, dass de KI-Transpiler alli andere Qiskit-Synthesemethode für däne Satz zufälligi Permutationsschaltige übertrifft. Wichtigi Erkenntniss umfasse:

1. Tieffi: De KI-Transpiler erreicht d'niedrigscht durchschnittlichi Tieffi, was uf überlëgeni Optimierig vo Schaltingslayouts hiidütet.
2. Gate-Aazahl: Er reduziert d'Aazahl vo de Gates im Vergliich zu andere Methode erheblich und verbesseret d'Usführigs-Fidelität und -Effizïänz.
3. Transpilationsziit: Alli Methode löffe uf dere Skala sehr schnäll, was sie praktisch iisetzbar macht. De KI-Transpiler het aber e bemarkenswärti Loufziiterhöhig im Vergliich zu traditionelle Methode wëge de Komplexität vo de verwendete KI-Modell.

Dää Ergebnis etabliere de KI-Transpiler als de effektivschti Aasatz für däne Benchmark, bsunders für Tieffi- und Gate-Aazahl-Optimierig.

Stell d'Ergebnis dar, zum d'Leistig vo de KI-Synthese-Passes mit de generische Synthesemethode z'vergliche.

```python
methods = results_df["Method"].unique()

fig, axs = plt.subplots(1, 3, figsize=(18, 5))

# Pivot the DataFrame and reorder columns to ensure AI is first
pivot_depth = results_df.pivot(
    index="Pattern", columns="Method", values="Depth (2Q)"
)[["AI", "Depth-LNN-KMS", "Basic"]]
pivot_gates = results_df.pivot(
    index="Pattern", columns="Method", values="Gates"
)[["AI", "Depth-LNN-KMS", "Basic"]]
pivot_time = results_df.pivot(
    index="Pattern", columns="Method", values="Time (s)"
)[["AI", "Depth-LNN-KMS", "Basic"]]

pivot_depth.plot(kind="bar", ax=axs[0], legend=False)
axs[0].set_title("Circuit Depth Comparison")
axs[0].set_ylabel("Depth")
axs[0].set_xlabel("Pattern")
axs[0].tick_params(axis="x", rotation=45)
pivot_gates.plot(kind="bar", ax=axs[1], legend=False)
axs[1].set_title("2Q Gate Count Comparison")
axs[1].set_ylabel("Number of 2Q Gates")
axs[1].set_xlabel("Pattern")
axs[1].tick_params(axis="x", rotation=45)
pivot_time.plot(
    kind="bar", ax=axs[2], legend=True, title="Legend"
)  # Show legend on the last plot
axs[2].set_title("Time Comparison")
axs[2].set_ylabel("Time (seconds)")
axs[2].set_xlabel("Pattern")
axs[2].tick_params(axis="x", rotation=45)
fig.suptitle(
    "Benchmarking AI Synthesis Methods vs Non-AI Synthesis Methods For Random Permutations Circuits",
    fontsize=16,
    y=1,
)

plt.tight_layout()
plt.show()
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/a326f268-0115-442c-8563-968676b66670-0.avif)

Das Diagramm hebt d'individuellè Ergebnis für jedi Schaltig (`qc_1` bis `qc_10`) über verschideni Synthesemethode hinwëg füre:

Während dää Ergebnis d'Effektivität vom KI-Transpiler für Permutationsschaltige underschtriche, isch es wichtig, siini Iischränkige z'beachte. D'KI-Synthesemethode isch aktuell nume für bestimmti Coupling-Maps verfüegbar, was ihri breiteri Aawändbarkeit iischränke chan. Dää Iischränkig söll bi de Bewertig vo ihrere Verwendig i verschidene Szenarios berücksichtigt wärde.

Insgsamt zeigt de KI-Transpiler vielverspräch endi Verbesserige i de Tieffi- und Gate-Aazahl-Optimierig für dää spezifische Schaltige bi verglichbare Transpilationsziite.

## Schritt 3: Usführig mit Qiskit Primitives {#step-3-execute-using-qiskit-primitives-2}
Wil sich das Tutorial uf Transpilation konzentriert, wärde kei Experimänt uf em Quantegerät uusgfüert. S'Ziil isch es, d'Optimierige uus Schritt 2 z'nutze, zum e transpilierti Schaltig mit reduzierter Tieffi oder Gate-Aazahl z'übercho.

## Schritt 4: Nohbearbeitig und Rückgab vom Ergebnis im gwünschte klassische Format {#step-4-post-process-and-return-result-in-desired-classical-format-2}
Wil's kei Usführig für das Notebook git, git's kei Ergebnis zur Nohbearbeitig.

## Tutorial-Umfraag {#tutorial-survey}

Bitte mach bi dere churze Umfraag mit, zum Feedback zu däm Tutorial z'gëë. Diini Iisichte hälfed üs, üses Inhaltsaagebot und üsi Benutzererfahrig z'verbessere.

[Link zur Umfraag](https://your.feedback.ibm.com/jfe/form/SV_0igXMtMCQfApgDI)
