---
title: "Kompilierigsmethode für Hamiltonian-Simulationsschaltkreis"
sidebar_label: "Kompilierigsmethode für Hamiltonian-Simulationsschaltkreis"
description: "Das Tutorial git en verglychende Überblick über drüü Kompilierigsmethode i Qiskit für Hamiltonian-Simulationsworkloads."
notebook_path: "docs/tutorials/compilation-methods-for-hamiltonian-simulation-circuits.ipynb"
---
{/* doqumentation-source-hash: ff66bde1 */}

<OpenInLabBanner notebookPath="docs/tutorials/compilation-methods-for-hamiltonian-simulation-circuits.ipynb" />



Gschätzte QPU-Verbruuch: Kei Uusführig fand statt i dämm Tutorial, wil's sich uf de Transpilationsprozess konzentriert.

{/* cspell:ignore Rustiq, nshuffles, edgecolors, edgecolor, Hamlib, Benchpress, Brugière, Goubault, Martiel, Dubal, Lishman, Ivrii, fontweight, fontsize, textprops, wedgeprops, startangle, autopct */}
## Hintergrundinformatione {#background}

D'Kompilierig vo Quanteschaltkreis isch en wichtige Schritt im Quantecomputing-Workflow. Si umfasst d'Umwandlig vo emene hochstufige Quantealgorithmus i en physikalische Quanteschaltkreis, wo d'Beschränkige vo de Ziel-Quantehardware iinhautet. Effektivi Kompilierig cha d'Leistig vo Quantealgorithme erheblich verbessere, indem si d'Schaltkreistiifi, d'Gatteranzahl und d'Uusführigszyt reduziert. Dases Tutorial erforschet drüü verschiedenartigi Aasätz zur Quanteschaltkreiskompilierig i Qiskit und zeigt ihre Stärke und Aawändigsberiich anhand vo praktische Bispiil.

S'Ziel vo dämm Tutorial isch, dir z'zeige, wie du drüü Kompilierigsmethode i Qiskit aawände und bewärte chasch: de SABRE-Transpiler, de KI-gstützte Transpiler und s'Rustiq-Plugin. Du lernsch, wie du jedi Methode effektiv iisetze chasch und wie du ihri Leistig über verschiedeni Quanteschaltkreis hinweg benchmarkisch. Am End vo dämm Tutorial wirsch d'Fähigkeit ha, Kompilierungsstrategii je nach spezifische Optimierziil z'wähle und aapasse — zum Bispiil zum Reduziere vo de Schaltkreistiifi, Minimiere vo de Gatterzahl oder Verbessere vo de Luufzyt.

### Was du lernsch {#what-you-will-learn}
- **Wie du de Qiskit-Transpiler mit SABRE für Layout- und Routing-Optimierig bruuchsch.**
- **Wie du de KI-Transpiler für fortgschritteni, automatisierti Schaltkreisoptimierig nutze chasch.**
- **Wie du s'Rustiq-Plugin für Schaltkreis iisetze chasch, wo präzisi Synthese vo Operatione bruuche — bsunders bi Hamiltonian-Simulationsufgabe.**

Das Tutorial bruucht drüü Bispielschaltkreis nach em [Qiskit-Patterns](/guides/intro-to-patterns)-Workflow, um d'Leistig vo jedere Kompilierigsmethode z'illustriere. Am End vo dämm Tutorial wirsch gerüstet si, d'passendi Kompilierungsstrategie entsprechend dyne spezifische Aaforderige und Beschränkige z'wähle.

### Überblick über di Kompilierigsmethode {#compilation-methods-overview}

#### 1. **Qiskit-Transpiler mit SABRE** {#1-qiskit-transpiler-with-sabre}
Dr Qiskit-Transpiler bruucht de SABRE-Algorithmus (SWAP-based BidiREctional heuristic search) zum Optimiere vo Schaltkreislayout und -Routing. SABRE konzentriert sich uf s'Minimiere vo SWAP-Gattern und ihrem Iifluuss uf d'Schaltkreistiifi, wobii d'Hardware-Verbindigkeitsbeschränkige iighautet wärde. Desi Methode isch sehr vielsytig und geignet für allgemeini Schaltkreisoptimierig und git es Gleichgewicht zwüsche Leistig und Recheufwand. Um vo de nöischte Verbesseriige vo SABRE z'profitiere, wie i [\[1\]](https://arxiv.org/abs/2409.08368) detailliert, chasch d'Anzahl vo Versuech erhöhe (zum Bispiil `layout_trials=400, swap_trials=400`). Für dases Tutorial brüüche mir d'Standardwärt für d'Anzahl vo Versuech, um mit Qiskit's Standard-Transpiler z'vergliche. D'Vorteile und d'Parameterexploration vo SABRE wärde i emene separaate [Vertiefungs-Tutorial](/tutorials/transpilation-optimizations-with-sabre) behandlet.

#### 2. **KI-Transpiler** {#2-ai-transpiler}

Dr KI-gstützte Transpiler i Qiskit bruucht maschinells Lerne, um optimali Transpilationsstrategii vorherzusäge, indem er Muster i de Schaltkreisstruktur und d'Hardwarebeschränkige analysiert, um d'besti Abfolge vo Optimierungen für en bestimmte Iigab uuszuwähle. Desi Methode isch bsunders effektiv für grossmassstäbigi Quanteschaltkreis und bitet en hohe Grad vo Automatisierig und Aapässigkait a diverse Problemtypen. Zusätzlich zur allgemeine Schaltkreisoptimierig cha dr KI-Transpiler mit em `AIPauliNetworkSynthesis`-Pass bruucht wärde, wo uf Pauli-Netzwerkschaltkreis abzilt — Blöck bestehend uus H-, S-, SX-, CX-, RX-, RY- und RZ-Gattern — und en verstärkigslernebasierte Syntheseaasatz aawändet. Meh Informatione zum KI-Transpiler und syne Synthesestrategii findisch i [\[2\]](https://arxiv.org/abs/2405.13196) und [\[3\]](https://arxiv.org/abs/2503.14448).

#### 3. **Rustiq-Plugin**
S'Rustiq-Plugin füehrt fortgschritteni Synthesetechnike speziell für `PauliEvolutionGate`-Operatione ii, wo Pauli-Rotationen darstellend, wie si ghäufig i trotterisierten Dynamike bruucht wärde. Das Plugin isch wertvoll für Schaltkreis, wo Hamiltonian-Simulation implementiere, wie zumm Bispiil die, wo i de Quantenchemie und -physik bruucht wärde, wo präzisi Pauli-Rotationen entscheidend sind für s'effektivi Simuliere vo Problem-Hamiltonians. Rustiq bitet präzisi, tiifungsarmi Schaltkreissynthese für disi spezialisierten Operatione. Meh Details zur Implementation und Leistig vo Rustiq findisch i [\[4\]](https://arxiv.org/abs/2404.03280).

Dur s'vertiefte Erforsche vo dise Kompilierungsmethode rüstet dich dases Tutorial mit de Mittle uus, d'Leistig dyne Quanteschaltkreis z'verbessere — und ebnit dr Weg für effizientereri und praktischereri Quanteberechnige.

## Vorussetzige {#requirements}

Bevor du mit dämm Tutorial afasch, lueg, dass du Folgendes installiert hesch:
- Qiskit SDK v1.3 oder neuer, mit [Visualisierig](https://docs.quantum.ibm.com/api/qiskit/visualization)-Unterstützig
- Qiskit Runtime v0.28 oder neuer (`pip install qiskit-ibm-runtime`)
- Qiskit IBM Transpiler (`pip install qiskit-ibm-transpiler`)
- Qiskit AI Transpiler im lokale Modus (`pip install qiskit_ibm_ai_local_transpiler`)
- Networkx-Graphbibliothek (`pip install networkx`)

## Setup {#setup}

```python
# Added by doQumentation — installs packages not in the Binder environment
%pip install -q qiskit-ibm-transpiler
```

```python
from qiskit.circuit import QuantumCircuit
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit.circuit.library import (
    efficient_su2,
    PauliEvolutionGate,
)
from qiskit_ibm_transpiler import generate_ai_pass_manager
from qiskit.quantum_info import SparsePauliOp
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit.transpiler.passes.synthesis.high_level_synthesis import HLSConfig
from collections import Counter
from IPython.display import display
import time
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import json
import requests
import logging

# Suppress noisy loggers
logging.getLogger(
    "qiskit_ibm_transpiler.wrappers.ai_local_synthesis"
).setLevel(logging.ERROR)

seed = 42  # Seed for reproducibility
```

## Teil 1: Efficient-SU2-Schaltkreis {#part-1-efficient-su2-circuit}

### Schritt 1: Klassischi Iigabe uf es Quanteproblem abbilden {#step-1-map-classical-inputs-to-a-quantum-problem}

I dämm Abschnitt erforsche mir de `efficient_su2`-Schaltkreis, en hardware-effizienten Ansatz, wo ghäufig i variationelle Quantealgorithme (wie VQE) und Quantemaschinellernen-Ufgabe bruucht wird. Dr Schaltkreis besteit uus abwechselnde Schichte vo Einqubit-Rotationen und Verschränkigsgatter, wo i emene kreisförmige Muster aageordnet sind, und isch designt, um de Quantezustandsruum effektiv z'erforsche, wobii d'Tiifi handhabbar blibt.

Mir fange mit emm einzelne `efficient_su2`-Schaltkreis aa, um z'zeige, wie mer verschiedeni Kompilierungsmethode vergliche cha. Nach Teil 1 usdiine mir üseri Analyse uf en grösserere Satz vo Schaltkreise, was en umfassende Benchmark zur Bewärtig vo de Leistig vo verschiedene Kompilierungstechnike ermöglicht.

```python
qubit_size = list(range(10, 101, 10))
qc_su2_list = [
    efficient_su2(n, entanglement="circular", reps=1)
    .decompose()
    .copy(name=f"SU2_{n}")
    for n in qubit_size
]

# Draw the first circuit
qc_su2_list[0].draw(output="mpl")
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/f362cdac-94d8-4cc5-85f4-015c3d9eba3a-0.avif)

### Schritt 2: Problem für d'Quantehardware-Uusführig optimiere {#step-2-optimize-problem-for-quantum-hardware-execution}

Daser Schritt isch de Hauptfokus vo dämm Tutorial. Hie wend mir Quanteschaltkreis für d'effizient Uusführig uf echter Quantehardware optimiere. Üser primärs Ziel isch es, d'Schaltkreistiifi und d'Gatterzahl z'reduziere, was Schlüsselfaktore für d'Verbesserig vo de Uusführigstreue und d'Minderig vo Hardware-Rüsche sind.

- **SABRE-Transpiler**: Bruucht Qiskit's Standard-Transpiler mit em SABRE-Layout- und Routing-Algorithmus.
- **KI-Transpiler (lokale Modus)**: Dr Standard-KI-gstützte Transpiler mit lokaler Inferenz und dr Standard-Synthesestrategie.
- **Rustiq-Plugin**: En Transpiler-Plugin für tiifungsarmi Kompilierig, speziell uf Hamiltonian-Simulationsufgabe zugeschnitten.

S'Ziel vo dämm Schritt isch s'Vergliche vo de Ergebnis diser Methode uf Basis vo de transpilierten Schaltkreistiifi und Gatterzahl. En anderi wichtigi Metrik, wo mir berücksichtige, isch d'Transpilationsluufzyt. Dur s'Analysiere vo dise Metriken chöme mir d'relative Stärke vo jedere Methode bewärte und bestimme, weli d'effizientischte Schaltkreis für d'Uusführig uf dr gwählte Hardware produziert.

Hinwys: Für s'aaifangend SU2-Schaltkreisbispiil vergliche mir nur de SABRE-Transpiler mit em Standard-KI-Transpiler. Im nachfolgenden Benchmark mit Hamlib-Schaltkreise wärde mir aber alli drüü Transpilationsmethode vergliche.

```python
# QiskitRuntimeService.save_account(channel="ibm_quantum_platform", token="<YOUR-API-KEY>", overwrite=True, set_as_default=True)
service = QiskitRuntimeService(channel="ibm_quantum_platform")
backend = service.backend("ibm_torino")
print(f"Using backend: {backend}")
```

```text
qiskit_runtime_service._get_crn_from_instance_name:WARNING:2025-07-30 21:46:30,843: Multiple instances found. Using all matching instances.
```

```text
Using backend: <IBMBackend('ibm_torino')>
```

Qiskit-Transpiler mit SABRE:

```python
pm_sabre = generate_preset_pass_manager(
    optimization_level=3, backend=backend, seed_transpiler=seed
)
```

KI-Transpiler:

```python
# Standard AI transpiler pass manager, using the local mode
pm_ai = generate_ai_pass_manager(
    backend=backend, optimization_level=3, ai_optimization_level=3
)
```

Rustiq-Plugin:

```python
hls_config = HLSConfig(
    PauliEvolution=[
        (
            "rustiq",
            {
                "nshuffles": 400,
                "upto_phase": True,
                "fix_clifford": True,
                "preserve_order": False,
                "metric": "depth",
            },
        )
    ]
)
pm_rustiq = generate_preset_pass_manager(
    optimization_level=3,
    backend=backend,
    hls_config=hls_config,
    seed_transpiler=seed,
)
```

#### Transpiliere und Metriken erfasse {#transpile-and-capture-metrics}

Um d'Leistig vo de Kompilierigsmethode z'vergliche, definiere mir e Funktion, wo de Iigabeschaltkreis transpiliert und relevanti Metriken uf konsistenti Art und Wys erfasst. Dazu ghört d'gesamti Schaltkreistiifi, d'Gesamtgatterzahl und d'Transpilationsluufzyt.

Zusätzlich zu dise Standardmetriken erfasse mir au d'Zweiaubit-Gattertiifi, was e bsunders wichtigi Metrik für d'Bewärtig vo de Uusführig uf Quantehardware isch. Im Unterschied zur Gesamttiifi, wo alli Gatter umfasst, reflektiert d'Zweiaubit-Tiifi genauer d'tatsächlichi Uusführigsdauer uf dr Hardware. Das liegt daran, dass Zweiaubit-Gatter typischerwys de Zyt- und Fählerbudget i de meischte Quantegeräten dominiere. Drum isch s'Minimiere vo de Zweiaubit-Tiifi entscheidend für d'Verbesserig vo de Treue und d'Reduktion vo Dekohärenzeffekte während dr Uusführig.

Mir bruuche disi Funktion, um d'Leistig vo de verschiedene Kompilierigsmethode über mehreri Schaltkreis hinweg z'analysiere.

```python
def capture_transpilation_metrics(
    results, pass_manager, circuits, method_name
):
    """
    Capture transpilation metrics for a list of circuits and stores the results in a DataFrame.

    Args:
        results (pd.DataFrame): DataFrame to store the results.
        pass_manager: Pass manager used for transpilation.
        circuits (list): List of quantum circuits to transpile.
        method_name (str): Name of the transpilation method.

    Returns:
        list: List of transpiled circuits.
    """
    transpiled_circuits = []

    for i, qc in enumerate(circuits):
        # Transpile the circuit
        start_time = time.time()
        transpiled_qc = pass_manager.run(qc)
        end_time = time.time()

        # Needed for AI transpiler to be consistent with other methods
        transpiled_qc = transpiled_qc.decompose(gates_to_decompose=["swap"])

        # Collect metrics
        transpilation_time = end_time - start_time
        circuit_depth = transpiled_qc.depth(
            lambda x: x.operation.num_qubits == 2
        )
        circuit_size = transpiled_qc.size()

        # Append results to DataFrame
        results.loc[len(results)] = {
            "method": method_name,
            "qc_name": qc.name,
            "qc_index": i,
            "num_qubits": qc.num_qubits,
            "ops": transpiled_qc.count_ops(),
            "depth": circuit_depth,
            "size": circuit_size,
            "runtime": transpilation_time,
        }
        transpiled_circuits.append(transpiled_qc)
        print(
            f"Transpiled circuit index {i} ({qc.name}) in {transpilation_time:.2f} seconds with method {method_name}, "
            f"depth {circuit_depth}, and size {circuit_size}."
        )

    return transpiled_circuits
```

```python
results_su2 = pd.DataFrame(
    columns=[
        "method",
        "qc_name",
        "qc_index",
        "num_qubits",
        "ops",
        "depth",
        "size",
        "runtime",
    ]
)

tqc_sabre = capture_transpilation_metrics(
    results_su2, pm_sabre, qc_su2_list, "sabre"
)
tqc_ai = capture_transpilation_metrics(results_su2, pm_ai, qc_su2_list, "ai")
```

```text
Transpiled circuit index 0 (SU2_10) in 0.06 seconds with method sabre, depth 13, and size 167.
Transpiled circuit index 1 (SU2_20) in 0.24 seconds with method sabre, depth 20, and size 299.
Transpiled circuit index 2 (SU2_30) in 10.72 seconds with method sabre, depth 72, and size 627.
Transpiled circuit index 3 (SU2_40) in 16.16 seconds with method sabre, depth 40, and size 599.
Transpiled circuit index 4 (SU2_50) in 76.89 seconds with method sabre, depth 77, and size 855.
Transpiled circuit index 5 (SU2_60) in 86.12 seconds with method sabre, depth 60, and size 899.
Transpiled circuit index 6 (SU2_70) in 94.46 seconds with method sabre, depth 79, and size 1085.
Transpiled circuit index 7 (SU2_80) in 69.05 seconds with method sabre, depth 80, and size 1199.
Transpiled circuit index 8 (SU2_90) in 88.25 seconds with method sabre, depth 105, and size 1420.
Transpiled circuit index 9 (SU2_100) in 83.80 seconds with method sabre, depth 100, and size 1499.
Transpiled circuit index 0 (SU2_10) in 0.17 seconds with method ai, depth 10, and size 168.
Transpiled circuit index 1 (SU2_20) in 0.29 seconds with method ai, depth 20, and size 299.
Transpiled circuit index 2 (SU2_30) in 13.56 seconds with method ai, depth 36, and size 548.
Transpiled circuit index 3 (SU2_40) in 15.95 seconds with method ai, depth 40, and size 599.
Transpiled circuit index 4 (SU2_50) in 80.70 seconds with method ai, depth 54, and size 823.
Transpiled circuit index 5 (SU2_60) in 75.99 seconds with method ai, depth 60, and size 899.
Transpiled circuit index 6 (SU2_70) in 64.96 seconds with method ai, depth 74, and size 1087.
Transpiled circuit index 7 (SU2_80) in 68.25 seconds with method ai, depth 80, and size 1199.
Transpiled circuit index 8 (SU2_90) in 75.07 seconds with method ai, depth 90, and size 1404.
Transpiled circuit index 9 (SU2_100) in 63.97 seconds with method ai, depth 100, and size 1499.
```

D'transpilierte Ergebnis vo emem Schaltkreis azeige:

```python
print("Sabre transpilation")
display(tqc_sabre[0].draw("mpl", fold=-1, idle_wires=False))
print("AI transpilation")
display(tqc_ai[0].draw("mpl", fold=-1, idle_wires=False))
```

```text
Sabre transpilation
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/37924fc2-8fb6-451a-b8f9-cd79573f2384-1.avif)

```text
AI transpilation
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/37924fc2-8fb6-451a-b8f9-cd79573f2384-3.avif)

Ergebnistabelle:

```python
summary_su2 = (
    results_su2.groupby("method")[["depth", "size", "runtime"]]
    .mean()
    .round(2)
)
print(summary_su2)

results_su2
```

```text
depth   size  runtime
method
ai       56.4  852.5    45.89
sabre    64.6  864.9    52.57
```

```text
method  qc_name  qc_index  num_qubits                                ops  \
0   sabre   SU2_10         0          10     {'rz': 81, 'sx': 70, 'cz': 16}
1   sabre   SU2_20         1          20   {'rz': 160, 'sx': 119, 'cz': 20}
2   sabre   SU2_30         2          30   {'sx': 295, 'rz': 242, 'cz': 90}
3   sabre   SU2_40         3          40   {'rz': 320, 'sx': 239, 'cz': 40}
4   sabre   SU2_50         4          50   {'rz': 402, 'sx': 367, 'cz': 86}
5   sabre   SU2_60         5          60   {'rz': 480, 'sx': 359, 'cz': 60}
6   sabre   SU2_70         6          70   {'rz': 562, 'sx': 441, 'cz': 82}
7   sabre   SU2_80         7          80   {'rz': 640, 'sx': 479, 'cz': 80}
8   sabre   SU2_90         8          90  {'rz': 721, 'sx': 585, 'cz': 114}
9   sabre  SU2_100         9         100  {'rz': 800, 'sx': 599, 'cz': 100}
10     ai   SU2_10         0          10     {'rz': 81, 'sx': 71, 'cz': 16}
11     ai   SU2_20         1          20   {'rz': 160, 'sx': 119, 'cz': 20}
12     ai   SU2_30         2          30   {'sx': 243, 'rz': 242, 'cz': 63}
13     ai   SU2_40         3          40   {'rz': 320, 'sx': 239, 'cz': 40}
14     ai   SU2_50         4          50   {'rz': 403, 'sx': 346, 'cz': 74}
15     ai   SU2_60         5          60   {'rz': 480, 'sx': 359, 'cz': 60}
16     ai   SU2_70         6          70   {'rz': 563, 'sx': 442, 'cz': 82}
17     ai   SU2_80         7          80   {'rz': 640, 'sx': 479, 'cz': 80}
18     ai   SU2_90         8          90  {'rz': 721, 'sx': 575, 'cz': 108}
19     ai  SU2_100         9         100  {'rz': 800, 'sx': 599, 'cz': 100}

    depth  size    runtime
0      13   167   0.058845
1      20   299   0.238217
2      72   627  10.723922
3      40   599  16.159262
4      77   855  76.886604
5      60   899  86.118255
6      79  1085  94.458287
7      80  1199  69.048184
8     105  1420  88.254809
9     100  1499  83.795482
10     10   168   0.171532
11     20   299   0.291691
12     36   548  13.555931
13     40   599  15.952733
14     54   823  80.702141
15     60   899  75.993404
16     74  1087  64.960162
17     80  1199  68.253280
18     90  1404  75.072412
19    100  1499  63.967446
```

#### Ergebnisdiagramm {#results-graph}

Wie mir e Funktion zum konsistente Erfasse vo Metriken definiere, definiere mir au eini zum Visualisiere dere Metriken. Do stellen mir d'Zweiaubit-Tiifi, d'Gatterzahl und d'Luufzyt für jedi Kompilierigsmethode über d'Schaltkreis hinweg dar.

```python
def plot_transpilation_metrics(results, overall_title, x_axis="qc_index"):
    """
    Plots transpilation metrics (depth, size, runtime) for different transpilation methods.

    Parameters:
        results (DataFrame): Data containing columns ['num_qubits', 'method', 'depth', 'size', 'runtime']
        overall_title (str): The title of the overall figure.
        x_axis (str): The x-axis label, either 'num_qubits' or 'qc_index'.
    """

    fig, axs = plt.subplots(1, 3, figsize=(24, 6))
    metrics = ["depth", "size", "runtime"]
    titles = ["Circuit Depth", "Circuit Size", "Transpilation Runtime"]
    y_labels = ["Depth", "Size (Gate Count)", "Runtime (s)"]

    methods = results["method"].unique()
    colors = plt.colormaps["tab10"]
    markers = ["o", "^", "s", "D", "P", "*", "X", "v"]
    color_list = [colors(i % colors.N) for i in range(len(methods))]
    color_map = {method: color_list[i] for i, method in enumerate(methods)}
    marker_map = {
        method: markers[i % len(markers)] for i, method in enumerate(methods)
    }
    jitter_factor = 0.1  # Small x-axis jitter for visibility
    handles, labels = [], []  # Unique handles for legend

    # Plot each metric
    for i, metric in enumerate(metrics):
        for method in methods:
            method_data = results[results["method"] == method]

            # Introduce slight jitter to avoid exact overlap
            jitter = np.random.uniform(
                -jitter_factor, jitter_factor, len(method_data)
            )

            scatter = axs[i].scatter(
                method_data[x_axis] + jitter,
                method_data[metric],
                color=color_map[method],
                label=method,
                marker=marker_map[method],
                alpha=0.7,
                edgecolors="black",
                s=80,
            )

            if method not in labels:
                handles.append(scatter)
                labels.append(method)

        axs[i].set_title(titles[i])
        axs[i].set_xlabel(x_axis)
        axs[i].set_ylabel(y_labels[i])
        axs[i].grid(axis="y", linestyle="--", alpha=0.7)
        axs[i].tick_params(axis="x", rotation=45)
        axs[i].set_xticks(sorted(results[x_axis].unique()))

    fig.suptitle(overall_title, fontsize=16)
    fig.legend(
        handles=handles,
        labels=labels,
        loc="upper right",
        bbox_to_anchor=(1.05, 1),
    )

    plt.tight_layout()
    plt.show()
```

```python
plot_transpilation_metrics(
    results_su2, "Transpilation Metrics for SU2 Circuits", x_axis="num_qubits"
)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/7f7b502a-8ed6-45fa-a698-02977149e283-0.avif)

#### Analyse vo de SU2-Schaltkreis-Kompilierigsergebnis {#analysis-of-su2-circuit-compilation-results}

I dämm Experiment vergliche mir zwee Transpilationsmethode — Qiskit's SABRE-Transpiler und de KI-gstützte Transpiler — uf ememe Satz vo `efficient_su2`-Schaltkreise. Wil disi Schaltkreis keini `PauliEvolutionGate`-Operatione enthaute, wird s'Rustiq-Plugin i dämm Verglich nid iibezoge.

Im Durchschnitt schneidet dr KI-Transpiler bsser ab bi de Schaltkreistiifi, mit emere Verbesserig vo meh als 10% über de gesamte Bericht vo SU2-Schaltkreise. Bi de Gatterzahl (Schaltkreisgrösse) und dr Transpilationsluufzyt liefere beidi Methode insgesamt ähnlichi Ergebnis.

Wenn mer aber d'einzelne Datenpunkt betrachtet, wärde tiefer liegende Erkenntnisse sichtbar:
- Für d'meischte Qubitzahle produziere sowohl SABRE als au KI nahezu identischi Ergebnis, was daruf hindütet, dass beidi Methode in viele Fäll zu ähnlich effizienten Lösige konvergiere.
- Für bestimmti Schaltkreisgrösse — konkret bi 30, 50, 70 und 90 Qubits — findet dr KI-Transpiler deutlich flaacheri Schaltkreis als SABRE. Das zeigt, dass dr lernbasierti Aasatz vo KI in Fäll, wo d'SABRE-Heuristik nid s'Optimum findet, bessereri Layouts oder Routing-Pfad entdecke cha.

Das Verhaltne hebt en wichtige Erkenntnispunkt hervor:
> Obwohl SABRE und KI oft verglychbari Ergebnis liefere, cha dr KI-Transpiler gelegenlich viel besseri Lösige entdecke — bsunders i Bezug uf d'Tiifi — was zu erheblich verbesserter Leistig uf dr Hardware füehre cha.

## Teil 2: Hamiltonian-Simulationsschaltkreis {#part-2-hamiltonian-simulation-circuit}

### Schritt 1: Schaltkreis mit `PauliEvolutionGate` undersueche {#step-1-investigate-circuits-with-paulievolutiongate}

I dämm Abschnitt undersueme mir Quanteschaltkreis, wo mit `PauliEvolutionGate` konstruiert worde sind, was d'effizient Simulation vo Hamiltonians ermöglicht. Mir analysiere, wie verschiedeni Kompilierungsmethode disi Schaltkreis über verschiedeni Hamiltonians hinweg optimiere.

#### Hamiltonians im Benchmark {#hamiltonians-used-in-the-benchmark}

D'Hamiltonians im Benchmark beschriibe paarwisi Wechselwirkige zwüsche Qubits, inkl. Terme wie $ZZ$, $XX$ und $YY$. Disi Hamiltonians wärde ghäufig i de Quantechemie, dr kondensierte Materiephysik und dr Materialwüssenschaft bruucht, wo si Systeem vo wechselwürkende Teilchen modelliere.

Als Referenz chasch en breiteren Satz vo Hamiltonians i dämm Papier erforschen: [Efficient Hamiltonian Simulation on Noisy Quantum Devices](https://arxiv.org/pdf/2306.13126).

#### Benchmarkquälle: Hamlib und Benchpress {#benchmark-source-hamlib-and-benchpress}

D'Schaltkreis im Benchmark stamme uus em [Hamlib-Benchmark-Repository](https://github.com/SRI-International/QC-App-Oriented-Benchmarks/tree/master/hamlib), wo realistische Hamiltonian-Simulationsworkloads enthautet.

Disi Schaltkreis worde vo [Benchpress](https://github.com/Qiskit/benchpress) vorhin gebenchmarkt, ememe Open-Source-Framework zur Bewärtig vo de Quantetranspilationsleistig. Dur d'Verwändung vo dämm standardisierte Satz vo Schaltkreise chöme mir d'Effektivität vo verschiedene Kompilierungsstrategii bi repräsentativen Simulationsproblemin diräkt mittenander vergliche.

Hamiltonian-Simulation isch e grundlegendi Ufgab im Quantecomputing, mit Aawändigsberiich i Molekülsimulationen, Optimierungsproblem und der Quantenvielkörperphysik. S'Verständnis, wie verschiedeni Kompilierungsmethode disi Schaltkreis optimiere, cha Benutzer helfe, d'praktischi Uusführig vo solche Schaltkreise uf Nahzyt-Quantegeräten z'verbessere.

```python
# Obtain the Hamiltonian JSON from the benchpress repository
url = "https://raw.githubusercontent.com/Qiskit/benchpress/e7b29ef7be4cc0d70237b8fdc03edbd698908eff/benchpress/hamiltonian/hamlib/100_representative.json"
response = requests.get(url)
response.raise_for_status()  # Raise an error if download failed
ham_records = json.loads(response.text)
# Remove circuits that are too large for the backend
ham_records = [
    h for h in ham_records if h["ham_qubits"] <= backend.num_qubits
]
# Remove the circuits that are large to save transpilation time
ham_records = sorted(ham_records, key=lambda x: x["ham_terms"])[:35]

qc_ham_list = []
for h in ham_records:
    terms = h["ham_hamlib_hamiltonian_terms"]
    coeff = h["ham_hamlib_hamiltonian_coefficients"]
    num_qubits = h["ham_qubits"]
    name = h["ham_problem"]

    evo_gate = PauliEvolutionGate(SparsePauliOp(terms, coeff))

    qc_ham = QuantumCircuit(num_qubits)
    qc_ham.name = name

    qc_ham.append(evo_gate, range(num_qubits))
    qc_ham_list.append(qc_ham)
print(f"Number of Hamiltonian circuits: {len(qc_ham_list)}")

# Draw the first Hamiltonian circuit
qc_ham_list[0].draw("mpl", fold=-1)
```

```text
Number of Hamiltonian circuits: 35
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/66347c00-1607-4405-bb76-610690adf6b8-1.avif)

### Schritt 2: Problem für d'Quantehardware-Uusführig optimiere {#step-2-optimize-problem-for-quantum-hardware-execution-2}

Wie im vorherige Bispiil bruuche mir dasselbe Backend, um d'Konsistenz i üsere Verglych z'gwährleischte. Wil d'Pass-Manager (`pm_sabre`, `pm_ai` und `pm_rustiq`) scho initialisiert worde sind, chöme mir diräkt mit em Transpiliere vo de Hamiltonian-Schaltkreis mit jedere Methode fortfahre.

Daser Schritt konzentriert sich us druf, d'Transpilation durchzfüehre und d'resultierenden Schaltkreismetriken z'erfasse, inkl. Tiifi, Gatterzahl und Transpilationsluufzyt. Dur s'Analysiere vo dise Ergebnis wend mir d'Effizienz vo jedere Transpilationsmethode für dese Schaltkreistyp bestimme.

Transpiliere und Metriken erfasse:

```python
results_ham = pd.DataFrame(
    columns=[
        "method",
        "qc_name",
        "qc_index",
        "num_qubits",
        "ops",
        "depth",
        "size",
        "runtime",
    ]
)

tqc_sabre = capture_transpilation_metrics(
    results_ham, pm_sabre, qc_ham_list, "sabre"
)
tqc_ai = capture_transpilation_metrics(results_ham, pm_ai, qc_ham_list, "ai")
tqc_rustiq = capture_transpilation_metrics(
    results_ham, pm_rustiq, qc_ham_list, "rustiq"
)
```

```text
Transpiled circuit index 0 (all-vib-o3) in 0.02 seconds with method sabre, depth 6, and size 58.
Transpiled circuit index 1 (all-vib-c2h) in 1.10 seconds with method sabre, depth 2, and size 39.
Transpiled circuit index 2 (all-vib-bh) in 0.01 seconds with method sabre, depth 3, and size 30.
Transpiled circuit index 3 (all-vib-c2h) in 0.03 seconds with method sabre, depth 18, and size 115.
Transpiled circuit index 4 (graph-gnp_k-2) in 0.02 seconds with method sabre, depth 24, and size 129.
Transpiled circuit index 5 (all-vib-fccf) in 0.05 seconds with method sabre, depth 14, and size 134.
Transpiled circuit index 6 (all-vib-hno) in 8.39 seconds with method sabre, depth 6, and size 174.
Transpiled circuit index 7 (all-vib-bhf2) in 3.92 seconds with method sabre, depth 22, and size 220.
Transpiled circuit index 8 (LiH) in 0.03 seconds with method sabre, depth 67, and size 290.
Transpiled circuit index 9 (uf20-ham) in 0.04 seconds with method sabre, depth 50, and size 340.
Transpiled circuit index 10 (all-vib-fccf) in 0.62 seconds with method sabre, depth 30, and size 286.
Transpiled circuit index 11 (all-vib-fccf) in 0.04 seconds with method sabre, depth 67, and size 339.
Transpiled circuit index 12 (all-vib-ch2) in 0.04 seconds with method sabre, depth 87, and size 421.
Transpiled circuit index 13 (tfim) in 0.05 seconds with method sabre, depth 36, and size 222.
Transpiled circuit index 14 (all-vib-cyclo_propene) in 9.51 seconds with method sabre, depth 22, and size 345.
Transpiled circuit index 15 (graph-gnp_k-4) in 0.05 seconds with method sabre, depth 128, and size 704.
Transpiled circuit index 16 (all-vib-hc3h2cn) in 13.83 seconds with method sabre, depth 2, and size 242.
Transpiled circuit index 17 (TSP_Ncity-4) in 0.05 seconds with method sabre, depth 106, and size 609.
Transpiled circuit index 18 (tfim) in 0.29 seconds with method sabre, depth 73, and size 399.
Transpiled circuit index 19 (all-vib-h2co) in 21.97 seconds with method sabre, depth 30, and size 572.
Transpiled circuit index 20 (Be2) in 0.09 seconds with method sabre, depth 324, and size 1555.
Transpiled circuit index 21 (graph-complete_bipart) in 0.12 seconds with method sabre, depth 250, and size 1394.
Transpiled circuit index 22 (all-vib-f2) in 0.07 seconds with method sabre, depth 215, and size 1027.
Transpiled circuit index 23 (all-vib-cyclo_propene) in 41.22 seconds with method sabre, depth 30, and size 1144.
Transpiled circuit index 24 (TSP_Ncity-5) in 1.89 seconds with method sabre, depth 175, and size 1933.
Transpiled circuit index 25 (H2) in 0.32 seconds with method sabre, depth 1237, and size 5502.
Transpiled circuit index 26 (uuf100-ham) in 0.20 seconds with method sabre, depth 385, and size 4303.
Transpiled circuit index 27 (ham-graph-gnp_k-5) in 0.20 seconds with method sabre, depth 311, and size 3654.
Transpiled circuit index 28 (tfim) in 0.15 seconds with method sabre, depth 276, and size 3213.
Transpiled circuit index 29 (uuf100-ham) in 0.21 seconds with method sabre, depth 520, and size 5250.
Transpiled circuit index 30 (flat100-ham) in 0.15 seconds with method sabre, depth 131, and size 3157.
Transpiled circuit index 31 (uf100-ham) in 0.24 seconds with method sabre, depth 624, and size 7378.
Transpiled circuit index 32 (OH) in 0.88 seconds with method sabre, depth 2175, and size 9808.
Transpiled circuit index 33 (HF) in 0.66 seconds with method sabre, depth 2206, and size 9417.
Transpiled circuit index 34 (BH) in 0.89 seconds with method sabre, depth 2177, and size 9802.
Transpiled circuit index 0 (all-vib-o3) in 0.02 seconds with method ai, depth 6, and size 58.
Transpiled circuit index 1 (all-vib-c2h) in 1.11 seconds with method ai, depth 2, and size 39.
Transpiled circuit index 2 (all-vib-bh) in 0.01 seconds with method ai, depth 3, and size 30.
Transpiled circuit index 3 (all-vib-c2h) in 0.11 seconds with method ai, depth 18, and size 94.
Transpiled circuit index 4 (graph-gnp_k-2) in 0.11 seconds with method ai, depth 22, and size 129.
Transpiled circuit index 5 (all-vib-fccf) in 0.06 seconds with method ai, depth 22, and size 177.
Transpiled circuit index 6 (all-vib-hno) in 8.62 seconds with method ai, depth 10, and size 198.
Transpiled circuit index 7 (all-vib-bhf2) in 3.71 seconds with method ai, depth 18, and size 195.
Transpiled circuit index 8 (LiH) in 0.19 seconds with method ai, depth 62, and size 267.
Transpiled circuit index 9 (uf20-ham) in 0.22 seconds with method ai, depth 47, and size 321.
Transpiled circuit index 10 (all-vib-fccf) in 0.71 seconds with method ai, depth 38, and size 369.
Transpiled circuit index 11 (all-vib-fccf) in 0.24 seconds with method ai, depth 65, and size 315.
Transpiled circuit index 12 (all-vib-ch2) in 0.24 seconds with method ai, depth 91, and size 430.
Transpiled circuit index 13 (tfim) in 0.15 seconds with method ai, depth 12, and size 251.
Transpiled circuit index 14 (all-vib-cyclo_propene) in 8.50 seconds with method ai, depth 18, and size 311.
Transpiled circuit index 15 (graph-gnp_k-4) in 0.25 seconds with method ai, depth 117, and size 659.
Transpiled circuit index 16 (all-vib-hc3h2cn) in 16.11 seconds with method ai, depth 2, and size 242.
Transpiled circuit index 17 (TSP_Ncity-4) in 0.39 seconds with method ai, depth 98, and size 564.
Transpiled circuit index 18 (tfim) in 0.38 seconds with method ai, depth 23, and size 437.
Transpiled circuit index 19 (all-vib-h2co) in 24.97 seconds with method ai, depth 38, and size 707.
Transpiled circuit index 20 (Be2) in 1.07 seconds with method ai, depth 293, and size 1392.
Transpiled circuit index 21 (graph-complete_bipart) in 0.61 seconds with method ai, depth 229, and size 1437.
Transpiled circuit index 22 (all-vib-f2) in 0.57 seconds with method ai, depth 178, and size 964.
Transpiled circuit index 23 (all-vib-cyclo_propene) in 50.89 seconds with method ai, depth 34, and size 1425.
Transpiled circuit index 24 (TSP_Ncity-5) in 1.61 seconds with method ai, depth 171, and size 2020.
Transpiled circuit index 25 (H2) in 6.39 seconds with method ai, depth 1148, and size 5208.
Transpiled circuit index 26 (uuf100-ham) in 3.97 seconds with method ai, depth 376, and size 5048.
Transpiled circuit index 27 (ham-graph-gnp_k-5) in 3.54 seconds with method ai, depth 357, and size 4451.
Transpiled circuit index 28 (tfim) in 1.72 seconds with method ai, depth 216, and size 3026.
Transpiled circuit index 29 (uuf100-ham) in 4.45 seconds with method ai, depth 426, and size 5399.
Transpiled circuit index 30 (flat100-ham) in 7.02 seconds with method ai, depth 86, and size 3108.
Transpiled circuit index 31 (uf100-ham) in 12.85 seconds with method ai, depth 623, and size 8354.
Transpiled circuit index 32 (OH) in 15.19 seconds with method ai, depth 2084, and size 9543.
Transpiled circuit index 33 (HF) in 17.51 seconds with method ai, depth 2063, and size 9446.
Transpiled circuit index 34 (BH) in 15.33 seconds with method ai, depth 2094, and size 9730.
Transpiled circuit index 0 (all-vib-o3) in 0.02 seconds with method rustiq, depth 13, and size 83.
Transpiled circuit index 1 (all-vib-c2h) in 1.11 seconds with method rustiq, depth 2, and size 39.
Transpiled circuit index 2 (all-vib-bh) in 0.01 seconds with method rustiq, depth 3, and size 30.
Transpiled circuit index 3 (all-vib-c2h) in 0.01 seconds with method rustiq, depth 13, and size 79.
Transpiled circuit index 4 (graph-gnp_k-2) in 0.02 seconds with method rustiq, depth 31, and size 131.
Transpiled circuit index 5 (all-vib-fccf) in 0.04 seconds with method rustiq, depth 50, and size 306.
Transpiled circuit index 6 (all-vib-hno) in 14.03 seconds with method rustiq, depth 22, and size 276.
Transpiled circuit index 7 (all-vib-bhf2) in 3.15 seconds with method rustiq, depth 13, and size 155.
Transpiled circuit index 8 (LiH) in 0.03 seconds with method rustiq, depth 54, and size 270.
Transpiled circuit index 9 (uf20-ham) in 0.04 seconds with method rustiq, depth 65, and size 398.
Transpiled circuit index 10 (all-vib-fccf) in 0.16 seconds with method rustiq, depth 41, and size 516.
Transpiled circuit index 11 (all-vib-fccf) in 0.02 seconds with method rustiq, depth 34, and size 189.
Transpiled circuit index 12 (all-vib-ch2) in 0.03 seconds with method rustiq, depth 49, and size 240.
Transpiled circuit index 13 (tfim) in 0.05 seconds with method rustiq, depth 20, and size 366.
Transpiled circuit index 14 (all-vib-cyclo_propene) in 9.08 seconds with method rustiq, depth 16, and size 277.
Transpiled circuit index 15 (graph-gnp_k-4) in 0.04 seconds with method rustiq, depth 116, and size 612.
Transpiled circuit index 16 (all-vib-hc3h2cn) in 13.89 seconds with method rustiq, depth 2, and size 257.
Transpiled circuit index 17 (TSP_Ncity-4) in 0.05 seconds with method rustiq, depth 133, and size 737.
Transpiled circuit index 18 (tfim) in 0.11 seconds with method rustiq, depth 25, and size 680.
Transpiled circuit index 19 (all-vib-h2co) in 27.19 seconds with method rustiq, depth 66, and size 983.
Transpiled circuit index 20 (Be2) in 0.07 seconds with method rustiq, depth 215, and size 1030.
Transpiled circuit index 21 (graph-complete_bipart) in 0.14 seconds with method rustiq, depth 328, and size 1918.
Transpiled circuit index 22 (all-vib-f2) in 0.05 seconds with method rustiq, depth 114, and size 692.
Transpiled circuit index 23 (all-vib-cyclo_propene) in 62.25 seconds with method rustiq, depth 74, and size 2348.
Transpiled circuit index 24 (TSP_Ncity-5) in 0.20 seconds with method rustiq, depth 436, and size 3605.
Transpiled circuit index 25 (H2) in 0.21 seconds with method rustiq, depth 643, and size 3476.
Transpiled circuit index 26 (uuf100-ham) in 0.24 seconds with method rustiq, depth 678, and size 6120.
Transpiled circuit index 27 (ham-graph-gnp_k-5) in 0.22 seconds with method rustiq, depth 588, and size 5241.
Transpiled circuit index 28 (tfim) in 0.34 seconds with method rustiq, depth 340, and size 5901.
Transpiled circuit index 29 (uuf100-ham) in 0.33 seconds with method rustiq, depth 881, and size 7667.
Transpiled circuit index 30 (flat100-ham) in 0.31 seconds with method rustiq, depth 279, and size 4910.
Transpiled circuit index 31 (uf100-ham) in 0.38 seconds with method rustiq, depth 1138, and size 10607.
Transpiled circuit index 32 (OH) in 0.38 seconds with method rustiq, depth 1148, and size 6512.
Transpiled circuit index 33 (HF) in 0.37 seconds with method rustiq, depth 1090, and size 6256.
Transpiled circuit index 34 (BH) in 0.37 seconds with method rustiq, depth 1148, and size 6501.
```

Ergebnistabelle (ohni Visualisierig, wil d'Uusgabeschaltkreis sehr gross sind):

```python
summary_ham = (
    results_ham.groupby("method")[["depth", "size", "runtime"]]
    .mean()
    .round(2)
)
print(summary_ham)

results_ham
```

```text
depth     size  runtime
method
ai      316.86  2181.26     5.97
rustiq  281.94  2268.80     3.86
sabre   337.97  2120.14     3.07
```

```text
method        qc_name  qc_index  num_qubits  \
0     sabre     all-vib-o3         0           4
1     sabre    all-vib-c2h         1           4
2     sabre     all-vib-bh         2           2
3     sabre    all-vib-c2h         3           3
4     sabre  graph-gnp_k-2         4           4
..      ...            ...       ...         ...
100  rustiq    flat100-ham        30          90
101  rustiq      uf100-ham        31          46
102  rustiq             OH        32          10
103  rustiq             HF        33          10
104  rustiq             BH        34          10

                                               ops  depth   size   runtime
0                    {'rz': 28, 'sx': 24, 'cz': 6}      6     58  0.016597
1            {'rz': 17, 'sx': 16, 'cz': 4, 'x': 2}      2     39  1.102089
2                    {'sx': 14, 'rz': 13, 'cz': 3}      3     30  0.011042
3           {'sx': 46, 'rz': 45, 'cz': 18, 'x': 6}     18    115  0.025816
4           {'sx': 49, 'rz': 47, 'cz': 24, 'x': 9}     24    129  0.023077
..                                             ...    ...    ...       ...
100    {'sx': 2709, 'cz': 1379, 'rz': 817, 'x': 5}    279   4910  0.309448
101   {'sx': 6180, 'cz': 3120, 'rz': 1303, 'x': 4}   1138  10607  0.380977
102  {'sx': 3330, 'cz': 1704, 'rz': 1455, 'x': 23}   1148   6512  0.383564
103  {'sx': 3213, 'cz': 1620, 'rz': 1406, 'x': 17}   1090   6256  0.368578
104  {'sx': 3331, 'cz': 1704, 'rz': 1447, 'x': 19}   1148   6501  0.374822

[105 rows x 8 columns]
```

Leistig nach Schaltkreisindex visualisiere:

```python
plot_transpilation_metrics(
    results_ham, "Transpilation Metrics for Hamiltonian Circuits"
)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/4c6b810d-a4cf-4de3-aae6-c6c1cdd83d8f-0.avif)

De Prozentsatz vo de Schaltkreis visualisiere, für wel jedi Methode am bescht abgschnitte het.

```python
def analyze_and_plot_best_methods(results, metric):
    """
    Analyze the best-performing methods for a given metric and plot a pie chart.

    Parameters:
        results (DataFrame): The input DataFrame containing method performance data.
        metric (str): The metric to evaluate ("depth" or "size").
    """
    method_counts = Counter()
    for qc_idx, group in results.groupby("qc_index"):
        min_value = group[metric].min()

        # Find all methods that achieved this minimum value
        best_methods = group[group[metric] == min_value]["method"]
        # Update counts for all best methods (handling ties)
        method_counts.update(best_methods)
    best_method_counts = dict(
        sorted(method_counts.items(), key=lambda x: x[1], reverse=True)
    )

    # Print summary
    print(f"Best-performing methods based on {metric}:")
    for method, count in best_method_counts.items():
        print(f"    {method}: {count} circuit(s)")

    # Plot pie chart
    num_methods = len(best_method_counts)
    colors = plt.cm.viridis_r(range(0, 256, 256 // num_methods))
    plt.figure(figsize=(5, 5))
    plt.pie(
        best_method_counts.values(),
        labels=best_method_counts.keys(),
        autopct="%1.1f%%",
        startangle=140,
        wedgeprops={"edgecolor": "black"},
        textprops={"fontsize": 10},
        colors=colors,
    )
    plt.title(
        f"Percentage of Circuits Method Performed Best for {metric.capitalize()}",
        fontsize=12,
        fontweight="bold",
    )
    plt.show()

analyze_and_plot_best_methods(results_ham, "depth")
analyze_and_plot_best_methods(results_ham, "size")
```

```text
Best-performing methods based on depth:
    ai: 16 circuit(s)
    rustiq: 16 circuit(s)
    sabre: 10 circuit(s)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/01b4644e-ac91-483c-944b-924f8b41718d-1.avif)

```text
Best-performing methods based on size:
    sabre: 18 circuit(s)
    rustiq: 14 circuit(s)
    ai: 10 circuit(s)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/01b4644e-ac91-483c-944b-924f8b41718d-3.avif)

#### Analyse vo de Hamiltonian-Schaltkreis-Kompilierigsergebnis {#analysis-of-hamiltonian-circuit-compilation-results}

I dämm Abschnitt bewärte mir d'Leistig vo drüü Transpilationsmethode — SABRE, dr KI-gstützte Transpiler und Rustiq — uf Quanteschaltkreise, wo mit `PauliEvolutionGate` konstruiert worde sind und ghäufig i Hamiltonian-Simulationsufgabe bruucht wärde.

Rustiq het im Durchschnitt am beschte abgschnitten i Bezug uf d'Schaltkreistiifi** und erreicht e rund 20% niedrigeri Tiifi als SABRE. Das isch erwartungsgemäss, wil Rustiq speziell designt isch zum Synthesiere vo `PauliEvolutionGate`-Operatione mit optimierte, tiifungsarme Dekompositionsstrategii. Zudem zeigt s'Tiifi-Diagramm, dass Rustiq, wenn d'Schaltkreis a Grösse und Komplexität zunehme, am effektivsten skaliert und deutlich niedrigeri Tiifi als KI und SABRE uf grössere Schaltkreis beibehaut.

Dr KI-Transpiler zeigt e starki und konsistenti Leistig bi dr Schaltkreistiifi und schneidet konsistent bsser als SABRE über d'meischte Schaltkreis hinweg ab. Er weist aber au d'höchste Luufzyt uf, bsunders bi grössere Schaltkreise, was sini Praktikabilität bi zeitkritische Workloads beschränke cha. Sini Luufzytskalierig blibt e Schlüsselbeschränkig, obwohl er solidi Verbesserungen i de Tiifi bitet.

SABRE, obwohl s'd'höchste durchschnittlichi Tiifi produziert, erreicht d'niedrigscht durchschnittlichi Gatterzahl, knapp gefolgt vom KI-Transpiler. Das entspricht em Design vo SABREs Heuristik, wo direkt uf s'Minimiere vo de Gatterzahl abzilt. Rustiq, trotz sinere Stärke bim Reduziere vo de Tiifi, het d'höchste durchschnittlichi Gatterzahl — e Tradeoff, wo mer i Aawändigsberiich, wo d'Schaltkreisgrösse wichtiger isch als d'Schaltkreisdauer, beachte söll.

### Zusammefassig {#summary}

Obwohl dr KI-Transpiler im Algemeinen bessereri Ergebnis als SABRE liefert — bsunders bi de Schaltkreistiifi — söll die Erkenntniss nid eifach «bruuch immer de KI-Transpiler» bedeute. Es git wichtigi Nuancen z'beachte:

- **KI-Transpiler** isch typischerwys zuverlässig und liefert tiifenoptimierti Schaltkreis, het aber Kompromiss bi de Luufzyt und weitere Beschränkige, wie unterstützti Kupplungsmaps und Synthesefähigkeite. Disi sind detailliert i dr [Qiskit-Transpiler-Service-Dokumentation](/guides/qiskit-transpiler-service) beschriibe.

- I bestimmte Fäll — bsunders mit sehr grossen oder hardwarespezifische Schaltkreise — cha dr KI-Transpiler nid so effektiv si. I dene Fäll blibt dr Standard-SABRE-Transpiler usserorentlich zuverlässig und cha dur s'Aapasssse vo syne Parameter wiiter optimiert wärde (lueg s'[SABRE-Optimierigs-Tutorial](/tutorials/transpilation-optimizations-with-sabre)).

- Es isch au wichtig, d'Schaltkreisstruktur bi dr Wahl vo de Methode z'berücksichtige. Zum Bispiil isch `rustiq` speziell für Schaltkreis mit `PauliEvolutionGate` entwicklet und liefert oft d'besti Leistig für Hamiltonian-Simulationsprobleme.

**Empfehlig:**
> Es git kei Einheitsstrategie für d'Transpilation. D'Benutzer wärde ermutigt, d'Struktur vo ihrem Schaltkreis z'verstah und mehreri Transpilationsmethode z'teste — inkl. KI, SABRE und spezialisierti Tools wie Rustiq — um d'effizientischti Lösig für ihr spezifisches Problem und ihri Hardwarebeschränkige z'finde.

### Schritt 3: Mit Qiskit-Primitiven uusfüehre {#step-3-execute-using-qiskit-primitives}

Wil sich dases Tutorial uf d'Transpilation konzentriert, wärde keini Experiment uf emem Quantegerät uusgfüehrt. S'Ziel isch, d'Optimierungen uus Schritt 2 z'nutze, um en transpilierten Schaltkreis mit reduzierter Tiifi und Gatterzahl z'erhalte.

### Schritt 4: Nachbearbeite und Ergebnis im gwünschte klassische Format zrückgä {#step-4-post-process-and-return-result-in-desired-classical-format}

Wil für dases Notebook kei Uusführig stattfindet, git's keini Ergebnis zum Nachbearbeite.

## Referenze {#references}

[1] "LightSABRE: A Lightweight and Enhanced SABRE Algorithm". H. Zou, M. Treinish, K. Hartman, A. Ivrii, J. Lishman et al. https://arxiv.org/abs/2409.08368

[2] "Practical and efficient quantum circuit synthesis and transpiling with Reinforcement Learning". D. Kremer, V. Villar, H. Paik, I. Duran, I. Faro, J. Cruz-Benito et al. https://arxiv.org/abs/2405.13196

[3] "Pauli Network Circuit Synthesis with Reinforcement Learning". A. Dubal,  D. Kremer, S. Martiel, V. Villar, D. Wang, J. Cruz-Benito et al. https://arxiv.org/abs/2503.14448

[4] "Faster and shorter synthesis of Hamiltonian simulation circuits". T. Goubault de Brugière, S. Martiel et al. https://arxiv.org/abs/2404.03280
