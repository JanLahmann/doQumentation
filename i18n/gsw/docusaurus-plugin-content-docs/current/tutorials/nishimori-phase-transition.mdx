---
title: "Nishimori Phasenübergang"
sidebar_label: "Nishimori Phasenübergang"
description: "Das Tutorial zeigt, wiä mer än Nishimori Phasenübergang uf emä IBM Quanteprozässor dürefüert."
notebook_path: "docs/tutorials/nishimori-phase-transition.ipynb"
---

<OpenInLabBanner notebookPath="docs/tutorials/nishimori-phase-transition.ipynb" />



*Bruuchtziit: Öppe 3 Minutä uf emä Heron r2 Prozässor (ACHTUNG: Das isch numä Schätzig. Dini Loufziit cha andersch sii.)*
## Hintergrund {#background}
Das Tutorial zeigt, wiä mer än Nishimori Phasenübergang uf emä IBM&reg; Quanteprozässor dürefüert. Das Experimänt isch ursprünglich beschribä wordä i [*Realizing the Nishimori transition across the error threshold for constant-depth quantum circuits*](https://arxiv.org/abs/2309.02863).

Dr Nishimori Phasenübergang beschribt dä Übergang zwüschä churz- und langstreckeordnätä Phasä im Zuefalls-Bindig-Ising-Modäll. Uf emä Quantecomputer zeigt sich di langstreckeordnät Phase als än Zustand, wo d'Qubits übär s'ganzä Grät verschränkt sind. Derä hochgradig verschränktä Zustand wird mitäm *generation of entanglement by measurement* (GEM) Protokoll ufbout. Durch s'Bruchä vo Messigä innärhalb vom Schaltkreis cha s'GEM-Protokoll Qubits übär s'ganzä Grät verschränkä mit Schaltkreisä vo numä konstantä Tüüfi. Hiä bruchä mir di Implementierig vom GEM-Protokoll usäm [GEM Suite](https://github.com/qiskit-community/gem-suite) Software-Paket.
## Vorussetzigä {#requirements}
Bevors mit däm Tutorial afangsch, lueg dass de das installiert hesch:

- Qiskit SDK v1.0 oder nöier, mit [Visualisierig](https://docs.quantum.ibm.com/api/qiskit/visualization) Ungerstützig
- Qiskit Runtime v0.22 oder nöier ( `pip install qiskit-ibm-runtime` )
- GEM Suite ( `pip install gem-suite` )
## Iirichtig {#setup}

```python
# Added by doQumentation — installs packages not in the Binder environment
%pip install -q gem-suite
```

```python
import matplotlib.pyplot as plt

from collections import defaultdict

from qiskit_ibm_runtime import QiskitRuntimeService

from qiskit.transpiler import generate_preset_pass_manager

from gem_suite import PlaquetteLattice
from gem_suite.experiments import GemExperiment
```

## Schritt 1: Klassischi Iigabä uf es Quanteproblem abbildä {#step-1-map-classical-inputs-to-a-quantum-problem}

S'GEM-Protokoll schaffet uf emä Quanteprozässor mit Qubit-Konnektivität, wo durch äs Gittär beschribä wird. Di hütigä IBM Quanteprozässorä bruchä s' [Heavy-Hex-Gittär](https://www.ibm.com/quantum/blog/heavy-hex-lattice). D'Qubits vom Prozässor wärdä i *Plaquettä* iigteilts, nach welem Iiheitszellä vom Gittär si liggä. Wiil äs Qubit i meh als einärä Iiheitszellä vorchoo cha, sind d'Plaquettä nöd disjunkt. Ufäm Heavy-Hex-Gittär het äni Plaquette 12 Qubits. D'Plaquettä sälber bildä ou äs Gittär, wo zwei Plaquettä verbundä sind, wänn si irgendwelchi Qubits teilä. Ufäm Heavy-Hex-Gittär teilä benochbrati Plaquettä 3 Qubits.

Imä GEM Suite Software-Paket isch di Grundklass für d'Implementierig vom GEM-Protokoll `PlaquetteLattice`, wo s'Gittär vo dä Plaquettä darstellt (wo andersch isch als s'Heavy-Hex-Gittär). Ä `PlaquetteLattice` cha usärä Qubit Coupling Map initialisiert wärdä. Momäntä wärdä numä Heavy-Hex Coupling Maps ungerstützt.

Di nöchscht Code-Zellä initialisiert äs Plaquette-Gittär usärä Coupling Map vonäm IBM Quanteprozässor. S'Plaquette-Gittär umfasst nöd immer di ganzi Hardware. Zum Bispil het `ibm_torino` 133 Qubits total, aber s'gröschti Plaquette-Gittär, wo ufs Grät passt, brucht numä 125 devo und umfasst total 18 Plaquettä. Ähnlichs cha mer ou bi IBM Quantum&reg; Grätä mit verschidänä Qubit-Azahlä beobachtä.

```python
# QiskitRuntimeService.save_account(channel="ibm_quantum", token="<YOUR_API_KEYN>", overwrite=True, set_as_default=True)
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=127
)
plaquette_lattice = PlaquetteLattice.from_coupling_map(backend.coupling_map)

print(f"Number of qubits in backend: {backend.num_qubits}")
print(
    f"Number of qubits in plaquette lattice: {len(list(plaquette_lattice.qubits()))}"
)
print(f"Number of plaquettes: {len(list(plaquette_lattice.plaquettes()))}")
```

```text
Number of qubits in backend: 133
Number of qubits in plaquette lattice: 125
Number of plaquettes: 18
```

Du chasch s'Plaquette-Gittär visualisierä, indäm äs Diagramm vo sinärä Graph-Darstellig generiersch. Imä Diagramm wärdä d'Plaquettä als bezeichneti Sächseckä dargestellt, und zwei Plaquettä sind durch äni Kantä verbundä, wänn si Qubits teilä.

```python
plaquette_lattice.draw_plaquettes()
```

![Output of the previous code cell](/docs/images/tutorials/nishimori-phase-transition/extracted-outputs/625882a4-faeb-4d96-b441-c989f43c4dea-0.avif)

Du chasch Informatione über einzelni Plaquettä abfragä, wiä zum Bispil d'Qubits wo si beinhaltet, mitärä `plaquettes` Methodä.

```python
# Get a list of the plaquettes
plaquettes = list(plaquette_lattice.plaquettes())
# Display information about plaquette 0
plaquettes[0]
```

```text
PyPlaquette(index=0, qubits=[0, 1, 2, 3, 4, 15, 16, 19, 20, 21, 22, 23], neighbors=[3, 1])
```

Du chasch ou äs Diagramm vo dä zu Grund liggendä Qubits generierä, wo s'Plaquette-Gittär bildä.

```python
plaquette_lattice.draw_qubits()
```

![Output of the previous code cell](/docs/images/tutorials/nishimori-phase-transition/extracted-outputs/a19d63ce-3572-4081-a008-c1332fbbe303-0.avif)

Zuesätzlich zu dä Qubit-Bezeichnigä und dä Kantä, wo zeigä, welchi Qubits verbundä sind, enthaltet s'Diagramm drüü witeri Informatione, wo für s'GEM-Protokoll relevant sind:
- Jedäs Qubit isch entweder schattiert (grau) oder nöd schattiert. Di schattiertä Qubits sind "Site"-Qubits, wo d'Plätz vom Ising-Modäll darstellä, und di nöd schattiertä Qubits sind "Bond"-Qubits, wo brucht wärdä, zum Interaktione zwüschä dä Site-Qubits z'vermittlä.
- Jedäs Site-Qubit isch entweder (A) oder (B) bezeichnet, wo eini vo zwei Rollä azeigt, wo äs Site-Qubit imä GEM-Protokoll cha spielä (d'Rollä wärdä spötär erklärt).
- Jedi Kantä isch mit einärä vo sächs Farbä igfärbt, wo d'Kantä i sächs Gruppä ufteilt. Di Ufteilig bestimmt, wiä Zwei-Qubit-Gattärä parallelisiert wärdä chönä, so wiä verschidäni Ziitplän, wo wohrschinlich verschidäni Fählerrätä uf emä ruschendä Quanteprozässor verursachä. Wiil d'Kantä innerä Gruppä disjunkt sind, cha äni Schicht vo Zwei-Qubit-Gattärä uf dänä Kantä gliichziitig agleit wärdä. Tatsächlich cha mer di sächs Farbä i drüü Gruppä vo zwei Farbä ufteilä, so dass di Vereinigung vo jedärä Gruppä vo zwei Farbä immer no disjunkt isch. Drum wärdä numä drüü Schichtä vo Zwei-Qubit-Gattärä brucht, zum jedi Kantä z'aktivierä. S'git 12 Wägä, di sächs Farbä so ufzteilä, und jedi so äni Ufteilig lieferet än anderä 3-Schichtä-Gattärä-Ziitplaan.

Nachdäm du äs Plaquette-Gittär ufbout hesch, isch dr nöchscht Schritt, äs `GemExperiment` Objekt z'initialisierä, wo du sowohl s'Plaquette-Gittär als ou s'Backend igisch, uf dem du s'Experimänt dürefüerä wotsch. Di `GemExperiment` Klass verwaltet di eigentlichi Implementierig vom GEM-Protokoll, wo ou Schaltkreisä generiert, Jobs iireicht und Datä analysiert. Di nöchscht Code-Zellä initialisiert di Experimänt-Klass und beschränkt s'Plaquette-Gittär uf numä zwei vo dä Plaquettä (21 Qubits), zum d'Grössi vom Experimänt z'reduzierä und sichärzschtellä, dass s'Ruschä i dä Hardware nöd s'Signal übärwältigt.

```python
gem_exp = GemExperiment(plaquette_lattice.filter([9, 12]), backend=backend)

# visualize the plaquette lattice after filtering
plaquette_lattice.filter([9, 12]).draw_qubits()
```

![Output of the previous code cell](/docs/images/tutorials/nishimori-phase-transition/extracted-outputs/02357c6e-5c83-4ac0-811d-22602d9f33d5-0.avif)

Ä GEM-Protokoll-Schaltkreis wird mit dänä Schritt bout:
1. Bau dr all-$|+\rangle$ Zustand uf, indäm äs Hadamard-Gattär uf jedäs Qubit agleit wird.
2. Leg äs $R_{ZZ}$ Gattär zwüschä jedem Paar vo verbundänä Qubits aa. Das cha mer mit 3 Schichtä vo Gattärä erreichä. Jedäs $R_{ZZ}$ Gattär wirkt uf äs Site-Qubit und äs Bond-Qubit. Wänn s'Site-Qubit (B) bezeichnet isch, dänn isch dr Winkäl fest uf $\frac{\pi}{2}$ gsetzt. Wänn s'Site-Qubit (A) bezeichnet isch, dänn darf dr Winkäl variierä, wo verschidäni Schaltkreisä lieferet. Standardmässig isch dr Bereich vo Winkle uf 21 gliichmässig verteilti Punkte zwüschä $0$ und $\frac{\pi}{2}$, inklusive, gsetzt.
3. Miss jedäs Bond-Qubit i dä Pauli $X$ Basis. Wiil Qubits i dä Pauli $Z$ Basis gmässä wärdä, cha mer das machä, indäm äs Hadamard-Gattär vor dä Messig agleit wird.

Beacht, dass s'Paper, wo i dä Iileitig vo däm Tutorial zitiert wird, äni anderi Konväntion für dä $R_{ZZ}$ Winkäl brucht, wo sich durch än Faktor vo 2 vo dä Konväntion i däm Tutorial ungerscheidet.

I Schritt 3 wärdä numä d'Bond-Qubits gmässä. Zum z'verstah, i welem Zustand d'Site-Qubits bliebä, isch hilfriich, dä Fall z'betrachtä, dass dr $R_{ZZ}$ Winkäl, wo i Schritt 2 uf Site-Qubits (A) agleit wird, gliich $\frac{\pi}{2}$ isch. I däm Fall bliebä d'Site-Qubits i emä hochgradig verschränktä Zustand, ähnlich wiäm GHZ-Zustand,

$$
\lvert \text{GHZ} \rangle = \lvert 00 \cdots 00 \rangle + \lvert 11 \cdots 11 \rangle.
$$

Wegäm Zuefälligkeit i dä Messigsergebnis chönt dr eigentlich Zustand vo dä Site-Qubits än anderä Zustand mit Langstreckeordnig sii, zum Bispil, $\lvert 00110 \rangle + \lvert 11001 \rangle$. Aber dr GHZ-Zustand cha wider härgschtellt wärdä, indäm äni Dekodierigsoparation basierend uf dä Messigsergebnis agleit wird. Wänn dr $R_{ZZ}$ Winkäl vo $\frac{\pi}{2}$ abä dreht wird, cha di Langstreckeordnig no immer wider härgschtellt wärdä bis zu emä kritischä Winkäl, wo i Abwäsäheit vo Ruschä öppe $0.3 \pi$ isch. Ungär däm Winkäl zeigt dr Zustand, wo ufbout wird, nüm Langstreckäverschränkig. Derä Übergang zwüschä dä Awäsäheit und Abwäsäheit vo Langstreckeordnig isch dr Nishimori Phasenübergang.

I dä Beschribig hiä obä wärdä d'Site-Qubits nöd gmässä, und di Dekodierigsoparation cha düregfüert wärdä, indäm Quantägattärä agleit wärdä. Imä Experimänt, wiä's i dä GEM Suite implementiert isch, wo däm Tutorial folgt, wärdä d'Site-Qubits tatsächlich gmässä, und di Dekodierigsoparation wird i emä klassischä Nachbearbeitigsschritt agleit.

I dä Beschribig hiä obä cha di Dekodierigsoparation düregfüert wärdä, indäm Quantägattärä uf d'Site-Qubits agleit wärdä, zum dä Quantezustand wider härzschtellä. Aber wänn s'Ziil isch, dä Zustand sofort z'mässä, zum Bispil für Charakterisierigs-Zwäck, dänn wärdä d'Site-Qubits zämä mit dä Bond-Qubits gmässä, und di Dekodierigsoparation cha i emä klassischä Nachbearbeitigsschritt agleit wärdä. So isch s'Experimänt i dä GEM Suite implementiert, wo däm Tutorial folgt.

Zuesätzlich dezue, dass's vom $R_{ZZ}$ Winkäl i Schritt 2 abhängt, wo standardmässig über 21 Wert geit, hängt dr GEM-Protokoll-Schaltkreis ou vom Ziitplaan-Mustär ab, wo brucht wird, zum di 3 Schichtä vo $R_{ZZ}$ Gattärä z'implementierä. Wiä vorär bschrochä git's 12 so Ziitplaan-Mustär. Drum isch di totali Azahl vo Schaltkreisä imä Experimänt $21 \times 12 = 252$.

Di Schaltkreisä vom Experimänt chönä mit dä `circuits` Methodä vo dä `GemExperiment` Klass generiert wärdä.

```python
circuits = gem_exp.circuits()
print(f"Total number of circuits: {len(circuits)}")
```

```text
Total number of circuits: 252
```

Für di Zwäck vo däm Tutorial isch's gnueg, numä äs einzelnäs Ziitplaan-Mustär z'betrachtä. Di nöchscht Code-Zellä beschränkt s'Experimänt uf s'erscht Ziitplaan-Mustär. Demit het s'Experimänt numä 21 Schaltkreisä, einä für jedä $R_{ZZ}$ Winkäl, über wo gangä wird.

```python
# Restrict experiment to the first scheduling pattern
gem_exp.set_experiment_options(schedule_idx=0)

# There are less circuits now
circuits = gem_exp.circuits()
print(f"Total number of circuits: {len(circuits)}")

# Print the RZZ angles swept over
print(f"RZZ angles:\n{gem_exp.parameters()}")
```

```text
Total number of circuits: 21
RZZ angles:
[0.         0.07853982 0.15707963 0.23561945 0.31415927 0.39269908
 0.4712389  0.54977871 0.62831853 0.70685835 0.78539816 0.86393798
 0.9424778  1.02101761 1.09955743 1.17809725 1.25663706 1.33517688
 1.41371669 1.49225651 1.57079633]
```

Di nöchscht Code-Zellä zeigt äs Diagramm vom Schaltkreis bi Index 5. Zum d'Grössi vom Diagramm z'reduzierä, wärdä di Messigs-Gattärä am Änd vom Schaltkreis entfärnt.

```python
# Get the circuit at index 5
circuit = circuits[5]
# Remove the final measurements to ease visualization
circuit.remove_final_measurements()
# Draw the circuit
circuit.draw("mpl", fold=-1, scale=0.5)
```

![Output of the previous code cell](/docs/images/tutorials/nishimori-phase-transition/extracted-outputs/fd57d483-c70b-4ad5-b309-15750ad38bac-0.avif)

## Schritt 2: Problem für Quantä-Hardware-Usfüerig optimierä {#step-2-optimize-problem-for-quantum-hardware-execution}

S'Transpilierä vo Quanteschaltkreisä für di Usfüerig uf Hardware umfasst typischerwiis [äni ganzi Reihä vo Etappä](/guides/transpiler-stages). Typischerwiis sind di Etappä, wo am meistä rachenintensiv sind, di Uswahl vom Qubit-Layout, s'Routing vo dä Zwei-Qubit-Gattärä, zum sich a d'Qubit-Konnektivität vo dä Hardware azpassä, und di Optimierig vom Schaltkreis, zum sini Gattärä-Azahl und Tüüfi z'minimerä. Imä GEM-Protokoll sind di Layout- und Routing-Etappä onnötig, wiil di Hardware-Konnektivität scho i s'Design vom Protokoll ibout isch. Di Schaltkreisä hend scho äs Qubit-Layout, und di Zwei-Qubit-Gattärä sind scho uf nativi Verbindigä abbildet. Dezue sött numä sehr eifachi Schaltkreis-Optimierig düregfüert wärdä, zum di Struktur vom Schaltkreis z'erhalte, wänn dr $R_{ZZ}$ Winkäl variiert wird.

Di `GemExperiment` Klass transpiliert Schaltkreisä transparent, wänn s'Experimänt düregfüert wird. Di Layout- und Routing-Etappä sind standardmässig scho überschribä, zum nüt z'tuä, und Schaltkreis-Optimierig wird uf emä Niveau düregfüert, wo numä Een-Qubit-Gattärä optimiert. Aber du chasch zuesätzlichi Optione überschribä oder agä, indäm du di `set_transpile_options` Methodä bruchsch. Für di Zwäck vo dä Visualisierig transpiliert di nöchscht Code-Zellä manuell dä Schaltkreis, wo vorär azäigt wurdä isch, und zeigt dä transpiliert Schaltkreis.

```python
# Demonstrate setting transpile options
gem_exp.set_transpile_options(
    optimization_level=1  # This is the default optimization level
)
pass_manager = generate_preset_pass_manager(
    backend=backend,
    initial_layout=list(gem_exp.physical_qubits),
    **dict(gem_exp.transpile_options),
)
transpiled = pass_manager.run(circuit)
transpiled.draw("mpl", idle_wires=False, fold=-1, scale=0.5)
```

![Output of the previous code cell](/docs/images/tutorials/nishimori-phase-transition/extracted-outputs/e9b99d48-8d33-46b5-bff5-480ab1c1c1f2-0.avif)

## Schritt 3: Mit Qiskit Primitives usfüerä {#step-3-execute-using-qiskit-primitives}

Zum di GEM-Protokoll-Schaltkreisä uf dä Hardware usfüerä, ruef di `run` Methodä vom `GemExperiment` Objekt uf. Du chasch di Azahl vo Shots agä, wo du us jedem Schaltkreis samplä wotsch. Di `run` Methodä lieferet äs [ExperimentData](https://qiskit-community.github.io/qiskit-experiments/stubs/qiskit_experiments.framework.ExperimentData.html) Objekt, wo du i ärä Variablä speicherä sötsch. Beacht, dass di `run` Methodä numä Jobs iireicht ohni uf si z'wartä bis si färtig sind, so dass's än nöd-blockierendä Ufruef isch.

```python
exp_data = gem_exp.run(shots=10_000)
```

Zum uf di Ergebnis z'wartä, ruef di `block_for_results` Methodä vom `ExperimentData` Objekt uf. Derä Ufruef lat dä Interpreter hängä, bis di Jobs färtig sind.

```python
exp_data.block_for_results()
```

```text
ExperimentData(GemExperiment, d0d5880a-34c1-4aab-a7b6-c4f58516bc03, job_ids=['cwg12ptmptp00082khhg'], metadata=<5 items>, figure_names=['two_point_correlation.svg', 'normalized_variance.svg', 'plaquette_ops.svg', 'bond_ops.svg'])
```

## Schritt 4: Nachbearbeitä und Ergebnis im gwünschtä klassischä Format zrugggä {#step-4-post-process-and-return-result-in-desired-classical-format}

Bi emä $R_{ZZ}$ Winkäl vo $\frac{\pi}{2}$ würd dr dekodiert Zustand dr GHZ-Zustand i Abwäsäheit vo Ruschä sii. Di Langstreckeordnig vom GHZ-Zustand cha visualisiert wärdä, indäm di Magnetisierig vo dä gmässänä Bitstrings abbildet wird. Di Magnetisierig $M$ wird definiert als di Summ vo dä Een-Qubit-Pauli $Z$ Operatore,
$$
M = \sum_{j=1}^N Z_j,
$$
wo $N$ di Azahl vo Site-Qubits isch. Sin Wert für än Bitstring isch gliich dr Ungärschied zwüschä dä Azahl vo Nullä und dä Azahl vo Einsä. S'Mässä vom GHZ-Zustand lieferet dä all-Null Zustand oder dä all-Eins Zustand mit gliichär Wohrschienlichkeit, so dass di Magnetisierig $+N$ di halbä Ziit und $-N$ di anderi halbä Ziit würd sii. I dä Awäsäheit vo Fählär wegäm Ruschä würdä ou anderi Wert ufträtä, aber wänn s'Ruschä nöd z'gross isch, würd di Verteilig no immer Spitzä bi $+N$ und $-N$ zeigä.

Für di rohä Bitstrings vor dä Dekodierig würd di Verteilig vo dä Magnetisierig gliichbedütend mit dänä vo gliichmässig zuefälligä Bitstrings sii, i Abwäsäheit vo Ruschä.

Di nöchscht Code-Zellä zeigt di Magnetisierig vo dä rohä Bitstrings und dä dekodierte Bitstrings bim $R_{ZZ}$ Winkäl vo $\frac{\pi}{2}$.

```python
def magnetization_distribution(
    counts_dict: dict[str, int],
) -> dict[str, float]:
    """Compute magnetization distribution from counts dictionary."""
    # Construct dictionary from magnetization to count
    mag_dist = defaultdict(float)
    for bitstring, count in counts_dict.items():
        mag = bitstring.count("0") - bitstring.count("1")
        mag_dist[mag] += count
    # Normalize
    shots = sum(counts_dict.values())
    for mag in mag_dist:
        mag_dist[mag] /= shots
    return mag_dist

# Get counts dictionaries with and without decoding
data = exp_data.data()
# Get the last data point, which is at the angle for the GHZ state
raw_counts = data[-1]["counts"]
# Without decoding
site_indices = [
    i for i, q in enumerate(gem_exp.plaquettes.qubits()) if q.role == "Site"
]
site_raw_counts = defaultdict(int)
for key, val in raw_counts.items():
    site_str = "".join(key[-1 - i] for i in site_indices)
    site_raw_counts[site_str] += val
# With decoding
_, site_decoded_counts = gem_exp.plaquettes.decode_outcomes(
    raw_counts, return_counts=True
)

# Compute magnetization distribution
raw_magnetization = magnetization_distribution(site_raw_counts)
decoded_magnetization = magnetization_distribution(site_decoded_counts)

# Plot
plt.bar(*zip(*raw_magnetization.items()), label="raw")
plt.bar(*zip(*decoded_magnetization.items()), label="decoded", width=0.3)
plt.legend()
plt.xlabel("Magnetization")
plt.ylabel("Frequency")
plt.title("Magnetization distribution with and without decoding")
```

```text
Text(0.5, 1.0, 'Magnetization distribution with and without decoding')
```

![Output of the previous code cell](/docs/images/tutorials/nishimori-phase-transition/extracted-outputs/8ead3582-16df-4616-836c-bdce867ad6b8-1.avif)

Zum di Langstreckeordnig rigoroser z'charakterisierä, chasch du di dürchschnittlich Zwei-Punkt-Korrelatschon $f$ betrachtä, definiert als
$$
f = \frac{1}{N^2} \left(\langle M^2 \rangle - \langle M \rangle ^2\right).
$$
Ä höcherä Wert zeigt än grösserä Graad vo Verschränkig aa. Di `GemExperiment` Klass berechnet derä Wert automatisch für di dekodierte Bitstrings als Teil vo dä Verarbeitig vo dä experimentällä Datä. Si speicheret äs Diagramm, wo über di `figure` Methodä vo dä Experimänt-Datä-Klass zuegreifbar isch. I däm Fall heisst s'Diagramm `two_point_correlation`.

```python
exp_data.figure("two_point_correlation")
```

![Output of the previous code cell](/docs/images/tutorials/nishimori-phase-transition/extracted-outputs/4ecb25c8-e572-49af-a879-9943039db131-0.avif)

Zum dä kritisch Punkt vom Nishimori Phasenübergang z'bestimmä, chasch du uf di normalisiert Varianz vo $M^2 / N$ luegä, definiert als
$$
g = \frac{1}{N^3} \left(\langle M^4 \rangle - \langle M^2 \rangle^2\right),
$$
wo di Stärki vo dä Schwankig i dä quadriertä Magnetisierig quantifiziert. Derä Wert isch maximal am kritischä Punkt vom Nishimori Phasenübergang. I Abwäsäheit vo Ruschä tritt dr kritisch Punkt bi öppe $0.3 \pi$ uf. I Awäsäheit vo Ruschä wird dr kritisch Punkt nach obä verschobä, aber dr Phasenübergang wird no immer beobachtet, solang dr kritisch Punkt ungär $0.5 \pi$ lit.

```python
exp_data.figure("normalized_variance")
```

![Output of the previous code cell](/docs/images/tutorials/nishimori-phase-transition/extracted-outputs/2b351d68-3924-445a-94ef-047b16214e8a-0.avif)

## S'Experimänt ufskalierä {#scale-up-the-experiment}

Di nöchschtä Code-Zellä füert s'Experimänt für sächs Plaquettä (49 Qubits) und di vollä 12 Plaquettä (125 Qubits) dure und zeigt di normalisiert Varianz. Wänn s'Experimänt uf gröseri Grössä ufskaliert wird, verschiebt di grösseri Azahl vo Ruschä dä kritisch Punkt nach rächts.

```python
gem_exp = GemExperiment(
    plaquette_lattice.filter(range(3, 9)), backend=backend
)
gem_exp.set_experiment_options(schedule_idx=0)
exp_data = gem_exp.run(shots=10_000)
exp_data.block_for_results()
exp_data.figure("normalized_variance")
```

![Output of the previous code cell](/docs/images/tutorials/nishimori-phase-transition/extracted-outputs/08581c09-a6a5-4a56-9fc4-abf22b063c6a-0.avif)

```python
gem_exp = GemExperiment(plaquette_lattice, backend=backend)
gem_exp.set_experiment_options(schedule_idx=0)
exp_data = gem_exp.run(shots=10_000)
exp_data.block_for_results()
exp_data.figure("normalized_variance")
```

![Output of the previous code cell](/docs/images/tutorials/nishimori-phase-transition/extracted-outputs/37e9a4cd-6efb-4ade-ad09-8139db9d58e9-0.avif)

## Fazit {#conclusion}

I däm Tutorial hesch du än Nishimori Phasenübergang uf emä Quanteprozässor mitäm GEM-Protokoll realisiert. Di Metrikä, wo du währänd dä Nachbearbeitig ungärsuecht hesch, bsunders di Zwei-Punkt-Korrelatschon und di normalisiert Varianz, dienä als Benchmarks für di Fähigkeit vom Grät, langstreck verschränkti Zuständ z'generierä. Di Benchmarks erwiiterä dä Nutzä vom GEM-Protokoll über s'Erforschä vo interessantär Physik uusä. Als Teil vom Protokoll hesch du Qubits über s'ganzä Grät verschränkt mit Schaltkreisä vo numä konstantä Tüüfi. Di Kunschtleischtig isch numä möglich durchs Bruchä vo Messigä innärhalb vom Schaltkreis vom Protokoll. I däm Experimänt isch dr verschränkt Zustand sofort gmässä wordä, aber än interessantä Wäg, wo mer erforschä chönt, würd sii, dä Zustand witer z'bruchä i zuesätzlichär Quanteverarbeitig!
## Tutorial-Umfraag {#tutorial-survey}

Bitte nimm a derä churzä Umfraag teil, zum Feedback zu däm Tutorial z'gä. Dini Iisichtä hälffä üs, üsi Inhalts-Agebott und Bnutzererfahrig z'verbessärä.

[Link zur Umfraag](https://your.feedback.ibm.com/jfe/form/SV_bsCKQkgzuQUQ7ky)
