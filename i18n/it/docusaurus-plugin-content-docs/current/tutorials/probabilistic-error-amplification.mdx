---
title: "Mitigazione degli errori su scala industriale con amplificazione probabilistica dell'errore"
sidebar_label: "Mitigazione degli errori su scala industriale con amplificazione probabilistica dell'errore"
description: "Eseguire un esperimento di mitigazione degli errori su scala industriale con estrapolazione a rumore zero e amplificazione probabilistica dell'errore."
notebook_path: "docs/tutorials/probabilistic-error-amplification.ipynb"
---

<OpenInLabBanner notebookPath="docs/tutorials/probabilistic-error-amplification.ipynb" />



{/* cspell:ignore mapsto multigraph inds extrap sharex sharey pidx */}

*Stima di utilizzo: 16 minuti su un processore Heron r2 (NOTA: Questa è solo una stima. Il vostro tempo di esecuzione potrebbe variare.)*
## Background

Questo tutorial dimostra come eseguire un esperimento di mitigazione degli errori su scala industriale con Qiskit Runtime utilizzando una versione sperimentale dell'*estrapolazione a rumore zero* (ZNE) con *amplificazione probabilistica dell'errore* (PEA).

![kim_nature_fig.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/e1e67c34-9d4d-4a88-9340-f0b2f3676770.avif)
__Riferimento__: Y. Kim et al. *Evidence for the utility of quantum computing before fault tolerance.* [Nature 618.7965 (2023)](https://www.nature.com/articles/s41586-023-06096-3)
### Estrapolazione a rumore zero (ZNE) {#zero-noise-extrapolation-zne}
L'estrapolazione a rumore zero (ZNE) è una tecnica di mitigazione degli errori che rimuove gli effetti di un rumore *sconosciuto* durante l'esecuzione di un circuito che può essere scalato in modo *noto*.

Essa assume che i valori di aspettazione scalino con il rumore secondo una funzione nota

$$
\langle A(\lambda) \rangle = \langle A(0) \rangle + \sum_{k=0}^{m} a_k \lambda^k + R
$$
dove $\lambda$ parametrizza l'intensità del rumore e può essere amplificato.
Possiamo implementare la ZNE seguendo i seguenti passaggi:

1. Amplificare il rumore del circuito per diversi fattori di rumore $\lambda_1, \lambda_2, ... $
2. Eseguire ogni circuito con rumore amplificato per misurare $\langle A(\lambda_1)\rangle, ...$
3. Estrapolare al limite di rumore zero $\langle A(0)\rangle$

![zne_stages.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/5e63d706-82d8-4212-b802-c9191ce53341.avif)
#### Amplificare il rumore per la ZNE {#amplify-noise-for-zne}
La sfida principale nell'implementare con successo la ZNE è avere un modello accurato per il rumore nel valore di aspettazione e amplificare il rumore in modo noto.

Esistono tre modi comuni in cui l'amplificazione dell'errore viene implementata per la ZNE.

| **Allungamento degli impulsi** | **Piegatura dei gate** | **Amplificazione probabilistica dell'errore** |
|-----------|-----------|-----------|
| Scalare la durata degli impulsi tramite calibrazione | Ripetere i gate in cicli identità $U\mapsto U(U^{-1}U)^{\lambda-1}/2$ | Aggiungere rumore tramite campionamento di canali di Pauli |
| ![zne_pulse_stretching.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/83188b57-e88f-43a1-a7bd-29327f46ecf5.avif) | ![zne_gate_folding.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/e1358d08-2632-4fd2-bf0f-f9384a2d3340.avif) | ![zne_pea.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/3d69d5bd-70e5-4eeb-aa02-fc0a62043010.avif) |
| Kandala et al. Nature (2019) | Shultz et al. PRA (2022) | Li & Benjamin PRX (2017) |
Per esperimenti su scala industriale, l'*amplificazione probabilistica dell'errore* (PEA) è la più interessante.
- L'allungamento degli impulsi assume che il rumore dei gate sia proporzionale alla durata, cosa che tipicamente non è vera. Anche la calibrazione è costosa.
- La piegatura dei gate richiede grandi fattori di allungamento che limitano notevolmente la profondità dei circuiti eseguibili.
- La PEA può essere applicata a qualsiasi circuito eseguibile con il fattore di rumore nativo ($\lambda=1$) ma richiede l'apprendimento del modello di rumore.
### Apprendere il modello di rumore per la PEA {#learn-the-noise-model-for-pea}
La PEA assume lo stesso modello di rumore basato su layer della *cancellazione probabilistica dell'errore* (PEC); tuttavia, evita il sovraccarico di campionamento che scala esponenzialmente con il rumore del circuito.
| **Passaggio 1** | **Passaggio 2** | **Passaggio 3** |
|-----------|-----------|-----------|
| Applicare il twirling di Pauli ai layer di gate a due qubit | Ripetere coppie identità di layer e apprendere il rumore | Derivare una fedeltà (errore per ogni canale di rumore) |
| ![pec_pauli_twirling.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/2eab5ff4-40fa-4a41-9f2c-74f5e22c4643.avif) | ![pec_learn_layer.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/8d0d64c3-65ad-4419-8ac9-4ec9633d39a0.avif) | ![pec_curve_fitting.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/c51bd42d-2463-4c78-807b-d284ca79296f.avif) |

__Riferimento__: E. van den Berg, Z. Minev, A. Kandala, and K. Temme, _Probabilistic error cancellation with sparse Pauli-Lindblad models on noisy quantum processors_ [arXiv:2201.09866](https://arxiv.org/abs/2201.09866)
## Requisiti {#requirements}

Prima di iniziare questo tutorial, assicuratevi di avere installato quanto segue:

- Qiskit SDK v1.0 o successivo, con supporto per la [visualizzazione](https://docs.quantum.ibm.com/api/qiskit/visualization)
- Qiskit Runtime v0.22 o successivo (`pip install qiskit-ibm-runtime`)
## Configurazione {#setup}

```python
from __future__ import annotations
from collections.abc import Sequence
from collections import defaultdict
import numpy as np
import rustworkx
import matplotlib.pyplot as plt

from qiskit.circuit import QuantumCircuit, Parameter
from qiskit.circuit.library import CXGate, CZGate, ECRGate
from qiskit.providers import Backend
from qiskit.visualization import plot_error_map
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit.quantum_info import SparsePauliOp
from qiskit.primitives import PubResult

from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_runtime import EstimatorV2 as Estimator
```

## Passaggio 1: Mappare input classici a un problema quantistico {#step-1-map-classical-inputs-to-a-quantum-problem}
### Creare un circuito parametrizzato del modello di Ising {#create-a-parameterized-ising-model-circuit}
Innanzitutto, scegliete un backend su cui eseguire. Questa dimostrazione viene eseguita su un backend a 127 qubit, ma potete modificarlo con qualsiasi backend disponibile per voi.

```python
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=127
)
backend
```

```text
<IBMBackend('ibm_kingston')>
```

#### Funzioni di supporto per la costruzione del circuito {#helper-functions-for-circuit-construction}
Successivamente, create alcune funzioni di supporto per costruire i circuiti per l'evoluzione temporale trotterizzata di un modello di Ising bidimensionale a campo trasverso che aderisce alla topologia del backend.

```python
"""Trotter circuit generation"""

def remove_qubit_couplings(
    couplings: Sequence[tuple[int, int]], qubits: Sequence[int] | None = None
) -> list[tuple[int, int]]:
    """Remove qubits from a coupling list.

    Args:
        couplings: A sequence of qubit couplings.
        qubits: Optional, the qubits to remove.

    Returns:
        The input couplings with the specified qubits removed.
    """
    if qubits is None:
        return couplings
    qubits = set(qubits)
    return [edge for edge in couplings if not qubits.intersection(edge)]

def coupling_qubits(
    *couplings: Sequence[tuple[int, int]],
    allowed_qubits: Sequence[int] | None = None,
) -> list[int]:
    """Return a sorted list of all qubits involved in one or more couplings lists.

    Args:
        couplings: one or more coupling lists.
        allowed_qubits: Optional, the allowed qubits to include. If None all
            qubits are allowed.

    Returns:
        The intersection of all qubits in the couplings and the allowed qubits.
    """
    qubits = set()
    for edges in couplings:
        for edge in edges:
            qubits.update(edge)
    if allowed_qubits is not None:
        qubits = qubits.intersection(allowed_qubits)
    return list(qubits)

def construct_layer_couplings(
    backend: Backend,
) -> list[list[tuple[int, int]]]:
    """Separate a coupling map into disjoint 2-qubit gate layers.

    Args:
        backend: A backend to construct layer couplings for.

    Returns:
        A list of disjoint layers of directed couplings for the input coupling map.
    """
    coupling_graph = backend.coupling_map.graph.to_undirected(
        multigraph=False
    )
    edge_coloring = rustworkx.graph_bipartite_edge_color(coupling_graph)

    layers = defaultdict(list)
    for edge_idx, color in edge_coloring.items():
        layers[color].append(
            coupling_graph.get_edge_endpoints_by_index(edge_idx)
        )
    layers = [sorted(layers[i]) for i in sorted(layers.keys())]

    return layers

def entangling_layer(
    gate_2q: str,
    couplings: Sequence[tuple[int, int]],
    qubits: Sequence[int] | None = None,
) -> QuantumCircuit:
    """Generating a entangling layer for the specified couplings.

    This corresponds to a Trotter layer for a ZZ Ising term with angle Pi/2.

    Args:
        gate_2q: The 2-qubit basis gate for the layer, should be "cx", "cz", or "ecr".
        couplings: A sequence of qubit couplings to add CX gates to.
        qubits: Optional, the physical qubits for the layer. Any couplings involving
            qubits not in this list will be removed. If None the range up to the largest
            qubit in the couplings will be used.

    Returns:
        The QuantumCircuit for the entangling layer.
    """
    # Get qubits and convert to set to order
    if qubits is None:
        qubits = range(1 + max(coupling_qubits(couplings)))
    qubits = set(qubits)

    # Mapping of physical qubit to virtual qubit
    qubit_mapping = {q: i for i, q in enumerate(qubits)}

    # Convert couplings to indices for virtual qubits
    indices = [
        [qubit_mapping[i] for i in edge]
        for edge in couplings
        if qubits.issuperset(edge)
    ]

    # Layer circuit on virtual qubits
    circuit = QuantumCircuit(len(qubits))

    # Get 2-qubit basis gate and pre and post rotation circuits
    gate2q = None
    pre = QuantumCircuit(2)
    post = QuantumCircuit(2)

    if gate_2q == "cx":
        gate2q = CXGate()
        # Pre-rotation
        pre.sdg(0)
        pre.z(1)
        pre.sx(1)
        pre.s(1)
        # Post-rotation
        post.sdg(1)
        post.sxdg(1)
        post.s(1)
    elif gate_2q == "ecr":
        gate2q = ECRGate()
        # Pre-rotation
        pre.z(0)
        pre.s(1)
        pre.sx(1)
        pre.s(1)
        # Post-rotation
        post.x(0)
        post.sdg(1)
        post.sxdg(1)
        post.s(1)
    elif gate_2q == "cz":
        gate2q = CZGate()
        # Identity pre-rotation
        # Post-rotation
        post.sdg([0, 1])
    else:
        raise ValueError(
            f"Invalid 2-qubit basis gate {gate_2q}, should be 'cx', 'cz', or 'ecr'"
        )

    # Add 1Q pre-rotations
    for inds in indices:
        circuit.compose(pre, qubits=inds, inplace=True)

    # Use barriers around 2-qubit basis gate to specify a layer for PEA noise learning
    circuit.barrier()
    for inds in indices:
        circuit.append(gate2q, (inds[0], inds[1]))
    circuit.barrier()

    # Add 1Q post-rotations after barrier
    for inds in indices:
        circuit.compose(post, qubits=inds, inplace=True)

    # Add physical qubits as metadata
    circuit.metadata["physical_qubits"] = tuple(qubits)

    return circuit

def trotter_circuit(
    theta: Parameter | float,
    layer_couplings: Sequence[Sequence[tuple[int, int]]],
    num_steps: int,
    gate_2q: str | None = "cx",
    backend: Backend | None = None,
    qubits: Sequence[int] | None = None,
) -> QuantumCircuit:
    """Generate a Trotter circuit for the 2D Ising

    Args:
        theta: The angle parameter for X.
        layer_couplings: A list of couplings for each entangling layer.
        num_steps: the number of Trotter steps.
        gate_2q: The 2-qubit basis gate to use in entangling layers.
            Can be "cx", "cz", "ecr", or None if a backend is provided.
        backend: A backend to get the 2-qubit basis gate from, if provided
            will override the basis_gate field.
        qubits: Optional, the allowed physical qubits to truncate the
            couplings to. If None the range up to the largest
            qubit in the couplings will be used.

    Returns:
        The Trotter circuit.
    """
    if backend is not None:
        try:
            basis_gates = backend.configuration().basis_gates
        except AttributeError:
            basis_gates = backend.basis_gates
        for gate in ["cx", "cz", "ecr"]:
            if gate in basis_gates:
                gate_2q = gate
                break

    # If no qubits, get the largest qubit from all layers and
    # specify the range so the same one is used for all layers.
    if qubits is None:
        qubits = range(1 + max(coupling_qubits(layer_couplings)))

    # Generate the entangling layers
    layers = [
        entangling_layer(gate_2q, couplings, qubits=qubits)
        for couplings in layer_couplings
    ]

    # Construct the circuit for a single Trotter step
    num_qubits = len(qubits)
    trotter_step = QuantumCircuit(num_qubits)
    trotter_step.rx(theta, range(num_qubits))
    for layer in layers:
        trotter_step.compose(layer, range(num_qubits), inplace=True)

    # Construct the circuit for the specified number of Trotter steps
    circuit = QuantumCircuit(num_qubits)
    for _ in range(num_steps):
        circuit.rx(theta, range(num_qubits))
        for layer in layers:
            circuit.compose(layer, range(num_qubits), inplace=True)

    circuit.metadata["physical_qubits"] = tuple(qubits)
    return circuit
```

#### Definire gli accoppiamenti dei layer di entanglement {#define-entangling-layer-couplings}
Per implementare la simulazione di Ising trotterizzata, definite tre layer di accoppiamenti di gate a due qubit per il dispositivo, da ripetere in ciascuno dei passaggi di Trotter. Questi definiscono i tre layer twirled di cui avete bisogno per apprendere il rumore per implementare la mitigazione.

```python
layer_couplings = construct_layer_couplings(backend)
for i, layer in enumerate(layer_couplings):
    print(f"Layer {i}:\n{layer}\n")
```

```text
Layer 0:
[(2, 3), (4, 5), (6, 7), (8, 9), (10, 11), (12, 13), (14, 15), (16, 23), (18, 31), (19, 35), (20, 21), (25, 37), (26, 27), (28, 29), (33, 39), (36, 41), (38, 49), (42, 43), (45, 46), (47, 57), (51, 52), (53, 54), (56, 63), (58, 71), (59, 75), (61, 62), (64, 65), (66, 67), (68, 69), (72, 73), (76, 81), (79, 93), (82, 83), (84, 85), (86, 87), (88, 89), (91, 98), (94, 95), (97, 107), (99, 115), (100, 101), (102, 103), (105, 117), (108, 109), (110, 111), (113, 114), (116, 121), (118, 129), (123, 136), (124, 125), (126, 127), (130, 131), (132, 133), (135, 139), (138, 151), (142, 143), (144, 145), (146, 147), (152, 153), (154, 155)]

Layer 1:
[(0, 1), (3, 16), (5, 6), (7, 8), (11, 18), (13, 14), (17, 27), (21, 22), (23, 24), (25, 26), (29, 38), (30, 31), (32, 33), (34, 35), (39, 53), (41, 42), (43, 56), (44, 45), (47, 48), (49, 50), (51, 58), (54, 55), (57, 67), (60, 61), (62, 63), (65, 66), (69, 78), (70, 71), (73, 79), (74, 75), (77, 85), (80, 81), (83, 84), (87, 97), (89, 90), (91, 92), (93, 94), (96, 103), (101, 116), (104, 105), (106, 107), (109, 118), (111, 112), (113, 119), (114, 115), (117, 125), (121, 122), (123, 124), (127, 137), (128, 129), (131, 138), (133, 134), (136, 143), (139, 155), (140, 141), (145, 146), (147, 148), (149, 150), (151, 152)]

Layer 2:
[(1, 2), (3, 4), (7, 17), (9, 10), (11, 12), (15, 19), (21, 36), (22, 23), (24, 25), (27, 28), (29, 30), (31, 32), (33, 34), (37, 45), (40, 41), (43, 44), (46, 47), (48, 49), (50, 51), (52, 53), (55, 59), (61, 76), (63, 64), (65, 77), (67, 68), (69, 70), (71, 72), (73, 74), (78, 89), (81, 82), (83, 96), (85, 86), (87, 88), (90, 91), (92, 93), (95, 99), (98, 111), (101, 102), (103, 104), (105, 106), (107, 108), (109, 110), (112, 113), (119, 133), (120, 121), (122, 123), (125, 126), (127, 128), (129, 130), (131, 132), (134, 135), (137, 147), (141, 142), (143, 144), (148, 149), (150, 151), (153, 154)]
```

#### Rimuovere i qubit difettosi {#remove-bad-qubits}
Osservate la mappa di accoppiamento per il backend e verificate se qualche qubit si connette ad accoppiamenti con errore elevato. Rimuovete questi qubit "difettosi" dal vostro esperimento.

```python
# Plot gate error map
# NOTE: These can change over time, so your results may look different
plot_error_map(backend)
```

![Output of the previous code cell](/docs/images/tutorials/probabilistic-error-amplification/extracted-outputs/401e2d48-1b39-40c8-bf32-7b439ae0980d-0.avif)

```python
bad_qubits = {
    56,
    63,
    67,
}  # qubits removed based on high coupling error (1.00)
good_qubits = list(set(range(backend.num_qubits)).difference(bad_qubits))
print("Physical qubits:\n", good_qubits)
```

```text
Physical qubits:
 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62, 64, 65, 66, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155]
```

#### Generazione del circuito di Trotter principale {#main-trotter-circuit-generation}

```python
num_steps = 6
theta = Parameter("theta")
circuit = trotter_circuit(
    theta, layer_couplings, num_steps, qubits=good_qubits, backend=backend
)
```

### Creare un elenco di valori di parametri da assegnare successivamente {#create-a-list-of-parameter-values-to-be-assigned-later}

```python
num_params = 12

# 12 parameter values for Rx between [0, pi/2].
# Reshape to outer product broadcast with observables
parameter_values = np.linspace(0, np.pi / 2, num_params).reshape(
    (num_params, 1)
)
num_params = parameter_values.size
```

## Passaggio 2: Ottimizzare il problema per l'esecuzione su hardware quantistico {#step-2-optimize-problem-for-quantum-hardware-execution}
### Circuito ISA {#isa-circuit}
Prima di eseguire il circuito sull'hardware, ottimizzatelo per l'esecuzione hardware. Questo processo comporta alcuni passaggi:

- Scegliere un layout di qubit che mappi i qubit virtuali del vostro circuito ai qubit fisici sull'hardware.
- Inserire gate di swap secondo necessità per instradare le interazioni tra qubit che non sono connessi.
- Tradurre i gate nel vostro circuito in istruzioni [Instruction Set Architecture (ISA)](/guides/transpile#instruction-set-architecture) che possono essere eseguite direttamente sull'hardware.
- Eseguire ottimizzazioni del circuito per minimizzare la profondità del circuito e il numero di gate.

Sebbene il transpiler integrato in Qiskit possa eseguire tutti questi passaggi, questo tutorial dimostra la costruzione del circuito di Trotter su scala industriale in modo bottom-up. Selezionate i qubit fisici buoni e definite i layer di entanglement su coppie di qubit connessi tra quei qubit selezionati. Ciononostante, dovete ancora tradurre i gate non-ISA nel circuito e avvalervi di qualsiasi ottimizzazione del circuito offerta dal transpiler.

Transpilate il vostro circuito per il backend scelto creando un pass manager e quindi eseguendo il pass manager sul circuito. Inoltre, fissate il layout iniziale del circuito ai `good_qubits` già selezionati. Un modo semplice per creare un pass manager è utilizzare la funzione [`generate_preset_pass_manager`](https://docs.quantum.ibm.com/api/qiskit/qiskit.transpiler.generate_preset_pass_manager). Consultate [Transpile with pass managers](/guides/transpile-with-pass-managers) per una spiegazione più dettagliata della transpilazione con i pass manager.

```python
pm = generate_preset_pass_manager(
    backend=backend,
    initial_layout=good_qubits,
    layout_method="trivial",
    optimization_level=1,
)

isa_circuit = pm.run(circuit)
```

### Osservabili ISA {#isa-observables}
Successivamente, create tutte le osservabili $\langle Z \rangle$ di peso 1 per ciascun qubit virtuale aggiungendo il numero necessario di termini $\langle I \rangle$.

```python
observables = []
num_qubits = len(good_qubits)
for q in range(num_qubits):
    observables.append(
        SparsePauliOp("I" * (num_qubits - q - 1) + "Z" + "I" * q)
    )
```

Il processo di transpilazione ha mappato i qubit virtuali del vostro circuito ai qubit fisici sull'hardware. L'informazione sul layout dei qubit è memorizzata nell'attributo `layout` del circuito transpilato. La vostra osservabile è anch'essa definita in termini di qubit virtuali, quindi dovete applicare questo layout all'osservabile. Questo viene fatto utilizzando il metodo `apply_layout` di `SparsePauliOp`.

Notate che ogni osservabile è racchiusa in una lista nel seguente blocco di codice. È fatto per effettuare il _broadcast_ con i valori dei parametri in modo che ogni osservabile di qubit venga misurata per ogni valore di theta. Le regole di broadcasting per i primitivi possono essere trovate [qui](/guides/primitives).

```python
isa_observables = [
    [obs.apply_layout(layout=isa_circuit.layout)] for obs in observables
]
```

## Passo 3: Eseguire utilizzando le primitive Qiskit {#step-3-execute-using-qiskit-primitives}

```python
pub = (isa_circuit, isa_observables, parameter_values)
```

### Configurare le opzioni dell'Estimator {#configure-estimator-options}
Successivamente, configurate le opzioni dell'`Estimator` necessarie per eseguire l'esperimento di mitigazione. Ciò include le opzioni per l'apprendimento del rumore degli strati di entanglement e per l'estrapolazione ZNE.

Utilizziamo la seguente configurazione:

```python
# Experiment options
num_randomizations = 700
num_randomizations_learning = 40
max_batch_circuits = 3 * num_params
shots_per_randomization = 64
learning_pair_depths = [0, 1, 2, 4, 6, 12, 24]
noise_factors = [1, 1.3, 1.6]
extrapolated_noise_factors = np.linspace(0, max(noise_factors), 20)

# Base option formatting
options = {
    # Builtin resilience settings for ZNE
    "resilience": {
        "measure_mitigation": True,
        "zne_mitigation": True,
        # TREX noise learning configuration
        "measure_noise_learning": {
            "num_randomizations": num_randomizations_learning,
            "shots_per_randomization": 1024,
        },
        # PEA noise model configuration
        "layer_noise_learning": {
            "max_layers_to_learn": 3,
            "layer_pair_depths": learning_pair_depths,
            "shots_per_randomization": shots_per_randomization,
            "num_randomizations": num_randomizations_learning,
        },
        "zne": {
            "amplifier": "pea",
            "noise_factors": noise_factors,
            "extrapolator": ("exponential", "linear"),
            "extrapolated_noise_factors": extrapolated_noise_factors.tolist(),
        },
    },
    # Randomization configuration
    "twirling": {
        "num_randomizations": num_randomizations,
        "shots_per_randomization": shots_per_randomization,
        "strategy": "active-circuit",
    },
    # Optional Dynamical Decoupling (DD)
    "dynamical_decoupling": {"enable": True, "sequence_type": "XY4"},
}
```

#### Spiegazione delle opzioni ZNE {#explanation-of-zne-options}
Quanto segue fornisce dettagli sulle opzioni aggiuntive nel ramo sperimentale. Si noti che queste opzioni e nomi non sono definitivi e tutto ciò che è presente qui è soggetto a modifiche prima di un rilascio ufficiale.

* __amplifier__: Il metodo da utilizzare per amplificare il rumore ai fattori di rumore previsti.
    I valori consentiti sono `"gate_folding"`, che amplifica ripetendo i gate base a due qubit,
    e `"pea"`, che amplifica mediante campionamento probabilistico dopo aver appreso il
    modello di rumore Pauli-twirled per gli strati di gate base a due qubit twirled. Esistono anche le opzioni `"gate_folding_front"` e `"gate_folding_back"` che sono spiegate nella [documentazione API](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/options-zne-options#amplifier)
* __extrapolated_noise_factors__: Specificare uno o più valori di fattore di rumore ai quali valutare i
    modelli estrapolati. Se è una sequenza di valori, i risultati restituiti saranno array-valued con il fattore di rumore specificato valutato per il modello di estrapolazione. Un valore
    di 0 corrisponde all'estrapolazione a rumore zero.
### Eseguire l'esperimento {#run-the-experiment}

```python
estimator = Estimator(mode=backend, options=options)
job = estimator.run([pub])
```

```python
print(f"Job ID {job.job_id()}")
```

```text
Job ID d0mcsvik4jhc73afljrg
```

## Passo 4: Post-elaborare e restituire il risultato nel formato classico desiderato {#step-4-post-process-and-return-result-in-desired-classical-format}
Una volta completato l'esperimento, potete visualizzare i vostri risultati. Recuperate i valori di aspettazione grezzi e mitigati e confrontateli con i risultati esatti. Quindi, tracciate i valori di aspettazione, sia mitigati (estrapolati) che grezzi, mediati su tutti i qubit per ciascun parametro. Infine, tracciate i valori di aspettazione per i singoli qubit di vostra scelta.

```python
primitive_result = job.result()
```

### Forme generali dei risultati e metadati {#general-result-shapes-and-metadata}
L'oggetto `PrimitiveResult` contiene una struttura simile a una lista denominata `PubResult`. Poiché inviamo solo un PUB all'estimator, il `PrimitiveResult` contiene un singolo oggetto `PubResult`.

I valori di aspettazione e gli errori standard del risultato PUB (primitive unified bloc) sono array-valued. Per i lavori dell'estimator con ZNE, ci sono diversi campi dati di valori di aspettazione ed errori standard disponibili nel contenitore `DataBin` del `PubResult`. Discuteremo brevemente i campi dati per i valori di aspettazione qui (campi dati simili sono disponibili anche per gli errori standard (`stds`)).

1. `pub_result.data.evs`: Valori di aspettazione corrispondenti al rumore zero (basati sull'estrapolazione euristicamente migliore).
    - Il primo asse è l'indice del qubit virtuale per l'osservabile $\langle Z_i\rangle$ ($124$ qubit-virtuali/osservabili)
    - Il secondo asse indicizza il valore del parametro per $\theta$ ($12$ valori di parametro)
2. `pub_result.data.evs_extrapolated`: Valori di aspettazione per fattori di rumore estrapolati per ogni estrapolatore. Questo array ha due assi aggiuntivi.
    - Il terzo asse indicizza i metodi di estrapolazione ($2$ estrapolatori, `exponential` e `linear`)
    - L'ultimo asse indicizza i `extrapolated_noise_factors` ($20$ punti di estrapolazione specificati nell'opzione)
3. `pub_result.data.evs_noise_factors`: Valori di aspettazione grezzi per ciascun fattore di rumore.
   - Il terzo asse indicizza i `noise_factors` grezzi ($3$ fattori)

```python
pub_result = primitive_result[0]

print(
    f"{pub_result.data.evs.shape=}\n"
    f"{pub_result.data.evs_extrapolated.shape=}\n"
    f"{pub_result.data.evs_noise_factors.shape=}\n"
)
```

```text
pub_result.data.evs.shape=(153, 12)
pub_result.data.evs_extrapolated.shape=(153, 12, 2, 20)
pub_result.data.evs_noise_factors.shape=(153, 12, 3)
```

Diversi campi di metadati sono disponibili anche nel `PrimitiveResult`. I metadati includono
- `resilience/zne/noise_factors`: I fattori di rumore grezzi
- `resilience/zne/extrapolator`: Gli estrapolatori utilizzati per ciascun risultato

```python
primitive_result.metadata
```

```text
{'dynamical_decoupling': {'enable': True,
  'sequence_type': 'XY4',
  'extra_slack_distribution': 'middle',
  'scheduling_method': 'alap'},
 'twirling': {'enable_gates': True,
  'enable_measure': True,
  'num_randomizations': 700,
  'shots_per_randomization': 64,
  'interleave_randomizations': True,
  'strategy': 'active-circuit'},
 'resilience': {'measure_mitigation': True,
  'zne_mitigation': True,
  'pec_mitigation': False,
  'zne': {'noise_factors': [1.0, 1.3, 1.6],
   'extrapolator': ['exponential', 'linear'],
   'extrapolated_noise_factors': [0.0,
    0.08421052631578947,
    0.16842105263157894,
    0.25263157894736843,
    0.3368421052631579,
    0.42105263157894735,
    0.5052631578947369,
    0.5894736842105263,
    0.6736842105263158,
    0.7578947368421053,
    0.8421052631578947,
    0.9263157894736842,
    1.0105263157894737,
    1.0947368421052632,
    1.1789473684210525,
    1.263157894736842,
    1.3473684210526315,
    1.431578947368421,
    1.5157894736842106,
    1.6]},
  'layer_noise_model': [LayerError(circuit=<qiskit.circuit.quantumcircuit.QuantumCircuit object at 0x168671910>, qubits=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62, 64, 65, 66, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155], error=PauliLindbladError(generators=['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...'], rates=[0.0005690271593536562,
    0.0006237089437969191,
    0.0008046341687049414,
    0.0008485023883264026,
    0.0007876695095380857,
    0.0007676815042042098,
    0.0008206616965509984,
    0.0007888881638843095,
    0.0007867318994871093,
    0.0008150648949970831,
    0.0007818084127166099,
    0.0007815085654916024,
    0.0006848037887607054,
    0.000780966030437397,
    0.0008025076616239815,
    0.0007954618831997621,
    0.0007802479804876805,
    0.0007984825479062877,
    0.0007942899835186643,
    0.0008151896363844669,
    0.0008030914061094395,
    0.0008141896617069651,
    0.0008046650669178899,
    0.0008017881050281064,
    0.0008159863736244479,
    0.0007957924488433468,
    0.0007969638251850363,
    0.0007894289577989867,
    0.0007839823966738993,
    0.000795618869925862,
    0.0007792089896145584,
    0.0007940277653084653,
    0.0007906381353593287,
    0.0008123090043568946,
    0.0007966645930476779,
    0.0007931639551353948,
    0.0008076551765046692,
    0.0006904098084804532,
    0.0007973818043598764,
    0.0006699089966050163,
    0.000808092832863703,
    0.0007782569886831677,
    0.0008074099883695058,
    0.0007873091857036918,
    0.0007973055234950945,
    0.0008026929189988963,
    0.0008038387508669984,
    0.0007819027058866285,
    0.0007799556033838467,
    0.0007948084858857824,
    0.0007872397619823883,
    0.0007927923206983606,
    0.0007764844639226869,
    0.000777883437652078,
    0.0008102569668062643,
    0.0007978296353321318,
    0.0007971738695088969,
    0.0007893127664960092,
    0.0007978889093189324,
    0.0008047851882027043,
    0.0007972598928408073,
    0.0007842169682726899,
    0.00078846066318096,
    0.0008120379806682296,
    0.0007983934990318318,
    0.0008048032894287294,
    0.0008146598990766071,
    0.0007887697858485254,
    0.0008110084048636048,
    0.0007936296918044903,
    0.000805332897023799,
    0.0007888086084099935,
    0.0007952959036906332,
    0.0007856863802346407,
    0.0008041775406085048,
    0.0008103913716976643,
    0.0007939095876073958,
    0.0008105606051831663,
    0.0007889555603933388,
    0.0007918034976178854,
    0.0007869041682912934,
    0.0008069926913176278,
    0.0007926871969045699,
    0.0007914611988162303,
    0.0007841951363186851,
    0.0007990073964847061,
    0.0008040838896513406,
    0.0007898094834318197,
    0.0007951989169291068,
    0.0007970616296144892,
    0.0008084329048172448,
    0.0007982821438638687,
    0.0007918929458584069,
    0.0007782556023084877,
    0.0008044776990092645,
    0.000804087044629199,
    0.0007872877970397593,
    0.0007897868950806197,
    0.00080096330309649,
    0.0008026682381336148,
    0.0008009621924796595,
    0.0008001879119959846,
    0.0008019924036976834,
    0.0008024697598945148,
    0.0007914066919699073,
    0.0007848074486906622,
    0.0008017844849056307,
    0.0007965903051965551,
    0.0007994876050193943,
    0.0007925996732609068,
    0.0008063734990065654,
    0.0008112866932166288,
    0.0007968556093698668,
    0.0008020955302996427,
    0.0008122188082066906,
    0.0008026109486851387,
    0.0008000037037530699,
    0.0007990883652732685,
    0.0008139166399932738,
    0.0008063771603089735,
    0.0007878488639683848,
    0.0007978933551869932,
    0.0007824862266967838,
    0.0007973882509046089,
    0.0007851754370773467,
    0.0008082127949039073,
    0.0007874128437023087,
    0.0007862773829962904,
    0.0007874528028438848,
    0.0008103348486346076,
    0.0007922851244896103,
    0.0007983824697094809,
    0.0007974219066951746,
    0.0007948699049255903,
    0.0008053419834099018,
    0.0007959706449176906,
    0.0007906073084867746,
    0.000822294913879308,
    0.0008167069761072195,
    0.0008052608956965803,
    0.0008065638802424003,
    0.0008062554073226447,
    0.0007916291764889877,
    0.0008024360970903076,
    0.0008146881058082257,
    0.0007940664084206336,
    0.0007878570178843868,
    0.0008072017932309652,
    0.0007978743761638888,
    0.0008077026925044063,
    0.0008040036370938025,
    0.000805997368316199,
    0.0007978097419682667,
    0.0008114056024584323]))],
  'pec': {}}}
```

```python
# Qubit map of the 1D array
q_map = coupling_map.reduce([layout[q] for q in range(num_qubits)]).graph.nodes()
sorted_qubits = sorted(q_map)


def exact_expval(x):
    # x is given in $[0, \pi]$
    h = np.array([[np.cos(x / 2), np.sin(x / 2)], [np.sin(x / 2), -np.cos(x / 2)]])
    gs_energy, gs_vec = np.linalg.eigh(h)
    return np.abs(gs_vec[0, 0]) ** 2 - np.abs(gs_vec[1, 0]) ** 2


exact_expvals = np.array([exact_expval(x) for x in parameter_values])
```

### Tracciare i risultati della simulazione di Trotter {#plot-trotter-simulation-results}

Questo codice traccia i valori di aspettazione, sia mitigati (estrapolati) che grezzi, mediati su tutti i qubit per ciascun parametro. Questo mostra quanto bene i risultati mitigati si avvicinano ai valori di aspettazione esatti.

```python
import matplotlib.pyplot as plt

fig, axes = plt.subplots(1, 3, figsize=(18, 4.5))

x_plot = parameter_values / np.pi

colors_nf = ["tab:blue", "tab:orange", "tab:green", "tab:red"]
colors_ex = ["tab:purple", "tab:olive"]

# Plot mitigated (extrapolated) expectation values
for i, ex_name in enumerate(["exponential", "linear"]):
    evs_ex = pub_result.data.evs_extrapolated[:, :, i, 0].mean(axis=0)
    stds_ex = pub_result.data.stds_extrapolated[:, :, i, 0].mean(axis=0)
    axes[0].errorbar(
        x_plot,
        evs_ex,
        yerr=1.96 * stds_ex,
        fmt="o",
        label=f"ZNE ({ex_name})",
        color=colors_ex[i],
    )
axes[0].plot(x_plot, exact_expvals, "-", label="Exact", color="k", linewidth=1.5)
axes[0].set_xlabel("$\\theta/\\pi$")
axes[0].set_ylabel("$\\langle Z \\rangle$ mediato")
axes[0].set_title("Valori di aspettazione mitigati (estrapolati)")
axes[0].legend()

# Plot raw expectation values for each noise factor
for i, nf in enumerate(noise_factors):
    evs_nf = pub_result.data.evs_noise_factors[:, :, i].mean(axis=0)
    stds_nf = pub_result.data.stds_noise_factors[:, :, i].mean(axis=0)
    axes[1].errorbar(
        x_plot,
        evs_nf,
        yerr=1.96 * stds_nf,
        fmt="o",
        label=f"noise factor={nf}",
        color=colors_nf[i],
    )
axes[1].plot(x_plot, exact_expvals, "-", label="Exact", color="k", linewidth=1.5)
axes[1].set_xlabel("$\\theta/\\pi$")
axes[1].set_ylabel("$\\langle Z \\rangle$ mediato")
axes[1].set_title("Valori di aspettazione grezzi (per fattore di rumore)")
axes[1].legend()

# Plot mitigated vs exact
for i, ex_name in enumerate(["exponential", "linear"]):
    evs_ex = pub_result.data.evs_extrapolated[:, :, i, 0].mean(axis=0)
    axes[2].plot(
        exact_expvals, evs_ex, "o", label=f"ZNE ({ex_name})", color=colors_ex[i]
    )

# Plot raw vs exact
for i, nf in enumerate(noise_factors):
    evs_nf = pub_result.data.evs_noise_factors[:, :, i].mean(axis=0)
    axes[2].plot(evs_nf, exact_expvals, "x", label=f"raw (nf={nf})", color=colors_nf[i])
axes[2].plot(
    [exact_expvals.min(), exact_expvals.max()],
    [exact_expvals.min(), exact_expvals.max()],
    "k-",
    label="Exact",
)
axes[2].set_xlabel("Risultato dell'esperimento")
axes[2].set_ylabel("Valore esatto")
axes[2].set_title("Mitigato vs esatto")
axes[2].legend()

plt.tight_layout()
plt.show()
```

![Diagramma dei valori di aspettazione mediati](/images/guides/probabilistic-error-amplification/average_expvals.png)

Dai grafici si può vedere che i risultati estrapolati con ZNE (viola e oliva) sono molto più vicini ai valori esatti (neri) rispetto ai risultati grezzi (blu, arancione, verde). Questo dimostra l'efficacia della mitigazione dell'errore probabilistica per questo circuito e backend.

### Tracciare i risultati di estrapolazione per singoli qubit {#plot-extrapolation-results-for-individual-qubits}

Il codice seguente crea un grafico per mostrare le curve di estrapolazione per diversi valori di theta su un qubit specifico.

```python
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

qubit_indices = [0, 1, 2, 3]

for ax_idx, qubit_idx in enumerate(qubit_indices):
    ax = axes[ax_idx // 2, ax_idx % 2]

    # Plot mitigated (extrapolated) expectation values
    for i, ex_name in enumerate(["exponential", "linear"]):
        evs_ex = pub_result.data.evs_extrapolated[qubit_idx, :, i, 0]
        stds_ex = pub_result.data.stds_extrapolated[qubit_idx, :, i, 0]
        ax.errorbar(
            x_plot,
            evs_ex,
            yerr=1.96 * stds_ex,
            fmt="o",
            label=f"ZNE ({ex_name})",
            color=colors_ex[i],
        )

    # Plot raw expectation values
    for i, nf in enumerate(noise_factors):
        evs_nf = pub_result.data.evs_noise_factors[qubit_idx, :, i]
        stds_nf = pub_result.data.stds_noise_factors[qubit_idx, :, i]
        ax.errorbar(
            x_plot,
            evs_nf,
            yerr=1.96 * stds_nf,
            fmt="x",
            label=f"raw (nf={nf})",
            color=colors_nf[i],
            alpha=0.6,
        )

    # Plot exact
    ax.plot(x_plot, exact_expvals, "-", label="Exact", color="k", linewidth=1.5)

    ax.set_xlabel("$\\theta/\\pi$")
    ax.set_ylabel("$\\langle Z \\rangle$")
    ax.set_title(f"Qubit virtuale {qubit_idx} (fisico {sorted_qubits[qubit_idx]})")
    ax.legend()

plt.tight_layout()
plt.show()
```

![Diagramma dei valori di aspettazione per singoli qubit](/images/guides/probabilistic-error-amplification/individual_expvals.png)

Questi grafici mostrano le prestazioni della mitigazione dell'errore per singoli qubit. Potete vedere che alcuni qubit hanno risultati mitigati migliori di altri, il che può essere dovuto alle diverse caratteristiche di rumore di ciascun qubit fisico.

## Passaggi successivi {#tutorial-survey}

<Admonition type="tip" title="Raccomandazioni">
    - Provate a modificare i parametri della configurazione (ad esempio, `noise_factors`, `learning_pair_depths`) per vedere come influenzano i risultati
    - Esplorate diversi metodi di estrapolazione per trovare quello che funziona meglio per il vostro circuito e backend
    - Confrontate i risultati con e senza il disaccoppiamento dinamico abilitato
    - Applicate questa tecnica ad altri circuiti quantistici e problemi di interesse
</Admonition>
