---
title: Tutorial
sidebar_label: Panoramica
sidebar_position: 1
description: Esplorate i tutorial IBM Quantum — eseguibili su RasQberry, tramite Binder o sul vostro server Jupyter.
---

# Tutorial {#tutorials}

Utilizzate questi tutorial per imparare come applicare Qiskit ai casi d'uso comuni del quantum computing.

- Iniziate con la serie di tutorial nella sezione [Per iniziare](#per-iniziare) se è la prima volta che eseguite codice su un computer quantistico.
- La sezione sui [workflow verso il vantaggio quantistico](#esplora-i-workflow-verso-il-vantaggio-quantistico) contiene esempi end-to-end di utilizzo di un computer quantistico per risolvere problemi del mondo reale. Questi tutorial si concentrano su algoritmi che sono candidati promettenti per ottenere un vantaggio computazionale di un computer quantistico rispetto a un computer classico.
- La sezione sulle [capacità di Qiskit](#sfrutta-le-capacità-di-qiskit) contiene esempi che utilizzano le tecniche più recenti e avanzate nell'ecosistema Qiskit per migliorare parte o l'intero flusso di lavoro particolare.

## Per iniziare {#get-started}

Questi tutorial sono per principianti pronti ad esplorare l'esecuzione di algoritmi quantistici su un computer quantistico.

* [Disuguaglianza CHSH](/tutorials/chsh-inequality)

## Esplora i workflow verso il vantaggio quantistico {#explore-workflows-toward-advantage}

I tutorial in questa sezione coprono dimostrazioni su larga scala di algoritmi quantistici.

<details>
  <summary>**Algoritmi di campionamento verificabile**</summary>

Gli algoritmi in questa categoria si concentrano su circuiti quantistici le cui distribuzioni di output codificano soluzioni a problemi strutturati con output verificabile. La verificabilità significa che potete controllare la coerenza tra i dati misurati, sia valutando la bitstring scelta sia sapendo che non si verificano falsi positivi.

I tutorial evidenziano tecniche in cui il campionamento ripetuto consente la stima di quantità specifiche del problema (ad esempio, valori di funzioni di costo o pesi spettrali). Questi metodi sono particolarmente rilevanti per compiti di ottimizzazione e simulazione con simmetrie.

* [Diagonalizzazione quantistica basata su campionamento di un Hamiltoniano chimico](/tutorials/sample-based-quantum-diagonalization)

* [Diagonalizzazione quantistica Krylov basata su campionamento di un modello reticolare fermionico](/tutorials/sample-based-krylov-quantum-diagonalization)

* [Quantum approximate optimization algorithm](/tutorials/quantum-approximate-optimization-algorithm)

* [Tecniche avanzate per QAOA](/tutorials/advanced-techniques-for-qaoa)

* [Pauli Correlation Encoding per ridurre i requisiti Maxcut](/tutorials/pauli-correlation-encoding-for-qaoa)

</details>

<details>
  <summary>**Stima di osservabili**</summary>

Questi tutorial si concentrano sulla stima di quantità fisicamente significative, come energia o valori di correlazione, preparando stati quantistici e misurando osservabili. Le tecniche includono approcci di circuiti sia variazionali che di Trotter che bilanciano l'espressività del circuito con l'efficienza della profondità del circuito. L'enfasi è posta sui workflow che riducono le richieste di risorse quantistiche mantenendo l'accuratezza e consentendo la stima pratica di osservabili in sistemi chimici e fisici.

* [Diagonalizzazione quantistica Krylov di Hamiltoniani reticolari](/tutorials/krylov-quantum-diagonalization)

* [Transizione di fase di Nishimori](/tutorials/nishimori-phase-transition)

* [Stima dell'energia dello stato fondamentale della catena di Heisenberg con VQE](/tutorials/spin-chain-vqe)

* [Quantum kernel training](/tutorials/quantum-kernel-training)

* [Migliora la classificazione delle feature usando projected quantum kernel](/tutorials/projected-quantum-kernels)

* [Disuguaglianza CHSH](/tutorials/chsh-inequality)

</details>

<details>
  <summary>**Algoritmi fault-tolerant**</summary>

Questa sezione presenta algoritmi con garanzie teoriche ben definite progettati per essere eseguiti su futuri hardware quantistici con correzione degli errori. I circuiti o l'overhead di campionamento per questi algoritmi scalano in modo non efficiente in profondità e quindi hanno maggiori probabilità di dimostrare un vantaggio quantistico quando esisteranno computer quantistici fault-tolerant. Questi tutorial illustrano come funzionano i metodi in ambienti idealizzati e dimostrano esempi su piccola scala.

* [Algoritmo di Shor](/tutorials/shors-algorithm)
* [Algoritmo di Grover](/tutorials/grovers-algorithm)

</details>

## Sfrutta le capacità di Qiskit {#leverage-qiskit-capabilities}

Questa sezione introduce capacità avanzate all'interno dell'ecosistema Qiskit che migliorano le prestazioni, l'affidabilità e la velocità durante l'esecuzione di algoritmi quantistici.

<details>
  <summary>**Ottimizzazione del carico di lavoro**</summary>

L'ottimizzazione del carico di lavoro si concentra sull'orchestrazione efficiente delle risorse classiche e quantistiche o su metodi personalizzati per migliorare la manipolazione dei circuiti quantistici.

* [Benchmark di circuiti dinamici con cut Bell pair](/tutorials/edc-cut-bell-pair-benchmarking)

* [Introduzione ai fractional gate](/tutorials/fractional-gates)

* [Introduzione al servizio transpiler AI-powered di Qiskit](/tutorials/ai-transpiler-introduction)

* [Ottimizzazioni di transpilation con SABRE](/tutorials/transpilation-optimizations-with-sabre)

* [Metodi di compilazione per circuiti di simulazione Hamiltoniana](/tutorials/compilation-methods-for-hamiltonian-simulation-circuits)

* [Entanglement a lungo raggio con circuiti dinamici](/tutorials/long-range-entanglement)

* [Simulazione di kicked Ising Hamiltonian con circuiti dinamici](/tutorials/dc-hex-ising)

</details>

<details>
<summary>**Qiskit Functions**</summary>

Le Qiskit Functions sono una raccolta di strumenti di gestione degli errori e applicazioni preconfezionati, che rendono facile progettare esperimenti su larga scala con circuiti, molecole, QUBO e altro.

- Progettate nuovi algoritmi con le **Circuit functions** -- con pipeline di transpilation, error suppression e error mitigation precostruite.

  * [Error mitigation con la IBM Circuit function](/tutorials/error-mitigation-with-qiskit-functions)

  * [Transverse-Field Ising Model con Performance Management di Q-CTRL](/tutorials/transverse-field-ising-model)

  * [Quantum Phase Estimation con le Qiskit Functions di Q-CTRL](/tutorials/quantum-phase-estimation-qctrl)

  * [Simula 2D tilted-field Ising con la funzione QESEM](/tutorials/qedma-2d-ising-with-qesem)

- Sperimentate con problemi specifici del dominio con le **Application functions** -- con input e output familiari ai risolutori classici.

  * [Quantum Portfolio Optimizer - A Qiskit Function by Global Data Quantum](/tutorials/global-data-quantum-optimizer)

  * [Ottimizzazione binaria di ordine superiore con Optimization Solver di Q-CTRL](/tutorials/solve-higher-order-binary-optimization-problems-with-q-ctrls-optimization-solver)

  * [Modella un fluido non viscoso in movimento usando QUICK-PDE](/tutorials/colibritd-pde)

  * [Curve PES di dissociazione con Qunova HiVQE](/tutorials/qunova-hivqe)

  * [Classificazione ensemble ibrida quantum-enhanced (workflow di stabilità della rete)](/tutorials/sml-classification)

  * [Risolvi il problema Market Split con Iskay Quantum Optimizer di Kipu Quantum](/tutorials/solve-market-split-problem-with-iskay-quantum-optimizer)

</details>

<details>
  <summary>**Qiskit addons**</summary>

Gli addon consentono la manipolazione avanzata di circuiti, come il taglio, la retropropagazione di osservabili o l'approssimazione di circuiti, che permettono agli utenti di aggirare le limitazioni hardware al costo di un maggiore overhead di calcolo classico.

* [Formule multi-prodotto per ridurre l'errore di Trotter](/tutorials/multi-product-formula)

* [Compilazione quantistica approssimata per circuiti di evoluzione temporale](/tutorials/approximate-quantum-compilation-for-time-evolution)

* [Operator backpropagation (OBP) per la stima di valori di aspettazione](/tutorials/operator-back-propagation)

* [Wire cutting per la stima di valori di aspettazione](/tutorials/wire-cutting)

* [Circuit cutting per condizioni al contorno periodiche](/tutorials/periodic-boundary-conditions-with-circuit-cutting)

* [Circuit cutting per la riduzione della profondità](/tutorials/depth-reduction-with-circuit-cutting)

* [Readout error mitigation per la primitiva Sampler usando M3](/tutorials/readout-error-mitigation-sampler)

</details>

<details>
  <summary>**Error mitigation**</summary>

L'error mitigation affronta la sfida del rumore senza una completa fault tolerance recuperando valori di aspettazione accurati attraverso la manipolazione controllata dei circuiti e il post-processing.

* [Error mitigation a scala di utilità con amplificazione probabilistica dell'errore](/tutorials/probabilistic-error-amplification)

* [Combina opzioni di error mitigation con la primitiva Estimator](/tutorials/combine-error-mitigation-techniques)

* [Benchmarking in tempo reale per la selezione dei qubit](/tutorials/real-time-benchmarking-for-qubit-selection)

</details>

<details>
  <summary>**Error detection**</summary>

L'error detection identifica operazioni difettose per restituire risultati privi di rumore shot-by-shot tramite post-processing.

* [Codici di ripetizione](/tutorials/repetition-codes)

* [Error detection a basso overhead con codici spaziotemporali](/tutorials/ghz-spacetime-codes)

</details>

