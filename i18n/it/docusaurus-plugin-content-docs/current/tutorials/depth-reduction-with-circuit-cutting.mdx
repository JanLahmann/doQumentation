---
title: "Taglio di circuiti per la riduzione della profondità"
sidebar_label: "Taglio di circuiti per la riduzione della profondità"
description: "Costruire un pattern Qiskit per tagliare le porte in un circuito quantistico per ridurre la profondità del circuito."
notebook_path: "docs/tutorials/depth-reduction-with-circuit-cutting.ipynb"
---

<OpenInLabBanner notebookPath="docs/tutorials/depth-reduction-with-circuit-cutting.ipynb" />



*Stima di utilizzo: Otto minuti su un processore Eagle (NOTA: Questa è solo una stima. Il vostro tempo di esecuzione potrebbe variare.)*
## Contesto {#background}

Questo tutorial dimostra come costruire un `pattern Qiskit` per tagliare le porte in un circuito quantistico al fine di ridurre la profondità del circuito. Per una discussione più approfondita sul taglio dei circuiti, visitate la [documentazione dell'addon Qiskit per il taglio di circuiti](https://qiskit.github.io/qiskit-addon-cutting/).
## Requisiti {#requirements}

Prima di iniziare questo tutorial, assicuratevi di avere installato quanto segue:
- Qiskit SDK v2.0 o successivo, con supporto per la [visualizzazione](https://docs.quantum.ibm.com/api/qiskit/visualization)
- Qiskit Runtime v0.22 o successivo (`pip install qiskit-ibm-runtime`)
- Addon Qiskit per il taglio di circuiti v0.9.0 o successivo (`pip install qiskit-addon-cutting`)
## Configurazione {#setup}

```python
# Added by doQumentation — installs packages not in the Binder environment
%pip install -q qiskit-addon-cutting
```

```python
import numpy as np

from qiskit.circuit.library import EfficientSU2
from qiskit.quantum_info import PauliList, Statevector, SparsePauliOp
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

from qiskit_addon_cutting import (
    cut_gates,
    generate_cutting_experiments,
    reconstruct_expectation_values,
)

from qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2
```

## Passaggio 1: Mappare gli input classici a un problema quantistico {#step-1-map-classical-inputs-to-a-quantum-problem}

Implementeremo il nostro pattern Qiskit utilizzando i quattro passaggi delineati nella [documentazione](/guides/intro-to-patterns). In questo caso, simuleremo i valori di aspettazione su un circuito di una certa profondità tagliando le porte che risultano in porte swap ed eseguendo sottoesperimenti su circuiti meno profondi. Il taglio delle porte è rilevante per i Passaggi 2 (ottimizzare il circuito per l'esecuzione quantistica decomponendo le porte distanti) e 4 (post-elaborazione per ricostruire i valori di aspettazione sul circuito originale).
Nel primo passaggio, genereremo un circuito dalla libreria di circuiti Qiskit e definiremo alcune osservabili.

*   Input: Parametri classici per definire un circuito
*   Output: Circuito astratto e osservabili

```python
circuit = EfficientSU2(num_qubits=4, entanglement="circular").decompose()
circuit.assign_parameters([0.4] * len(circuit.parameters), inplace=True)
observables = PauliList(["ZZII", "IZZI", "IIZZ", "XIXI", "ZIZZ", "IXIX"])
circuit.draw("mpl", scale=0.8, style="iqp")
```

![Output of the previous code cell](/docs/images/tutorials/depth-reduction-with-circuit-cutting/extracted-outputs/54ed0f13-0.avif)

## Passaggio 2: Ottimizzare il problema per l'esecuzione su hardware quantistico {#step-2-optimize-problem-for-quantum-hardware-execution}

*   Input: Circuito astratto e osservabili
*   Output: Circuito target e osservabili prodotti tagliando le porte distanti per ridurre la profondità del circuito traspilato

Scegliamo un layout iniziale che richiede due swap per eseguire le porte tra i qubit 3 e 0 e altri due swap per riportare i qubit alle loro posizioni iniziali. Scegliamo `optimization_level=3`, che è il livello più alto di ottimizzazione disponibile con un gestore di passaggi preimpostato.

```python
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, min_num_qubits=circuit.num_qubits, simulator=False
)

pm = generate_preset_pass_manager(
    optimization_level=3, initial_layout=[0, 1, 2, 3], backend=backend
)
transpiled_qc = pm.run(circuit)
```

![Coupling map showing the qubits that will need to be swapped](/docs/images/tutorials/depth-reduction-with-circuit-cutting/swaps.avif)

```python
print(f"Transpiled circuit depth: {transpiled_qc.depth()}")
transpiled_qc.draw("mpl", scale=0.4, idle_wires=False, style="iqp", fold=-1)
```

```text
Transpiled circuit depth: 103
```

![Output of the previous code cell](/docs/images/tutorials/depth-reduction-with-circuit-cutting/extracted-outputs/4fe4af43-1.avif)

*Trovare e tagliare le porte distanti:* Sostituiremo le porte distanti (porte che collegano qubit non locali, 0 e 3) con oggetti `TwoQubitQPDGate` specificando i loro indici. `cut_gates` sostituirà le porte negli indici specificati con oggetti `TwoQubitQPDGate` e restituirà anche un elenco di istanze `QPDBasis` -- una per ciascuna decomposizione di porta. L'oggetto `QPDBasis` contiene informazioni su come decomporre le porte tagliate in operazioni a singolo qubit.

```python
# Find the indices of the distant gates
cut_indices = [
    i
    for i, instruction in enumerate(circuit.data)
    if {circuit.find_bit(q)[0] for q in instruction.qubits} == {0, 3}
]

# Decompose distant CNOTs into TwoQubitQPDGate instances
qpd_circuit, bases = cut_gates(circuit, cut_indices)

qpd_circuit.draw("mpl", scale=0.8)
```

![Output of the previous code cell](/docs/images/tutorials/depth-reduction-with-circuit-cutting/extracted-outputs/23e3d25e-0.avif)

*Generare i sottoesperimenti da eseguire sul backend*: `generate_cutting_experiments` accetta un circuito contenente istanze di `TwoQubitQPDGate` e osservabili come `PauliList`.

Per simulare il valore di aspettazione del circuito completo, molti sottoesperimenti vengono generati dalla distribuzione di quasiprobabilità congiunta delle porte decomposte e poi eseguiti su uno o più backend. Il numero di campioni prelevati dalla distribuzione è controllato da `num_samples`, e viene fornito un coefficiente combinato per ciascun campione unico. Per maggiori informazioni su come vengono calcolati i coefficienti, fate riferimento al [materiale esplicativo](https://qiskit.github.io/qiskit-addon-cutting/explanation/index.html).

```python
# Generate the subexperiments and sampling coefficients
subexperiments, coefficients = generate_cutting_experiments(
    circuits=qpd_circuit, observables=observables, num_samples=np.inf
)
```

*Per confronto, vediamo che i sottoesperimenti QPD saranno meno profondi dopo il taglio delle porte distanti*: Ecco un esempio di un sottoesperimento scelto arbitrariamente generato dal circuito QPD. La sua profondità è stata ridotta di più della metà. Molti di questi sottoesperimenti probabilistici devono essere generati e valutati per ricostruire un valore di aspettazione del circuito più profondo.

```python
# Transpile the decomposed circuit to the same layout
transpiled_qpd_circuit = pm.run(subexperiments[100])

print(f"Original circuit depth after transpile: {transpiled_qc.depth()}")
print(
    f"QPD subexperiment depth after transpile: {transpiled_qpd_circuit.depth()}"
)
transpiled_qpd_circuit.draw(
    "mpl", scale=0.6, style="iqp", idle_wires=False, fold=-1
)
```

```text
Original circuit depth after transpile: 103
QPD subexperiment depth after transpile: 46
```

![Output of the previous code cell](/docs/images/tutorials/depth-reduction-with-circuit-cutting/extracted-outputs/70e2f1b6-1.avif)

*D'altra parte, il taglio comporta la necessità di campionamento aggiuntivo*. Qui tagliamo tre porte CNOT, con un sovraccarico di campionamento risultante di $9^3$. Per maggiori informazioni sul sovraccarico di campionamento causato dal taglio di circuiti, fate riferimento alla [documentazione del Circuit Knitting Toolbox](https://qiskit-extensions.github.io/circuit-knitting-toolbox/circuit_cutting/explanation/index.html).

```python
print(f"Sampling overhead: {np.prod([basis.overhead for basis in bases])}")
```

```text
Sampling overhead: 729.0
```

## Passaggio 3: Eseguire utilizzando le primitive Qiskit {#step-3-execute-using-qiskit-primitives}

Eseguire i circuiti target ("sottoesperimenti") con la Primitiva Sampler.

*   Input: Circuiti target
*   Output: Distribuzioni di quasiprobabilità

```python
# Transpile the subexperiments to the backend's instruction set architecture (ISA)
isa_subexperiments = pm.run(subexperiments)

# Set up the Qiskit Runtime Sampler primitive.  For a fake backend, this will use a local simulator.
sampler = SamplerV2(backend)

# Submit the subexperiments
job = sampler.run(isa_subexperiments)
```

```python
# Retrieve the results
results = job.result()
```

```python
print(job.job_id())
```

```text
czypg1r6rr3g008mgp6g
```

## Passaggio 4: Post-elaborare e restituire il risultato nel formato classico desiderato {#step-4-post-process-and-return-result-in-desired-classical-format}

Utilizzare i risultati dei sottoesperimenti, le sotto-osservabili e i coefficienti di campionamento per ricostruire il valore di aspettazione del circuito originale.

Input: Distribuzioni di quasiprobabilità
Output: Valori di aspettazione ricostruiti

```python
reconstructed_expvals = reconstruct_expectation_values(
    results,
    coefficients,
    observables,
)
# Reconstruct final expectation value
final_expval = np.dot(reconstructed_expvals, [1] * len(observables))
print("Final reconstructed expectation value")
print(final_expval)
```

```text
Final reconstructed expectation value
1.0751342773437473
```

```python
ideal_expvals = [
    Statevector(circuit).expectation_value(SparsePauliOp(observable))
    for observable in observables
]
print("Ideal expectation value")
print(np.dot(ideal_expvals, [1] * len(observables)).real)
```

```text
Ideal expectation value
1.2283177520039992
```

## Sondaggio sul tutorial {#tutorial-survey}

Vi preghiamo di compilare questo breve sondaggio per fornire feedback su questo tutorial. Le vostre opinioni ci aiuteranno a migliorare i nostri contenuti e l'esperienza utente.

[Link to survey](https://your.feedback.ibm.com/jfe/form/SV_2ftYFf9t72yFNIO)
