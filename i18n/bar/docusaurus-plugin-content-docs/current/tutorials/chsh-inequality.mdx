---
title: "CHSH-Ungleichung"
sidebar_label: "CHSH-Ungleichung"
description: "Führts a Experiment auf eim Quantencomputer durch, um de Verletzung vo da CHSH-Ungleichung mit em Estimator-Primitiv z'zeign."
notebook_path: "docs/tutorials/chsh-inequality.ipynb"
---
{/* doqumentation-source-hash: 05263e84 */}

<OpenInLabBanner notebookPath="docs/tutorials/chsh-inequality.ipynb" />



{/* cspell:ignore zorder */}

*Nutzungsschätzung: Zwoa Minuten auf eim Heron r2-Prozessor (HINWEIS: Des is nur a Schätzung. Ihri Laufzeit ko variieren.)*
## Hintergrund {#hintergrund}

In dem Tutorial führt mia a Experiment auf eim Quantencomputer durch, um de Verletzung vo da CHSH-Ungleichung mit em Estimator-Primitiv z'zeign.

De CHSH-Ungleichung, benannt nach de Autoren Clauser, Horne, Shimony und Holt, wird verwendet, um Bells Theorem (1969) experimentell z'beweisn. Des Theorem besagt, dass lokale Theorien mit verborgenen Variablen manche Konsequenzen vo da Verschränkung in da Quantenmechanik ned erklärn kinntn. De Verletzung vo da CHSH-Ungleichung wird verwendet, um z'zeign, dass de Quantenmechanik mit lokalen Theorien mit verborgenen Variablen ned vereinbar is. Des is a wichdigs Experiment zum Verständnis vo de Grundlagen vo da Quantenmechanik.

Da Nobelpreis für Physik 2022 is an Alain Aspect, John Clauser und Anton Zeilinger verliehen worn, unter anderem für ihre Pionierarbeit in da Quanteninformationswissenschaft und insbesondere für ihre Experimente mit verschränkten Photonen, wo de Verletzung vo de Bellschen Ungleichungen demonstriert ham.
## Anforderungen {#anforderungen}

Stellt's vor dem Beginn von dem Tutorial sicher, dass mia Folgendes installiert ham:

* Qiskit SDK v1.0 oder neuer, mit [visualization](https://docs.quantum.ibm.com/api/qiskit/visualization)-Unterstützung
* Qiskit Runtime (`pip install qiskit-ibm-runtime`) v0.22 oder neuer
## Setup {#setup}

```python
# General
import numpy as np

# Qiskit imports
from qiskit import QuantumCircuit
from qiskit.circuit import Parameter
from qiskit.quantum_info import SparsePauliOp
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

# Qiskit Runtime imports
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_runtime import EstimatorV2 as Estimator

# Plotting routines
import matplotlib.pyplot as plt
import matplotlib.ticker as tck
```

## Schritt 1: Klassische Eingaben auf a Quantenproblem abbildn {#schritt-1-klassische-eingaben-auf-ein-quantenproblem-abbilden}
Für des Experiment erstellt mia a verschränkts Paar, bei dem mia jeds Qubit auf zwoa verschiedene Basen misst. Mia bezeichnen de Basen für des erschte Qubit mit $A$ und $a$ und de Basen für des zweite Qubit mit $B$ und $b$. Des ermöglicht uns, de CHSH-Größe $S_1$ z'berechnen:

$$
S_1 = A(B-b) + a(B+b).
$$

Jede Observable is entweder $+1$ oder $-1$. Klar is, dass einer vo de Terme $B\pm b$ gleich $0$ sei muss und da andere $\pm 2$ sei muss. Deswegn is $S_1 = \pm 2$. Da Durchschnittswert vo $S_1$ muss de Ungleichung erfülln:

$$
|\langle S_1 \rangle|\leq 2.
$$

De Entwicklung vo $S_1$ in Bezug auf $A$, $a$, $B$ und $b$ ergibt:

$$
|\langle S_1 \rangle| = |\langle AB \rangle - \langle Ab \rangle + \langle aB \rangle + \langle ab \rangle| \leq 2
$$

Ihr kinnts a weitane CHSH-Größe $S_2$ definieren:

$$
S_2 = A(B+b) - a(B-b),
$$

Des führt zu ana weiteren Ungleichung:

$$
|\langle S_2 \rangle| = |\langle AB \rangle + \langle Ab \rangle - \langle aB \rangle + \langle ab \rangle| \leq 2
$$

Wenn de Quantenmechanik durch lokale Theorien mit verborgenen Variablen beschrieben wern ko, müssn de vorherigen Ungleichungen wahr sein. Wie aber in dem Tutorial demonstriert wird, kinntn dese Ungleichungen auf eim Quantencomputer verletzt wern. Deswegn is de Quantenmechanik ned mit lokalen Theorien mit verborgenen Variablen vereinbar.
Falls Ihr mehr Theorie lernen wollts, erkundet's [Entanglement in Action](/learning/courses/basics-of-quantum-information/entanglement-in-action/chsh-game) mit em John Watrous.
Ihr werdts a verschränkts Paar zwischen zwoa Qubits in eim Quantencomputer erstellen, indem Ihr de Bell-Zustand $|\Phi^+\rangle = \frac{|00\rangle + |11\rangle}{\sqrt{2}}$ erzeugt's. Mit em Estimator-Primitiv kinnts Ihr direkt de benötigten Erwartungswerte ($\langle AB \rangle, \langle Ab \rangle, \langle aB \rangle$ und $\langle ab \rangle$) kriagn, um de Erwartungswerte vo de beiden CHSH-Größen $\langle S_1\rangle$ und $\langle S_2\rangle$ z'berechnen. Vor da Einführung vom Estimator-Primitiv ham's de Erwartungswerte aus de Messergebnisse konstruieren müssn.

Ihr werdts des zweite Qubit in de $Z$- und $X$-Basen messen. Des erschte Qubit wird ebenfalls in orthogonalen Basen gmessen, aber mit eim Winkel bezüglich vom zweiten Qubit, den mia zwischen $0$ und $2\pi$ variieren wern. Wie Ihr segn werdts, macht des Estimator-Primitiv des Ausführen vo parametrisierten Schaltkreisn sehr einfach. Anstatt a Reihe vo CHSH-Schaltkreisn z'erstellen, müssts Ihr nur *oabn* CHSH-Schaltkreis mit eim Parameter erstellen, wo de Messwinkel angibt, und a Reihe vo Phasenwerten für de Parameter.

Schließlich werdts Ihr de Ergebnisse analysieren und gengn de Messwinkel auftragen. Ihr werdts segn, dass für oan bestimmten Bereich vo Messwinkeln de Erwartungswerte vo de CHSH-Größen $|\langle S_1\rangle| > 2$ oder $|\langle S_2\rangle| > 2$ san, was de Verletzung vo da CHSH-Ungleichung demonstriert.

```python
# To run on hardware, select the backend with the fewest number of jobs in the queue
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=127
)
backend.name
```

```text
'ibm_kingston'
```

### Oan parametrisierten CHSH-Schaltkreis erstellen {#einen-parametrisierten-chsh-schaltkreis-erstellen}

Zerscht schreibt mia de Schaltkreis mit em Parameter $\theta$, den mia `theta` nennt. Des [`Estimator`-Primitiv](https://docs.quantum-computing.ibm.com/api/qiskit-ibm-runtime/qiskit_ibm_runtime.EstimatorV2) ko de Schaltkreisaufbau und de Ausgabeanalyse enorm vereinfachen, indem's direkt Erwartungswerte vo Observablen liefert. Viele interessante Probleme, insbesondere für kurzfristige Anwendungen auf verrauschten Systemen, kinntn in Form vo Erwartungswerten formuliert wern. Des `Estimator` (V2)-Primitiv ko automatisch de Messbasis basierend auf da bereitgestellten Observable ändern.

```python
theta = Parameter("$\\theta$")

chsh_circuit = QuantumCircuit(2)
chsh_circuit.h(0)
chsh_circuit.cx(0, 1)
chsh_circuit.ry(theta, 0)
chsh_circuit.draw(output="mpl", idle_wires=False, style="iqp")
```

![Output of the previous code cell](/docs/images/tutorials/chsh-inequality/extracted-outputs/6c77e40a-0.avif)

### A Liste vo Phasenwerten erstellen, de später zugewiesen wern {#eine-liste-von-phasenwerten-erstellen-die-später-zugewiesen-werden}

Nachdem Ihr de parametrisierten CHSH-Schaltkreis erstellt's ham, erstellt's a Liste vo Phasenwerten, de dem Schaltkreis im nächsten Schritt zugewiesen wern. Ihr kinnts de folgenden Code verwenden, um a Liste vo 21 Phasenwerten im Bereich vo $0$ bis $2 \pi$ mit gleichem Abstand z'erstellen, also $0$, $0.1 \pi$, $0.2 \pi$, ..., $1.9 \pi$, $2 \pi$.

```python
number_of_phases = 21
phases = np.linspace(0, 2 * np.pi, number_of_phases)
# Phases need to be expressed as list of lists in order to work
individual_phases = [[ph] for ph in phases]
```

### Observablen {#observablen}

Jetzt brauchma Observablen, aus denen mia de Erwartungswerte berechnen kinntn. In unserem Fall betrachten mia orthogonale Basen für jeds Qubit, wobei de parametrisierte $Y$-Rotation für des erschte Qubit de Messbasis nahezu kontinuierlich in Bezug auf de Basis vom zweiten Qubit variiert. Mia wählen deswegn de Observablen $ZZ$, $ZX$, $XZ$ und $XX$.

```python
# <CHSH1> = <AB> - <Ab> + <aB> + <ab> -> <ZZ> - <ZX> + <XZ> + <XX>
observable1 = SparsePauliOp.from_list(
    [("ZZ", 1), ("ZX", -1), ("XZ", 1), ("XX", 1)]
)

# <CHSH2> = <AB> + <Ab> - <aB> + <ab> -> <ZZ> + <ZX> - <XZ> + <XX>
observable2 = SparsePauliOp.from_list(
    [("ZZ", 1), ("ZX", 1), ("XZ", -1), ("XX", 1)]
)
```

## Schritt 2: Problem für de Ausführung auf Quantenhardware optimieren {#schritt-2-problem-für-die-ausführung-auf-quantenhardware-optimieren}
Um de Gesamtausführungszeit vom Job z'reduzieren, akzeptieren V2-Primitive nur Schaltkreise und Observablen, de de vom Zielsystem unterstützten Anweisungen und de Konnektivität entsprechn (bezeichnet als Instruction Set Architecture (ISA)-Schaltkreise und -Observablen).
### ISA-Schaltkreis {#isa-schaltkreis}

```python
target = backend.target
pm = generate_preset_pass_manager(target=target, optimization_level=3)

chsh_isa_circuit = pm.run(chsh_circuit)
chsh_isa_circuit.draw(output="mpl", idle_wires=False, style="iqp")
```

![Output of the previous code cell](/docs/images/tutorials/chsh-inequality/extracted-outputs/9a5561eb-0.avif)

### ISA-Observablen {#isa-observablen}
Genauso müssma de Observablen transformieren, um se backend-kompatibel z'machn, bevor mia Jobs mit [`Runtime Estimator V2`](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/estimator-v2#run) ausführen. Mia kinntn de Transformation mit da `apply_layout`-Methode vom `SparsePauliOp`-Objekt durchführen.

```python
isa_observable1 = observable1.apply_layout(layout=chsh_isa_circuit.layout)
isa_observable2 = observable2.apply_layout(layout=chsh_isa_circuit.layout)
```

## Schritt 3: Ausführn mit Qiskit-Primitiven {#schritt-3-ausführen-mit-qiskit-primitiven}

Um des gesamte Experiment in eim einzigen Aufruf vom [`Estimator`](https://docs.quantum-computing.ibm.com/api/qiskit-ibm-runtime/qiskit_ibm_runtime.EstimatorV2) ausführn.
Mia kinntn oa [Qiskit Runtime `Estimator`](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/estimator-v2)-Primitiv erstellen, um unsere Erwartungswerte z'berechnen. De `EstimatorV2.run()`-Methode akzeptiert oa Iterable vo `primitive unified blocs (PUBs)`. Jeds PUB is oa Iterable im Format `(circuit, observables, parameter_values: Optional, precision: Optional)`.

```python
# To run on a local simulator:
# Use the StatevectorEstimator from qiskit.primitives instead.

estimator = Estimator(mode=backend)

pub = (
    chsh_isa_circuit,  # ISA circuit
    [[isa_observable1], [isa_observable2]],  # ISA Observables
    individual_phases,  # Parameter values
)

job_result = estimator.run(pubs=[pub]).result()
```

## Schritt 4: Nachbearbeitung und Rückgabe vom Ergebnis im gwünschten klassischen Format {#schritt-4-nachbearbeitung-und-rückgabe-des-ergebnisses-im-gewünschten-klassischen-format}

Da Estimator gibt Erwartungswerte für beide Observablen zruck, $\langle ZZ \rangle - \langle ZX \rangle + \langle XZ \rangle + \langle XX \rangle$ und $\langle ZZ \rangle + \langle ZX \rangle - \langle XZ \rangle + \langle XX \rangle$.

```python
chsh1_est = job_result[0].data.evs[0]
chsh2_est = job_result[0].data.evs[1]
```

```python
fig, ax = plt.subplots(figsize=(10, 6))

# results from hardware
ax.plot(phases / np.pi, chsh1_est, "o-", label="CHSH1", zorder=3)
ax.plot(phases / np.pi, chsh2_est, "o-", label="CHSH2", zorder=3)

# classical bound +-2
ax.axhline(y=2, color="0.9", linestyle="--")
ax.axhline(y=-2, color="0.9", linestyle="--")

# quantum bound, +-2√2
ax.axhline(y=np.sqrt(2) * 2, color="0.9", linestyle="-.")
ax.axhline(y=-np.sqrt(2) * 2, color="0.9", linestyle="-.")
ax.fill_between(phases / np.pi, 2, 2 * np.sqrt(2), color="0.6", alpha=0.7)
ax.fill_between(phases / np.pi, -2, -2 * np.sqrt(2), color="0.6", alpha=0.7)

# set x tick labels to the unit of pi
ax.xaxis.set_major_formatter(tck.FormatStrFormatter("%g $\\pi$"))
ax.xaxis.set_major_locator(tck.MultipleLocator(base=0.5))

# set labels, and legend
plt.xlabel("Theta")
plt.ylabel("CHSH witness")
plt.legend()
plt.show()
```

![Output of the previous code cell](/docs/images/tutorials/chsh-inequality/extracted-outputs/f6267448-0.avif)

In da Abbildung grenzen de Linien und de grauen Bereiche de Grenzen ab; de äußersten (strichpunktierten) Linien begrenzen de Quantengrenzen ($\pm 2$), während de inneren (gestrichelten) Linien de klassischen Grenzen ($\pm 2\sqrt{2}$) begrenzen. Ihr kinnts segn, dass es Bereiche gibt, wo de CHSH-Zeugengröße de klassischen Grenzen überschreitet. Herzlichen Glückwunsch! Mia ham erfolgreich de Verletzung vo da CHSH-Ungleichung in eim echten Quantensystem demonstriert!
## Tutorial-Umfrage {#tutorial-umfrage}

Bitte machet's bei derer kurzen Umfrage mit, um Feedback zu dem Tutorial z'gebn. Eure Erkenntnisse helfn uns, unsere Inhaltsangebote und Benutzererfahrung z'verbessern.

[Link zur Umfrage](https://your.feedback.ibm.com/jfe/form/SV_3xxAgm1SF1wGp9k)
