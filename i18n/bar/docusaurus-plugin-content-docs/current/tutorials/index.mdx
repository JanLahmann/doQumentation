---
title: Tutorials
sidebar_label: Übersicht
sidebar_position: 1
description: Durchschaugn S' de IBM Quantum Tutorials — ausführbar auf RasQberry, über Binder oda auf Ihrem eigenen Jupyter-Server.
---

# Tutorials

Nutzts de Tutorials, um z'lerna, wia ma Qiskit auf gängige Anwendungsfälle im Quantencomputing owendn ko.

- Fangts mit de Tutorials im Abschnitt [Erste Schritte](#erste-schritte) o, wemma zum erschtn Moi Code auf am Quantencomputer auführt.
- Da Abschnitt über [Workflows in Richtung Vorteil](#workflows-in-richtung-vorteil-erkunden) enthoit durchgängige Beispiele, wia ma an Quantencomputer zur Lösung echter Probleme hernehma ko. De Tutorials konzentriern si auf Algorithmen, de vielversprechende Kandidaten dafür san, an rechnerischen Vorteil vom Quantencomputer gegenüber am klassischen Computer z'erreichen.
- Da Abschnitt über [Qiskit-Funktionalitäten](#qiskit-funktionalitäten-nutzen) enthoit Beispiele, de de neuesten und fortschrittlichsten Techniken im Qiskit-Ökosystem verwendn, um an Teil oda den ganzen Ablauf von am bestimmten Workflow z'verbessern.

## Erste Schritte

De Tutorials san für Anfänger, de bereit san, de Ausführung von Quantenalgorithmen auf am Quantencomputer z'erkunden.

* [CHSH-Ungleichung](/tutorials/chsh-inequality)

## Workflows in Richtung Vorteil erkunden

De Tutorials in dem Abschnitt behandeln groß olegde Demonstrationen von Quantenalgorithmen.

<details>
  <summary>**Verifizierbare Sampling-Algorithmen**</summary>

De Algorithmen in dera Kategorie konzentriern si auf Quantenschaltungen, wo de Ausgabeverteilungen Lösungen für strukturierte Probleme mit verifizierbarer Ausgabe eincodieren. Verifizierbarkeit bedeutet, dass ma de Konsistenz zwischn gemessenen Daten überprüfn ko, entweder durch Auswertung von da gewählten Bitfolge oda durch des Wissen, dass koa Falsch-Positiven auftreten.

De Tutorials hebn Techniken hervor, bei denen wiederholts Sampling de Schätzung von problemspezifischen Größen ermöglicht (zum Beispü Kostenfunktionswerte oda spektrale Gewichte). De Methoden san besonders relevant für Optimierungs- und Simulationsaufgaben mit Symmetrien.

* [Sample-basierte Quantendiagonalisierung eines Chemie-Hamiltonians](/tutorials/sample-based-quantum-diagonalization)

* [Sample-basierte Krylov-Quantendiagonalisierung eines fermionischen Gittermodells](/tutorials/sample-based-krylov-quantum-diagonalization)

* [Quantum Approximate Optimization Algorithm](/tutorials/quantum-approximate-optimization-algorithm)

* [Fortgeschrittene Techniken für QAOA](/tutorials/advanced-techniques-for-qaoa)

* [Pauli-Korrelationscodierung zur Reduzierung von Maxcut-Anforderungen](/tutorials/pauli-correlation-encoding-for-qaoa)

</details>

<details>
  <summary>**Schätzung von Observablen**</summary>

De Tutorials konzentriern si auf de Schätzung von physikalisch bedeutsamen Größen, wia Energie oda Korrelationswerte, durch de Vorbereitung von Quantenzuständen und de Messung von Observablen. Zu de Techniken ghörn sowoi variationelle als a Trotterisierte Schaltungsansätze, de de Ausdrucksstärke von da Schaltung mit da Effizienz von da Schaltungstiefe in Einklang bring. Da Schwerpunkt liegt auf Workflows, de de Anforderungen an Quantenressourcen reduzieren und gleichzeitig de Genauigkeit behaltn, und de praktische Schätzung von Observablen in chemischen und physikalischen Systemen ermöglichen.

* [Krylov-Quantendiagonalisierung von Gitter-Hamiltonians](/tutorials/krylov-quantum-diagonalization)

* [Nishimori-Phasenübergang](/tutorials/nishimori-phase-transition)

* [Grundzustandsenergieschätzung der Heisenberg-Kette mit VQE](/tutorials/spin-chain-vqe)

* [Quantum Kernel Training](/tutorials/quantum-kernel-training)

* [Verbesserung der Merkmalsklassifizierung mit projizierten Quantenkernels](/tutorials/projected-quantum-kernels)

* [CHSH-Ungleichung](/tutorials/chsh-inequality)

</details>

<details>
  <summary>**Fehlertolerante Algorithmen**</summary>

In dem Abschnitt san Algorithmen mit klar definierten theoretischen Garantien, de für de Ausführung auf zukünftiger fehlerkorrigierter Quantenhardware entwickelt worn san. De Schaltungen oda da Sampling-Overhead für de Algorithmen skalieren auf a Weis, de ned tiefeneffizient is, und demonstriern daher eher an Quantenvorteil, wann fehlertolerante Quantencomputer existieren. De Tutorials zeign, wia de Methoden in idealisierten Umgebungen funktionieren, und demonstriern Beispiele im kleinen Maßstab.

* [Shors Algorithmus](/tutorials/shors-algorithm)
* [Grovers Algorithmus](/tutorials/grovers-algorithm)

</details>

## Qiskit-Funktionalitäten nutzen

In dem Abschnitt werdn fortgeschrittene Funktionalitäten im Qiskit-Ökosystem vorgestellt, de Leistung, Zuverlässigkeit und Geschwindigkeit bei da Ausführung von Quantenalgorithmen verbessern.

<details>
  <summary>**Workload-Optimierung**</summary>

De Workload-Optimierung konzentriert si entweder auf de effiziente Orchestrierung von klassischen und Quantenressourcen oda auf maßgeschneiderte Methoden zur Verbesserung von da Manipulation von Quantenschaltungen.

* [Benchmark für dynamische Schaltungen mit geschnittenen Bell-Paaren](/tutorials/edc-cut-bell-pair-benchmarking)

* [Einführung in Fractional Gates](/tutorials/fractional-gates)

* [Einführung in den Qiskit AI-gestützten Transpiler-Service](/tutorials/ai-transpiler-introduction)

* [Transpilationsoptimierungen mit SABRE](/tutorials/transpilation-optimizations-with-sabre)

* [Kompilierungsmethoden für Hamiltonian-Simulationsschaltungen](/tutorials/compilation-methods-for-hamiltonian-simulation-circuits)

* [Weitreichende Verschränkung mit dynamischen Schaltungen](/tutorials/long-range-entanglement)

* [Simulation des Kicked-Ising-Hamiltonians mit dynamischen Schaltungen](/tutorials/dc-hex-ising)

</details>

<details>
<summary>**Qiskit Functions**</summary>

Qiskit Functions san a Sammlung von vorgefertigten Fehlerverwaltungs- und Anwendungswerkzeugen, de's einfach machn, groß olegde Experimente mit Schaltungen, Molekülen, QUBOs und mehr z'entwerfen.

- Entwerft neue Algorithmen mit **Circuit Functions** -- mit vorgefertigten Pipelines für Transpilation, Fehlerunterdrückung und Fehlerminderung.

  * [Fehlerminderung mit der IBM Circuit Function](/tutorials/error-mitigation-with-qiskit-functions)

  * [Transverse-Field Ising-Modell mit Q-CTRLs Performance Management](/tutorials/transverse-field-ising-model)

  * [Quantum Phase Estimation mit Q-CTRLs Qiskit Functions](/tutorials/quantum-phase-estimation-qctrl)

  * [Simulation des 2D-Tilted-Field-Ising mit der QESEM-Funktion](/tutorials/qedma-2d-ising-with-qesem)

- Experimentiert mit domänenspezifischen Problemen mit **Application Functions** -- mit vertrauten Ein- und Ausgaben für klassische Solver.

  * [Quantum Portfolio Optimizer - Eine Qiskit Function von Global Data Quantum](/tutorials/global-data-quantum-optimizer)

  * [Binäre Optimierung höherer Ordnung mit Q-CTRLs Optimization Solver](/tutorials/solve-higher-order-binary-optimization-problems-with-q-ctrls-optimization-solver)

  * [Modellierung einer strömenden nicht-viskosen Flüssigkeit mit QUICK-PDE](/tutorials/colibritd-pde)

  * [Dissoziations-PES-Kurven mit Qunova HiVQE](/tutorials/qunova-hivqe)

  * [Hybride quantengestützte Ensemble-Klassifikation (Grid-Stabilitäts-Workflow)](/tutorials/sml-classification)

  * [Lösung des Market-Split-Problems mit Kipu Quantums Iskay Quantum Optimizer](/tutorials/solve-market-split-problem-with-iskay-quantum-optimizer)

</details>

<details>
  <summary>**Qiskit Addons**</summary>

Addons ermöglichen de fortgeschrittene Schaltungsmanipulation, wia des Schneidan, Rückpropagieren von Observablen oda Approximieren von Schaltungen, was de Benutzer in d'Lage versetzt, Hardwarebeschränkungen z'umgehn, auf Kosten von erhöhtem klassischen Rechenaufwand.

* [Multi-Produkt-Formeln zur Reduzierung des Trotter-Fehlers](/tutorials/multi-product-formula)

* [Approximative Quantenkompilierung für Zeitentwicklungsschaltungen](/tutorials/approximate-quantum-compilation-for-time-evolution)

* [Operator-Backpropagation (OBP) zur Schätzung von Erwartungswerten](/tutorials/operator-back-propagation)

* [Wire-Cutting zur Schätzung von Erwartungswerten](/tutorials/wire-cutting)

* [Circuit-Cutting für periodische Randbedingungen](/tutorials/periodic-boundary-conditions-with-circuit-cutting)

* [Circuit-Cutting zur Tiefenreduktion](/tutorials/depth-reduction-with-circuit-cutting)

* [Readout-Fehlerminderung für das Sampler-Primitive mit M3](/tutorials/readout-error-mitigation-sampler)

</details>

<details>
  <summary>**Fehlerminderung**</summary>

Fehlerminderung geht de Herausforderung von Rauschen ohne vollständige Fehlertoleranz o, indem genaue Erwartungswerte durch kontrollierte Schaltungsmanipulation und Nachbearbeitung wiederhergestellt werdn.

* [Utility-Scale-Fehlerminderung mit probabilistischer Fehlerverstärkung](/tutorials/probabilistic-error-amplification)

* [Kombination von Fehlerminderungsoptionen mit dem Estimator-Primitive](/tutorials/combine-error-mitigation-techniques)

* [Echtzeit-Benchmarking zur Qubit-Auswahl](/tutorials/real-time-benchmarking-for-qubit-selection)

</details>

<details>
  <summary>**Fehlererkennung**</summary>

Fehlererkennung identifiziert fehlerhafte Operationen, damit ma durch Nachbearbeitung rauschfreie Ergebnisse Shot-für-Shot zrüakkriagn ko.

* [Repetition Codes](/tutorials/repetition-codes)

* [Fehlererkennung mit geringem Overhead durch Raumzeit-Codes](/tutorials/ghz-spacetime-codes)

</details>
