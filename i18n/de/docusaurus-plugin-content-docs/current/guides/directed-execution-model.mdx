---
title: Directed Execution Model (Beta)
description: Verwenden Sie dieses komponierbare, explizite Ausführungsmodell für Ihre Utility-Scale-Experimente, um Fehlerkorrektur und andere Techniken feinabzustimmen.

---

# Directed Execution Model (Beta)

<Admonition type="note" title="Beta-Version">
Alle Komponenten im Directed Execution Model befinden sich derzeit in der Beta-Phase und sind möglicherweise nicht stabil. Sie sind eingeladen, sie zu testen und Feedback zu geben, indem Sie ein Issue im [Samplomatic](https://github.com/Qiskit/samplomatic/issues)- oder [Qiskit Runtime](https://github.com/Qiskit/qiskit-ibm-runtime/issues)-GitHub-Repository öffnen.
</Admonition>

Die Schnittstellen der Sampler- und Estimator-Primitiven bieten eine höhere Abstraktionsebene, damit sich Algorithmen-Entwickler mehr auf Innovation und weniger auf Datenkonvertierung konzentrieren können. Sie sind jedoch weniger geeignet für Quanteninformationswissenschaftler, die mehr Kontrolle und Flexibilität für ihre Utility-Scale-Experimente benötigen. Das **Directed Execution Model**, das sich derzeit in der Beta-Version befindet, geht auf diesen Bedarf ein. Dieses Ausführungsmodell bietet die Bausteine, um Designabsichten auf der Client-Seite zu erfassen, und verlagert die kostspielige Generierung von Schaltungsvarianten auf die Server-Seite, sodass Sie Fehlerkorrektur und andere Techniken feinabstimmen können, ohne die Leistung zu beeinträchtigen. Dieses explizite und komponierbare Modell erleichtert es, mit neuen Techniken zu experimentieren, Ergebnisse zu reproduzieren und Methoden zu teilen.

In seiner Beta-Version konzentriert sich das Directed Execution Model darauf, Ihnen die Kontrolle über Techniken zu geben, die in die bestehenden Sampler und Estimator integriert sind, einschließlich Pauli Twirling, Noise Model Learning und Injection sowie Basis Changes. Unterstützung für andere Fähigkeiten wird im Laufe der Zeit schrittweise hinzugefügt.

## Workflow

Ein Hauptziel des Directed Execution Models besteht darin, eine modulare Möglichkeit zur Anwendung von Fehlerkorrekturmethoden bereitzustellen. Sie können beispielsweise definieren, welche Schichten in der Schaltung korrigiert werden sollen, oder die in die Schaltung injizierten Rauschpegel anpassen.

Um Fehlerkorrektur auf eine Schaltung im Rahmen dieses Frameworks anzuwenden, umfasst Ihr Workflow typischerweise die folgenden Schritte (die hier erwähnten Tools werden im [nächsten Abschnitt](#samplomatic-tools) ausführlicher beschrieben):

1. Gruppieren Sie Anweisungen in Boxen und wenden Sie Annotationen auf sie an. Die Annotationen erfassen die beabsichtigte Transformation, ohne tatsächlich die Schaltungsvarianten zu generieren.

2. Lernen Sie bei Bedarf die Rauschmodelle der eindeutigen Schichten mit dem neuen [NoiseLearnerV3](#noiselearnerv3).

3. Erstellen Sie die Template-Schaltung und Samplex aus der geboxten Schaltung.

4. Führen Sie die Template-Schaltung und Samplex mit dem [Executor](#executor-primitive)-Primitiv aus, das die Schaltungsvarianten wie angewiesen generiert und ausführt.

5. Nachbearbeitung der Ausführungsergebnisse. Sie können beispielsweise Post-Selection anwenden oder korrigierte Erwartungswerte aus den Ausführungsergebnissen extrapolieren.

<span id="samplomatic-tools"></span>
## Tools für das Directed Execution Model

Die folgenden Tools können zusammen verwendet werden, um eine Fehlerkorrektur-Technik im Directed Execution Model zu implementieren.

### Samplomatic

[Samplomatic](https://github.com/Qiskit/samplomatic/) ist eine neue Open-Source-Bibliothek, die angepasste Sampling-Randomisierungen unterstützt. Sie verwendet das [Box](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#box)-Konstrukt, um über Sammlungen von Schaltungsoperationen zu argumentieren, die als stabile Rauschkontexte behandelt werden sollten, und verwendet Annotationen auf Boxen, um Ihnen die Deklaration und Konfiguration von Absichten zu ermöglichen. Sie können beispielsweise Ihre Schaltung in Boxen stratifizieren, eine Twirling-Annotation zu jeder Box hinzufügen und angeben, welche Twirling-Gruppe verwendet werden soll, wie in der folgenden Abbildung dargestellt:

![Example of using boxes and twirling annotations](/docs/images/guides/directed-execution-model/execution-model.avif)

Eine Schaltung mit annotierten Boxen kann dann verwendet werden, um eine *Template-Schaltung* und einen *Samplex* zu generieren. Die ausgegebene Template-Schaltung ist eine parametrisierte Schaltung, die ohne weitere Änderung ausgeführt wird (außer dass ihr unterschiedliche Parameterwerte zugewiesen werden). Der Samplex, der der Kerntyp der Samplomatic-Bibliothek ist, repräsentiert eine parametrische Wahrscheinlichkeitsverteilung über die Parameter der Template-Schaltung und andere Array-wertige Felder. Diese Felder können verwendet werden, um Daten nachzubearbeiten, die durch Ausführung der gebundenen Template-Schaltung gesammelt wurden. Mit anderen Worten, das Template-Schaltung- und Samplex-Paar teilt dem Executor-Primitiv (unten beschrieben) genau mit, welche Parameter generiert und welche gebundenen Schaltungen ausgeführt werden sollen. Da diese beiden Konstrukte auf der Client-Seite erstellt werden, können Sie lokale Inspektion und Sampling durchführen, um die Ausgaben vor dem Senden zur Hardware-Ausführung zu überprüfen.

Um den Prozess der Generierung annotierter Boxen zu vereinfachen, bietet die Samplomatic-Bibliothek auch Transpiler-Passes, die Schaltungsanweisungen automatisch basierend auf den von Ihnen bereitgestellten Strategien in annotierte Boxen gruppieren.

Um mehr über Samplomatic zu erfahren, besuchen Sie die [Guides](https://qiskit.github.io/samplomatic/guides/index.html) und die [API-Referenz](https://qiskit.github.io/samplomatic/)-Dokumentation. Senden Sie gerne Feedback und melden Sie Fehler in seinem [GitHub](https://github.com/Qiskit/samplomatic)-Repository.

### Executor-Primitiv

Executor ist ein neues Qiskit Runtime-Primitiv, das das Template-Schaltung- und Samplex-Paar als Eingabe nimmt, Parameterwerte gemäß dem Samplex generiert und bindet, die gebundenen Schaltungen auf der Hardware ausführt und die Ausführungsergebnisse und Metadaten zurückgibt. Es folgt den Anweisungen des Eingabepaars und trifft keine impliziten Entscheidungen für Sie, sodass der Prozess transparent und dennoch leistungsfähig ist.

Um auf `Executor` zuzugreifen, installieren Sie den `executor_preview`-Branch von `qiskit-ibm-runtime`:

```bash
pip install -U git+https://github.com/Qiskit/qiskit-ibm-runtime.git@executor_preview
```
Die Ein- und Ausgaben des Executor-Primitivs unterscheiden sich stark von denen von Sampler und Estimator. Weitere Informationen finden Sie in der [Executor-API-Referenz](https://qiskit.github.io/qiskit-ibm-runtime/stubs/qiskit_ibm_runtime.Executor.html). Darüber hinaus bietet der [Executor-Quickstart-Guide](https://qiskit.github.io/qiskit-ibm-runtime/guides/executor_basic.html) einen Überblick und Codebeispiele.

### NoiseLearnerV3

Ähnlich wie der aktuelle [`NoiseLearner`](/guides/noise-learning) gibt dieses Qiskit Runtime-Hilfsprogramm das sparse [Pauli-Lindblad-Rauschmodell](https://arxiv.org/abs/2201.09866) zurück, das in vielen Fehlerkorrekturmethoden verwendet wird, einschließlich [PEC](/guides/error-mitigation-and-suppression-techniques#probabilistic-error-cancellation-pec), [PEA](/guides/error-mitigation-and-suppression-techniques#probabilistic-error-amplification-pea) und [PNA](https://github.com/Qiskit/qiskit-addon-pna/tree/main). Im ursprünglichen `NoiseLearner` übergeben Sie eine Liste von Schaltungen, und das Programm stratifiziert die Schaltungen in Schichten und gibt das Rauschmodell für jede eindeutige Schicht zurück. `NoiseLearnerV3` hingegen gibt Ihnen Kontrolle darüber, wie Sie Ihre Schaltungen stratifizieren, und das Programm nimmt einfach eine Liste von geboxten Schaltungsanweisungen (z. B. eindeutige Schichten) als Eingaben.

`NoiseLearnerV3` unterstützt auch das Lernen von Messrauschen. Für jeden Anweisungssatz in der Eingabeliste führt es das Pauli-Lindblad-Lernprotokoll aus, wenn der Satz Ein- und Zwei-Qubit-Gates enthält, und das [TREX](/guides/error-mitigation-and-suppression-techniques#twirled-readout-error-extinction-trex)-Protokoll, wenn der Satz Messungen enthält.
Um auf `NoiseLearnerV3` zuzugreifen, installieren Sie den `executor_preview`-Branch von `qiskit-ibm-runtime`:

```bash
pip install -U git+https://github.com/Qiskit/qiskit-ibm-runtime.git@executor_preview
```
Um mehr über NoiseLearnerV3 zu erfahren, lesen Sie die [API-Referenz](https://qiskit.github.io/qiskit-ibm-runtime/apidocs/noise_learner_v3.html)-Dokumentation.

## Nächste Schritte

<Admonition type="tip" title="Empfehlungen">
- Sehen Sie sich zwei Qiskit-Addons an, [Shaded lightcones](https://qiskit.github.io/qiskit-addon-slc/) und [Propagated noise absorption](https://github.com/Qiskit/qiskit-addon-pna), die auf diesem Ausführungsmodell aufbauen.
</Admonition>
