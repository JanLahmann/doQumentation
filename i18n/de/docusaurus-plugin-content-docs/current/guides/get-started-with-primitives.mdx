---
title: "Erste Schritte mit Primitives"
sidebar_label: "Erste Schritte mit Primitives"
description: "Wie Sie die Estimator- und Sampler-Primitives in Qiskit Runtime verwenden."
notebook_path: "docs/guides/get-started-with-primitives.ipynb"
---

<OpenInLabBanner notebookPath="docs/guides/get-started-with-primitives.ipynb" />



<Admonition type="note" title="New execution model, now in beta release">
Die Beta-Version eines neuen Ausführungsmodells ist jetzt verfügbar. Das Directed Execution Model bietet mehr Flexibilität bei der Anpassung Ihres Error-Mitigation-Workflows. Weitere Informationen finden Sie im Leitfaden [Directed execution model](/guides/directed-execution-model).
</Admonition>

<Admonition type="note">
Während diese Dokumentation die Primitives von Qiskit Runtime verwendet, die die Nutzung von IBM&reg;-Backends ermöglichen, können die Primitives mit jedem Anbieter durch Verwendung der [Backend-Primitives](#backend) ausgeführt werden. Zusätzlich können Sie die *Referenz*-Primitives verwenden, um auf einem lokalen Statevector-Simulator zu laufen. Einzelheiten finden Sie unter [Exact simulation with Qiskit primitives](/guides/simulate-with-qiskit-sdk-primitives).
</Admonition>
Die Schritte in diesem Thema beschreiben, wie Sie Primitives einrichten, die Optionen erkunden, die Sie zur Konfiguration verwenden können, und sie in einem Programm aufrufen.

<Admonition type="note" title="Using Fractional Gates">
    Um die neu unterstützten [Fractional Gates](./fractional-gates) zu verwenden, setzen Sie `use_fractional_gates=True`, wenn Sie ein Backend von einer `QiskitRuntimeService`-Instanz anfordern. Zum Beispiel:
    ```python
    service = QiskitRuntimeService()
    fractional_gate_backend = service.least_busy(use_fractional_gates=True)
    ```

    Beachten Sie, dass dies eine experimentelle Funktion ist und sich in Zukunft ändern kann.
</Admonition>
{/*
  DO NOT EDIT THIS CELL!!!
  This cell's content is generated automatically by a script. Anything you add
  here will be removed next time the notebook is run. To add new content, create
  a new cell before or after this one.
*/}

<details>
<summary><b>Package versions</b></summary>

The code on this page was developed using the following requirements.
We recommend using these versions or newer.

```
qiskit[all]~=2.3.0
qiskit-ibm-runtime~=0.43.1
```
</details>
<span id="start-estimator"></span>
## Erste Schritte mit Estimator

{/*Verified the v2 examples 2/29/24 - updated 10/29/24*/}

### 1. Initialisieren Sie das Konto

Da Qiskit Runtime Estimator ein verwalteter Dienst ist, müssen Sie zunächst Ihr Konto initialisieren. Anschließend können Sie die QPU auswählen, die Sie zur Berechnung des Erwartungswerts verwenden möchten.

Folgen Sie den Schritten im Thema [Install and set up topic](install-qiskit), wenn Sie noch kein Konto haben.

```python
from qiskit_ibm_runtime import QiskitRuntimeService

service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=127
)

print(backend.name)
```

```text
ibm_torino
```

### 2. Erstellen Sie einen Circuit und eine Observable

Sie benötigen mindestens einen Circuit und eine Observable als Eingaben für das Estimator-Primitive.

```python
from qiskit.circuit.library import qaoa_ansatz
from qiskit.quantum_info import SparsePauliOp

entanglement = [tuple(edge) for edge in backend.coupling_map.get_edges()]
observable = SparsePauliOp.from_sparse_list(
    [("ZZ", [i, j], 0.5) for i, j in entanglement],
    num_qubits=backend.num_qubits,
)
circuit = qaoa_ansatz(observable, reps=2)
# the circuit is parametrized, so we will define the parameter values for execution
param_values = [0.1, 0.2, 0.3, 0.4]

print(f">>> Observable: {observable.paulis}")
```

```text
>>> Observable: ['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...', ...]
```

Der Circuit und die Observable müssen so transformiert werden, dass sie nur Anweisungen verwenden, die von der QPU unterstützt werden (bezeichnet als *Instruction Set Architecture (ISA)* Circuits). Wir verwenden den Transpiler, um dies zu tun.

```python
from qiskit.transpiler import generate_preset_pass_manager

pm = generate_preset_pass_manager(optimization_level=1, backend=backend)
isa_circuit = pm.run(circuit)
isa_observable = observable.apply_layout(isa_circuit.layout)
print(f">>> Circuit ops (ISA): {isa_circuit.count_ops()}")
```

```text
>>> Circuit ops (ISA): OrderedDict([('rz', 3826), ('sx', 1601), ('cz', 968)])
```

### 3. Initialisieren Sie Qiskit Runtime Estimator

Wenn Sie den Estimator initialisieren, verwenden Sie den Parameter `mode`, um den Modus anzugeben, in dem er ausgeführt werden soll. Mögliche Werte sind `batch`, `session` oder `backend`-Objekte für Batch-, Session- und Job-Ausführungsmodus. Weitere Informationen finden Sie unter [Introduction to Qiskit Runtime execution modes.](execution-modes)

```python
from qiskit_ibm_runtime import EstimatorV2 as Estimator

estimator = Estimator(mode=backend)
```

### 4. Rufen Sie den Estimator auf und erhalten Sie Ergebnisse

Rufen Sie als Nächstes die Methode `run()` auf, um Erwartungswerte für die Eingabe-Circuits und -Observables zu berechnen. Der Circuit, die Observable und optionale Parameterwertesätze werden als *Primitive Unified Bloc* (PUB)-Tupel eingegeben.

```python
job = estimator.run([(isa_circuit, isa_observable, param_values)])
print(f">>> Job ID: {job.job_id()}")
print(f">>> Job Status: {job.status()}")
```

```text
>>> Job ID: d5k96c4jt3vs73ds5smg
```

```text
>>> Job Status: QUEUED
```

```python
result = job.result()
print(f">>> {result}")
print(f"  > Expectation value: {result[0].data.evs}")
print(f"  > Metadata: {result[0].metadata}")
```

```text
>>> PrimitiveResult([PubResult(data=DataBin(evs=np.ndarray(<shape=(), dtype=float64>), stds=np.ndarray(<shape=(), dtype=float64>), ensemble_standard_error=np.ndarray(<shape=(), dtype=float64>)), metadata={'shots': 4096, 'target_precision': 0.015625, 'circuit_metadata': {}, 'resilience': {}, 'num_randomizations': 32})], metadata={'dynamical_decoupling': {'enable': False, 'sequence_type': 'XX', 'extra_slack_distribution': 'middle', 'scheduling_method': 'alap'}, 'twirling': {'enable_gates': False, 'enable_measure': True, 'num_randomizations': 'auto', 'shots_per_randomization': 'auto', 'interleave_randomizations': True, 'strategy': 'active-accum'}, 'resilience': {'measure_mitigation': True, 'zne_mitigation': False, 'pec_mitigation': False}, 'version': 2})
  > Expectation value: 25.8930784649363
  > Metadata: {'shots': 4096, 'target_precision': 0.015625, 'circuit_metadata': {}, 'resilience': {}, 'num_randomizations': 32}
```

<span id="start-sampler"></span>
## Erste Schritte mit Sampler

### 1. Initialisieren Sie das Konto

Da Qiskit Runtime Sampler ein verwalteter Dienst ist, müssen Sie zunächst Ihr Konto initialisieren. Anschließend können Sie die QPU auswählen, die Sie zur Berechnung des Erwartungswerts verwenden möchten.

Folgen Sie den Schritten im Thema [Install and set up topic](install-qiskit), wenn Sie noch kein Konto eingerichtet haben.

```python
from qiskit_ibm_runtime import QiskitRuntimeService

service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=127
)
```

### 2. Erstellen Sie einen Circuit

Sie benötigen mindestens einen Circuit als Eingabe für das Sampler-Primitive.

```python
import numpy as np
from qiskit.circuit.library import efficient_su2

circuit = efficient_su2(127, entanglement="linear")
circuit.measure_all()
# The circuit is parametrized, so we will define the parameter values for execution
param_values = np.random.rand(circuit.num_parameters)
```

Verwenden Sie den Transpiler, um einen ISA-Circuit zu erhalten.

```python
from qiskit.transpiler import generate_preset_pass_manager

pm = generate_preset_pass_manager(optimization_level=1, backend=backend)
isa_circuit = pm.run(circuit)
print(f">>> Circuit ops (ISA): {isa_circuit.count_ops()}")
```

```text
>>> Circuit ops (ISA): OrderedDict([('sx', 3089), ('rz', 3036), ('cz', 1092), ('measure', 127), ('barrier', 1)])
```

### 3. Initialisieren Sie den Qiskit Runtime Sampler

Wenn Sie den Sampler initialisieren, verwenden Sie den Parameter `mode`, um den Modus anzugeben, in dem er ausgeführt werden soll. Mögliche Werte sind `batch`, `session` oder `backend`-Objekte für Batch-, Session- und Job-Ausführungsmodus. Weitere Informationen finden Sie unter [Introduction to Qiskit Runtime execution modes.](execution-modes) Beachten Sie, dass Open Plan-Benutzer keine Session-Jobs übermitteln können.

```python
from qiskit_ibm_runtime import SamplerV2 as Sampler

sampler = Sampler(mode=backend)
```

### 4. Rufen Sie den Sampler auf und erhalten Sie Ergebnisse

Rufen Sie als Nächstes die Methode `run()` auf, um die Ausgabe zu generieren. Der Circuit und optionale Parameterwertesätze werden als *Primitive Unified Bloc* (PUB)-Tupel eingegeben.

```python
job = sampler.run([(isa_circuit, param_values)])
print(f">>> Job ID: {job.job_id()}")
print(f">>> Job Status: {job.status()}")
```

```text
>>> Job ID: d5k96rsjt3vs73ds5tig
>>> Job Status: QUEUED
```

```python
result = job.result()

# Get results for the first (and only) PUB
pub_result = result[0]
print(
    f"First ten results for the 'meas' output register: {pub_result.data.meas.get_bitstrings()[:10]}"
)
```

```text
First ten results for the 'meas' output register: ['0101001101010000011001110001011000010010001100001000100110011111011110000010110001101000110011101010000100011011000110101111000', '0100111000000100110001100100000101111000111001101000110111101110110010010100001101001111001010011101010000010011000110000010001', '0101111101111111010011010101000000110100000010000010011101100011100011001100000100100001000101000000100001010101010011001101100', '1100110101111111001110010000010100101010101010001000001100100110011111010000000010001000110111010000010101100000100000110111001', '0010000001111001111010100100010111101000101000100000101100001000011100000100011010110110100011100110001001110110111101010011000', '0101110000001000100100010010100100111000010100000000010010000000010110010010000110000001110110010100000111001110100100111101100', '0100011111101001000111110011011101101101110101110001010111011101111110011101001000000001110000011110000101010000001010000100000', '0001010101011000110100000100111111100001011000111110000011000111001101010000010001001100000110000000100000110101010010101110010', '0100011010001110011110000110100101100100101001001111010100100101010100010000000010100000101010110010000000001000010101011111110', '0000011000000111000001000101111111110110101100110000001100010010011101011100001010000100011010001010001101000000000000010001001']
```

<span id="backend"></span>
## Erste Schritte mit Backend-Primitives

Im Gegensatz zu anbieterspezifischen Primitives sind Backend-Primitives generische Implementierungen, die mit einem beliebigen `backend`-Objekt verwendet werden können, solange es die [`Backend`](https://docs.quantum.ibm.com/api/qiskit/qiskit.providers.Backend)-Schnittstelle implementiert.

- Das Sampler-Primitive kann mit jedem Anbieter durch Verwendung von [`qiskit.primitives.BackendSamplerV2`](https://docs.quantum.ibm.com/api/qiskit/qiskit.primitives.BackendSamplerV2) ausgeführt werden.
- Das Estimator-Primitive kann mit jedem Anbieter durch Verwendung von [`qiskit.primitives.BackendEstimatorV2`](../api/qiskit/qiskit.primitives.BackendEstimatorV2) ausgeführt werden.

Einige Anbieter implementieren Primitives nativ. Einzelheiten finden Sie auf der [Qiskit Ecosystem-Seite](https://qiskit.github.io/ecosystem#provider).
### Beispiel: BackendEstimator

```python
from qiskit.primitives import BackendEstimatorV2
from <some_qiskit_provider> import QiskitProvider

provider = QiskitProvider()
backend = provider.get_backend('backend_name')
estimator = BackendEstimatorV2(backend)
```

### Beispiel: BackendSampler

```python
from qiskit.primitives import BackendSamplerV2
from <some_qiskit_provider> import QiskitProvider

provider = QiskitProvider()
backend = provider.get_backend('backend_name')
sampler = BackendSamplerV2(backend)
```
### Gemeinsamkeiten und Unterschiede zwischen Backend- und Runtime-Primitives

- Die Eingaben und Ausgaben von [`qiskit.primitives.BackendSamplerV2`](https://docs.quantum.ibm.com/api/qiskit/qiskit.primitives.BackendSamplerV2) und [`qiskit.primitives.BackendEstimatorV2`](../api/qiskit/qiskit.primitives.BackendEstimatorV2)
folgen dem gleichen PUB-Format wie die Primitives in Qiskit Runtime. Einzelheiten finden Sie unter [Primitive inputs and outputs](primitive-input-output).
Es kann jedoch Unterschiede in den Feldern der zurückgegebenen Metadaten geben.

- Die Klasse [`qiskit.primitives.BackendEstimatorV2`](https://docs.quantum.ibm.com/api/qiskit/qiskit.primitives.BackendEstimatorV2) bietet standardmäßig keine Mess- oder Gate-Fehlerminderungs-Implementierungen, da
Backend-Primitives für die lokale Ausführung auf dem Computer des Benutzers konzipiert sind.

- Die Klasse [`qiskit.primitives.BackendSamplerV2`](https://docs.quantum.ibm.com/api/qiskit/qiskit.primitives.BackendSamplerV2) erfordert ein Backend, das die Option `memory` unterstützt.

- Die Backend-Primitive-Schnittstellen stellen benutzerdefinierte [`SamplerV2`](https://docs.quantum.ibm.com/api/qiskit/qiskit.primitives.BackendSamplerV2)- und [`EstimatorV2`](https://docs.quantum.ibm.com/api/qiskit/qiskit.primitives.BackendEstimatorV2)-`Options` bereit, die sich von den Runtime-Implementierungen unterscheiden.
## Nächste Schritte

<Admonition type="tip" title="Recommendations">
    - Erfahren Sie, wie Sie [lokal testen](local-testing-mode), bevor Sie auf Quantencomputern ausführen.
    - Sehen Sie sich detaillierte [Primitives-Beispiele](primitives-examples) an.
    - Üben Sie mit Primitives, indem Sie die Lektion [Cost function lesson](/learning/courses/variational-algorithm-design/cost-functions) in IBM Quantum Learning durcharbeiten.
    - Erfahren Sie, wie Sie lokal im Abschnitt [Transpile](transpile/) transpilieren.
    - Probieren Sie den Leitfaden [Compare transpiler settings](/guides/circuit-transpilation-settings#compare-transpiler-settings) aus.
    - Erfahren Sie, wie Sie [die Primitive-Optionen verwenden](runtime-options-overview).
    - Sehen Sie sich die API für [Sampler](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/options-sampler-options)- und [Estimator](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/options-estimator-options)-Optionen an.
    - Lesen Sie [Migrate to V2 primitives](/guides/v2-primitives).
</Admonition>
