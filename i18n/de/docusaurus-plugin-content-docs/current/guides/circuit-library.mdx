---
title: "Schaltkreis-Bibliothek"
sidebar_label: "Schaltkreis-Bibliothek"
description: "Erfahren Sie mehr über vorgefertigte Schaltkreise, die von der Qiskit-Schaltkreis-Bibliothek bereitgestellt werden, einschließlich N-lokaler, Zeitentwicklungs- und Datenkodierungs-Schaltkreise"
notebook_path: "docs/guides/circuit-library.ipynb"
---

<OpenInLabBanner notebookPath="docs/guides/circuit-library.ipynb" />



{/* cspell:ignore cout */}

{/*
  DO NOT EDIT THIS CELL!!!
  This cell's content is generated automatically by a script. Anything you add
  here will be removed next time the notebook is run. To add new content, create
  a new cell before or after this one.
*/}

<details>
<summary><b>Paketversionen</b></summary>

Der Code auf dieser Seite wurde mit den folgenden Anforderungen entwickelt.
Wir empfehlen die Verwendung dieser oder neuerer Versionen.

```
qiskit[all]~=2.3.0
```
</details>
Das Qiskit SDK enthält eine Bibliothek beliebter Schaltkreise, die als Bausteine in Ihren eigenen Programmen verwendet werden können. Die Verwendung vordefinierter Schaltkreise spart Zeit bei der Recherche, beim Schreiben von Code und beim Debugging. Die Bibliothek umfasst beliebte Schaltkreise im Quantencomputing, Schaltkreise, die klassisch schwer zu simulieren sind, und Schaltkreise, die für das Benchmarking von Quanten-Hardware nützlich sind.

Diese Seite listet die verschiedenen Schaltkreis-Kategorien auf, die die Bibliothek bereitstellt. Eine vollständige Liste der Schaltkreise finden Sie in der [Schaltkreis-Bibliothek API-Dokumentation](https://docs.quantum.ibm.com/api/qiskit/circuit_library).
## Standard-Gates

Die Schaltkreis-Bibliothek enthält auch Standard-Quanten-Gates. Einige sind grundlegendere Gates (wie das `UGate`), und andere sind Multi-Qubit-Gates, die normalerweise aus Ein- und Zwei-Qubit-Gates aufgebaut werden müssen. Um importierte Gates zu Ihrem Schaltkreis hinzuzufügen, verwenden Sie die `append`-Methode; das erste Argument ist das Gate und das nächste Argument ist eine Liste von Qubits, auf die das Gate angewendet werden soll.

Zum Beispiel erstellt die folgende Code-Zelle einen Schaltkreis mit einem Hadamard-Gate und einem Multi-Controlled-X-Gate.

```python
from qiskit import QuantumCircuit
from qiskit.circuit.library import HGate, MCXGate

mcx_gate = MCXGate(3)
hadamard_gate = HGate()

qc = QuantumCircuit(4)
qc.append(hadamard_gate, [0])
qc.append(mcx_gate, [0, 1, 2, 3])
qc.draw("mpl")
```

![Output of the previous code cell](/docs/images/guides/circuit-library/extracted-outputs/a846a845-7ac5-4c92-b124-d2b90a773ba2-0.svg)

Siehe [Standard Gates](https://docs.quantum.ibm.com/api/qiskit/circuit_library#standard-gates) in der Schaltkreis-Bibliothek API-Dokumentation.

<CodeAssistantAdmonition tagLine="Nicht sicher, wie Ihr Gate heißt? Versuchen Sie, Qiskit Code Assistant zu fragen." />
## N-lokale Schaltkreise

Diese Schaltkreise wechseln Schichten von Ein-Qubit-Rotations-Gates mit Schichten von Multi-Qubit-Verschränkungs-Gates ab.

Diese Familie von Schaltkreisen ist in variationalen Quantenalgorithmen beliebt, da sie eine breite Palette von Quantenzuständen erzeugen können. Variationsalgorithmen passen die Gate-Parameter an, um Zustände zu finden, die bestimmte Eigenschaften haben (wie Zustände, die eine gute Lösung für ein Optimierungsproblem darstellen). Zu diesem Zweck sind viele Schaltkreise in der Bibliothek **parametrisiert**, was bedeutet, dass Sie sie ohne feste Werte definieren können.

Die folgende Code-Zelle importiert einen `n_local`-Schaltkreis, bei dem die Verschränkungs-Gates Zwei-Qubit-Gates sind. Dieser Schaltkreis verschachtelt Blöcke parametrisierter Ein-Qubit-Gates, gefolgt von Verschränkungs-Blöcken aus Zwei-Qubit-Gates. Der folgende Code erstellt einen Drei-Qubit-Schaltkreis mit Ein-Qubit-RX-Gates und Zwei-Qubit-CZ-Gates.

```python
from qiskit.circuit.library import n_local

two_local = n_local(3, "rx", "cz")
two_local.draw("mpl")
```

![Output of the previous code cell](/docs/images/guides/circuit-library/extracted-outputs/3ccaeb1b-03c6-4dfa-9000-e48db2516303-0.svg)

Sie können ein listenähnliches Objekt der Parameter des Schaltkreises vom `parameters`-Attribut erhalten.

```python
two_local.parameters
```

```text
 ParameterView([ParameterVectorElement(θ[0]), ParameterVectorElement(θ[1]), ParameterVectorElement(θ[2]), ParameterVectorElement(θ[3]), ParameterVectorElement(θ[4]), ParameterVectorElement(θ[5]), ParameterVectorElement(θ[6]), ParameterVectorElement(θ[7]), ParameterVectorElement(θ[8]), ParameterVectorElement(θ[9]), ParameterVectorElement(θ[10]), ParameterVectorElement(θ[11])])
```

Sie können dies auch verwenden, um diese Parameter realen Werten zuzuweisen, indem Sie ein Dictionary der Form `{ Parameter: Zahl }` verwenden. Um dies zu demonstrieren, weist die folgende Code-Zelle jedem Parameter im Schaltkreis `0` zu.

```python
bound_circuit = two_local.assign_parameters(
    {p: 0 for p in two_local.parameters}
)
bound_circuit.decompose().draw("mpl")
```

![Output of the previous code cell](/docs/images/guides/circuit-library/extracted-outputs/89227b48-12b2-4b1b-9680-55a7fce88a2b-0.svg)

Für weitere Informationen siehe [N-local gates](https://docs.quantum.ibm.com/api/qiskit/circuit_library#n-local-circuits) in der Schaltkreis-Bibliothek API-Dokumentation oder besuchen Sie den [Variational algorithm design course](/learning/courses/variational-algorithm-design) im IBM Quantum Learning.
## Datenkodierungs-Schaltkreise

Diese parametrisierten Schaltkreise kodieren Daten auf Quantenzustände zur Verarbeitung durch Quantum-Machine-Learning-Algorithmen. Einige von Qiskit unterstützte Schaltkreise sind:
 - Amplitudenkodierung, die jede Zahl in die Amplitude eines Basiszustands kodiert. Dies kann $2^n$ Zahlen in einem einzigen Zustand speichern, kann aber kostspielig zu implementieren sein.
 - Basiskodierung, die eine Ganzzahl $k$ kodiert, indem der entsprechende Basiszustand $|k\rangle$ vorbereitet wird.
 - Winkelkodierung, die jede Zahl in den Daten als Rotationswinkel in einem parametrisierten Schaltkreis festlegt.

Der beste Ansatz hängt von den Besonderheiten Ihrer Anwendung ab. Auf aktuellen Quantencomputern verwenden wir jedoch häufig Winkelkodierungs-Schaltkreise wie die `zz_feature_map`.

```python
from qiskit.circuit.library import zz_feature_map

features = [0.2, 0.4, 0.8]
feature_map = zz_feature_map(feature_dimension=len(features))

encoded = feature_map.assign_parameters(features)
encoded.draw("mpl")
```

![Output of the previous code cell](/docs/images/guides/circuit-library/extracted-outputs/cf8b1efc-57b3-4681-8e6a-d5b8406d092d-0.svg)

Siehe [Data encoding circuits](https://docs.quantum.ibm.com/api/qiskit/circuit_library#data-encoding-circuits) in der Schaltkreis-Bibliothek API-Dokumentation.
## Zeitentwicklungs-Schaltkreise

Diese Schaltkreise simulieren, wie sich ein Quantenzustand im Laufe der Zeit entwickelt. Verwenden Sie Zeitentwicklungs-Schaltkreise, um physikalische Effekte wie Wärmeübertragung oder Phasenübergänge in einem System zu untersuchen. Zeitentwicklungs-Schaltkreise sind auch ein grundlegender Baustein von Chemie-Wellenfunktionen (wie unitäre Coupled-Cluster-Trial-Zustände) und des QAOA-Algorithmus, den wir für Optimierungsprobleme verwenden.

```python
from qiskit.circuit.library import PauliEvolutionGate
from qiskit.circuit import QuantumCircuit
from qiskit.quantum_info import SparsePauliOp

# Prepare an initial state with a Hadamard on the middle qubit
state = QuantumCircuit(3)
state.h(1)

hamiltonian = SparsePauliOp(["ZZI", "IZZ"])
evolution = PauliEvolutionGate(hamiltonian, time=1)

# Evolve state by appending the evolution gate
state.compose(evolution, inplace=True)

state.draw("mpl")
```

![Output of the previous code cell](/docs/images/guides/circuit-library/extracted-outputs/834794df-86e9-4bea-8efa-5380499e359b-0.svg)

Lesen Sie die [`PauliEvolutionGate` API-Dokumentation](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.PauliEvolutionGate).
## Benchmarking- und Komplexitätstheorie-Schaltkreise

Benchmarking-Schaltkreise geben uns einen Eindruck davon, wie gut unsere Hardware tatsächlich funktioniert, und Komplexitätstheorie-Schaltkreise helfen uns zu verstehen, wie schwierig die Probleme sind, die wir lösen möchten.

Zum Beispiel misst der "Quantum Volume"-Benchmark, wie genau ein Quantencomputer eine Art von zufälligem Quantenschaltkreis ausführt. Die Punktzahl des Quantencomputers steigt mit der Größe des Schaltkreises, den er zuverlässig ausführen kann. Dies berücksichtigt alle Aspekte des Computers, einschließlich Qubit-Anzahl, Anweisungsgenauigkeit, Qubit-Konnektivität und des Software-Stacks, der Ergebnisse transpiliert und nachverarbeitet. Lesen Sie mehr über Quantum Volume im ursprünglichen [Quantum Volume Paper](https://arxiv.org/abs/1811.12926).

Der folgende Code zeigt ein Beispiel eines in Qiskit erstellten Quantum-Volume-Schaltkreises, der auf vier Qubits läuft (die `unitary`-Blöcke sind randomisierte Zwei-Qubit-Gates).

```python
from qiskit.circuit.library import quantum_volume

quantum_volume(4).draw("mpl")
```

![Output of the previous code cell](/docs/images/guides/circuit-library/extracted-outputs/9629a507-8191-409e-b895-fd0833c8fcd7-0.svg)

Die Schaltkreis-Bibliothek enthält auch Schaltkreise, von denen angenommen wird, dass sie klassisch schwer zu simulieren sind, wie instantaneous quantum polynomial (iqp)-Schaltkreise. Diese Schaltkreise umrahmen bestimmte diagonale Gates (in der Rechenbasis) zwischen Blöcken von Hadamard-Gates.

Andere Schaltkreise umfassen `grover_operator` zur Verwendung in Grovers Algorithmus und den `fourier_checking`-Schaltkreis für das Fourier-Checking-Problem. Siehe diese Schaltkreise in [Particular quantum circuits](https://docs.quantum.ibm.com/api/qiskit/circuit_library#particular-quantum-circuits) in der Schaltkreis-Bibliothek API-Dokumentation.
## Arithmetik-Schaltkreise

Arithmetische Operationen sind klassische Funktionen, wie das Addieren von Ganzzahlen und bitweise Operationen. Diese können nützlich sein mit Algorithmen wie der Amplitudenschätzung für Finanzanwendungen und in Algorithmen wie dem HHL-Algorithmus, der lineare Gleichungssysteme löst.

Als Beispiel versuchen wir, zwei Drei-Bit-Zahlen unter Verwendung eines "Ripple-Carry"-Schaltkreises zu addieren, um eine In-Place-Addition durchzuführen (`FullAdderGate`). Dieser Addierer addiert zwei Zahlen (wir nennen sie "A" und "B") und schreibt das Ergebnis in das Register, das B enthielt. Im folgenden Beispiel sind A=2 und B=3.

```python
from qiskit.circuit.library import FullAdderGate
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister

adder = FullAdderGate(3)  # Adder of 3-bit numbers

# Create the number A=2
reg_a = QuantumRegister(3, "a")
number_a = QuantumCircuit(reg_a)
number_a.initialize(2)  # Number 2; |010>

# Create the number B=3
reg_b = QuantumRegister(3, "b")
number_b = QuantumCircuit(reg_b)
number_b.initialize(3)  # Number 3; |011>

# Create a circuit to hold everything, including a classical register for
# the result
qregs = [
    QuantumRegister(1, "cin"),
    QuantumRegister(3, "a"),
    QuantumRegister(3, "b"),
    QuantumRegister(1, "cout"),
]
reg_result = ClassicalRegister(3)
circuit = QuantumCircuit(*qregs, reg_result)

# Compose number initializers with the adder. Adder stores the result to
# register B, so we'll measure those qubits.
circuit = (
    circuit.compose(number_a, qubits=reg_a)
    .compose(number_b, qubits=reg_b)
    .compose(adder)
)
circuit.measure(reg_b, reg_result)
circuit.draw("mpl")
```

![Output of the previous code cell](/docs/images/guides/circuit-library/extracted-outputs/77555a5a-a81c-47b8-a9ae-3015d84adcf5-0.svg)

Die Simulation des Schaltkreises zeigt, dass er `5` für alle `1024` Shots ausgibt (d. h. mit Wahrscheinlichkeit `1.0` gemessen wird).

```python
from qiskit.primitives import StatevectorSampler

result = StatevectorSampler().run([circuit]).result()

print(f"Count data:\n {result[0].data.c0.get_int_counts()}")
```

```text
Count data:
 {5: 1024}
```

Siehe [Arithmetic](https://docs.quantum.ibm.com/api/qiskit/circuit_library#arithmetic) in der Schaltkreis-Bibliothek API-Dokumentation.
## Nächste Schritte

<Admonition type="tip" title="Empfehlungen">
  -  Lernen Sie fortgeschrittene Methoden zum Erstellen von Schaltkreisen im Thema [Schaltkreise konstruieren](./construct-circuits).
  -  Sehen Sie ein Beispiel für verwendete Schaltkreise im Tutorial [Grover's Algorithm](/tutorials/grovers-algorithm).
  -  Lesen Sie die [Schaltkreis-Bibliothek API](https://docs.quantum.ibm.com/api/qiskit/circuit_library)-Referenz.
</Admonition>
