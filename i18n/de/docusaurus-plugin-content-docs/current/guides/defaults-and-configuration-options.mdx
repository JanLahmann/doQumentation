---
title: "Standardeinstellungen und Konfigurationsoptionen für die Transpilierung"
sidebar_label: "Standardeinstellungen und Konfigurationsoptionen für die Transpilierung"
description: "Die Standardeinstellungen und Konfigurationsoptionen für die Transpilierung von Quantenschaltungen im Qiskit SDK."
notebook_path: "docs/guides/defaults-and-configuration-options.ipynb"
---
{/* doqumentation-source-hash: d79246d8 */}

<OpenInLabBanner notebookPath="docs/guides/defaults-and-configuration-options.ipynb" />



# Standardeinstellungen und Konfigurationsoptionen für die Transpilierung {#transpilation-default-settings-and-configuration-options}
{/*
  DO NOT EDIT THIS CELL!!!
  This cell's content is generated automatically by a script. Anything you add
  here will be removed next time the notebook is run. To add new content, create
  a new cell before or after this one.
*/}

<details>
<summary><b>Paketversionen</b></summary>

Der Code auf dieser Seite wurde mit den folgenden Anforderungen entwickelt.
Wir empfehlen die Verwendung dieser oder neuerer Versionen.

```
qiskit[all]~=2.3.0
qiskit-ibm-runtime~=0.43.1
```
</details>
Abstrakte Schaltungen müssen transpiliert werden, da QPUs über eine begrenzte Anzahl von Basis-Gates verfügen und keine beliebigen Operationen ausführen können. Die Funktion des Transpilers besteht darin, beliebige Schaltungen so zu ändern, dass sie auf einer bestimmten QPU ausgeführt werden können. Dies geschieht durch Übersetzung der Schaltungen in die unterstützten Basis-Gates und durch Einführung von SWAP-Gates nach Bedarf, sodass die Konnektivität der Schaltung mit der der QPU übereinstimmt.

Wie in [Transpile with pass managers](transpile-with-pass-managers) erläutert, kannst du einen [Pass Manager](https://docs.quantum.ibm.com/api/qiskit/qiskit.transpiler.PassManager) mit der Funktion [`generate_preset_pass_manager`](https://docs.quantum.ibm.com/api/qiskit/qiskit.transpiler.generate_preset_pass_manager#qiskit.transpiler.generate_preset_pass_manager) erstellen und eine Schaltung oder Liste von Schaltungen an dessen [run](https://docs.quantum.ibm.com/api/qiskit/qiskit.transpiler.PassManager#run)-Methode übergeben, um sie zu transpilieren. Du kannst `generate_preset_pass_manager` aufrufen, indem du nur die Optimierungsstufe und das Backend übergibst und die Standardwerte für alle anderen Optionen verwendest, oder du kannst zusätzliche Argumente an die Funktion übergeben, um die Transpilierung feinabzustimmen.

## Grundlegende Verwendung ohne Parameter {#basic-usage-without-parameters}

In diesem Beispiel übergeben wir eine Schaltung und die Ziel-QPU an den Transpiler, ohne weitere Parameter anzugeben.

Erstelle eine Schaltung und zeige das Ergebnis an:

```python
from qiskit import QuantumCircuit
from qiskit.circuit.library import grover_operator, DiagonalGate
from qiskit_ibm_runtime.fake_provider import FakeSherbrooke

# Create circuit to test transpiler on
oracle = DiagonalGate([1] * 7 + [-1])
qc = QuantumCircuit(3)
qc.h([0, 1, 2])
qc = qc.compose(grover_operator(oracle))

# Add measurements to the circuit
qc.measure_all()

# View the circuit
qc.draw(output="mpl")
```

![Output of the previous code cell](/docs/images/guides/defaults-and-configuration-options/extracted-outputs/f7070db2-2b3e-4dcd-bbc7-cac7662867b3-0.svg)

Transpiliere die Schaltung und zeige das Ergebnis an:

```python
from qiskit.transpiler import generate_preset_pass_manager

# Specify the QPU to target
backend = FakeSherbrooke()

# Transpile the circuit
pass_manager = generate_preset_pass_manager(
    optimization_level=1, backend=backend
)
transpiled_circ = pass_manager.run(qc)

# View the transpiled circuit
transpiled_circ.draw(output="mpl", idle_wires=False)
```

![Output of the previous code cell](/docs/images/guides/defaults-and-configuration-options/extracted-outputs/27ab746b-e3d7-49a7-b40b-d1e2d9ca6088-0.svg)

## Alle verfügbaren Parameter {#all-available-parameters}

Im Folgenden sind alle verfügbaren Parameter für die Funktion [`generate_preset_pass_manager`](https://docs.quantum.ibm.com/api/qiskit/qiskit.transpiler.generate_preset_pass_manager#qiskit.transpiler.generate_preset_pass_manager) aufgeführt. Es gibt zwei Klassen von Argumenten: solche, die das Ziel der Kompilierung beschreiben, und solche, die beeinflussen, wie der Transpiler arbeitet.

Alle Parameter außer `optimization_level` sind optional. Vollständige Details findest du in der [Transpiler-API-Dokumentation](https://docs.quantum.ibm.com/api/qiskit/transpiler#transpiler-api).

- `optimization_level` (int) - Wie viel Optimierung an den Schaltungen durchgeführt werden soll. Ganzzahl im Bereich (0 - 3). Höhere Stufen erzeugen besser optimierte Schaltungen, auf Kosten einer längeren Transpilierungszeit. Weitere Details findest du unter [Set transpiler optimization level](set-optimization).

### Parameter zur Beschreibung des Kompilierungsziels: {#parameters-used-to-describe-the-compilation-target}

Diese Argumente beschreiben die Ziel-QPU für die Schaltungsausführung, einschließlich Informationen wie der Coupling Map der QPU (die die Konnektivität der Qubits beschreibt), der von der QPU unterstützten Basis-Gates und der Fehlerraten der Gates.

Viele dieser Parameter werden ausführlich unter [Commonly used parameters for transpilation](common-parameters) beschrieben.

<details>
  <summary>
    **QPU (`Backend`) Parameter**
  </summary>

**Backend-Parameter** - Wenn du `backend` angibst, musst du weder `target` noch andere Backend-Optionen angeben. Ebenso musst du bei Angabe von `target` weder `backend` noch andere Backend-Optionen angeben.
- `backend` (Backend) - Wenn dies gesetzt ist, kompiliert der Transpiler die Eingabeschaltung für dieses Gerät. Wenn eine andere Option gesetzt ist, die diese Einstellungen beeinflusst, wie z. B. `coupling_map`, überschreibt sie die Einstellungen von `backend`.
- `target` (Target) - Ein Backend-Transpiler-Ziel. Normalerweise wird dies als Teil des Backend-Arguments angegeben, aber wenn du manuell ein Target-Objekt erstellt hast, kannst du es hier angeben. Dies überschreibt das Ziel von `backend`.
- `backend_properties` (BackendProperties) - Von einer QPU zurückgegebene Eigenschaften, einschließlich Informationen über Gate-Fehler, Auslesefehler, Qubit-Kohärenzzeiten usw. Finde eine QPU, die diese Informationen bereitstellt, indem du `backend.properties()` ausführst.
- `timing_constraints` (Dict[str, int] | None) - Eine optionale Hardware-Beschränkung für die Zeitauflösung von Anweisungen. Diese Information wird durch die QPU-Konfiguration bereitgestellt. Wenn die QPU keine Beschränkung für die Zeitaufteilung von Anweisungen hat, ist `timing_constraints` `None` und es wird keine Anpassung vorgenommen. Eine QPU kann eine Reihe von Beschränkungen melden, nämlich:
    - `granularity`: Ein ganzzahliger Wert, der die minimale Puls-Gate-Auflösung in Einheiten von dt darstellt. Ein benutzerdefiniertes Puls-Gate sollte eine Dauer haben, die ein Vielfaches dieses Granularitätswerts ist.
    - `min_length`: Ein ganzzahliger Wert, der die minimale Puls-Gate-Länge in Einheiten von dt darstellt. Ein benutzerdefiniertes Puls-Gate sollte länger als diese Länge sein.
    - `pulse_alignment`: Ein ganzzahliger Wert, der eine Zeitauflösung der Startzeit von Gate-Anweisungen darstellt. Gate-Anweisungen sollten zu einem Zeitpunkt beginnen, der ein Vielfaches dieses Werts ist.
    - `acquire_alignment`: Ein ganzzahliger Wert, der eine Zeitauflösung der Startzeit von Messanweisungen darstellt. Messanweisungen sollten zu einem Zeitpunkt beginnen, der ein Vielfaches dieses Werts ist.
</details>

<details>
  <summary>
    **Layout- und Topologie-Parameter**
  </summary>

- `basis_gates` (List[str] | None) - Liste der Basis-Gate-Namen, zu denen aufgerollt werden soll. Zum Beispiel ['u1', 'u2', 'u3', 'cx']. Wenn `None`, nicht aufrollen.
- `coupling_map` (CouplingMap | List[List[int]]) - Gerichtete Coupling Map (möglicherweise benutzerdefiniert), die beim Mapping angesteuert werden soll. Wenn die Coupling Map symmetrisch ist, müssen beide Richtungen angegeben werden. Diese Formate werden unterstützt:
    - CouplingMap-Instanz
    - Liste - muss als Adjazenzmatrix angegeben werden, wobei jeder Eintrag alle gerichteten Zwei-Qubit-Interaktionen spezifiziert, die von der QPU unterstützt werden. Zum Beispiel: [[0, 1], [0, 3], [1, 2], [1, 5], [2, 5], [4, 1], [5, 3]]
- `inst_map` (List[InstructionScheduleMap] | None) - Zuordnung von Schaltungsoperationen zu Pulssequenzen. Wenn `None`, wird die `instruction_schedule_map` der QPU verwendet.
</details>

### Parameter zur Beeinflussung der Funktionsweise des Transpilers {#parameters-used-to-influence-how-the-transpiler-works}

Diese Parameter beeinflussen bestimmte Transpilierungsstufen. Einige von ihnen können mehrere Stufen beeinflussen, wurden aber der Einfachheit halber nur unter einer Stufe aufgeführt. Wenn du ein Argument angibst, wie z. B. `initial_layout` für die Qubits, die du verwenden möchtest, überschreibt dieser Wert alle Passes, die ihn ändern könnten. Mit anderen Worten, der Transpiler ändert nichts, was du manuell angibst. Einzelheiten zu bestimmten Stufen findest du unter [Transpiler stages](transpiler-stages).

<details>
  <summary>
    **Initialisierungsstufe**
  </summary>

- `hls_config` (HLSConfig) - Eine optionale Konfigurationsklasse `HLSConfig`, die direkt an den `HighLevelSynthesis`-Transformationspass übergeben wird. Mit dieser Konfigurationsklasse kannst du die Listen der Synthese-Algorithmen und deren Parameter für verschiedene High-Level-Objekte angeben.
- `init_method` (str) - Der Plugin-Name, der für die Initialisierungsstufe verwendet werden soll. Standardmäßig wird kein externes Plugin verwendet. Du kannst eine Liste der installierten Plugins anzeigen, indem du `list_stage_plugins()` mit `init` als Stage-Name-Argument ausführst.
- `unitary_synthesis_method` (str) - Der Name der zu verwendenden unitären Synthesemethode. Standardmäßig wird `default` verwendet. Du kannst eine Liste der installierten Plugins anzeigen, indem du `unitary_synthesis_plugin_names()` ausführst.
- `unitary_synthesis_plugin_config` (dict) - Ein optionales Konfigurationswörterbuch, das direkt an das unitäre Synthese-Plugin übergeben wird. Standardmäßig hat diese Einstellung keine Auswirkung, da die standardmäßige unitäre Synthesemethode keine benutzerdefinierte Konfiguration annimmt. Die Anwendung einer benutzerdefinierten Konfiguration sollte nur notwendig sein, wenn ein unitäres Synthese-Plugin mit dem Argument `unitary_synthesis` angegeben wird. Da dies für jedes unitäre Synthese-Plugin spezifisch ist, lies bitte die Dokumentation des Plugins, um zu erfahren, wie du diese Option verwendest.
</details>

<details>
  <summary>
    **Layout-Stufe**
  </summary>

- `initial_layout` (Layout | Dict | List) - Anfangsposition der virtuellen Qubits auf physischen Qubits. Wenn dieses Layout die Schaltung mit den `coupling_map`-Beschränkungen kompatibel macht, wird es verwendet. Das endgültige Layout ist nicht garantiert gleich, da der Transpiler Qubits durch Swaps oder andere Mittel permutieren kann. Vollständige Details findest du im [Initial layout-Abschnitt.](common-parameters#initial-layout)
- `layout_method` (str) - Name des Layout-Auswahlpasses (`default`, `dense`, `sabre` und `trivial`). Dies kann auch der externe Plugin-Name sein, der für die Layout-Stufe verwendet werden soll. Du kannst eine Liste der installierten Plugins anzeigen, indem du `list_stage_plugins()` mit `layout` als `stage_name`-Argument ausführst. Der Standardwert ist `sabre`.
</details>

<details>
  <summary>
    **Routing-Stufe**
  </summary>

- `routing_method` (str) - Name des Routing-Passes (`basic`, `lookahead`, `default`, `sabre` oder `none`). Dies kann auch der externe Plugin-Name sein, der für die Routing-Stufe verwendet werden soll. Du kannst eine Liste der installierten Plugins anzeigen, indem du `list_stage_plugins()` mit `routing` als `stage_name`-Argument ausführst. Der Standardwert ist `sabre`.
</details>

<details>
  <summary>
    **Übersetzungsstufe**
  </summary>

- `translation_method` (str) - Name des Übersetzungspasses (`default`, `synthesis`, `translator`, `ibm_backend`, `ibm_dynamic_circuits`, `ibm_fractional`). Dies kann auch der externe Plugin-Name sein, der für die Übersetzungsstufe verwendet werden soll. Du kannst eine Liste der installierten Plugins anzeigen, indem du `list_stage_plugins()` mit `translation` als `stage_name`-Argument ausführst. Der Standardwert ist `translator`.
</details>

<details>
  <summary>
    **Optimierungsstufe**
  </summary>

- `approximation_degree` (float, im Bereich 0-1 | None) - Heuristisches Maß für die Schaltungsapproximation (1.0 = keine Approximation, 0.0 = maximale Approximation). Der Standardwert ist 1.0. Die Angabe von `None` setzt den Approximationsgrad auf die gemeldete Fehlerrate. Weitere Details findest du im [Approximation degree-Abschnitt](common-parameters#approx-degree).
- `optimization_method` (str) - Der Plugin-Name, der für die Optimierungsstufe verwendet werden soll. Standardmäßig wird kein externes Plugin verwendet. Du kannst eine Liste der installierten Plugins anzeigen, indem du `list_stage_plugins()` mit `optimization` als `stage_name`-Argument ausführst.
</details>

<details>
  <summary>
    **Scheduling-Stufe**
  </summary>

- `scheduling_method` (str) - Name des Scheduling-Passes. Dies kann auch der externe Plugin-Name sein, der für die Scheduling-Stufe verwendet werden soll. Du kannst eine Liste der installierten Plugins anzeigen, indem du `list_stage_plugins()` mit `scheduling` als `stage_name`-Argument ausführst.
  * 'as_soon_as_possible': Plant Anweisungen gierig, so früh wie möglich auf einer Qubit-Ressource (Alias: `asap`).
  * 'as_late_as_possible': Plant Anweisungen spät, d.h. hält Qubits nach Möglichkeit im Grundzustand (Alias: `alap`). Dies ist die Standardeinstellung.
</details>

<details>
  <summary>
    **Transpiler-Ausführung**
  </summary>

- `seed_transpiler` (int) - Setzt Zufallszahlen-Seeds für die stochastischen Teile des Transpilers.
</details>

Die folgenden Standardwerte werden verwendet, wenn du keinen der oben genannten Parameter angibst. Weitere Informationen findest du auf der [API-Referenzseite](../api/qiskit/transpiler_preset) der Methode:

```python
generate_preset_pass_manager(
    optimization_level=1,
    backend=None,
    target=None,
    basis_gates=None,
    coupling_map=None,
    initial_layout=None,
    layout_method=None,
    routing_method=None,
    translation_method=None,
    scheduling_method=None,
    approximation_degree=1.0,
    seed_transpiler=None,
    unitary_synthesis_method="default",
    unitary_synthesis_plugin_config=None,
    hls_config=None,
    init_method=None,
    optimization_method=None,
)
```

```text
<qiskit.transpiler.passmanager.StagedPassManager at 0x7fa3e6dab110>
```

## Nächste Schritte {#next-steps}

<Admonition type="tip" title="Empfehlungen">
    - Erfahre, wie du [Set the optimization level](set-optimization) festlegst.
    - Überprüfe weitere [Commonly used parameters](common-parameters).
    - Erfahre, wie du [Set the optimization level when using Qiskit Runtime.](./runtime-options-overview) festlegst.
    - Besuche das Thema [Transpile with pass managers](transpile-with-pass-managers).
    - Beispiele findest du unter [Representing quantum computers.](./represent-quantum-computers)
    - Erfahre, [wie du Schaltungen transpilierst](/guides/circuit-transpilation-settings) als Teil des Qiskit-Patterns-Workflows mit Qiskit Runtime.
    - Überprüfe die [Transpile-API-Dokumentation](https://docs.quantum.ibm.com/api/qiskit/transpiler).
</Admonition>
