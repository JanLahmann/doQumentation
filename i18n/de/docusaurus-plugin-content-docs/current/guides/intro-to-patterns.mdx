---
title: Entwicklungsworkflow
description: Ein Qiskit Pattern ist die Menge von umfassenden Schritten zur Verwendung beim Ausführen eines domänenspezifischen Problems auf Quantenhardware.
---
{/* doqumentation-source-hash: a8683eee */}

# Entwicklungsworkflow {#development-workflow}

Der Begriff *Qiskit Pattern* beschreibt den Entwicklungsworkflow für das Aufschlüsseln domänenspezifischer Probleme und die Kontextualisierung erforderlicher Fähigkeiten in Phasen. Dies ermöglicht die nahtlose Zusammensetzbarkeit neuer Fähigkeiten, die von IBM Quantum&reg;-Forschern (und anderen) entwickelt wurden, und ermöglicht eine Zukunft, in der Quantum-Computing-Aufgaben von leistungsstarker heterogener (CPU/GPU/QPU) Computerinfrastruktur ausgeführt werden. Blöcke oder Gruppen von Blöcken führen die Schritte eines Patterns aus, wobei das Qiskit SDK eine wichtige grundlegende Schicht bereitstellt, die von anderen Tools oder Diensten unterstützt wird, die von IBM Quantum oder der Quantum-Open-Source-Community entwickelt wurden. Qiskit Patterns ermöglichen es Domänenexperten, ein Problem zu spezifizieren und die Tools (Blöcke) zusammenzustellen, die ein Qiskit Pattern erreichen. Dieses Pattern kann dann lokal, über Cloud-Dienste oder mit Qiskit Serverless bereitgestellt ausgeführt werden.

Die vier Schritte eines Qiskit Patterns sind wie folgt:

- **Abbilden** des Problems auf Quantenschaltungen und Operatoren
- **Optimieren** für Zielhardware
- **Ausführen** auf Zielhardware
- **Nachbearbeiten** der Ergebnisse

Jeder Schritt wird in den folgenden Abschnitten detailliert beschrieben.

## Abbilden des Problems auf Quantenschaltungen und Operatoren {#map-the-problem-to-quantum-circuits-and-operators}

Dieser Schritt beschreibt, wie ein Benutzer mit einem klassischen Problem beginnt und herausfindet, wie er es auf einen Quantencomputer abbildet. Beispielsweise umfasst dieser Schritt in Anwendungen wie Chemie und Quantensimulation im Allgemeinen die Konstruktion einer Quantenschaltung, die den Hamiltonian darstellt, den Sie zu lösen versuchen. Während dieses Schritts kann es für bestimmte Probleme auch wünschenswert sein, die Abbildung des Problems auf Qubits im Heavy-Hex-(oder Grob-)Gitter der IBM&reg;-Hardware von Anfang an festzulegen, wenn die Struktur des Problems sich zur frühzeitigen Optimierung eignet. Es ist auch zu diesem Zeitpunkt wert, zu überlegen, was das Ergebnis des jeweiligen Algorithmus sein wird, in Vorbereitung auf den späteren Ausführungsschritt - zum Beispiel, wenn das gewünschte Ergebnis das Ableiten von Korrelationsfunktionen unter Verwendung von Hadamard-Tests umfasst, könnten Sie sich darauf vorbereiten, Sampler zu verwenden, während die Spezifikation von Observables den Estimator verwenden würde und viele Fehlerminderungsoptionen bieten könnte.

Die Ausgabe dieses Schritts ist normalerweise eine Sammlung von Schaltungen oder Quantenoperatoren, die im nächsten Schritt für Hardware optimiert werden können.

## Optimieren für Zielhardware {#optimize-for-target-hardware}

In diesem Schritt nehmen Sie die abstrakten Schaltungen (oder Operatoren), die aus dem Abbildungsschritt erstellt wurden, und führen eine Reihe von Optimierungen an ihnen durch. Dies kann das Abbilden der Route und des Layouts der Schaltung auf physische Qubit-Hardware, das Konvertieren in Basis-Gates der Hardware und die Reduzierung der Anzahl der Operationen umfassen, alles darauf ausgelegt, die Erfolgswahrscheinlichkeit im späteren Ausführungsschritt zu optimieren. An diesem Punkt möchten Sie möglicherweise auch Ihre Schaltungen mit einem Simulator testen, bevor Sie im nächsten Schritt auf echter Hardware ausführen.

Während dieses Schritts müssen abstrakte Schaltungen in Instruction Set Architecture (ISA)-Schaltungen transpiliert werden. Eine ISA-Schaltung ist eine, die nur aus Gates besteht, die von der Zielhardware verstanden werden (Basis-Gates), und alle Multi-Qubit-Gates müssen alle Konnektivitätsbeschränkungen (Coupling Map) einhalten. Nur ISA-Schaltungen können auf IBM-Hardware mit IBM Qiskit Runtime ausgeführt werden.

## Ausführen auf Zielhardware {#execute-on-target-hardware}

Dieser Schritt umfasst die Ausführung Ihrer Schaltungen auf Hardware und erzeugt die Ausgaben der Quantenberechnung. Die im vorherigen Schritt erstellten ISA-Schaltungen können entweder mit einem Sampler- oder Estimator-Primitiv aus Qiskit Runtime ausgeführt werden, das lokal auf Ihrem Computer oder von einem Cluster oder einer anderen heterogenen Rechenumgebung aus initialisiert wird. Diese können in einem Batch ausgeführt werden, der parallele Transpilierung für klassische Recheneffizienz ermöglicht - oder in einer Session, die es ermöglicht, iterative Aufgaben effizient ohne Warteschlangenverzögerungen zu implementieren. Während dieses Schritts gibt es auch die Option, bestimmte Fehlerunterdrückungs- und Minderungstechniken zu konfigurieren, die von Qiskit Runtime bereitgestellt werden.

Je nachdem, ob Sie das Sampler- oder Estimator-Primitiv verwenden, wird das Ergebnis dieses Schritts unterschiedlich sein. Bei Verwendung des Samplers wird die Ausgabe pro-Shot-Messungen in Form von Bitstrings sein. Bei Verwendung des Estimators wird die Ausgabe Erwartungswerte von Observables sein, die physikalischen Größen oder Kostenfunktionen entsprechen.

## Nachbearbeiten der Ergebnisse {#post-process-results}

Dieser letzte Schritt umfasst das Zusammenfügen der Ausgaben aus dem vorherigen Schritt, um das gewünschte Ergebnis zu erhalten. Dies kann eine Reihe klassischer Datenverarbeitungsschritte umfassen, wie z.B. das Visualisieren von Ergebnissen, Readout-Fehlerminderungstechniken, das Marginalisieren von Quasi-Wahrscheinlichkeitsverteilungen zur Ermittlung von Ergebnissen auf kleineren Qubit-Sätzen oder Post-Selektion auf inhärenten Eigenschaften des Problems, wie Gesamtspin, Parität oder Teilchenerhaltung durch Entfernen unphysikalischer Observables.

Da sich das Feld von maßgeschneiderter Schaltungskonstruktion zu Workflows im Utility-Scale bewegt, eröffnet die Flexibilität und Leichtigkeit, mit der Qiskit Patterns es Benutzern ermöglichen, die verschiedenen Schritte des Patterns zusammenzustellen, das Quantencomputing für eine Vielzahl von Anwendungen und Techniken zur einfachen Nutzung durch Quantenberechnungswissenschaftler.
