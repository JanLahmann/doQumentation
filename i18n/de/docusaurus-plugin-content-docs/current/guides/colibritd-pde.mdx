---
title: "QUICK-PDE - Eine Qiskit Function von ColibriTD"
sidebar_label: "QUICK-PDE - Eine Qiskit Function von ColibriTD"
description: "Die QUICK-PDE-Funktion löst domänenspezifische partielle Differentialgleichungen unter Verwendung des H-DES-Algorithmus von ColibriTD, der komplexe Multiphysik-Probleme lösen kann."
notebook_path: "docs/guides/colibritd-pde.ipynb"
---
{/* doqumentation-source-hash: f194bb4f */}

<OpenInLabBanner notebookPath="docs/guides/colibritd-pde.ipynb" />



{/* cspell:ignore CMAES, Hypoelastic, edgecolor, royalblue, rstride, cstride, colibritd, xlabel, ylabel, zlabel, Jaffali */}
# QUICK-PDE: Eine Qiskit Function von ColibriTD {#quick-pde-a-qiskit-function-by-colibritd}

<Admonition type="note">
  Qiskit Functions sind eine experimentelle Funktion, die Benutzern des IBM Quantum&reg; Premium Plans, Flex Plans und On-Prem (über IBM Quantum Platform API) Plans zur Verfügung steht. Sie befinden sich im Preview-Release-Status und können sich ändern.
</Admonition>
## Überblick {#overview}

Der hier vorgestellte Solver für partielle Differentialgleichungen (PDE) ist Teil unserer Quantum Innovative Computing Kit (QUICK)-Plattform (QUICK-PDE) und wird als Qiskit Function bereitgestellt. Mit der QUICK-PDE-Funktion kannst du domänenspezifische partielle Differentialgleichungen auf IBM Quantum QPUs lösen. Diese Funktion basiert auf dem in [ColibriTDs H-DES-Beschreibungspapier](https://arxiv.org/abs/2410.01130) beschriebenen Algorithmus. Dieser Algorithmus kann komplexe Multiphysik-Probleme lösen, beginnend mit Computational Fluid Dynamics (CFD) und Materials Deformation (MD), wobei weitere Anwendungsfälle in Kürze folgen.

Um die Differentialgleichungen anzugehen, werden die Testlösungen als Linearkombinationen orthogonaler Funktionen (typischerweise Chebyshev-Polynome, und genauer $2^n$ davon, wobei $n$ die Anzahl der Qubits ist, die deine Funktion kodieren) kodiert, parametrisiert durch die Winkel einer Variable Quantum Circuit (VQC). Der Ansatz erzeugt einen Zustand, der die Funktion kodiert, die durch Observablen ausgewertet wird, deren Kombinationen die Auswertung der Funktion an allen Punkten ermöglichen. Du kannst dann die Verlustfunktion auswerten, in der die Differentialgleichungen kodiert sind, und die Winkel in einer hybriden Schleife feinabstimmen, wie im Folgenden gezeigt. Die Testlösungen kommen den tatsächlichen Lösungen schrittweise näher, bis du ein zufriedenstellendes Ergebnis erreichst.

![Workflow der QUICK-PDE-Funktion](/docs/images/guides/colibritd-equation-solver/diagram.svg)

Zusätzlich zu dieser hybriden Schleife kannst du auch verschiedene Optimierer verketten. Dies ist nützlich, wenn du einen globalen Optimierer verwenden möchtest, um einen guten Satz von Winkeln zu finden, und dann einen feineren Optimierer, um einem Gradienten zum besten Satz benachbarter Winkel zu folgen. Im Fall der Computational Fluid Dynamics (CFD) liefert die Standard-Optimierungssequenz die besten Ergebnisse - aber im Fall der Material Deformation (MD) kannst du, während der Standard gute Ergebnisse liefert, ihn für problemspezifische Vorteile weiter konfigurieren.

Beachte, dass wir für jede Variable der Funktion die Anzahl der Qubits angeben (mit der du experimentieren kannst). Durch das Stapeln von 10 identischen Schaltungen und die Auswertung der 10 identischen Observablen auf verschiedenen Qubits durch eine große Schaltung kannst du innerhalb des CMA-Optimierungsprozesses Rauschminderung durchführen, wobei du auf die Noise-Learner-Methode vertraust und die Anzahl der benötigten Shots erheblich reduzierst.
## Eingabe/Ausgabe {#inputoutput}

### Computational Fluid Dynamics

Die inviszide Burgers-Gleichung modelliert strömende nicht-viskose Flüssigkeiten wie folgt:

$$\frac{\partial u}{\partial t} + u\frac{\partial u}{\partial x} = 0,$$

$u$ stellt das Fluidgeschwindigkeitsfeld dar. Dieser Anwendungsfall hat eine zeitliche Randbedingung: Du kannst die Anfangsbedingung auswählen und dann das System relaxieren lassen. Derzeit sind die einzigen akzeptierten Anfangsbedingungen lineare Funktionen: $ax + b$.

Die Argumente für CFDs Differentialgleichungen befinden sich auf einem festen Gitter wie folgt:

- $t$ liegt zwischen 0 und 0,95 mit 30 Abtastpunkten. $x$ liegt zwischen 0 und 0,95 mit einer Schrittweite von 0,2375.

### Material Deformation

Dieser Anwendungsfall konzentriert sich auf hypoelastische Verformung mit dem eindimensionalen Zugversuch, bei dem ein im Raum fixierter Stab an seinem anderen Ende gezogen wird. Wir beschreiben das Problem wie folgt:

$$u' - \frac{\sigma}{3K} - \frac{2}{\sqrt{3}}\epsilon_0\left(\frac{\sigma'}{\sigma_0\sqrt{3}}\right)^n = 0$$

$$\sigma' - b = 0,$$

$K$ stellt den Kompressionsmodul des gedehnten Materials dar, $n$ den Exponenten eines Potenzgesetzes, $b$ die Kraft pro Masseneinheit, $\epsilon_0$ die Proportionalitätsspannungsgrenze, $\sigma_0$ die Proportionalitätsdehnungsgrenze, $u$ die Spannungsfunktion und $\sigma$ die Dehnungsfunktion.

Der betrachtete Stab hat eine Einheitslänge. Dieser Anwendungsfall hat eine Randbedingung für Oberflächenspannung $t$, oder die Menge an Arbeit, die benötigt wird, um den Stab zu dehnen.

Die Argumente für MDs Differentialgleichungen befinden sich auf einem festen Gitter wie folgt:

- $x$ liegt zwischen 0 und 1 mit einer Schrittweite von 0,04.
### Eingabe {#input}

Um die QUICK-PDE Qiskit Function auszuführen, kannst du die folgenden Parameter anpassen:

| Name              | Typ                                                  | Beschreibung                                                                                                                                                                                                                                                                                  | Anwendungsfallspezifisch | Beispiel                 |
| ----------------- | ---------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------ | ------------------------ |
| use_case          | `Literal["MD", "CFD"]`                               | Umschalter zur Auswahl des zu lösenden Systems von Differentialgleichungen                                                                                                                                                                                                                    | Nein                     | `"CFD"`                  |
| parameters        | `dict[str, Any]`                                     | Parameter der Differentialgleichung (weitere Details siehe nächste Tabelle)                                                                                                                                                                                                                   | Nein                     | `{"a": 1.0, "b": 1.0}`   |
| nb_qubits         | `Optional[dict[str, dict[str, int]]]`                | Anzahl der Qubits pro Funktion und pro Variable. Optimierte Werte werden von der Funktion ausgewählt, aber wenn du versuchen möchtest, eine bessere Kombination zu finden, kannst du die Standardwerte überschreiben                                                                        | Nein                     | `{"u": {"x": 1, "t":3}}` |
| depth             | `Optional[dict[str, int]]`                           | Tiefe des Ansatzes pro Funktion. Optimierte Werte werden von der Funktion ausgewählt, aber wenn du versuchen möchtest, eine bessere Kombination zu finden, kannst du die Standardwerte überschreiben                                                                                        | Nein                     | `{"u": 4}`               |
| optimizer         | `Optional[list[str]]`                                | Zu verwendende Optimierer, entweder "CMAES" aus der [`cma` Python-Bibliothek](https://github.com/CMA-ES/pycma) oder einer der [scipy-Optimierer](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html)                                                          | MD                       | `"SLSQP"`                |
| shots             | `Optional[list[int]]`                                | Anzahl der Shots zur Ausführung jeder Schaltung. Da mehrere Optimierungsschritte erforderlich sind, muss die Länge der Liste gleich der Anzahl der verwendeten Optimierer sein (4 im Fall von CFD). Standard ist `[50_000] * nb_optimizers` für MD und `[5_00, 2_000, 5_000, 10_000]` für CFD | Nein                     | `[15_000, 30_000]`       |
| optimizer_options | `Optional[dict[str, Any]]`                           | Optionen zur Übergabe an den Optimierer. Die Details dieser Eingabe hängen vom verwendeten Optimierer ab; für Einzelheiten siehe die Dokumentation des verwendeten Optimierers                                                                                                                | MD                       | `{"maxiter": 50 }`       |
| initialization    | `Optional[Literal["RANDOM", "PHYSICALLY_INFORMED"]]` | Ob mit zufälligen Winkeln oder intelligent gewählten Winkeln begonnen werden soll. Beachte, dass intelligent gewählte Winkel möglicherweise nicht in 100% der Fälle funktionieren. Standard ist `"PHYSICALLY_INFORMED"`.                                                                 | Nein                     | `"RANDOM"`               |
| backend_name      | `Optional[str]`                                      | Der zu verwendende Backend-Name.                                                                                                                                                                                                                                                              | Nein                     | `"ibm_torino"`           |
| mode              | `Optional[Literal["job", "session", "batch"]]`       | Der zu verwendende Ausführungsmodus. Standard ist `"job"`.                                                                                                                                                                                                                                    | Nein                     | `"job"`                  |

Die Parameter der Differentialgleichung (physikalische Parameter und Randbedingung) sollten dem angegebenen Format folgen:

| Anwendungsfall | Schlüssel   | Wertetyp | Beschreibung                            | Beispiel |
| -------------- | ----------- | -------- | --------------------------------------- | -------- |
| CFD            | `a`         | `float`  | Koeffizient der Anfangswerte von $u$    | `1.0`    |
| CFD            | `b`         | `float`  | Versatz der Anfangswerte von $u$        | `1.0`    |
| MD             | `t`         | `float`  | Oberflächenspannung                     | `12.0`   |
| MD             | `K`         | `float`  | Kompressionsmodul                       | `100.0`  |
| MD             | `n`         | `int`    | Potenzgesetz                            | `4.0`    |
| MD             | `b`         | `float`  | Kraft pro Masseneinheit                 | `10.0`   |
| MD             | `epsilon_0` | `float`  | Proportionalitätsspannungsgrenze        | `0.1`    |
| MD             | `sigma_0`   | `float`  | Proportionalitätsdehnungsgrenze         | `5.0`    |
### Ausgabe {#output}

Die Ausgabe ist ein Wörterbuch mit der Liste der Abtastpunkte sowie den Werten der Funktionen an jedem dieser Punkte:

```python
from numpy import array
```

```python
solution = {
    "functions": {
        "u": array(
            [
                [0.01, 0.1, 1],
                [0.02, 0.2, 2],
                [0.03, 0.3, 3],
                [0.04, 0.4, 4],
            ]
        ),
    },
    "samples": {
        "t": array([0.1, 0.2, 0.3, 0.4]),
        "x": array([0.5, 0.6, 0.7]),
    },
}
```

Die Form eines Lösungsarrays hängt von den Abtastpunkten der Variablen ab:

```python
assert len(solution["functions"]["u"].shape) == len(solution["samples"])
for col_size, samples in zip(
    solution["functions"]["u"].shape, solution["samples"].values()
):
    assert col_size == len(samples)
```

Die Zuordnung zwischen den Abtastpunkten der Funktionsvariablen und der Dimension des Lösungsarrays erfolgt in alphanumerischer Reihenfolge des Variablennamens. Wenn die Variablen beispielsweise `"t"` und `"x"` sind, repräsentiert eine Zeile von `solution["functions"]["u"]` die Werte der Lösung für ein festes `"t"`, und eine Spalte von `solution["functions"]["u"]` repräsentiert die Werte der Lösung für ein festes `"x"`.

Das Folgende ist ein Beispiel dafür, wie du den Wert der Funktion für einen bestimmten Satz von Koordinaten erhältst:

```python
# u(t=0.2, x=0.7) == 2
assert solution["samples"]["t"][1] == 0.2
assert solution["samples"]["x"][2] == 0.7
assert solution["functions"]["u"][1, 2] == 2
```

## Benchmarks

Die folgende Tabelle zeigt Statistiken zu verschiedenen Ausführungen unserer Funktion.

| Beispiel                              | Anzahl der Qubits | Initialisierung       | Fehler    | Gesamtzeit (min) | Runtime-Nutzung (min) |
| ------------------------------------- | ----------------- | --------------------- | --------- | ---------------- | --------------------- |
| Inviszide Burgers-Gleichung           | 50                | `PHYSICALLY_INFORMED` | $10^{-2}$ | 66               | 25                    |
| Hypoelastischer 1D-Zugversuch         | 18                | `RANDOM`              | $10^{-2}$ | 123              | 100                   |
## Erste Schritte {#get-started}

Fülle das [Formular aus, um Zugang zur QUICK-PDE-Funktion anzufordern.](https://forms.cloud.microsoft/e/3Wi9cbjQPK) Anschließend, vorausgesetzt du hast bereits [dein Konto gespeichert](/guides/functions#install-qiskit-functions-catalog-client) in deiner lokalen Umgebung, wähle die Funktion wie folgt aus:

```python
from qiskit_ibm_catalog import QiskitFunctionsCatalog

catalog = QiskitFunctionsCatalog(channel="ibm_quantum_platform")

quick = catalog.load("colibritd/quick-pde")
```

## Beispiele {#examples}

Um loszulegen, probiere eines der folgenden Beispiele:
### Computational Fluid Dynamics (CFD)

Wenn Anfangsbedingungen auf $u(0,x) = x$ gesetzt sind, sind die Ergebnisse wie folgt:

```python
# launch the simulation with initial conditions u(0,x) = a*x + b
job = quick.run(use_case="cfd", physical_parameters={"a": 1.0, "b": 0.0})
```

Überprüfe den [Status](/guides/functions#check-job-status) deiner Qiskit Function-Workload oder gib [Ergebnisse](/guides/functions#retrieve-results) wie folgt zurück:

```python
print(job.status())
solution = job.result()
```

```text
'QUEUED'
```

```python
import numpy as np
import matplotlib.pyplot as plt

_ = plt.figure()
ax = plt.axes(projection="3d")

# plot the solution using the 3d plotting capabilities of pyplot
t, x = np.meshgrid(solution["samples"]["t"], solution["samples"]["x"])
ax.plot_surface(
    t,
    x,
    solution["functions"]["u"],
    edgecolor="royalblue",
    lw=0.25,
    rstride=26,
    cstride=26,
    alpha=0.3,
)
ax.scatter(t, x, solution["functions"]["u"], marker=".")
ax.set(xlabel="t", ylabel="x", zlabel="u(t,x)")

plt.show()
```

![Output of the previous code cell](/docs/images/guides/colibritd-pde/extracted-outputs/c42aba9b-0.avif)

### Material Deformation

Der Material Deformation-Anwendungsfall erfordert die physikalischen Parameter deines Materials und die angewandte Kraft wie folgt:

```python
import matplotlib.pyplot as plt

# select the properties of your material
job = quick.run(
    use_case="md",
    physical_parameters={
        "t": 12.0,
        "K": 100.0,
        "n": 4.0,
        "b": 10.0,
        "epsilon_0": 0.1,
        "sigma_0": 5.0,
    },
)

# plot the result
solution = job.result()

_ = plt.figure()
stress_plot = plt.subplot(211)
plt.plot(solution["samples"]["x"], solution["functions"]["u"])
strain_plot = plt.subplot(212)
plt.plot(solution["samples"]["x"], solution["functions"]["sigma"])

plt.show()
```

![Output of the previous code cell](/docs/images/guides/colibritd-pde/extracted-outputs/a568e325-0.avif)

## Fehlermeldungen abrufen {#fetch-error-messages}

Wenn der Status deiner Workload `ERROR` ist, verwende `job.error_message()`, um die Fehlermeldung zum Debuggen abzurufen, wie folgt:

```python
job = quick.run(use_case="mdf", physical_params={})

print(job.error_message())

# or write a wrapper around it for a more human readable version
def pprint_error(job):
    print("".join(eval(job.error_message())["error"]))

print("___")
pprint_error(job)
```

```text
{"error": ["qiskit.exceptions.QiskitError: 'Unknown argument \"physical_params\", did you make a typo? -- https://docs.quantum.ibm.com/errors#1804'\n"]}
___
qiskit.exceptions.QiskitError: 'Unknown argument "physical_params", did you make a typo? -- https://docs.quantum.ibm.com/errors#1804'
```

## Support erhalten {#get-support}

Für Support kontaktiere qiskit-function-support@colibritd.com.
## Nächste Schritte {#next-steps}

<Admonition type="tip" title="Empfehlungen">
- Fülle das Formular aus, um [Zugang zur QUICK-PDE-Funktion anzufordern.](https://forms.cloud.microsoft/e/3Wi9cbjQPK)
- Versuche, eine strömende nicht-viskose Flüssigkeit mit QUICK-PDE im [Tutorial](/tutorials/colibritd-pde) zu modellieren.
- Lies [Jaffali, H., et al. (2025). H-DES: a Quantum-Classical Hybrid Differential Equation Solver. arXiv preprint arXiv:2410.01130.](https://arxiv.org/abs/2410.01130)
</Admonition>
