---
title: "Fraktionale Gates"
sidebar_label: "Fraktionale Gates"
description: "Verwende fraktionale Gates zur Ausführung von Ein- und Zwei-Qubit-Rotationen"
notebook_path: "docs/guides/fractional-gates.ipynb"
---
{/* doqumentation-source-hash: d3f6ba44 */}

<OpenInLabBanner notebookPath="docs/guides/fractional-gates.ipynb" />



{/*
  DO NOT EDIT THIS CELL!!!
  This cell's content is generated automatically by a script. Anything you add
  here will be removed next time the notebook is run. To add new content, create
  a new cell before or after this one.
*/}

<details>
<summary><b>Package versions</b></summary>

The code on this page was developed using the following requirements.
We recommend using these versions or newer.

```
qiskit[all]~=2.3.0
qiskit-ibm-runtime~=0.43.1
```
</details>
Diese Seite stellt zwei neu unterstützte Gate-Typen auf der IBM Quantum&reg; Flotte von QPUs vor. Diese *fraktionalen* Gates werden auf [Heron QPUs](/guides/processor-types#heron) in folgender Form unterstützt:
- $R_{ZZ}(\theta)$ für $0 \lt \theta \leq \pi/2$
- $R_X(\theta)$ für beliebige $\theta$

Diese Seite behandelt die Anwendungsfälle, in denen die Implementierung fraktionaler Gates die Effizienz deiner Workflows verbessern kann, sowie die Verwendung dieser Gates auf IBM Quantum QPUs.
## Wie man fraktionale Gates verwendet {#how-to-use-fractional-gates}

Intern funktionieren diese fraktionalen Gates durch direkte Ausführung einer $R_{ZZ}(\theta)$ und $R_X(\theta)$ Rotation für einen beliebigen Winkel. Die Verwendung des $R_X(\theta)$ Gates kann die Dauer und den Fehler für Ein-Qubit-Rotationen beliebigen Winkels um bis zu einen Faktor zwei reduzieren. Die direkte Ausführung der $R_{ZZ}(\theta)$ Gate-Rotation vermeidet die Zerlegung in mehrere `CZGate`-Objekte und reduziert somit ebenfalls die Dauer und den Fehler eines Schaltkreises. Dies ist besonders nützlich für Schaltkreise, die viele Ein- und Zwei-Qubit-Rotationen enthalten, wie etwa bei der Simulation der Dynamik eines Quantensystems oder bei der Verwendung eines variationalen Ansatzes mit vielen Parametern.

Obwohl diese Arten von Gates in der [Bibliothek der Standardgates](./circuit-library) enthalten sind, die ein `QuantumCircuit` besitzen kann, können sie nur auf spezifischen IBM Quantum QPUs verwendet werden und müssen mit dem auf `True` gesetzten Flag `use_fractional_gates` geladen werden (siehe unten). Dieses Flag stellt sicher, dass fraktionale Gates im `Target` des Backends für den Transpiler enthalten sind.

```python
service = QiskitRuntimeService()
backend = service.backend('ibm_torino', use_fractional_gates=True)
```

Dieses Codebeispiel demonstriert, wie fraktionale Gates im Kontext eines Workflows verwendet werden, der die Dynamik einer Ising-Kette unter Verwendung fraktionaler Gates simuliert. Die Schaltkreisdauer wird dann mit einem Backend verglichen, das keine fraktionalen Gates verwendet.

<Admonition title="Hinweis zu gemeldeten Fehlerraten" type="note">
  Der im `Target` eines Backends mit aktivierten fraktionalen Gates gemeldete Fehlerwert ist lediglich eine Kopie des Gegenstücks des nicht-fraktionalen Gates (was möglicherweise nicht identisch ist). Dies liegt daran, dass die Meldung von Fehlerraten für fraktionale Gates noch nicht unterstützt wird.

  Da jedoch die Gate-Zeit von fraktionalen und nicht-fraktionalen Gates gleich ist, ist es eine vernünftige Annahme, dass ihre Fehlerraten vergleichbar sind - insbesondere wenn die dominierende Fehlerquelle in einem Schaltkreis auf Relaxation zurückzuführen ist.
</Admonition>

```python
from qiskit import QuantumCircuit
from qiskit.circuit import Parameter
from qiskit.transpiler import generate_preset_pass_manager
from qiskit.visualization.timeline import draw as draw_timeline, IQXSimple

from qiskit_ibm_runtime import QiskitRuntimeService

num_qubits = 5
num_time_steps = 3
rx_angle = 0.1
rzz_angle = 0.1

ising_circuit = QuantumCircuit(num_qubits)
for i in range(num_time_steps):
    # rx layer
    for q in range(num_qubits):
        ising_circuit.rx(rx_angle, q)
    for q in range(1, num_qubits - 1, 2):
        ising_circuit.rzz(rzz_angle, q, q + 1)
    # 2nd rzz layer
    for q in range(0, num_qubits - 1, 2):
        ising_circuit.rzz(rzz_angle, q, q + 1)
    ising_circuit.barrier()
ising_circuit.draw("mpl")
```

![Output of the previous code cell](/docs/images/guides/fractional-gates/extracted-outputs/9cb7f696-dec0-4393-9320-fe945326c893-0.svg)

Spezifiziere zwei Backend-Objekte: eines mit aktivierten fraktionalen Gates und das andere mit deaktivierten Gates, und transpiliere beide.

```python
service = QiskitRuntimeService()
backend_fractional = service.backend("ibm_torino", use_fractional_gates=True)
backend_conventional = service.backend(
    "ibm_torino", use_fractional_gates=False
)

pm_fractional = generate_preset_pass_manager(
    optimization_level=3, backend=backend_fractional, scheduling_method="alap"
)
pm_conventional = generate_preset_pass_manager(
    optimization_level=3,
    backend=backend_conventional,
    scheduling_method="alap",
)

ising_circuit_fractional = pm_fractional.run(ising_circuit)
ising_circuit_conventional = pm_conventional.run(ising_circuit)
```

Zeige die Zeitachse des Schaltkreises unter Verwendung der beiden Gate-Typen an.

```python
# Draw timeline of circuit with conventional gates
draw_timeline(
    ising_circuit_conventional,
    idle_wires=False,
    target=backend_conventional.target,
    time_range=(0, 500),
    style=IQXSimple(),
)
```

![Output of the previous code cell](/docs/images/guides/fractional-gates/extracted-outputs/0013f5fa-4072-4aa4-94fe-7e195435f828-0.svg)

```python
# Draw timeline of circuit with fractional gates
draw_timeline(
    ising_circuit_fractional,
    idle_wires=False,
    target=backend_fractional.target,
    time_range=(0, 500),
    style=IQXSimple(),
)
```

![Output of the previous code cell](/docs/images/guides/fractional-gates/extracted-outputs/08dd1cdf-8b34-47c2-8324-f3538c9d1ab6-0.svg)

### Winkelbeschränkungen {#angle-constraints}

Für das Zwei-Qubit $R_{ZZ}(\theta)$ Gate können auf IBM Quantum Hardware nur Winkel zwischen $0$ und $\pi/2$ ausgeführt werden. Wenn ein Schaltkreis $R_{ZZ}(\theta)$ Gates mit einem Winkel außerhalb dieses Bereichs enthält, wird die Standard-Transpilations-Pipeline dies in der Regel mit einer geeigneten Schaltkreistransformation korrigieren (durch den [`FoldRzzAngle`](../api/qiskit-ibm-runtime/transpiler-passes-fold-rzz-angle) Pass). Für $R_{ZZ}(\theta)$ Gates, die einen oder mehrere [`Parameter`](../api/qiskit/qiskit.circuit.Parameter) enthalten, wird der Transpiler jedoch annehmen, dass diesen Parametern zur Laufzeit Winkel innerhalb dieses Bereichs zugewiesen werden. Der Job schlägt fehl, wenn einer der im an Qiskit Runtime übermittelten PUB angegebenen Parameterwerte außerhalb dieses Bereichs liegt.
## Wo man fraktionale Gates verwendet {#where-to-use-fractional-gates}

Historisch waren die auf IBM Quantum QPUs verfügbaren Basis-Gates **`CZ`**, **`X`**, **`RZ`**, **`SX`** und **`ID`**, die Schaltkreise mit Ein- und Zwei-Qubit-Rotationen, die keine Vielfachen von $\pi / 2$ sind, nicht effizient darstellen können. Beispielsweise muss ein $R_X(\theta)$ Gate bei der Transpilation in eine Reihe von $RZ$ und $\sqrt{X}$ Gates zerlegt werden, was einen Schaltkreis mit zwei Gates endlicher Dauer anstelle von einem erzeugt.

Ebenso erfordert die Zerlegung von Zwei-Qubit-Rotationen wie einem $R_{ZZ}(\theta)$ Gate bei der Transpilation zwei **`CZ`** Gates und mehrere Ein-Qubit-Gates, was die Schaltkreistiefe erhöht. Diese Zerlegungen werden im folgenden Code gezeigt.

```python
qc = QuantumCircuit(1)
param = Parameter("θ")
qc.rx(param, 0)
qc.draw("mpl")
```

![Output of the previous code cell](/docs/images/guides/fractional-gates/extracted-outputs/11b003ee-aa8e-4794-a84a-b6870d15fa11-0.svg)

```python
# Decomposition of an RX(θ) gate using the IBM Quantum QPU basis
service = QiskitRuntimeService()
backend = service.backend("ibm_torino")
optimization_level = 3
pm = generate_preset_pass_manager(optimization_level, backend=backend)
transpiled_circuit = pm.run(qc)
transpiled_circuit.draw("mpl", idle_wires=False)
```

![Output of the previous code cell](/docs/images/guides/fractional-gates/extracted-outputs/5da9bba4-9a3b-4569-9997-c5b9ccf87b6a-0.svg)

```python
from qiskit import QuantumCircuit
from qiskit.circuit import Parameter
from qiskit.transpiler import generate_preset_pass_manager

from qiskit_ibm_runtime import QiskitRuntimeService

qc = QuantumCircuit(2)
param = Parameter("θ")
qc.rzz(param, 0, 1)
qc.draw("mpl")
```

![Output of the previous code cell](/docs/images/guides/fractional-gates/extracted-outputs/6b256201-0237-4f63-91ff-fde1bb884804-0.svg)

```python
# Decomposition of an RZZ(θ) gate using the IBM Quantum QPU basis
service = QiskitRuntimeService()
backend = service.backend("ibm_torino")
optimization_level = 3
pm = generate_preset_pass_manager(optimization_level, backend=backend)
transpiled_circuit = pm.run(qc)
transpiled_circuit.draw("mpl", idle_wires=False)
```

![Output of the previous code cell](/docs/images/guides/fractional-gates/extracted-outputs/f07217b9-a6f0-4adf-b341-6da447535c33-0.svg)

Für Workflows, die viele Ein-Qubit $R_X(\theta)$ oder Zwei-Qubit-Rotationen erfordern (wie in einem variationalen Ansatz oder bei der Simulation der Zeitentwicklung von Quantensystemen), führt diese Beschränkung zu einem schnellen Wachstum der Schaltkreistiefe. Fraktionale Gates beseitigen jedoch diese Anforderung, da die Ein- und Zwei-Qubit-Rotationen direkt ausgeführt werden und einen effizienteren (und damit fehlerunterdrückten) Quantenschaltkreis erzeugen.
<span id="when-not-to-use"></span>
## Wann man fraktionale Gates *nicht* verwenden sollte {#when-not-to-use-fractional-gates}

Es ist wichtig zu beachten, dass fraktionale Gates eine *experimentelle* Funktion sind und sich das Verhalten des `use_fractional_gates` Flags in Zukunft ändern kann. Schau in den [Release Notes](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/release-notes) für neue Versionen von Qiskit Runtime nach weiteren Informationen. Siehe auch die API-Referenzdokumentation für [QiskitRuntimeService.backend](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/qiskit-runtime-service#backend), die `use_fractional_gates` beschreibt.

Zusätzlich hat der Qiskit-Transpiler nur begrenzte Fähigkeiten, $R_{ZZ}(\theta)$ in seinen Optimierungspässen zu verwenden. Dies erfordert mehr Sorgfalt beim Erstellen und Optimieren von Schaltkreisen, die diese Instruktionen enthalten.

Schließlich wird die Verwendung fraktionaler Gates nicht unterstützt für:
- [Dynamische Schaltkreise](/guides/classical-feedforward-and-control-flow)
- [Pauli Twirling](/guides/error-mitigation-and-suppression-techniques#pauli-twirling) - jedoch *wird* [Measurement Twirling mit TREX](/guides/error-mitigation-and-suppression-techniques#twirled-readout-error-extinction-trex) unterstützt.
- [Probabilistic Error Cancellation](/guides/error-mitigation-and-suppression-techniques#probabilistic-error-cancellation-pec)
- [Zero-Noise Extrapolation (unter Verwendung von Probabilistic Error Amplification)](/guides/error-mitigation-and-suppression-techniques#probabilistic-error-amplification-pea)

Lies den Leitfaden zu [Primitive-Optionen](/guides/runtime-options-overview), um mehr über die Anpassung der Fehlermilderungs- und Fehlerunterdrückungstechniken für einen bestimmten Quanten-Workload zu erfahren.
## Nächste Schritte {#next-steps}

<Admonition type="tip" title="Empfehlungen">
  -  Um mehr über Transpilation zu erfahren, siehe die Seite [Einführung in die Transpilation](/guides/transpile).
  -  Lies über das [Schreiben eines benutzerdefinierten Transpiler-Passes](/guides/custom-transpiler-pass).
  -  Verstehe, wie du [Fehlerminderung konfigurierst](/guides/configure-error-mitigation) für Qiskit Runtime.
</Admonition>
