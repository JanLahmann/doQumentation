---
title: "Schaltkreise visualisieren"
sidebar_label: "Schaltkreise visualisieren"
description: "Erstellen Sie Visualisierungen von Schaltkreisen und zeichnen Sie Job-Daten mit dem Qiskit Visualisierungsmodul"
notebook_path: "docs/guides/visualize-circuits.ipynb"
---

<OpenInLabBanner notebookPath="docs/guides/visualize-circuits.ipynb" />



{/* cspell:ignore qcircuit mactex, backgroundcolor, lightgreen */}
{/*
  DO NOT EDIT THIS CELL!!!
  This cell's content is generated automatically by a script. Anything you add
  here will be removed next time the notebook is run. To add new content, create
  a new cell before or after this one.
*/}

<details>
<summary><b>Package versions</b></summary>

Der Code auf dieser Seite wurde mit den folgenden Anforderungen entwickelt.
Wir empfehlen, diese oder neuere Versionen zu verwenden.

```
qiskit[all]~=2.3.0
```
</details>
Es ist oft nützlich, die Schaltkreise zu sehen, die Sie erstellen. Verwenden Sie die folgenden Optionen, um Qiskit-Schaltkreise anzuzeigen.

```python
from qiskit import QuantumCircuit
```

## Einen Quantenschaltkreis zeichnen {#draw-a-quantum-circuit}

Die `QuantumCircuit` Klasse unterstützt das Zeichnen von Schaltkreisen durch die `draw()` Methode oder durch Drucken des Schaltkreisobjekts. Standardmäßig rendern beide eine ASCII-Art-Version des Schaltkreisdiagramms.

Beachten Sie, dass `print` `None` zurückgibt, aber den Nebeneffekt hat, das Diagramm zu drucken, während `QuantumCircuit.draw` das Diagramm ohne Nebeneffekte zurückgibt. Da Jupyter Notebooks die Ausgabe der letzten Zeile jeder Zelle anzeigen, scheinen sie den gleichen Effekt zu haben.

```python
# Build a quantum circuit
circuit = QuantumCircuit(3, 3)
circuit.x(1)
circuit.h(range(3))
circuit.cx(0, 1)
circuit.measure(range(3), range(3));
```

```python
print(circuit)
```

```text
┌───┐          ┌─┐
q_0: ┤ H ├───────■──┤M├───
     ├───┤┌───┐┌─┴─┐└╥┘┌─┐
q_1: ┤ X ├┤ H ├┤ X ├─╫─┤M├
     ├───┤└┬─┬┘└───┘ ║ └╥┘
q_2: ┤ H ├─┤M├───────╫──╫─
     └───┘ └╥┘       ║  ║
c: 3/═══════╩════════╩══╩═
            2        0  1
```

```python
circuit.draw()
```

```text
┌───┐          ┌─┐
q_0: ┤ H ├───────■──┤M├───
     ├───┤┌───┐┌─┴─┐└╥┘┌─┐
q_1: ┤ X ├┤ H ├┤ X ├─╫─┤M├
     ├───┤└┬─┬┘└───┘ ║ └╥┘
q_2: ┤ H ├─┤M├───────╫──╫─
     └───┘ └╥┘       ║  ║
c: 3/═══════╩════════╩══╩═
            2        0  1
```

### Alternative Renderer {#alternative-renderers}

Eine Textausgabe ist nützlich, um die Ausgabe während der Entwicklung eines Schaltkreises schnell zu sehen, bietet aber nicht die größte Flexibilität. Es gibt zwei alternative Ausgabe-Renderer für den Quantenschaltkreis. Einer verwendet [Matplotlib](https://matplotlib.org/) und der andere verwendet [LaTeX](https://www.latex-project.org/). Der LaTeX-Renderer erfordert das [qcircuit-Paket](https://github.com/CQuIC/qcircuit). Wählen Sie diese Renderer aus, indem Sie das "output"-Argument auf die Strings `mpl` und `latex` setzen.

<Admonition type="tip">
  OSX-Benutzer können die erforderlichen LaTeX-Pakete über das [mactex-Paket](https://www.tug.org/mactex/) erhalten.
</Admonition>

```python
# Matplotlib drawing
circuit.draw(output="mpl")
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/3f9c61c9-58f9-4315-a639-455fa2e58450-0.svg)

```python
# Latex drawing
circuit.draw(output="latex")
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/94948dab-57de-45f0-8dd7-5901ae69b70a-0.avif)

### Ausgabe speichern {#save-output}

Das Zeichnen eines großen Schaltkreises inline in einem Jupyter Notebook kann langsam oder unleserlich sein.
Sie können das Diagramm direkt in eine Datei speichern, diese dann in einem Bildbetrachter öffnen und nach Bedarf hineinzoomen.

```python
# Save as an image using the Matplotlib drawer
circuit.draw(output="mpl", filename="circuit-mpl.jpeg")
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/17889caf-d953-4661-9188-00505c17064e-0.svg)

```python
# Or save a LaTeX rendering
circuit.draw(output="latex", filename="circuit-latex.pdf")
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/a36d1aa9-fa0d-4e27-ac83-5deee43a20dd-0.avif)

### Schaltkreiszeichnungen steuern {#control-circuit-drawings}

Standardmäßig gibt die `draw()` Methode das gerenderte Bild als Objekt zurück und gibt nichts aus. Die genaue zurückgegebene Klasse hängt von der angegebenen Ausgabe ab: `'text'` (die Standardeinstellung) gibt ein `TextDrawer` Objekt zurück, `'mpl'` gibt ein `matplotlib.Figure` Objekt zurück, und `latex` gibt ein `PIL.Image` Objekt zurück. Jupyter Notebooks verstehen diese Rückgabetypen und rendern sie ordnungsgemäß, aber beim Ausführen außerhalb von Jupyter werden Bilder nicht automatisch angezeigt.

Die `draw()` Methode hat optionale Argumente, um die Ausgabe anzuzeigen oder zu speichern. Wenn angegeben, nimmt das `filename` kwarg einen Pfad, unter dem die gerenderte Ausgabe gespeichert wird. Alternativ können Sie, wenn Sie die `mpl` oder `latex` Ausgaben verwenden, das `interactive` kwarg verwenden, um das Bild in einem neuen Fenster zu öffnen (dies funktioniert nicht immer innerhalb eines Notebooks).
### Die Ausgabe anpassen {#customize-the-output}

Abhängig von der Ausgabe gibt es auch Optionen, um das Schaltkreisdiagramm anzupassen.

#### Plot-Barrieren deaktivieren und Bit-Reihenfolge umkehren {#disable-plot-barriers-and-reverse-bit-order}
Die ersten beiden Optionen werden von allen drei Backends gemeinsam genutzt. Sie ermöglichen es Ihnen, sowohl die Bit-Reihenfolgen zu konfigurieren als auch zu entscheiden, ob Sie Barrieren zeichnen oder nicht. Diese können durch das `reverse_bits` kwarg bzw. das `plot_barriers` kwarg gesetzt werden. Die folgenden Beispiele funktionieren mit jedem Ausgabe-Renderer; `mpl` wird hier der Kürze halber verwendet.

```python
from qiskit import QuantumRegister, ClassicalRegister

# Draw a new circuit with barriers and more registers
q_a = QuantumRegister(3, name="a")
q_b = QuantumRegister(5, name="b")
c_a = ClassicalRegister(3)
c_b = ClassicalRegister(5)

circuit = QuantumCircuit(q_a, q_b, c_a, c_b)
circuit.x(q_a[1])
circuit.x(q_b[1])
circuit.x(q_b[2])
circuit.x(q_b[4])
circuit.barrier()
circuit.h(q_a)
circuit.barrier(q_a)
circuit.h(q_b)
circuit.cswap(q_b[0], q_b[1], q_b[2])
circuit.cswap(q_b[2], q_b[3], q_b[4])
circuit.cswap(q_b[3], q_b[4], q_b[0])
circuit.barrier(q_b)
circuit.measure(q_a, c_a)
circuit.measure(q_b, c_b);
```

```python
# Draw the circuit
circuit.draw(output="mpl")
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/8e57cd43-8a48-469d-8f69-8e7c936d4a1e-0.svg)

```python
# Draw the circuit with reversed bit order
circuit.draw(output="mpl", reverse_bits=True)
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/8e7a251a-0a4f-43e0-8cf5-48493df7bad9-0.svg)

```python
# Draw the circuit without barriers
circuit.draw(output="mpl", plot_barriers=False)
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/b4a601ad-1c04-4b16-afbd-ac5a0ad42653-0.svg)

### Renderer-spezifische Anpassungen {#renderer-specific-customizations}

Einige verfügbare Anpassungsoptionen sind spezifisch für einen Renderer.

Das `fold` Argument setzt eine maximale Breite für die Ausgabe. Im `text` Renderer setzt dies die Länge der Zeilen des Diagramms, bevor es zur nächsten Zeile umbricht. Bei Verwendung des 'mpl' Renderers ist dies die Anzahl der (visuellen) Schichten vor dem Falten zur nächsten Zeile.

Der `mpl` Renderer hat das `style` kwarg, das die Farben und Umrisse ändert. Siehe die [API-Dokumentation](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#draw) für weitere Details.

Die `scale` Option skaliert die Ausgabe der `mpl` und `latex` Renderer.

```python
circuit = QuantumCircuit(1)
for _ in range(10):
    circuit.h(0)
# limit line length to 40 characters
circuit.draw(output="text", fold=40)
```

```text
┌───┐┌───┐┌───┐┌───┐┌───┐┌───┐┌───┐»
q: ┤ H ├┤ H ├┤ H ├┤ H ├┤ H ├┤ H ├┤ H ├»
   └───┘└───┘└───┘└───┘└───┘└───┘└───┘»
«   ┌───┐┌───┐┌───┐
«q: ┤ H ├┤ H ├┤ H ├
«   └───┘└───┘└───┘
```

```python
# Change the background color in mpl

style = {"backgroundcolor": "lightgreen"}
circuit.draw(output="mpl", style=style)
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/decadf88-4866-45a0-9e2f-836c51491f9e-0.svg)

```python
# Scale the mpl output to 1/2 the normal size
circuit.draw(output="mpl", scale=0.5)
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/ade9a653-3243-4ac9-bb0e-c8fb82f7a034-0.svg)

### Eigenständige Schaltkreis-Zeichnungsfunktion {#standalone-circuit-drawing-function}

Falls Sie eine Anwendung haben, in der Sie es vorziehen, einen Schaltkreis mit einer eigenständigen Funktion anstatt als Methode eines Schaltkreisobjekts zu zeichnen, können Sie die `circuit_drawer()` Funktion direkt verwenden, die Teil der öffentlichen stabilen Schnittstelle von `qiskit.visualization` ist. Die Funktion verhält sich identisch zur `circuit.draw()` Methode, außer dass sie ein Schaltkreisobjekt als erforderliches Argument entgegennimmt.

```python
from qiskit.visualization import circuit_drawer

circuit_drawer(circuit, output="mpl", plot_barriers=False)
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/256dd092-b2eb-47af-a025-0ecdf85c2d5a-0.svg)

## Nächste Schritte {#next-steps}

<Admonition type="tip" title="Recommendations">
  -  Sehen Sie ein Beispiel für Schaltkreisvisualisierung im [Grover's Algorithm](/tutorials/grovers-algorithm) Tutorial.
  -  Visualisieren Sie einfache Schaltkreise mit [IBM Quantum Composer.](/guides/composer)
  -  [Schaltkreis-Timing visualisieren.](/guides/visualize-circuit-timing)
  -  Sehen Sie die [Qiskit Visualisierungs-API-Dokumentation](https://docs.quantum.ibm.com/api/qiskit/visualization) durch.
</Admonition>
