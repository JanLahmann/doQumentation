---
title: "Backend-Informationen mit Qiskit abrufen"
sidebar_label: "Backend-Informationen mit Qiskit abrufen"
description: "Verfügbare Backends finden und filtern, Konfigurations- und Kalibrierungsdaten programmgesteuert abrufen."
notebook_path: "docs/guides/get-qpu-information.ipynb"
---

<OpenInLabBanner notebookPath="docs/guides/get-qpu-information.ipynb" />



{/*
  DO NOT EDIT THIS CELL!!!
  This cell's content is generated automatically by a script. Anything you add
  here will be removed next time the notebook is run. To add new content, create
  a new cell before or after this one.
*/}

<details>
<summary><b>Package versions</b></summary>

The code on this page was developed using the following requirements.
We recommend using these versions or newer.

```
qiskit-ibm-runtime~=0.43.1
```
</details>
Diese Seite erklärt, wie Sie Qiskit verwenden, um Informationen über Ihre verfügbaren Backends zu finden.
## Backends auflisten

Um die Backends anzuzeigen, auf die Sie Zugriff haben, können Sie entweder eine Liste auf der [Compute resources-Seite](https://quantum.cloud.ibm.com/computers) anzeigen oder die Methode [`QiskitRuntimeService.backends()`](../api/qiskit-ibm-runtime/qiskit-runtime-service#backends) verwenden. Diese Methode gibt eine Liste von [`IBMBackend`](../api/qiskit-ibm-runtime/ibm-backend)-Instanzen zurück:

<Admonition type="note" title="Notes">
- Wenn Sie bei einer bestimmten Instanz oder Region angemeldet sind oder wenn Sie den Dienst mit einer bestimmten Instanz oder Region über `QiskitRuntimeService()` initialisiert haben, werden nur die Backends zurückgegeben, die Ihnen in dieser Instanz oder Region zur Verfügung stehen. Andernfalls werden alle Backends zurückgegeben, die Ihnen in jeder Instanz und in jeder Region zur Verfügung stehen.
- Die Liste der zurückgegebenen Backends ist möglicherweise nicht identisch mit den auf der IBM Quantum Platform-Seite [Compute resources](https://quantum.cloud.ibm.com/computers) angezeigten Backends. Die Liste auf der Compute resources-Seite wird immer nach der oben auf der Seite ausgewählten Region gefiltert.
</Admonition>
Um den folgenden Code auszuführen, stellen Sie sicher, dass Sie sich bereits beim Dienst authentifiziert haben. Weitere Details finden Sie unter [Set up your IBM Cloud account](/guides/cloud-setup).

```python
# Initialize your account
from qiskit_ibm_runtime import QiskitRuntimeService

service = QiskitRuntimeService()

service.backends()
```

```text
[<IBMBackend('ibm_pittsburgh')>,
 <IBMBackend('ibm_boston')>,
 <IBMBackend('ibm_fez')>,
 <IBMBackend('ibm_miami')>,
 <IBMBackend('ibm_marrakesh')>,
 <IBMBackend('ibm_torino')>,
 <IBMBackend('ibm_kingston')>]
```

Die Methode [`QiskitRuntimeService.backend()`](../api/qiskit-ibm-runtime/qiskit-runtime-service#backend) (beachten Sie, dass dies Singular ist: *backend*) nimmt den Namen des Backends als Eingabeparameter und gibt eine [`IBMBackend`](../api/qiskit-ibm-runtime/ibm-backend)-Instanz zurück, die dieses bestimmte Backend repräsentiert:

```python
service.backend("ibm_fez")
```

```text
<IBMBackend('ibm_fez')>
```

## Backends filtern

Sie können die verfügbaren Backends auch nach ihren Eigenschaften filtern. Für allgemeinere Filter setzen Sie das Argument `filters` auf eine Funktion, die ein Backend-Objekt akzeptiert und `True` zurückgibt, wenn es Ihre Kriterien erfüllt. Weitere Details finden Sie in der [API-Dokumentation](../api/qiskit-ibm-runtime/qiskit-runtime-service#backends).

Der folgende Code gibt nur Backends zurück, die diese Kriterien erfüllen und Ihnen _in Ihrer aktuell ausgewählten Instanz_ zur Verfügung stehen:

*   Sind echte Quantengeräte (`simulator=False`)
*   Sind aktuell betriebsbereit (`operational=True`)
*   Haben mindestens 5 Qubits (`min_num_qubits=5`)

```python
# Optionally pass in an instance, region, or both, to
# further filter the backends.
service = QiskitRuntimeService()

service.backends(simulator=False, operational=True, min_num_qubits=5)
```

```text
[<IBMBackend('ibm_pittsburgh')>,
 <IBMBackend('ibm_boston')>,
 <IBMBackend('ibm_fez')>,
 <IBMBackend('ibm_miami')>,
 <IBMBackend('ibm_marrakesh')>,
 <IBMBackend('ibm_torino')>,
 <IBMBackend('ibm_kingston')>]
```

Verwenden Sie diese Schlüsselwortargumente, um nach jedem Attribut in der Backend-Konfiguration ([JSON-Schema](https://github.com/Qiskit/ibm-quantum-schemas/blob/main/schemas/backend_configuration_schema.json)) oder im Status ([JSON-Schema](https://github.com/Qiskit/ibm-quantum-schemas/blob/main/schemas/backend_status_schema.json)) zu filtern. Eine ähnliche Methode ist [`QiskitRuntimeService.least_busy()`](../api/qiskit-ibm-runtime/qiskit-runtime-service#least_busy), die dieselben Filter wie `backends()` verwendet, aber das Backend zurückgibt, das den Filtern entspricht und die geringste Anzahl von Jobs in der Warteschlange hat:

```python
service.least_busy(operational=True, min_num_qubits=5)
```

```text
<IBMBackend('ibm_torino')>
```

## Statische Backend-Informationen

Einige Informationen über ein Backend ändern sich nicht regelmäßig, wie z. B. sein Name, seine Version, die Anzahl der Qubits, die es hat, und die Arten von Funktionen, die es unterstützt. Diese Informationen sind als Attribute des `backend`-Objekts verfügbar.

Die folgende Zelle erstellt eine Beschreibung eines Backends.

```python
backend = service.backend("ibm_fez")

print(
    f"Name: {backend.name}\n"
    f"Version: {backend.version}\n"
    f"No. of qubits: {backend.num_qubits}\n"
)
```

```text
Name: ibm_fez
Version: 2
No. of qubits: 156
```

Eine vollständige Liste der Attribute finden Sie in der [`IBMBackend`-API-Dokumentation](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/ibm-backend).
## Native Gates und Operationen

Jede [Prozessorfamilie](/guides/processor-types) hat einen nativen Gate-Satz. Standardmäßig unterstützen die QPUs in jeder Familie nur die Ausführung der Gates und Operationen im nativen Gate-Satz. Daher muss jedes Gate im Circuit (vom Transpiler) in die Elemente dieses Satzes übersetzt werden.

Sie können die nativen Gates und Operationen für eine QPU entweder [mit Qiskit](#native-gates-with-qiskit) oder auf der IBM Quantum&reg; Platform-Seite [Compute resources](/guides/qpu-information#native-gates-on-platform) anzeigen.

<span id="native-gates-with-qiskit"></span>
```python

from qiskit_ibm_runtime import QiskitRuntimeService

service = QiskitRuntimeService()

for backend in service.backends():
    config = backend.configuration()
    if "simulator" in config.backend_name:
        continue
    print(f"Backend: {config.backend_name}")
    print(f"    Processor type: {config.processor_type}")
    print(f"    Supported instructions:")
    for instruction in config.supported_instructions:
        print(f"        {instruction}")
    print()
```
## Dynamische Backend-Informationen

Backends können auch Eigenschaften haben, die sich bei jeder Kalibrierung des Backends ändern, wie z. B. Qubit-Frequenz und Operationsfehlerraten. Backends werden normalerweise alle 24 Stunden kalibriert, und ihre Eigenschaften werden nach Abschluss der Kalibrierungssequenz aktualisiert. Diese Eigenschaften können bei der Optimierung von Quantenschaltungen oder zur Konstruktion von Rauschmodellen für einen klassischen Simulator verwendet werden.

### Qubit-Eigenschaften

Die Methode `backend.properties().qubit_property()` gibt Informationen über die physikalischen Attribute der Qubits zurück. Sie enthält ein Dictionary verschiedener Eigenschaften des Qubits, jeweils gepaart mit seinem Wert und dem Zeitstempel der letzten Kalibrierung.

- `T1 (Relaxation Time)`: Die T1-Zeit stellt die durchschnittliche Dauer dar, die ein Qubit in seinem angeregten Zustand $|1\rangle$ verbleibt, bevor es aufgrund von Energierelaxation in seinen Grundzustand $|0\rangle$ zerfällt. Dieser Parameter wird verwendet, um das Energierelaxationsverhalten des Qubits zu charakterisieren und wird in Sekunden (s) ausgedrückt.

- `T2 (Dephasing Time)`: Die T2-Zeit bezeichnet die Zeitskala, über die ein Qubit die Phasenkohärenz einer Superposition zwischen den Zuständen $|0\rangle$ und $|1\rangle$ aufrechterhält. Sie berücksichtigt sowohl Energierelaxations- als auch reine Dephasierungsprozesse und gibt Einblick in die Kohärenzeigenschaften des Qubits.

- `frequency`: Dieser Parameter gibt die Resonanzfrequenz des Qubits an, die den Energieunterschied zwischen den Zuständen $|0\rangle$ und $|1\rangle$ angibt, ausgedrückt in Hertz (Hz).

- `anharmonicity`: Anharmonizität ist der Energieunterschied zwischen dem ersten und zweiten angeregten Zustand des Qubits, ebenfalls ausgedrückt in Hertz (Hz).

- `readout_error`: Der Readout-Fehler quantifiziert die durchschnittliche Wahrscheinlichkeit, den Zustand eines Qubits falsch zu messen. Er wird üblicherweise als Mittelwert von prob_meas0_prep1 und prob_meas1_prep0 berechnet und liefert eine einzelne Metrik für die Messtreue.

- `prob_meas0_prep1`: Dieser Parameter gibt die Wahrscheinlichkeit an, ein Qubit im Zustand 0 zu messen, wenn es im Zustand $|1\rangle$ vorbereitet werden sollte, bezeichnet als $P(0 | 1)$. Er spiegelt Fehler bei der Zustandsvorbereitung und Messung (SPAM) wider, insbesondere Messfehler bei supraleitenden Qubits.

- `prob_meas1_prep0`: Ähnlich stellt dieser Parameter die Wahrscheinlichkeit dar, ein Qubit im Zustand 1 zu messen, wenn es im Zustand $|0\rangle$ vorbereitet werden sollte, bezeichnet als $P(1 | 0)$. Wie prob_meas0_prep1 spiegelt er SPAM-Fehler wider, wobei Messfehler der vorherrschende Beitrag bei supraleitenden Qubits sind.

- `readout_length`: Der readout_length gibt die Dauer der Readout-Operation für ein Qubit an. Er misst die Zeit vom Beginn des Messpulses bis zum Abschluss der Signaldigitalisierung, wonach das System für die nächste Operation bereit ist. Das Verständnis dieses Parameters ist entscheidend für die Optimierung der Circuit-Ausführung, insbesondere bei der Einbeziehung von Mid-Circuit-Messungen.

```python
# fundamental physical properties of qubit 1
backend.qubit_properties(1)
```

```text
QubitProperties(t1=0.00023160183954439313, t2=0.0002759670226087048, frequency=None)
```

```python
# calibration data with detailed properties of qubit 0
backend.properties().qubit_property(0)
```

```text
{'T1': (5.199156952582205e-05,
  datetime.datetime(2026, 1, 14, 16, 18, 26, tzinfo=tzlocal())),
 'T2': (2.253552085985709e-05,
  datetime.datetime(2026, 1, 14, 16, 19, 6, tzinfo=tzlocal())),
 'readout_error': (0.013916015625,
  datetime.datetime(2026, 1, 14, 21, 38, 31, tzinfo=tzlocal())),
 'prob_meas0_prep1': (0.026123046875,
  datetime.datetime(2026, 1, 14, 21, 38, 31, tzinfo=tzlocal())),
 'prob_meas1_prep0': (0.001708984375,
  datetime.datetime(2026, 1, 14, 21, 38, 31, tzinfo=tzlocal())),
 'readout_length': (1.56e-06,
  datetime.datetime(2026, 1, 14, 21, 38, 31, tzinfo=tzlocal()))}
```

```python
# Retrieve qubit properties
qubit_index = 126  # Replace with your qubit index
qubit_props = backend.properties().qubit_property(qubit_index)

# Access specific properties
t1 = qubit_props.get("T1", (None,))[0]
t2 = qubit_props.get("T2", (None,))[0]
frequency = qubit_props.get("frequency", (None,))[0]
anharmonicity = qubit_props.get("anharmonicity", (None,))[0]
readout_error = qubit_props.get("readout_error", (None,))[0]
prob_meas0_prep1 = qubit_props.get("prob_meas0_prep1", (None,))[0]
prob_meas1_prep0 = qubit_props.get("prob_meas1_prep0", (None,))[0]
readout_length = qubit_props.get("readout_length", (None,))[0]

print(f"Qubit {qubit_index} Properties:")
print(f"  T1: {t1} seconds")
print(f"  T2: {t2} seconds")
print(f"  Frequency: {frequency} Hz")
print(f"  Anharmonicity: {anharmonicity} Hz")
print(f"  Readout Error: {readout_error}")
print(f"  P(0 | 1): {prob_meas0_prep1}")
print(f"  P(1 | 0): {prob_meas1_prep0}")
print(f"  Readout Length: {readout_length} seconds")
```

```text
Qubit 126 Properties:
  T1: 9.563335658857979e-05 seconds
  T2: 6.570556299807121e-05 seconds
  Frequency: None Hz
  Anharmonicity: None Hz
  Readout Error: 0.006591796875
  P(0 | 1): 0.009765625
  P(1 | 0): 0.00341796875
  Readout Length: 1.56e-06 seconds
```

### Instruction-Eigenschaften

Das Attribut `backend.target` ist ein `qiskit.transpiler.Target`-Objekt: ein Objekt, das alle Informationen enthält, die zum Transpilieren eines Circuits für dieses Backend erforderlich sind. Dies umfasst Instruction-Fehler und -Dauern. Zum Beispiel ruft die folgende Zelle die Eigenschaften für ein [`cz`-Gate](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.CZGate) ab, das zwischen den Qubits 1 und 0 wirkt.

```python
backend.target["cz"][(1, 0)]
```

```text
InstructionProperties(duration=6.8e-08, error=0.007831625819164134)
```

Die folgende Zelle zeigt die Eigenschaften für eine Messoperation (einschließlich des Readout-Fehlers) auf Qubit 0.

```python
backend.target["measure"][(0,)]
```

```text
InstructionProperties(duration=1.56e-06, error=0.013916015625)
```

## Nächste Schritte

<Admonition type="tip" title="Recommendations">
    - Probieren Sie das Tutorial zu [Grover's algorithm](/tutorials/grovers-algorithm) aus.
    - Konsultieren Sie die API-Referenz für [QiskitRuntime backend API](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/qiskit-runtime-service#backend).
</Admonition>
