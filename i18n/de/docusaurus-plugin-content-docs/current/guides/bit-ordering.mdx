---
title: "Bit-Reihenfolge im Qiskit SDK"
sidebar_label: "Bit-Reihenfolge im Qiskit SDK"
description: "Lernen Sie die Reihenfolgekonventionen des Qiskit SDK und warum wir sie gewählt haben"
notebook_path: "docs/guides/bit-ordering.ipynb"
---

<OpenInLabBanner notebookPath="docs/guides/bit-ordering.ipynb" />



{/* cspell:ignore leftrightarrow */}
{/*
  DO NOT EDIT THIS CELL!!!
  This cell's content is generated automatically by a script. Anything you add
  here will be removed next time the notebook is run. To add new content, create
  a new cell before or after this one.
*/}

<details>
<summary><b>Paketversionen</b></summary>

Der Code auf dieser Seite wurde mit den folgenden Anforderungen entwickelt.
Wir empfehlen die Verwendung dieser oder neuerer Versionen.

```
qiskit[all]~=2.3.0
```
</details>
Falls Sie einen Satz von $n$ Bits (oder Qubits) haben, werden Sie normalerweise jedes Bit mit $0
\rightarrow n-1$ beschriften. Verschiedene Software und Ressourcen müssen entscheiden, wie sie
diese Bits sowohl im Computerspeicher als auch bei der Anzeige auf dem Bildschirm anordnen.

## Qiskit-Konventionen

So ordnet das Qiskit SDK Bits in verschiedenen Szenarien an.

### Quantenschaltkreise

Die `QuantumCircuit`-Klasse speichert ihre Qubits in einer Liste
(`QuantumCircuit.qubits`). Der Index eines Qubits in dieser Liste definiert die
Bezeichnung des Qubits.

```python
from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit import Qubit

qc = QuantumCircuit(2)
qc.qubits[0]  # qubit "0"

Qubit(QuantumRegister(2, "q"), 0)
```

```text
<Qubit register=(2, "q"), index=0>
```

### Schaltkreisdiagramme

In einem Schaltkreisdiagramm ist Qubit $0$ das oberste Qubit und Qubit $n-1$ das
unterste Qubit. Sie können dies mit dem `reverse_bits`-Argument von
`QuantumCircuit.draw` ändern (siehe [Reihenfolge in
Qiskit ändern](#change-ordering-in-qiskit)).

```python
qc.x(1)
qc.draw()
```

```text
q_0: ─────
     ┌───┐
q_1: ┤ X ├
     └───┘
```

### Ganzzahlen

Bei der Interpretation von Bits als Zahl ist Bit $0$ das niederwertigste Bit und
Bit $n-1$ das höchstwertige. Dies ist hilfreich beim Programmieren, da jedes Bit den
Wert $2^\text{label}$ hat (wobei label der Index des Qubits in
`QuantumCircuit.qubits` ist). Die folgende Schaltkreisausführung endet beispielsweise
damit, dass Bit $0$ `0` ist und Bit $1$ `1` ist. Dies wird als die
Dezimalzahl `2` interpretiert (gemessen mit Wahrscheinlichkeit `1.0`).

```python
from qiskit.primitives import StatevectorSampler as Sampler

qc.measure_all()

job = Sampler().run([qc])
result = job.result()
print(f" > Counts: {result[0].data.meas.get_counts()}")
```

```text
> Counts: {'10': 1024}
```

### Zeichenketten

Bei der Anzeige oder Interpretation einer Liste von Bits (oder Qubits) als Zeichenkette ist Bit
$n-1$ das linkeste Bit und Bit $0$ das rechteste Bit. Dies liegt daran, dass wir
normalerweise Zahlen mit der höchstwertigen Ziffer links schreiben, und in
Qiskit wird Bit $n-1$ als das höchstwertige Bit interpretiert.

Die folgende Zelle definiert beispielsweise einen `Statevector` aus einer Zeichenkette von
Einzelqubit-Zuständen. In diesem Fall befindet sich Qubit $0$ im Zustand $|+\rangle$ und
Qubit $1$ im Zustand $|0\rangle$.

```python
from qiskit.quantum_info import Statevector

sv = Statevector.from_label("0+")
sv.probabilities_dict()
```

```text
{np.str_('00'): np.float64(0.4999999999999999),
 np.str_('01'): np.float64(0.4999999999999999)}
```

Dies verursacht gelegentlich Verwirrung bei der Interpretation einer Bit-Zeichenkette, da Sie
möglicherweise erwarten, dass das linkeste Bit Bit $0$ ist, während es normalerweise Bit
$n-1$ darstellt.

### Zustandsvektor-Matrizen

Bei der Darstellung eines Zustandsvektors als Liste komplexer Zahlen (Amplituden)
ordnet Qiskit diese Amplituden so an, dass die Amplitude am Index $x$ den
Berechnungsbasiszustand $|x\rangle$ darstellt.

```python
print(sv[1])  # amplitude of state |01>
print(sv[2])  # amplitude of state |10>
```

```text
(0.7071067811865475+0j)
0j
```

### Gates

Jedes Gate in Qiskit kann eine Liste von Qubits auf seine eigene Weise interpretieren, aber
kontrollierte Gates folgen normalerweise der Konvention `(control, target)`.

Die folgende Zelle fügt beispielsweise ein Controlled-X-Gate hinzu, wobei Qubit $0$ die
Kontrolle ist und Qubit $1$ das Ziel.

```python
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.cx(0, 1)
qc.draw()
```

```text
q_0: ──■──
     ┌─┴─┐
q_1: ┤ X ├
     └───┘
```

Nach allen zuvor erwähnten Konventionen in Qiskit führt dieses CX-Gate
die Transformation $|01\rangle \leftrightarrow |11\rangle$ durch und hat daher die
folgende Matrix.

$$
\begin{pmatrix}
 1 & 0 & 0 & 0 \\
 0 & 0 & 0 & 1 \\
 0 & 0 & 1 & 0 \\
 0 & 1 & 0 & 0 \\
\end{pmatrix}
$$

## Reihenfolge in Qiskit ändern

Um einen Schaltkreis mit Qubits in umgekehrter Reihenfolge zu zeichnen (d.h. Qubit $0$ unten), verwenden Sie das `reverse_bits`-Argument. Dies betrifft nur das generierte
Diagramm und beeinflusst den Schaltkreis nicht; das X-Gate wirkt weiterhin auf Qubit $0$.

```python
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.x(0)
qc.draw(reverse_bits=True)
```

```text
q_1: ─────
     ┌───┐
q_0: ┤ X ├
     └───┘
```

Sie können die `reverse_bits`-Methode verwenden, um einen neuen Schaltkreis mit
umgekehrten Qubit-Bezeichnungen zurückzugeben (dies verändert den ursprünglichen Schaltkreis nicht).

```python
qc.reverse_bits().draw()
```

```text
q_0: ─────
     ┌───┐
q_1: ┤ X ├
     └───┘
```

Beachten Sie, dass in diesem neuen Schaltkreis das X-Gate auf Qubit $1$ wirkt.

## Nächste Schritte

<Admonition type="tip" title="Empfehlungen">
  -  Sehen Sie ein Beispiel für die Verwendung von Schaltkreisen im Tutorial [Grovers Algorithmus](/tutorials/grovers-algorithm).
  -  Erkunden Sie die [QuantumCircuit API](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#quantumcircuit-class)-Referenz.
</Admonition>
