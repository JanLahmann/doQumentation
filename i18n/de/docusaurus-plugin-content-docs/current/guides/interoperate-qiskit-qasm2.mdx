---
title: "OpenQASM 2 und das Qiskit SDK"
sidebar_label: "OpenQASM 2 und das Qiskit SDK"
description: "Wie man Code zwischen OpenQASM 2 und dem Qiskit SDK konvertiert."
notebook_path: "docs/guides/interoperate-qiskit-qasm2.ipynb"
---

<OpenInLabBanner notebookPath="docs/guides/interoperate-qiskit-qasm2.ipynb" />



{/*
  DO NOT EDIT THIS CELL!!!
  This cell's content is generated automatically by a script. Anything you add
  here will be removed next time the notebook is run. To add new content, create
  a new cell before or after this one.
*/}

<details>
<summary><b>Package versions</b></summary>

The code on this page was developed using the following requirements.
We recommend using these versions or newer.

```
qiskit[all]~=2.3.0
```
</details>
Das Qiskit SDK bietet einige Tools zur Konvertierung zwischen OpenQASM-Darstellungen von Quantenprogrammen und der [QuantumCircuit](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit)-Klasse.

<span id="qasm2-import"></span>
## Importieren eines OpenQASM 2-Programms in Qiskit {#import-an-openqasm-2-program-into-qiskit}

Zwei Funktionen importieren OpenQASM 2-Programme in Qiskit.
Dies sind [`qasm2.load()`](../api/qiskit/qasm2#load), die einen Dateinamen akzeptiert, und [`qasm2.loads()`](../api/qiskit/qasm2#loads), die das OpenQASM 2-Programm als String akzeptiert.

```python
import qiskit.qasm2

qiskit.qasm2.load(filename, include_path=('.',), include_input_directory='append', custom_instructions=(), custom_classical=(), strict=False)
qiskit.qasm2.loads(program, include_path=('.',), custom_instructions=(), custom_classical=(), strict=False)
```
Weitere Informationen finden Sie in der [OpenQASM 2 Qiskit API](https://docs.quantum.ibm.com/api/qiskit/qasm2).

### Importieren einfacher Programme {#import-simple-programs}

Für die meisten OpenQASM 2-Programme können Sie einfach `qasm2.load` und `qasm2.loads` mit einem einzigen Argument verwenden.

#### Beispiel: Importieren eines OpenQASM 2-Programms als String {#example-import-an-openqasm-2-program-as-a-string}

Verwenden Sie `qasm2.loads()`, um ein OpenQASM 2-Programm als String in einen QuantumCircuit zu importieren:

```python
import qiskit.qasm2

program = """
    OPENQASM 2.0;
    include "qelib1.inc";
    qreg q[2];
    creg c[2];

    h q[0];
    cx q[0], q[1];

    measure q -> c;
"""
circuit = qiskit.qasm2.loads(program)
circuit.draw()
```

```text
┌───┐     ┌─┐
q_0: ┤ H ├──■──┤M├───
     └───┘┌─┴─┐└╥┘┌─┐
q_1: ─────┤ X ├─╫─┤M├
          └───┘ ║ └╥┘
c: 2/═══════════╩══╩═
                0  1
```

#### Beispiel: Importieren eines OpenQASM 2-Programms aus einer Datei {#example-import-an-openqasm-2-program-from-a-file}

Verwenden Sie `load()`, um ein OpenQASM 2-Programm aus einer Datei in einen QuantumCircuit zu importieren:

```python
import qiskit.qasm2
circuit = qiskit.qasm2.load("myfile.qasm")
```

<span id="custom-instructions"></span>
### Verknüpfen von OpenQASM 2-Gates mit Qiskit-Gates {#link-openqasm-2-gates-with-qiskit-gates}

Standardmäßig behandelt der OpenQASM 2-Importer von Qiskit die Include-Datei `"qelib1.inc"` als *de facto* Standardbibliothek.
Der Importer behandelt diese Datei so, als enthielte sie genau die Gates, die in [dem ursprünglichen Papier, das OpenQASM 2 definiert](https://arxiv.org/abs/1707.03429), beschrieben sind.
Qiskit verwendet die integrierten Gates in [der Circuit Library](../api/qiskit/circuit_library), um die Gates in `"qelib1.inc"` darzustellen.
Gates, die im Programm durch manuelle OpenQASM 2 `gate`-Anweisungen definiert werden, werden standardmäßig als benutzerdefinierte [Qiskit `Gate`-Unterklassen](../api/qiskit/qiskit.circuit.Gate) konstruiert.

Sie können dem Importer mitteilen, spezifische [`Gate`](../api/qiskit/qiskit.circuit.Gate)-Klassen für die von ihm gefundenen `gate`-Anweisungen zu verwenden.
Sie können diesen Mechanismus auch verwenden, um zusätzliche Gate-Namen als "built-in" zu behandeln, d.h. keine explizite Definition zu erfordern.
Wenn Sie angeben, welche Gate-Klassen für `gate`-Anweisungen außerhalb von `"qelib1.inc"` verwendet werden sollen, ist die resultierende Schaltung typischerweise effizienter zu bearbeiten.

<Admonition type="warning">
Ab Qiskit SDK v1.0 verhält sich der OpenQASM 2-*Exporter* von Qiskit (siehe [Exportieren einer Qiskit-Schaltung nach OpenQASM 2](#qasm2-export)) immer noch so, als hätte `"qelib1.inc"` mehr Gates als tatsächlich vorhanden sind.
Das bedeutet, dass die Standardeinstellungen des Importers möglicherweise kein von unserem Exporter exportiertes Programm importieren können.
Siehe [das spezifische Beispiel zur Arbeit mit dem Legacy-Exporter](#qasm2-import-legacy), um dieses Problem zu lösen.

Dies ist Legacy-Verhalten von Qiskit, und [es wird in einer späteren Version von Qiskit behoben](https://github.com/Qiskit/qiskit/issues/10737).
</Admonition>

Um Informationen über eine benutzerdefinierte Anweisung an den OpenQASM 2-Importer zu übergeben, verwenden Sie [die `qasm2.CustomInstruction`-Klasse](../api/qiskit/qasm2#qiskit.qasm2.CustomInstruction).
Diese hat vier erforderliche Informationen, in dieser Reihenfolge:

* Der **Name** des Gates, der im OpenQASM 2-Programm verwendet wird
* Die **Anzahl der Winkelparameter**, die das Gate akzeptiert
* Die **Anzahl der Qubits**, auf die das Gate wirkt
* Die Python-**Konstruktor**-Klasse oder -Funktion für das Gate, die die Gate-Parameter (aber nicht die Qubits) als einzelne Argumente akzeptiert

Wenn der Importer auf eine `gate`-Definition trifft, die mit einer gegebenen benutzerdefinierten Anweisung übereinstimmt, wird er diese benutzerdefinierten Informationen verwenden, um das Gate-Objekt zu rekonstruieren.
Wenn eine `gate`-Anweisung gefunden wird, die mit dem `name` einer benutzerdefinierten Anweisung übereinstimmt, aber nicht sowohl mit der Anzahl der Parameter als auch mit der Anzahl der Qubits übereinstimmt, gibt der Importer einen [`QASM2ParseError`](../api/qiskit/qasm2#qasm2parseerror) aus, um die Diskrepanz zwischen den bereitgestellten Informationen und dem Programm anzuzeigen.

Zusätzlich kann ein fünftes Argument `builtin` optional auf `True` gesetzt werden, um das Gate automatisch innerhalb des OpenQASM 2-Programms verfügbar zu machen, auch wenn es nicht explizit definiert ist.
Wenn der Importer auf eine explizite `gate`-Definition für eine integrierte benutzerdefinierte Anweisung trifft, wird er sie stillschweigend akzeptieren.
Wie zuvor wird ein [`QASM2ParseError`](../api/qiskit/qasm2#qasm2parseerror) ausgegeben, wenn eine explizite Definition desselben Namens nicht mit der bereitgestellten benutzerdefinierten Anweisung kompatibel ist.
Dies ist nützlich für die Kompatibilität mit älteren OpenQASM 2-Exportern und mit bestimmten anderen Quantenplattformen, die die "Basis-Gates" ihrer Hardware als integrierte Anweisungen behandeln.

Qiskit bietet ein Datenattribut für die Arbeit mit OpenQASM 2-Programmen, die von Legacy-Versionen von [Qiskits OpenQASM 2-Exportfunktionen](#qasm2-export) erstellt wurden.
Dies ist [`qasm2.LEGACY_CUSTOM_INSTRUCTIONS`](../api/qiskit/qasm2#legacy-compatibility), das als `custom_instructions`-Argument an [`qasm2.load()`](../api/qiskit/qasm2#load) und [`qasm2.loads()`](../api/qiskit/qasm2#loads) übergeben werden kann.

<span id="qasm2-import-legacy"></span>
#### Beispiel: Importieren eines Programms, das vom Legacy-Exporter von Qiskit erstellt wurde {#example-import-a-program-created-by-qiskits-legacy-exporter}

Dieses OpenQASM 2-Programm verwendet Gates, die nicht in der ursprünglichen Version von `"qelib1.inc"` enthalten sind, ohne sie zu deklarieren, aber Standard-Gates in Qiskits Bibliothek sind.
Sie können [`qasm2.LEGACY_CUSTOM_INSTRUCTIONS`](../api/qiskit/qasm2#legacy-compatibility) verwenden, um dem Importer einfach mitzuteilen, dass er denselben Satz von Gates verwenden soll, den Qiskits OpenQASM 2-Exporter zuvor verwendet hat.

```python
from qiskit import qasm2

program = """
    OPENQASM 2.0;
    include "qelib1.inc";

    qreg q[4];
    creg c[4];

    h q[0];
    cx q[0], q[1];

    // 'rxx' is not actually in `qelib1.inc`,
    // but Qiskit used to behave as if it were.
    rxx(0.75) q[2], q[3];

    measure q -> c;
"""
circuit = qasm2.loads(
    program,
    custom_instructions=qasm2.LEGACY_CUSTOM_INSTRUCTIONS,
)
```

#### Beispiel: Verwendung einer bestimmten Gate-Klasse beim Importieren eines OpenQASM 2-Programms {#example-use-a-particular-gate-class-when-importing-an-openqasm-2-program}

Qiskit kann im Allgemeinen nicht überprüfen, ob die Definition in einer OpenQASM 2 `gate`-Anweisung genau einem Gate der Qiskit-Standardbibliothek entspricht.
Stattdessen wählt Qiskit ein benutzerdefiniertes Gate unter Verwendung der bereitgestellten genauen Definition.
Dies kann weniger effizient sein als die Verwendung eines der integrierten Standard-Gates oder eines benutzerdefinierten Gates.
Sie können manuell `gate`-Anweisungen mit bestimmten Klassen definieren.

```python
from qiskit import qasm2
from qiskit.circuit import Gate
from qiskit.circuit.library import RZXGate

# Define a custom gate that takes one qubit and two angles.
class MyGate(Gate):
    def __init__(self, theta, phi):
        super().__init__("my", 1, [theta, phi])

custom_instructions = [
    # Link the OpenQASM 2 name 'my' with our custom gate.
    qasm2.CustomInstruction("my", 2, 1, MyGate),
    # Link the OpenQASM 2 name 'rzx' with Qiskit's
    # built-in RZXGate.
    qasm2.CustomInstruction("rzx", 1, 2, RZXGate),
]

program = """
    OPENQASM 2.0;

    gate my(theta, phi) q {
        U(theta / 2, phi, -theta / 2) q;
    }
    gate rzx(theta) a, b {
        // It doesn't matter what definition is
        // supplied, if the parameters match;
        // Qiskit will still use `RZXGate`.
    }

    qreg q[2];
    my(0.25, 0.125) q[0];
    rzx(pi) q[0], q[1];
"""

circuit = qasm2.loads(
    program,
    custom_instructions=custom_instructions,
)
```

#### Beispiel: Definieren eines neuen integrierten Gates in einem OpenQASM 2-Programm {#example-define-a-new-built-in-gate-in-an-openqasm-2-program}

Wenn das Argument `builtin=True` gesetzt ist, benötigt ein benutzerdefiniertes Gate keine zugehörige Definition.

```python
from qiskit import qasm2
from qiskit.circuit import Gate

# Define a custom gate that takes one qubit and two angles.
class MyGate(Gate):
    def __init__(self, theta, phi):
        super().__init__("my", 1, [theta, phi])

custom_instructions = [
    qasm2.CustomInstruction("my", 2, 1, MyGate, builtin=True),
]

program = """
    OPENQASM 2.0;
    qreg q[1];

    my(0.25, 0.125) q[0];
"""

circuit = qasm2.loads(
    program,
    custom_instructions=custom_instructions,
)
```

<span id="custom-classical"></span>
### Definieren benutzerdefinierter klassischer Funktionen {#define-custom-classical-functions}

OpenQASM 2 enthält einige integrierte klassische Funktionen zur Verwendung in Gate-Argumenten.
Sie können die Sprache mit weiteren Funktionen erweitern, indem Sie das `custom_classical`-Argument für [`qasm2.load()`](../api/qiskit/qasm2#load) und [`qasm2.loads()`](../api/qiskit/qasm3#loads) mit der [`qasm2.CustomClassical`](../api/qiskit/qasm2#qiskit.qasm2.CustomClassical)-Klasse verwenden.

Um eine benutzerdefinierte klassische Funktion zu definieren, müssen Sie Folgendes angeben:

* Den *Namen* der Funktion, wie er im OpenQASM 2-Programm erscheint
* Die Anzahl der Gleitkomma-Argumente, die sie akzeptiert
* Ein aufrufbares Python-Objekt, das die Funktion auswertet

Alle definierten benutzerdefinierten klassischen Funktionen werden vom Importer als in die OpenQASM 2-Sprache integriert behandelt.
Es gibt keine offizielle Möglichkeit innerhalb der OpenQASM 2-Sprache, neue Funktionen zu definieren; dies ist eine Qiskit-Erweiterung.

#### Beispiel: Verwendung benutzerdefinierter klassischer Anweisungen {#example-use-custom-classical-instructions}

Hier stellen wir zwei benutzerdefinierte klassische Funktionen bereit.
Die erste ist einfach und fügt ihrem Eingabewert einfach eins hinzu.
Die zweite ist die Funktion ``math.atan2``, die die mathematische Operation $\arctan(y/x)$ quadrantengerecht darstellt.

```python
import math
from qiskit import qasm2

program = """
    include "qelib1.inc";
    qreg q[2];
    rx(arctan(pi, 3 + add_one(0.2))) q[0];
    cx q[0], q[1];
"""

def add_one(x):
    return x + 1

customs = [
    # Our `add_one` takes only one parameter.
    qasm2.CustomClassical("add_one", 1, add_one),
    # `arctan` takes two parameters, and `math.atan2` implements it.
    qasm2.CustomClassical("arctan", 2, math.atan2),
]
circuit = qasm2.loads(program, custom_classical=customs)
```

<span id="strict"></span>
### Strict-Modus {#strict-mode}

Standardmäßig ist dieser Parser entspannter als die offizielle Spezifikation.
Er erlaubt nachfolgende Kommas in Parameterlisten; unnötige (Leer-Statement-)Semikolons; Weglassen der `OPENQASM 2.0;`-Versionsanweisung; und mehrere andere Qualitätsverbesserungen ohne Ausgabe von Fehlern.
Sie können jedoch den "buchstabengetreuen" Modus mit `strict=True` verwenden.

<span id="qasm2-export"></span>
## Exportieren einer Qiskit-Schaltung nach OpenQASM 2 {#export-a-qiskit-circuit-to-openqasm-2}

Qiskit kann auch einen [`QuantumCircuit`](../api/qiskit/qiskit.circuit.QuantumCircuit) nach OpenQASM 2 exportieren.
Sie verwenden die Funktion [`qasm2.dump()`](../api/qiskit/qasm2#dump), um in eine Datei zu schreiben, und [`qasm2.dumps()`](../api/qiskit/qasm2#dumps), um in einen String zu schreiben.
Diese Funktionen haben derzeit eine sehr einfache Schnittstelle: Sie akzeptieren eine Schaltung und, nur im Fall von [`qasm2.dump()`](../api/qiskit/qasm2#dump), einen Ort, an den die Ausgabe geschrieben werden soll.

<Admonition type="warning">
Qiskits OpenQASM 2-Exporter geht immer noch von einer Legacy-, nicht standardmäßigen Version der `"qelib1.inc"`-Include-Datei aus.
[Dies wird in einer späteren Version von Qiskit behoben](https://github.com/Qiskit/qiskit/issues/10737), aber in der Zwischenzeit, wenn Sie ein mit Qiskit erstelltes OpenQASM 2-Programm erneut importieren müssen, verwenden Sie [das obige Beispiel dafür, wie Sie dem Importer über die Legacy-Gates mitteilen](#qasm2-import-legacy).
</Admonition>

### Beispiel: Exportieren einer Schaltung nach OpenQASM 2 {#example-export-a-circuit-to-openqasm-2}

```python
from qiskit import QuantumCircuit, qasm2

# Define any circuit.
circuit = QuantumCircuit(2, 2)
circuit.h(0)
circuit.cx(0, 1)
circuit.measure([0, 1], [0, 1])

# Export to a string.
program = qasm2.dumps(circuit)

# Export to a file.
qasm2.dump(circuit, "my_file.qasm")
```

## Nächste Schritte {#next-steps}

<Admonition type="tip" title="Empfehlungen">
    - Erfahren Sie, wie Sie OpenQASM-Code im Leitfaden [IBM Quantum Composer](/guides/composer) generieren.
    - Siehe die [OpenQASM 2 Qiskit API](https://docs.quantum.ibm.com/api/qiskit/qasm2)-Referenz.
    - Lesen Sie das Thema [Überprüfen Sie Ihr Programm](./debugging-tools).
    - Besuchen Sie die [OpenQASM Live Specification](https://openqasm.com/).
</Admonition>
