---
title: "Ausführungsmodi mit REST-API"
sidebar_label: "Ausführungsmodi mit REST-API"
description: "Wie man einen Quantum-Computing-Job in einer Qiskit Runtime-Session ausführt."
notebook_path: "docs/guides/execution-modes-rest-api.ipynb"
---
{/* doqumentation-source-hash: a74b7d4c */}

<OpenInLabBanner notebookPath="docs/guides/execution-modes-rest-api.ipynb" />

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';



Sie können Ihre Qiskit-Primitiv-Workloads mit REST-APIs in einem von drei Ausführungsmodi ausführen, abhängig von Ihren Anforderungen: Job, Session und Batch. Dieses Thema erklärt diese Modi.

<Admonition type="note">
    Diese Dokumentation verwendet das Python-`requests`-Modul, um die Qiskit Runtime REST-API zu demonstrieren. Dieser Workflow kann jedoch mit jeder Sprache oder jedem Framework ausgeführt werden, das die Arbeit mit REST-APIs unterstützt. Details finden Sie in der [API-Referenzdokumentation](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/tags/jobs).
</Admonition>

## Job-Modus mit REST-API {#job-mode-with-rest-api}

Im Job-Modus wird eine einzelne Primitiv-Anfrage des Estimators oder des Samplers ohne Context Manager gestellt. Beispiele für die Ausführung einer Quantenschaltung mit [Estimator](primitives-rest-api#estimator-primitive-with-rest-api) und [Sampler](primitives-rest-api#sampler-primitive-with-rest-api) finden Sie hier.

## Session-Modus mit REST-API {#session-mode-with-rest-api}

Eine Session ist eine Qiskit Runtime-Funktion, mit der Sie Multi-Job-iterative Workloads effizient auf Quantencomputern ausführen können. Die Verwendung von Sessions hilft, Verzögerungen zu vermeiden, die durch das separate Einreihen jedes Jobs verursacht werden, was besonders nützlich für iterative Aufgaben sein kann, die häufige Kommunikation zwischen klassischen und Quantenressourcen erfordern. Weitere Details zu Sessions finden Sie in der [Dokumentation](./execution-modes).

<Admonition type="note">
Open Plan-Benutzer können keine Session-Jobs einreichen.
</Admonition>

### Eine Session starten {#start-a-session}

Beginnen Sie mit der Erstellung einer Session und dem Erhalt einer Session-ID.

```python
import json
import requests

sessionsUrl = "https://quantum.cloud.ibm.com/api/v1/sessions"
auth_id = "Bearer <YOUR_BEARER_TOKEN>"
backend = "<BACKEND_NAME>"
crn = "<SERVICE-CRN>"

headersList = {
  "Accept": "application/json",
  "Content-Type": "application/json",
  "Authorization": auth_id,
  "Service-CRN": crn
}

payload = json.dumps({
  "backend": backend,
  "mode": 'dedicated',
})

response = requests.request("POST", sessionsUrl, data=payload,  headers=headersList)

sessionId = response.json()['id']

print(response.json())
```
Output
```text
{'id': 'crw9s7cdbt40008jxesg'}
```

### Eine Session schließen {#close-a-session}

Es ist eine gute Praxis, eine `Session` zu schließen, wenn alle Jobs erledigt sind. Dies verkürzt die Wartezeit für nachfolgende Benutzer.

```python
closureURL="https://quantum.cloud.ibm.com/api/v1/sessions/"+sessionId+"/close"

headersList = {
  "Accept": "application/json",
  "Authorization": auth_id,
  "Service-CRN": crn
}

closure_response = requests.request(
    "DELETE",
    closureURL,
    headers=headersList
    )

print("Session closure response ok?:",closure_response.ok,closure_response.text)
```
Output
```text
Session closure response ok?: True
```

## Batch-Modus mit REST-API {#batch-mode-with-rest-api}

Alternativ können Sie einen Batch-Job einreichen, indem Sie den `mode` in der Request-Payload angeben. Der Batch-Modus kann helfen, die Verarbeitungszeit zu verkürzen, wenn alle Jobs im Voraus bereitgestellt werden können. Erfahren Sie mehr über den Batch-Modus im [Introduction to execution modes](./execution-modes#batch-mode)-Guide.

```python
import json
import requests

sessionsUrl = "https://quantum.cloud.ibm.com/api/v1/sessions"

headersList = {
  "Accept": "application/json",
  "Authorization": auth_id,
  "Service-CRN": crn,
  'Content-Type': 'application/json'
}

payload = json.dumps({
  "backend": backend,
  "instance": "hub1/group1/project1",
  "mode": "batch"
})

response = requests.request("POST", sessionsUrl, data=payload,  headers=headersList)

sessionId = response.json()['id']
```

## Beispiele für Jobs, die in einer Session eingereicht wurden {#examples-of-jobs-submitted-in-a-session}

Sobald eine Session eingerichtet ist, können ein oder mehrere Sampler- oder Estimator-Jobs an dieselbe Session übermittelt werden, indem die Session-ID angegeben wird.

<Admonition type="note">
    Die `<parameter values>` in einem `PUB` können entweder ein einzelner Parameter oder eine Liste von Parametern sein. Es unterstützt auch `numpy`-Broadcasting.
</Admonition>

### Estimator-Jobs im Session-Modus {#estimator-jobs-in-session-mode}

  <Tabs>
    <TabItem value="1 circuit, 4 observables" label="1 Schaltung, 4 Observablen">
      ```python
      job_input = {
      'program_id': 'estimator',
      "backend": backend,
      "session_id": sessionId, # This specifies the previously created Session
      "params": {
          "pubs": [[resulting_qasm, [obs1, obs2, obs3, obs4]]], #primitive unified blocs (PUBs) containing one circuit each.
          "options":{
                  "transpilation":{"optimization_level": 1},
                  "twirling": {"enable_gates": True,"enable_measure": True},
                  # "dynamical_decoupling": {"enable": True, "sequence_type": "XpXm"},   #(optional)
                      },
      }

  }
  ```
    </TabItem>

    <TabItem value="1 circuit, 4 observables, 2 parameter sets" label="1 Schaltung, 4 Observablen, 2 Parametersätze">

      ```python
      job_input = {
      'program_id': 'estimator',
      "backend": backend,
      "session_id": sessionId, # This specifies the previously created Session
      "params": {
          "pubs": [[resulting_qasm, [[obs1], [obs2], [obs3], [obs4]], [[vals1], [vals2]]]], #primitive unified blocs (PUBs) containing one circuit each
          "options":{
                  "transpilation":{"optimization_level": 1},
                  "twirling": {"enable_gates": True,"enable_measure": True},
                  # "dynamical_decoupling": {"enable": True, "sequence_type": "XpXm"},   #(optional)
                      },
      }
  }
  ```
    </TabItem>

    <TabItem value="2 circuits, 2 observables" label="2 Schaltungen, 2 Observablen">

    ```python
      job_input = {
      'program_id': 'estimator',
      "backend": backend,
      "session_id": sessionId, # This specifies the previously created Session
      "params": {
          "pubs": [[resulting_qasm, obs1],[resulting_qasm, obs2]], #primitive unified blocs (PUBs) containing one circuit each
          "options":{
                  "transpilation":{"optimization_level": 1},
                  "twirling": {"enable_gates": True,"enable_measure": True},
                  # "dynamical_decoupling": {"enable": True, "sequence_type": "XpXm"},   #(optional)
                      },
      }
  }
  ```
    </TabItem>
  </Tabs>

### Sampler-Jobs im Session-Modus {#sampler-jobs-in-session-mode}

  <Tabs>
    <TabItem value="1 circuit, no parameters" label="1 Schaltung, keine Parameter">
      ```python
      job_input = {
      'program_id': 'sampler',
      "backend": backend,
      "session_id": sessionId, # This specifies the previously created Session
      "params": {
          "pubs": [[resulting_qasm]], #primitive unified blocs (PUBs) containing one circuit each
          "options":{
                  "transpilation":{"optimization_level": 1},
                  "twirling": {"enable_gates": True,"enable_measure": True},
                  # "dynamical_decoupling": {"enable": True, "sequence_type": "XpXm"},   #(optional)
                      },
      }

  }
  ```
    </TabItem>

    <TabItem value="1 circuit, 3 parameter sets" label="1 Schaltung, 3 Parametersätze">

      ```python
      job_input = {
      'program_id': 'sampler',
      "backend": backend,
      "session_id": sessionId, # This specifies the previously created Session
      "params": {
          "pubs": [[resulting_qasm, [vals1, vals2, vals3]]], #primitive unified blocs (PUBs) containing one circuit each
          "options":{
                  "transpilation":{"optimization_level": 1},
                  "twirling": {"enable_gates": True,"enable_measure": True},
                  # "dynamical_decoupling": {"enable": True, "sequence_type": "XpXm"},   #(optional)
                      },
      }
  }
  ```
    </TabItem>

    <TabItem value="2 circuits, 1 parameter set" label="2 Schaltungen, 1 Parametersatz">

    ```python
      job_input = {
      'program_id': 'sampler',
      "backend": backend,
      "session_id": sessionId, # This specifies the previously created Session
      "params": {
          "pubs": [[resulting_qasm, [val1]],[resulting_qasm,None,100]], #primitive unified blocs (PUBs) containing one circuit each
          "options":{
                  "transpilation":{"optimization_level": 1},
                  "twirling": {"enable_gates": True,"enable_measure": True},
                  # "dynamical_decoupling": {"enable": True, "sequence_type": "XpXm"},   #(optional)
                      },
      }
  }
  ```
    </TabItem>
  </Tabs>

## Nächste Schritte {#next-steps}

<Admonition type="tip" title="Empfehlungen">
    - Überprüfen Sie detaillierte [Sampler and Estimator](primitives-rest-api)-Primitiv-Beispiele mit REST-API.
    - Lesen Sie [Migrate to V2 primitives](/guides/v2-primitives).
    - Üben Sie mit Primitiven, indem Sie die [Cost function lesson](/learning/courses/variational-algorithm-design/cost-functions) in IBM Quantum&reg; Learning durcharbeiten.
    - Erfahren Sie, wie Sie lokal transpilieren, im Abschnitt [Transpile](./transpile).
</Admonition>
