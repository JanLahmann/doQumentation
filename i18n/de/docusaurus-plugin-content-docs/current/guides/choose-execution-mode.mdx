---
title: Den richtigen Ausführungsmodus wählen
description: Wählen Sie den richtigen Ausführungsmodus für Qiskit Runtime Sessions, Batch oder Einzel-Jobs.

---
<span id="sessions-versus-batch-usage" />
# Den richtigen Ausführungsmodus wählen {#choose-the-right-execution-mode}

Utility-Scale-Workloads können viele Stunden zur Fertigstellung benötigen, daher ist es wichtig, dass sowohl die klassischen als auch die Quanten-Ressourcen effizient geplant werden, um die Ausführung zu optimieren. Ausführungsmodi bieten Flexibilität beim Ausgleich des Kosten- und Zeit-Trade-offs, um Ressourcen optimal für Ihre Workloads zu nutzen. Es gibt mehrere Aspekte zu berücksichtigen, wenn Sie wählen, welchen Ausführungsmodus Sie verwenden möchten, wie z. B. die Gesamtausführungszeit (maximale Lebensdauer oder TTL) und die Zeit zwischen Jobs (interaktive TTL).

Die Vorteile jedes Modus sind unten zusammengefasst:

- **Batch**
   - Der gesamte Batch von Jobs wird zusammen geplant, und es gibt keine zusätzliche Warteschlangenzeit für jeden einzelnen.
   - Die klassische Berechnung der Jobs, wie z. B. die Kompilierung, wird parallel ausgeführt. Daher ist das Ausführen mehrerer Jobs in einem Batch erheblich schneller als das serielle Ausführen.
   - Normalerweise gibt es minimale Verzögerung zwischen Jobs, was helfen kann, Drift zu vermeiden.
   - Wenn Sie Ihre Workload in mehrere Jobs aufteilen und sie im Batch-Modus ausführen, können Sie Ergebnisse von einzelnen Jobs erhalten, was sie flexibler in der Handhabung macht. Wenn zum Beispiel die Ergebnisse eines Jobs Ihre Erwartungen nicht erfüllen, können Sie die verbleibenden Jobs abbrechen. Auch wenn ein Job fehlschlägt, können Sie ihn erneut einreichen, anstatt die gesamte Workload erneut auszuführen.
   - Ist im Allgemeinen weniger teuer als Sessions.
- **Session**
   - Alle Funktionalitäten aus dem Batch-Modus (jedoch mit erhöhter Nutzung; siehe [Workload-Nutzung](/guides/estimate-job-run-time#usage) für weitere Details, wie die Nutzung berechnet wird).
   - Dedizierter und exklusiver Zugriff auf die QPU während des aktiven Session-Fensters.
   - Nützlich für Workloads, die nicht alle Eingaben zu Beginn bereit haben, für iterative Workloads, die klassische Nachbearbeitung erfordern, bevor der nächste ausgeführt werden kann, und für Experimente, die so eng wie möglich zusammen laufen müssen.
- **Job**
   - Am einfachsten zu verwenden, wenn Sie ein kleines Experiment durchführen.
   - Könnte früher als der Batch-Modus laufen.

<span id="best-practices"></span>
## Empfehlungen und Best Practices {#recommendations-and-best-practices}

Verwenden Sie im Allgemeinen den Batch-Modus, es sei denn, Sie haben Workloads, die nicht alle Eingaben zu Beginn bereit haben.

- Verwenden Sie den **Batch**-Modus, um mehrere Primitive-Jobs gleichzeitig einzureichen, um die Verarbeitungszeit zu verkürzen.
- Verwenden Sie den **Session**-Modus für iterative Workloads oder wenn Sie dedizierten Zugriff auf die QPU benötigen.
- Verwenden Sie immer den **Job**-Modus, um eine einzelne Primitive-Anfrage einzureichen.
- Da _Sessions im Allgemeinen teurer sind_, wird empfohlen, dass Sie Batch verwenden, wann immer Sie die zusätzlichen Vorteile von Sessions nicht benötigen.

- Open-Plan-Benutzer können keine Session-Jobs einreichen.

Um die effizienteste Nutzung der Ausführungsmodi sicherzustellen, werden die folgenden Praktiken empfohlen:

- Es gibt einen festen Overhead, der mit dem Ausführen eines Jobs verbunden ist. Im Allgemeinen gilt: Wenn jeder Ihrer Jobs weniger als eine Minute _QPU-Zeit_ verwendet, erwägen Sie, mehrere zu einem größeren Job zu kombinieren (dies gilt für alle Ausführungsmodi). "QPU-Zeit" bezieht sich auf die Zeit, die der QPU-Komplex zur Verarbeitung Ihres Jobs aufwendet.

- Wenn jeder Ihrer Jobs mehr als eine Minute QPU-Zeit verbraucht, oder wenn das Kombinieren von Jobs nicht praktikabel ist, können Sie dennoch mehrere Jobs parallel ausführen. Jeder Job durchläuft sowohl klassische als auch Quantenverarbeitung. Während eine QPU jeweils nur einen Job verarbeiten kann, können bis zu fünf klassische Jobs parallel verarbeitet werden. Sie können dies nutzen, indem Sie mehrere Jobs im [Batch](/guides/run-jobs-batch#partition)- oder [Session](/guides/run-jobs-session#two-vqe)-Ausführungsmodus einreichen.

Die oben genannten sind allgemeine Richtlinien, und Sie sollten Ihre Workload anpassen, um das optimale Verhältnis zu finden, insbesondere bei Verwendung von Sessions. Wenn Sie beispielsweise eine Session verwenden, um exklusiven Zugriff auf ein Backend zu erhalten, erwägen Sie, große Jobs in kleinere aufzuteilen und sie parallel auszuführen. Dies könnte kostengünstiger sein, da es die Wall-Clock-Zeit reduzieren kann.

## Beispiele {#examples}

### Ausführung eines quantenvariationalen Algorithmus {#run-a-quantum-variational-algorithm}

Das Ausführen eines quantenvariationalen Algorithmus folgt typischerweise diesem Ablauf:

1. Bereiten Sie den Ansatz vor.
2. Bewerten Sie die Kostenfunktion auf einer QPU.
3. Nehmen Sie das Ergebnis aus dem vorherigen Schritt und führen Sie es durch einen klassischen Optimierer.
4. Passen Sie die Parameter gemäß der Ausgabe von (3) an und gehen Sie dann zurück zu Schritt (2).

In diesem Fall muss jeder Job, der durch Schritt (2) generiert wird, bei Verwendung des Job- oder Batch-Modus erneut durch die Warteschlange gehen. Dies verlängert die Experimentdauer (Wall-Clock-Zeit) drastisch aufgrund der Warteschlangenzeit. Es könnte auch länger dauern, bis eine Konvergenz aufgrund von Geräte-Drift erreicht wird. Das heißt, jede Iteration soll Ihnen ein besseres Ergebnis liefern, aber Geräte-Drift könnte nachfolgende Ergebnisse schlechter machen.

Wenn Sie außerdem [PEA](/guides/error-mitigation-and-suppression-techniques#pea) oder [PEC](/guides/error-mitigation-and-suppression-techniques#pec) verwenden, können Sie [das Rauschmodell lernen](/guides/noise-learning) einmal und es auf nachfolgende Jobs anwenden, wenn Sie in einer dedizierten Session laufen. Dies funktioniert normalerweise nicht mit Batch- oder Job-Modus, da das Rauschmodell veraltet sein könnte, bis der nächste Job aus der Warteschlange ist.

### Vergleich von Fehlerminderungs-Einstellungen {#compare-error-mitigation-settings}

Um die Auswirkungen der verfügbaren Fehlerminderungsmethoden zu vergleichen, könnten Sie diesem Ablauf folgen:

1. Konstruieren Sie einen Schaltkreis und eine Observable.
2. Reichen Sie Primitive-Jobs ein, die verschiedene Kombinationen von Fehlerminderungs-Einstellungen verwenden.
3. Stellen Sie die Ergebnisse dar, um die Auswirkungen der verschiedenen Einstellungen zu beobachten.

In diesem Fall sind alle Jobs (die verwandt, aber unabhängig sind) zu Beginn verfügbar. Wenn Sie den Batch-Modus verwenden, werden sie kollektiv geplant, sodass Sie nur darauf warten müssen, dass sie einmal durch die Warteschlange gehen. Da das Ziel außerdem darin besteht, die Auswirkungen verschiedener Fehlerminderungsmethoden zu vergleichen, ist es vorteilhaft, dass sie so eng wie möglich zusammen laufen. Daher wäre Batch eine gute Wahl. Sie _könnten_ diese Jobs in einer Session ausführen, aber da Sessions im Allgemeinen teurer sind, wird empfohlen, dass Sie Batch verwenden, wann immer Sie die zusätzliche Funktionalität, die Sessions bieten, nicht benötigen.

## Nächste Schritte {#next-steps}

<Admonition type="tip" title="Empfehlungen">
    - [Führen Sie einen Job im Batch-Modus aus](/guides/run-jobs-batch/).
    - [Führen Sie einen Job im Session-Modus aus](/guides/run-jobs-session).
    - [Workload-Nutzung](/guides/estimate-job-run-time).
</Admonition>
