---
title: Den richtigen Ausführungsmodus wählen
description: Wähle den richtigen Ausführungsmodus für Qiskit Runtime Sessions, Batch oder Einzel-Jobs.

---
{/* doqumentation-source-hash: 43aaa75b */}
<span id="sessions-versus-batch-usage" />
# Den richtigen Ausführungsmodus wählen {#choose-the-right-execution-mode}

Utility-Scale-Workloads können viele Stunden zur Fertigstellung benötigen, daher ist es wichtig, dass sowohl die klassischen als auch die Quanten-Ressourcen effizient geplant werden, um die Ausführung zu optimieren. Ausführungsmodi bieten Flexibilität beim Ausgleich des Kosten- und Zeit-Trade-offs, um Ressourcen optimal für deine Workloads zu nutzen. Es gibt mehrere Aspekte zu berücksichtigen, wenn du wählst, welchen Ausführungsmodus du verwenden möchtest, wie z. B. die Gesamtausführungszeit (maximale Lebensdauer oder TTL) und die Zeit zwischen Jobs (interaktive TTL).

Die Vorteile jedes Modus sind unten zusammengefasst:

- **Batch**
   - Der gesamte Batch von Jobs wird zusammen geplant, und es gibt keine zusätzliche Warteschlangenzeit für jeden einzelnen.
   - Die klassische Berechnung der Jobs, wie z. B. die Kompilierung, wird parallel ausgeführt. Daher ist das Ausführen mehrerer Jobs in einem Batch erheblich schneller als das serielle Ausführen.
   - Normalerweise gibt es minimale Verzögerung zwischen Jobs, was helfen kann, Drift zu vermeiden.
   - Wenn du deine Workload in mehrere Jobs aufteilst und sie im Batch-Modus ausführst, kannst du Ergebnisse von einzelnen Jobs erhalten, was sie flexibler in der Handhabung macht. Wenn zum Beispiel die Ergebnisse eines Jobs deine Erwartungen nicht erfüllen, kannst du die verbleibenden Jobs abbrechen. Auch wenn ein Job fehlschlägt, kannst du ihn erneut einreichen, anstatt die gesamte Workload erneut auszuführen.
   - Ist im Allgemeinen weniger teuer als Sessions.
- **Session**
   - Alle Funktionalitäten aus dem Batch-Modus (jedoch mit erhöhter Nutzung; siehe [Workload-Nutzung](/guides/estimate-job-run-time#usage) für weitere Details, wie die Nutzung berechnet wird).
   - Dedizierter und exklusiver Zugriff auf die QPU während des aktiven Session-Fensters.
   - Nützlich für Workloads, die nicht alle Eingaben zu Beginn bereit haben, für iterative Workloads, die klassische Nachbearbeitung erfordern, bevor der nächste ausgeführt werden kann, und für Experimente, die so eng wie möglich zusammen laufen müssen.
- **Job**
   - Am einfachsten zu verwenden, wenn du ein kleines Experiment durchführst.
   - Könnte früher als der Batch-Modus laufen.

<span id="best-practices"></span>
## Empfehlungen und Best Practices {#recommendations-and-best-practices}

Verwende im Allgemeinen den Batch-Modus, es sei denn, du hast Workloads, die nicht alle Eingaben zu Beginn bereit haben.

- Verwende den **Batch**-Modus, um mehrere Primitive-Jobs gleichzeitig einzureichen, um die Verarbeitungszeit zu verkürzen.
- Verwende den **Session**-Modus für iterative Workloads oder wenn du dedizierten Zugriff auf die QPU benötigst.
- Verwende immer den **Job**-Modus, um eine einzelne Primitive-Anfrage einzureichen.
- Da _Sessions im Allgemeinen teurer sind_, wird empfohlen, dass du Batch verwendest, wann immer du die zusätzlichen Vorteile von Sessions nicht benötigst.

- Open-Plan-Benutzer können keine Session-Jobs einreichen.

Um die effizienteste Nutzung der Ausführungsmodi sicherzustellen, werden die folgenden Praktiken empfohlen:

- Es gibt einen festen Overhead, der mit dem Ausführen eines Jobs verbunden ist. Im Allgemeinen gilt: Wenn jeder deiner Jobs weniger als eine Minute _QPU-Zeit_ verwendet, erwäge, mehrere zu einem größeren Job zu kombinieren (dies gilt für alle Ausführungsmodi). "QPU-Zeit" bezieht sich auf die Zeit, die der QPU-Komplex zur Verarbeitung deines Jobs aufwendet.

- Wenn jeder deiner Jobs mehr als eine Minute QPU-Zeit verbraucht, oder wenn das Kombinieren von Jobs nicht praktikabel ist, kannst du dennoch mehrere Jobs parallel ausführen. Jeder Job durchläuft sowohl klassische als auch Quantenverarbeitung. Während eine QPU jeweils nur einen Job verarbeiten kann, können bis zu fünf klassische Jobs parallel verarbeitet werden. Du kannst dies nutzen, indem du mehrere Jobs im [Batch](/guides/run-jobs-batch#partition)- oder [Session](/guides/run-jobs-session#two-vqe)-Ausführungsmodus einreichst.

Die oben genannten sind allgemeine Richtlinien, und du solltest deine Workload anpassen, um das optimale Verhältnis zu finden, insbesondere bei Verwendung von Sessions. Wenn du beispielsweise eine Session verwendest, um exklusiven Zugriff auf ein Backend zu erhalten, erwäge, große Jobs in kleinere aufzuteilen und sie parallel auszuführen. Dies könnte kostengünstiger sein, da es die Wall-Clock-Zeit reduzieren kann.

## Beispiele {#examples}

### Ausführung eines quantenvariationalen Algorithmus {#run-a-quantum-variational-algorithm}

Das Ausführen eines quantenvariationalen Algorithmus folgt typischerweise diesem Ablauf:

1. Bereite den Ansatz vor.
2. Bewerte die Kostenfunktion auf einer QPU.
3. Nimm das Ergebnis aus dem vorherigen Schritt und führe es durch einen klassischen Optimierer.
4. Passe die Parameter gemäß der Ausgabe von (3) an und gehe dann zurück zu Schritt (2).

In diesem Fall muss jeder Job, der durch Schritt (2) generiert wird, bei Verwendung des Job- oder Batch-Modus erneut durch die Warteschlange gehen. Dies verlängert die Experimentdauer (Wall-Clock-Zeit) drastisch aufgrund der Warteschlangenzeit. Es könnte auch länger dauern, bis eine Konvergenz aufgrund von Geräte-Drift erreicht wird. Das heißt, jede Iteration soll dir ein besseres Ergebnis liefern, aber Geräte-Drift könnte nachfolgende Ergebnisse schlechter machen.

Wenn du außerdem [PEA](/guides/error-mitigation-and-suppression-techniques#pea) oder [PEC](/guides/error-mitigation-and-suppression-techniques#pec) verwendest, kannst du [das Rauschmodell lernen](/guides/noise-learning) einmal und es auf nachfolgende Jobs anwenden, wenn du in einer dedizierten Session läufst. Dies funktioniert normalerweise nicht mit Batch- oder Job-Modus, da das Rauschmodell veraltet sein könnte, bis der nächste Job aus der Warteschlange ist.

### Vergleich von Fehlerminderungs-Einstellungen {#compare-error-mitigation-settings}

Um die Auswirkungen der verfügbaren Fehlerminderungsmethoden zu vergleichen, könntest du diesem Ablauf folgen:

1. Konstruiere einen Schaltkreis und eine Observable.
2. Reiche Primitive-Jobs ein, die verschiedene Kombinationen von Fehlerminderungs-Einstellungen verwenden.
3. Stelle die Ergebnisse dar, um die Auswirkungen der verschiedenen Einstellungen zu beobachten.

In diesem Fall sind alle Jobs (die verwandt, aber unabhängig sind) zu Beginn verfügbar. Wenn du den Batch-Modus verwendest, werden sie kollektiv geplant, sodass du nur darauf warten musst, dass sie einmal durch die Warteschlange gehen. Da das Ziel außerdem darin besteht, die Auswirkungen verschiedener Fehlerminderungsmethoden zu vergleichen, ist es vorteilhaft, dass sie so eng wie möglich zusammen laufen. Daher wäre Batch eine gute Wahl. Du _könntest_ diese Jobs in einer Session ausführen, aber da Sessions im Allgemeinen teurer sind, wird empfohlen, dass du Batch verwendest, wann immer du die zusätzliche Funktionalität, die Sessions bieten, nicht benötigst.

## Nächste Schritte {#next-steps}

<Admonition type="tip" title="Empfehlungen">
    - [Führe einen Job im Batch-Modus aus](/guides/run-jobs-batch/).
    - [Führe einen Job im Session-Modus aus](/guides/run-jobs-session).
    - [Workload-Nutzung](/guides/estimate-job-run-time).
</Admonition>
