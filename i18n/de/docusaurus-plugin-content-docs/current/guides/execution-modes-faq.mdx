---
title: Häufig gestellte Fragen zu Ausführungsmodi
description: Antworten auf häufig gestellte Fragen zu Qiskit Runtime-Ausführungsmodi

---
{/* doqumentation-source-hash: 06065209 */}
# Häufig gestellte Fragen zu Qiskit Runtime-Ausführungsmodi {#qiskit-runtime-execution-modes-faqs}

<details>
  <summary>
    Unterstützt der Qiskit Runtime Local Testing Mode verschiedene Ausführungsmodi?
  </summary>

Der Local Testing Mode unterstützt die Syntax für die verschiedenen Ausführungsmodi, aber da beim lokalen Testen keine Planung erforderlich ist, werden die Modi ignoriert.
</details>

<span id="parallel"></span>
<details>
  <summary>
    Wie viele Jobs können parallel für ein bestimmtes Backend ausgeführt werden?
  </summary>

Die Anzahl der parallel laufenden Jobs basiert auf dem für das Backend konfigurierten Grad der Parallelität, der heute für die meisten Backends fünf beträgt.
</details>

<details>
  <summary>
    Wie wird die Nutzung für fehlgeschlagene oder abgebrochene Jobs gemeldet?
  </summary>

Siehe den Abschnitt [Failed and canceled jobs](/guides/estimate-job-run-time#failed-job) auf der Seite Execution modes.
</details>

## Sessions

<details>
  <summary>
    Was passiert mit meinen Jobs, wenn eine Session geschlossen wird?
  </summary>

Wenn du die `Session`-Klasse in `qiskit-ibm-runtime` verwendest:

  - `Session.close()` bedeutet, dass die Session keine neuen Jobs mehr annimmt, aber bestehende Jobs werden abgeschlossen.
  - `Session.cancel()` bricht alle ausstehenden Session-Jobs ab.

Wenn du die REST-API direkt verwendest:

  - `PATCH /sessions/{id}` mit `accepting_jobs=False` bedeutet, dass die Session keine neuen Jobs mehr annimmt, aber bestehende Jobs werden abgeschlossen.
  - `DELETE /sessions/{id}/close` bricht alle ausstehenden Session-Jobs ab.
</details>

<details>
  <summary>
    Wenn du den Session-Modus verwendest und erwartest, dass dein Experiment viele Stunden dauern wird, gibt es eine Möglichkeit, Kalibrierungen anzufordern?
  </summary>

Nein. On-Demand-Kalibrierung ist nicht verfügbar.
</details>

<details>
  <summary>
    Gibt es ein interaktives Timeout (interaktive TTL) im Session-Modus?
  </summary>

Ja. Dies reduziert unerwünschte Kosten, wenn du vergisst, deine Session zu schließen.
</details>

<details>
  <summary>
    Kann ich die interaktive TTL oder die maximale TTL einer Session ändern?
  </summary>

Du kannst den Wert der interaktiven TTL nicht ändern. Du kannst den maximalen TTL-Wert einer Session ändern (siehe [Specify the session length](/guides/run-jobs-session#specify-length)), aber er muss kleiner als das systemdefinierte Maximum sein. Bitte deinen Administrator, sich an den IBM Support zu wenden, wenn du eine andere interaktive TTL oder systemmaximale TTL benötigst.

</details>

<details>
  <summary>
    Wie wirkt sich die Session-Nutzung auf IBM Quantum Network-Mitglieder aus, die nicht nach Nutzung abgerechnet werden?
  </summary>

IBM Quantum Network-Mitglieder erhalten reservierte Kapazität auf IBM Quantum&reg; QPUs. Die Nutzung wird von dieser Kapazität abgezogen, und Instanzen mit geringerer Kapazität haben längere Warteschlangen-Zeiten.
</details>

<details>
  <summary>
    Erhalte ich im Session-Modus die gleiche Parallelität wie im Batch-Modus?
  </summary>

Ja. Wenn du mehrere Jobs gleichzeitig in einer Session einreichst, werden diese Jobs parallel ausgeführt.
</details>

<details>
  <summary>
    Können Sessions durch QPU-Upgrades oder Kalibrierungen unterbrochen werden?
  </summary>

Nein. Sessions laufen im Dedicated Mode, was bedeutet, dass du vollen Zugriff auf das Backend hast. Sessions werden niemals durch Kalibrierungen oder Software-Upgrades unterbrochen.
</details>

<details>
  <summary>
    Wird die Kompilierungszeit als Nutzung im Session-Modus gezählt?
  </summary>

Ja. Im Session-Modus ist die Nutzung die Wanduhr-Zeit, in der die QPU **für die Session reserviert ist**. Sie beginnt, wenn der erste Session-Job startet, und endet, wenn die Session inaktiv wird, geschlossen wird oder wenn der letzte Job abgeschlossen ist, je nachdem, was **zuletzt** passiert. Daher akkumuliert sich die Nutzung weiterhin, nachdem eine Session endet, wenn die QPU noch einen Job ausführt. Zusätzlich zählt die Zeit nach Abschluss eines Jobs, während die QPU auf einen weiteren Session-Job wartet (die interaktive TTL), als Nutzung. Deshalb solltest du sicherstellen, dass die Session geschlossen wird, sobald du mit dem Einreichen von Jobs fertig bist.
</details>

## Batch

<details>
  <summary>
    Wie viele Jobs laufen im Batch-Modus parallel?
  </summary>

Die Anzahl der parallel laufenden Jobs basiert auf dem für das Backend konfigurierten Grad der Parallelität, der für die meisten Backends fünf beträgt. Die Anzahl der gleichzeitigen Jobs in einem aktiven Batch könnte jedoch geringer sein, da bereits andere Jobs laufen könnten, wenn der Batch aktiv wird.
</details>

<details>
  <summary>
    Wie unterscheidet sich die Ausführung von _N_ PUBs im Job-Modus von der Ausführung von _N_ Einzel-PUB-Jobs im Batch-Modus?
  </summary>

Der Hauptunterschied ist der Zeit- und Kosten-Kompromiss:

Batch-Modus:

- Die Gesamtlaufzeit ist geringer, da die klassische Verarbeitung möglicherweise parallel läuft.
- Es gibt einen leichten Overhead für die Ausführung jedes Jobs, sodass du am Ende etwas mehr für gebatchte Jobs bezahlst. Dieser Overhead korreliert mit der Größe des Jobs. Beispielsweise beträgt die Gesamtnutzung von zwei Jobs, die jeweils 40 100x100-Schaltungen enthalten, sechs Sekunden mehr als ein einzelner Job mit 80 Schaltungen.
- Da der Batch-Modus dir keinen exklusiven Zugriff auf ein Backend gibt, können Jobs innerhalb eines Batches mit Jobs anderer Benutzer oder Kalibrier-Jobs ausgeführt werden.
- Wenn einige Jobs fehlschlagen, erhältst du immer noch Ergebnisse von den abgeschlossenen Jobs.
- Du kannst in der Mitte einer Batch-Workload basierend auf den Ergebnissen abgeschlossener Jobs Maßnahmen ergreifen. Du kannst beispielsweise den Rest der Jobs abbrechen, wenn die ersten Ergebnisse falsch aussehen.

Job-Modus:

- Die Gesamtlaufzeit ist wahrscheinlich höher, da es keine Parallelität gibt.
- Du zahlst nicht für den zusätzlichen Job-Overhead, der mit Batch-Workloads verbunden ist.
- Alle deine Schaltungen werden zusammen ausgeführt.
- Wenn dieser einzelne Job fehlschlägt, erhältst du keine Teilergebnisse.
- Dein Job könnte das Limit erreichen, wenn er zu viele Schaltungen enthält oder wenn die Schaltungen zu groß sind.

Im Allgemeinen solltest du in Betracht ziehen, deine Jobs in einen größeren Job zu kombinieren, wenn jeder deiner Jobs weniger als eine Minute QPU-Zeit verbraucht (dies gilt für alle Ausführungsmodi).
</details>

<details>
  <summary>
    Wie viele Jobs kann ich in einem Batch einreichen?
  </summary>

Es gibt zwar keine Begrenzung für die Anzahl der Jobs, die du in einem Batch einreichen kannst, aber es gibt eine maximale Zeit, die mit einem Batch verbunden ist. Das heißt, wenn die Wanduhr-Zeit eines Batches (die beginnt, wenn der erste Batch-Job zu laufen beginnt) die systemdefinierte Maximalzeit überschreitet, nimmt der Batch keine neuen Jobs mehr an, und alle Jobs, die in der Warteschlange sind, aber nicht laufen, werden abgebrochen. Darüber hinaus gibt es Grenzen dafür, wie viel Nutzung deine Jobs basierend auf deinem Plan verbrauchen können. Um die maximale Zeit zu bestimmen, die mit einem Batch verbunden ist, verwende die [`batch.details()`-Methode](/guides/run-jobs-batch#batch-details) und suche nach dem `max_time`-Wert.
</details>

<details>
  <summary>
    Wann würden meine Batch-Modus-Jobs parallel mit Jobs anderer Benutzer laufen?
  </summary>

Der für ein Backend konfigurierte Grad der Parallelität wird auch als "Execution Lanes" bezeichnet. Wenn eine oder mehrere Execution Lanes verfügbar sind und deine Batch-Jobs als nächstes an der Reihe sind, startet der Scheduler genügend Jobs, um die Lanes zu füllen. Wenn dein Batch nicht genügend Jobs hat, um die Lanes zu füllen, startet der Scheduler Jobs anderer Benutzer.

Beispiel: Das von dir gewählte Backend hat fünf Execution Lanes, und zwei davon sind derzeit von Jobs anderer Benutzer belegt. Dein Batch von sechs Jobs ist als nächstes an der Reihe.

Da drei Lanes verfügbar sind, startet der Scheduler drei deiner sechs Batch-Jobs. Er fährt fort, Jobs in deinem Batch zu starten, sobald Jobs beendet sind und Execution Lanes verfügbar werden. Wenn eine Lane verfügbar wird und es keine weiteren Jobs in deinem Batch gibt, startet der Scheduler den nächsten Job in der Warteschlange.
</details>

<details>
  <summary>
    Müssen alle meine Batch-Jobs in der Warteschlange warten?
  </summary>

Da QPUs begrenzte und gemeinsam genutzte Ressourcen sind, müssen alle Jobs in der Warteschlange warten. Wenn jedoch der erste Job in deinem Batch zu laufen beginnt, springen im Wesentlichen alle anderen Jobs in diesem Batch an die Spitze der Warteschlange und werden vom Scheduler priorisiert.
</details>

<details>
  <summary>
    Endet ein Batch automatisch, wenn der letzte zugehörige Job endet?
  </summary>

Ja. Es gibt jedoch einen leichten Overhead im Zusammenhang mit dieser automatischen Erkennung, daher solltest du deinen Batch und deine Session immer schließen.
</details>

<details>
  <summary>
    Können Batches durch Kalibrierungen oder Software-Upgrades unterbrochen werden
  </summary>

Ja. Batch-Workloads können durch Kalibrierungen oder Software-Upgrades unterbrochen werden.
</details>

<details>
  <summary>
    Wird die Kompilierungszeit als Nutzung im Batch-Modus gezählt?
  </summary>

Nein. Im Batch-Modus zählt nur die auf der Quanten-Hardware verbrachte Zeit als Nutzung.
</details>
