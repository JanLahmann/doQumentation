---
title: Häufig gestellte Fragen zu Ausführungsmodi
description: Antworten auf häufig gestellte Fragen zu Qiskit Runtime-Ausführungsmodi

---
# Häufig gestellte Fragen zu Qiskit Runtime-Ausführungsmodi {#qiskit-runtime-execution-modes-faqs}

<details>
  <summary>
    Unterstützt der Qiskit Runtime Local Testing Mode verschiedene Ausführungsmodi?
  </summary>

Der Local Testing Mode unterstützt die Syntax für die verschiedenen Ausführungsmodi, aber da beim lokalen Testen keine Planung erforderlich ist, werden die Modi ignoriert.
</details>

<span id="parallel"></span>
<details>
  <summary>
    Wie viele Jobs können parallel für ein bestimmtes Backend ausgeführt werden?
  </summary>

Die Anzahl der parallel laufenden Jobs basiert auf dem für das Backend konfigurierten Grad der Parallelität, der heute für die meisten Backends fünf beträgt.
</details>

<details>
  <summary>
    Wie wird die Nutzung für fehlgeschlagene oder abgebrochene Jobs gemeldet?
  </summary>

Siehe den Abschnitt [Failed and canceled jobs](/guides/estimate-job-run-time#failed-job) auf der Seite Execution modes.
</details>

## Sessions

<details>
  <summary>
    Was passiert mit meinen Jobs, wenn eine Session geschlossen wird?
  </summary>

Wenn Sie die `Session`-Klasse in `qiskit-ibm-runtime` verwenden:

  - `Session.close()` bedeutet, dass die Session keine neuen Jobs mehr annimmt, aber bestehende Jobs werden abgeschlossen.
  - `Session.cancel()` bricht alle ausstehenden Session-Jobs ab.

Wenn Sie die REST-API direkt verwenden:

  - `PATCH /sessions/{id}` mit `accepting_jobs=False` bedeutet, dass die Session keine neuen Jobs mehr annimmt, aber bestehende Jobs werden abgeschlossen.
  - `DELETE /sessions/{id}/close` bricht alle ausstehenden Session-Jobs ab.
</details>

<details>
  <summary>
    Wenn ich den Session-Modus verwende und erwarte, dass mein Experiment viele Stunden dauern wird, gibt es eine Möglichkeit, Kalibrierungen anzufordern?
  </summary>

Nein. On-Demand-Kalibrierung ist nicht verfügbar.
</details>

<details>
  <summary>
    Gibt es ein interaktives Timeout (interaktive TTL) im Session-Modus?
  </summary>

Ja. Dies reduziert unerwünschte Kosten, wenn ein Benutzer vergisst, seine Session zu schließen.
</details>

<details>
  <summary>
    Kann ich die interaktive TTL oder die maximale TTL einer Session ändern?
  </summary>

Sie können den Wert der interaktiven TTL nicht ändern. Sie können den maximalen TTL-Wert einer Session ändern (siehe [Specify the session length](/guides/run-jobs-session#specify-length)), aber er muss kleiner als das systemdefinierte Maximum sein. Bitten Sie Ihren Administrator, sich an den IBM Support zu wenden, wenn Sie eine andere interaktive TTL oder systemmaximale TTL benötigen.

</details>

<details>
  <summary>
    Wie wirkt sich die Session-Nutzung auf IBM Quantum Network-Mitglieder aus, die nicht nach Nutzung abgerechnet werden?
  </summary>

IBM Quantum Network-Mitglieder erhalten reservierte Kapazität auf IBM Quantum&reg; QPUs. Die Nutzung wird von dieser Kapazität abgezogen, und Instanzen mit geringerer Kapazität haben längere Warteschlangen-Zeiten.
</details>

<details>
  <summary>
    Erhalte ich im Session-Modus die gleiche Parallelität wie im Batch-Modus?
  </summary>

Ja. Wenn Sie mehrere Jobs gleichzeitig in einer Session einreichen, werden diese Jobs parallel ausgeführt.
</details>

<details>
  <summary>
    Können Sessions durch QPU-Upgrades oder Kalibrierungen unterbrochen werden?
  </summary>

Nein. Sessions laufen im Dedicated Mode, was bedeutet, dass der Benutzer vollen Zugriff auf das Backend hat. Sessions werden niemals durch Kalibrierungen oder Software-Upgrades unterbrochen.
</details>

<details>
  <summary>
    Wird die Kompilierungszeit als Nutzung im Session-Modus gezählt?
  </summary>

Ja. Im Session-Modus ist die Nutzung die Wanduhr-Zeit, in der die QPU **für die Session reserviert ist**. Sie beginnt, wenn der erste Session-Job startet, und endet, wenn die Session inaktiv wird, geschlossen wird oder wenn der letzte Job abgeschlossen ist, je nachdem, was **zuletzt** passiert. Daher akkumuliert sich die Nutzung weiterhin, nachdem eine Session endet, wenn die QPU noch einen Job ausführt. Zusätzlich zählt die Zeit nach Abschluss eines Jobs, während die QPU auf einen weiteren Session-Job wartet (die interaktive TTL), als Nutzung. Deshalb sollten Sie sicherstellen, dass die Session geschlossen wird, sobald Sie mit dem Einreichen von Jobs fertig sind.
</details>

## Batch

<details>
  <summary>
    Wie viele Jobs laufen im Batch-Modus parallel?
  </summary>

Die Anzahl der parallel laufenden Jobs basiert auf dem für das Backend konfigurierten Grad der Parallelität, der für die meisten Backends fünf beträgt. Die Anzahl der gleichzeitigen Jobs in einem aktiven Batch könnte jedoch geringer sein, da bereits andere Jobs laufen könnten, wenn der Batch aktiv wird.
</details>

<details>
  <summary>
    Wie unterscheidet sich die Ausführung von _N_ PUBs im Job-Modus von der Ausführung von _N_ Einzel-PUB-Jobs im Batch-Modus?
  </summary>

Der Hauptunterschied ist der Zeit- und Kosten-Kompromiss:

Batch-Modus:

- Die Gesamtlaufzeit ist geringer, da die klassische Verarbeitung möglicherweise parallel läuft.
- Es gibt einen leichten Overhead für die Ausführung jedes Jobs, sodass Sie am Ende etwas mehr für gebatchte Jobs bezahlen. Dieser Overhead korreliert mit der Größe des Jobs. Beispielsweise beträgt die Gesamtnutzung von zwei Jobs, die jeweils 40 100x100-Schaltungen enthalten, sechs Sekunden mehr als ein einzelner Job mit 80 Schaltungen.
- Da der Batch-Modus Ihnen keinen exklusiven Zugriff auf ein Backend gibt, können Jobs innerhalb eines Batches mit Jobs anderer Benutzer oder Kalibrier-Jobs ausgeführt werden.
- Wenn einige Jobs fehlschlagen, erhalten Sie immer noch Ergebnisse von den abgeschlossenen Jobs.
- Sie können in der Mitte einer Batch-Workload basierend auf den Ergebnissen abgeschlossener Jobs Maßnahmen ergreifen. Sie können beispielsweise den Rest der Jobs abbrechen, wenn die ersten Ergebnisse falsch aussehen.

Job-Modus:

- Die Gesamtlaufzeit ist wahrscheinlich höher, da es keine Parallelität gibt.
- Sie zahlen nicht für den zusätzlichen Job-Overhead, der mit Batch-Workloads verbunden ist.
- Alle Ihre Schaltungen werden zusammen ausgeführt.
- Wenn dieser einzelne Job fehlschlägt, erhalten Sie keine Teilergebnisse.
- Ihr Job könnte das Limit erreichen, wenn er zu viele Schaltungen enthält oder wenn die Schaltungen zu groß sind.

Im Allgemeinen sollten Sie in Betracht ziehen, Ihre Jobs in einen größeren Job zu kombinieren, wenn jeder Ihrer Jobs weniger als eine Minute QPU-Zeit verbraucht (dies gilt für alle Ausführungsmodi).
</details>

<details>
  <summary>
    Wie viele Jobs kann ich in einem Batch einreichen?
  </summary>

Es gibt zwar keine Begrenzung für die Anzahl der Jobs, die Sie in einem Batch einreichen können, aber es gibt eine maximale Zeit, die mit einem Batch verbunden ist. Das heißt, wenn die Wanduhr-Zeit eines Batches (die beginnt, wenn der erste Batch-Job zu laufen beginnt) die systemdefinierte Maximalzeit überschreitet, nimmt der Batch keine neuen Jobs mehr an, und alle Jobs, die in der Warteschlange sind, aber nicht laufen, werden abgebrochen. Darüber hinaus gibt es Grenzen dafür, wie viel Nutzung Ihre Jobs basierend auf Ihrem Plan verbrauchen können. Um die maximale Zeit zu bestimmen, die mit einem Batch verbunden ist, verwenden Sie die [`batch.details()`-Methode](/guides/run-jobs-batch#batch-details) und suchen Sie nach dem `max_time`-Wert.
</details>

<details>
  <summary>
    Wann würden meine Batch-Modus-Jobs parallel mit Jobs anderer Benutzer laufen?
  </summary>

Der für ein Backend konfigurierte Grad der Parallelität wird auch als "Execution Lanes" bezeichnet. Wenn eine oder mehrere Execution Lanes verfügbar sind und Ihre Batch-Jobs als nächstes an der Reihe sind, startet der Scheduler genügend Jobs, um die Lanes zu füllen. Wenn Ihr Batch nicht genügend Jobs hat, um die Lanes zu füllen, startet der Scheduler Jobs anderer Benutzer.

Beispiel: Das von Ihnen gewählte Backend hat fünf Execution Lanes, und zwei davon sind derzeit von Jobs anderer Benutzer belegt. Ihr Batch von sechs Jobs ist als nächstes an der Reihe.

Da drei Lanes verfügbar sind, startet der Scheduler drei Ihrer sechs Batch-Jobs. Er fährt fort, Jobs in Ihrem Batch zu starten, sobald Jobs beendet sind und Execution Lanes verfügbar werden. Wenn eine Lane verfügbar wird und es keine weiteren Jobs in Ihrem Batch gibt, startet der Scheduler den nächsten Job in der Warteschlange.
</details>

<details>
  <summary>
    Müssen alle meine Batch-Jobs in der Warteschlange warten?
  </summary>

Da QPUs begrenzte und gemeinsam genutzte Ressourcen sind, müssen alle Jobs in der Warteschlange warten. Wenn jedoch der erste Job in Ihrem Batch zu laufen beginnt, springen im Wesentlichen alle anderen Jobs in diesem Batch an die Spitze der Warteschlange und werden vom Scheduler priorisiert.
</details>

<details>
  <summary>
    Endet ein Batch automatisch, wenn der letzte zugehörige Job endet?
  </summary>

Ja. Es gibt jedoch einen leichten Overhead im Zusammenhang mit dieser automatischen Erkennung, daher sollten Sie Ihren Batch und Ihre Session immer schließen.
</details>

<details>
  <summary>
    Können Batches durch Kalibrierungen oder Software-Upgrades unterbrochen werden
  </summary>

Ja. Batch-Workloads können durch Kalibrierungen oder Software-Upgrades unterbrochen werden.
</details>

<details>
  <summary>
    Wird die Kompilierungszeit als Nutzung im Batch-Modus gezählt?
  </summary>

Nein. Im Batch-Modus zählt nur die auf der Quanten-Hardware verbrachte Zeit als Nutzung.
</details>
