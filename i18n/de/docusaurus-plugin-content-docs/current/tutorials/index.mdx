---
title: Tutorials
sidebar_label: Übersicht
sidebar_position: 1
description: Durchsuche die IBM Quantum Tutorials — ausführbar auf RasQberry, über Binder oder auf deinem eigenen Jupyter-Server.
---
{/* doqumentation-source-hash: e0b80945 */}

# Tutorials

Nutze diese Tutorials, um zu lernen, wie du Qiskit auf gängige Anwendungsfälle im Quantencomputing anwenden kannst.

- Beginne mit den Tutorials im Abschnitt [Erste Schritte](#erste-schritte), wenn du zum ersten Mal Code auf einem Quantencomputer ausführst.
- Der Abschnitt über [Workflows in Richtung Vorteil](#workflows-in-richtung-vorteil-erkunden) enthält durchgängige Beispiele für die Verwendung eines Quantencomputers zur Lösung realer Probleme. Diese Tutorials konzentrieren sich auf Algorithmen, die vielversprechende Kandidaten dafür sind, einen rechnerischen Vorteil eines Quantencomputers gegenüber einem klassischen Computer zu erreichen.
- Der Abschnitt über [Qiskit-Funktionalitäten](#qiskit-funktionalitäten-nutzen) enthält Beispiele, die die neuesten und fortschrittlichsten Techniken im Qiskit-Ökosystem verwenden, um einen Teil oder den gesamten Ablauf eines bestimmten Workflows zu verbessern.

## Erste Schritte {#get-started}

Diese Tutorials richten sich an Anfänger, die bereit sind, die Ausführung von Quantenalgorithmen auf einem Quantencomputer zu erkunden.

* [CHSH-Ungleichung](/tutorials/chsh-inequality)

## Workflows in Richtung Vorteil erkunden {#explore-workflows-toward-advantage}

Die Tutorials in diesem Abschnitt behandeln groß angelegte Demonstrationen von Quantenalgorithmen.

<details>
  <summary>**Verifizierbare Sampling-Algorithmen**</summary>

Die Algorithmen in dieser Kategorie konzentrieren sich auf Quantenschaltungen, deren Ausgabeverteilungen Lösungen für strukturierte Probleme mit verifizierbarer Ausgabe codieren. Verifizierbarkeit bedeutet, dass du die Konsistenz zwischen gemessenen Daten überprüfen kannst, entweder durch Auswertung der gewählten Bitfolge oder durch das Wissen, dass keine Falsch-Positiven auftreten.

Die Tutorials heben Techniken hervor, bei denen wiederholtes Sampling die Schätzung problemspezifischer Größen ermöglicht (zum Beispiel Kostenfunktionswerte oder spektrale Gewichte). Diese Methoden sind besonders relevant für Optimierungs- und Simulationsaufgaben mit Symmetrien.

* [Sample-basierte Quantendiagonalisierung eines Chemie-Hamiltonians](/tutorials/sample-based-quantum-diagonalization)

* [Sample-basierte Krylov-Quantendiagonalisierung eines fermionischen Gittermodells](/tutorials/sample-based-krylov-quantum-diagonalization)

* [Quantum Approximate Optimization Algorithm](/tutorials/quantum-approximate-optimization-algorithm)

* [Fortgeschrittene Techniken für QAOA](/tutorials/advanced-techniques-for-qaoa)

* [Pauli-Korrelationscodierung zur Reduzierung von Maxcut-Anforderungen](/tutorials/pauli-correlation-encoding-for-qaoa)

</details>

<details>
  <summary>**Schätzung von Observablen**</summary>

Diese Tutorials konzentrieren sich auf die Schätzung physikalisch bedeutsamer Größen, wie Energie oder Korrelationswerte, durch Vorbereitung von Quantenzuständen und Messung von Observablen. Zu den Techniken gehören sowohl variationelle als auch Trotterisierte Schaltungsansätze, die die Ausdrucksstärke der Schaltung mit der Effizienz der Schaltungstiefe in Einklang bringen. Der Schwerpunkt liegt auf Workflows, die die Anforderungen an Quantenressourcen reduzieren und gleichzeitig die Genauigkeit beibehalten, und die praktische Schätzung von Observablen in chemischen und physikalischen Systemen ermöglichen.

* [Krylov-Quantendiagonalisierung von Gitter-Hamiltonians](/tutorials/krylov-quantum-diagonalization)

* [Nishimori-Phasenübergang](/tutorials/nishimori-phase-transition)

* [Grundzustandsenergieschätzung der Heisenberg-Kette mit VQE](/tutorials/spin-chain-vqe)

* [Quantum Kernel Training](/tutorials/quantum-kernel-training)

* [Verbesserung der Merkmalsklassifizierung mit projizierten Quantenkernels](/tutorials/projected-quantum-kernels)

* [CHSH-Ungleichung](/tutorials/chsh-inequality)

</details>

<details>
  <summary>**Fehlertolerante Algorithmen**</summary>

Dieser Abschnitt enthält Algorithmen mit klar definierten theoretischen Garantien, die für die Ausführung auf zukünftiger fehlerkorrigierter Quantenhardware entwickelt wurden. Die Schaltungen oder der Sampling-Overhead für diese Algorithmen skalieren in einer Weise, die nicht tiefeneffizient ist, und demonstrieren daher eher einen Quantenvorteil, wenn fehlertolerante Quantencomputer existieren. Diese Tutorials veranschaulichen, wie die Methoden in idealisierten Umgebungen funktionieren, und demonstrieren Beispiele im kleinen Maßstab.

* [Shors Algorithmus](/tutorials/shors-algorithm)
* [Grovers Algorithmus](/tutorials/grovers-algorithm)

</details>

## Qiskit-Funktionalitäten nutzen {#leverage-qiskit-capabilities}

Dieser Abschnitt stellt fortgeschrittene Funktionalitäten im Qiskit-Ökosystem vor, die Leistung, Zuverlässigkeit und Geschwindigkeit bei der Ausführung von Quantenalgorithmen verbessern.

<details>
  <summary>**Workload-Optimierung**</summary>

Die Workload-Optimierung konzentriert sich entweder auf die effiziente Orchestrierung klassischer und Quantenressourcen oder auf maßgeschneiderte Methoden zur Verbesserung der Manipulation von Quantenschaltungen.

* [Benchmark für dynamische Schaltungen mit geschnittenen Bell-Paaren](/tutorials/edc-cut-bell-pair-benchmarking)

* [Einführung in Fractional Gates](/tutorials/fractional-gates)

* [Einführung in den Qiskit AI-gestützten Transpiler-Service](/tutorials/ai-transpiler-introduction)

* [Transpilationsoptimierungen mit SABRE](/tutorials/transpilation-optimizations-with-sabre)

* [Kompilierungsmethoden für Hamiltonian-Simulationsschaltungen](/tutorials/compilation-methods-for-hamiltonian-simulation-circuits)

* [Weitreichende Verschränkung mit dynamischen Schaltungen](/tutorials/long-range-entanglement)

* [Simulation des Kicked-Ising-Hamiltonians mit dynamischen Schaltungen](/tutorials/dc-hex-ising)

</details>

<details>
<summary>**Qiskit Functions**</summary>

Qiskit Functions sind eine Sammlung vorgefertigter Fehlerverwaltungs- und Anwendungswerkzeuge, die es einfach machen, groß angelegte Experimente mit Schaltungen, Molekülen, QUBOs und mehr zu entwerfen.

- Entwirf neue Algorithmen mit **Circuit Functions** -- mit vorgefertigten Pipelines für Transpilation, Fehlerunterdrückung und Fehlerminderung.

  * [Fehlerminderung mit der IBM Circuit Function](/tutorials/error-mitigation-with-qiskit-functions)

  * [Transverse-Field Ising-Modell mit Q-CTRLs Performance Management](/tutorials/transverse-field-ising-model)

  * [Quantum Phase Estimation mit Q-CTRLs Qiskit Functions](/tutorials/quantum-phase-estimation-qctrl)

  * [Simulation des 2D-Tilted-Field-Ising mit der QESEM-Funktion](/tutorials/qedma-2d-ising-with-qesem)

- Experimentiere mit domänenspezifischen Problemen mit **Application Functions** -- mit vertrauten Ein- und Ausgaben für klassische Solver.

  * [Quantum Portfolio Optimizer - Eine Qiskit Function von Global Data Quantum](/tutorials/global-data-quantum-optimizer)

  * [Binäre Optimierung höherer Ordnung mit Q-CTRLs Optimization Solver](/tutorials/solve-higher-order-binary-optimization-problems-with-q-ctrls-optimization-solver)

  * [Modellierung einer strömenden nicht-viskosen Flüssigkeit mit QUICK-PDE](/tutorials/colibritd-pde)

  * [Dissoziations-PES-Kurven mit Qunova HiVQE](/tutorials/qunova-hivqe)

  * [Hybride quantengestützte Ensemble-Klassifikation (Grid-Stabilitäts-Workflow)](/tutorials/sml-classification)

  * [Lösung des Market-Split-Problems mit Kipu Quantums Iskay Quantum Optimizer](/tutorials/solve-market-split-problem-with-iskay-quantum-optimizer)

</details>

<details>
  <summary>**Qiskit Addons**</summary>

Addons ermöglichen fortgeschrittene Schaltungsmanipulation, wie das Schneiden, Rückpropagieren von Observablen oder Approximieren von Schaltungen, die es dir ermöglichen, Hardwarebeschränkungen zu umgehen, auf Kosten erhöhten klassischen Rechenaufwands.

* [Multi-Produkt-Formeln zur Reduzierung des Trotter-Fehlers](/tutorials/multi-product-formula)

* [Approximative Quantenkompilierung für Zeitentwicklungsschaltungen](/tutorials/approximate-quantum-compilation-for-time-evolution)

* [Operator-Backpropagation (OBP) zur Schätzung von Erwartungswerten](/tutorials/operator-back-propagation)

* [Wire-Cutting zur Schätzung von Erwartungswerten](/tutorials/wire-cutting)

* [Circuit-Cutting für periodische Randbedingungen](/tutorials/periodic-boundary-conditions-with-circuit-cutting)

* [Circuit-Cutting zur Tiefenreduktion](/tutorials/depth-reduction-with-circuit-cutting)

* [Readout-Fehlerminderung für das Sampler-Primitive mit M3](/tutorials/readout-error-mitigation-sampler)

</details>

<details>
  <summary>**Fehlerminderung**</summary>

Fehlerminderung adressiert die Herausforderung von Rauschen ohne vollständige Fehlertoleranz, indem genaue Erwartungswerte durch kontrollierte Schaltungsmanipulation und Nachbearbeitung wiederhergestellt werden.

* [Utility-Scale-Fehlerminderung mit probabilistischer Fehlerverstärkung](/tutorials/probabilistic-error-amplification)

* [Kombination von Fehlerminderungsoptionen mit dem Estimator-Primitive](/tutorials/combine-error-mitigation-techniques)

* [Echtzeit-Benchmarking zur Qubit-Auswahl](/tutorials/real-time-benchmarking-for-qubit-selection)

</details>

<details>
  <summary>**Fehlererkennung**</summary>

Fehlererkennung identifiziert fehlerhafte Operationen, um durch Nachbearbeitung rauschfreie Ergebnisse Shot-für-Shot zurückzugeben.

* [Repetition Codes](/tutorials/repetition-codes)

* [Fehlererkennung mit geringem Overhead durch Raumzeit-Codes](/tutorials/ghz-spacetime-codes)

</details>
