---
title: Tutorials
sidebar_label: Übersicht
sidebar_position: 1
description: Durchsuche d'IBM Quantum Tutorials — laufe lasse auf em RasQberry, über Binder oder auf Deim eigene Jupyter-Server.
---

# Tutorials

Nemmet Se die Tutorials, um z'lerne, wie mer Qiskit für gängige Anwendungsfäll im Quantencomputing bruche ka.

- Fange Se mit de Tutorials im Abschnitt [Erste Schritte](#erste-schritte) o, wenn Se zum erschte Mal Code auf emm Quantencomputer ausführe.
- Dr Abschnitt über [Workflows in Richtung Vorteil](#workflows-in-richtung-vorteil-erkunden) enthält durchgängige Beispiel, wie mer nen Quantencomputer zum Löse von echte Problemen brucht. Die Tutorials konzentriere sich auf Algorithmen, wo vielversprechende Kandidate send, um nen rechnerische Vorteil vom Quantencomputer gegenüber emm klassische Computer z'erreiche.
- Dr Abschnitt über [Qiskit-Funktionalitäten](#qiskit-funktionalitäten-nutzen) enthält Beispiel, wo d'neueschte und fortschrittlichschte Technike im Qiskit-Ökosystem bruche, um an Teil oder de ganze Ablauf von eme bestimmte Workflow z'verbessere.

## Erste Schritte

Die Tutorials send für Anfänger gmacht, wo bereit send, d'Ausführung von Quantenalgorithmen auf emm Quantencomputer z'erkunde.

* [CHSH-Ungleichung](/tutorials/chsh-inequality)

## Workflows in Richtung Vorteil erkunden

D'Tutorials in dem Abschnitt behandle groß angelegte Demonstratione von Quantenalgorithmen.

<details>
  <summary>**Verifizierbare Sampling-Algorithmen**</summary>

D'Algorithmen in dere Kategorie konzentriere sich auf Quantenschaltkreis, wo ihre Ausgabeverteilunge Lösunge für strukturierte Probleme mit verifizierbarar Ausgab verschlüssele. Verifizierbarkeit bedeutet, dass Se d'Konsistenz zwischa de gmessene Date überprüfe könnet, entweder durch d'Auswertung von dor gwählte Bitfolg oder durch s'Wisse, dass koi Falsch-Positive vorkemmet.

D'Tutorials hebe Technike hervor, wo wiederholtes Sampling d'Schätzung von problemspezifische Größe ermöglicht (zum Beispiel Kostenfunktionswert oder spektrale Gewicht). Die Methode send besonders wichtig für Optimierungs- und Simulationsaufgabe mit Symmetrie.

* [Sample-basierte Quantendiagonalisierung eines Chemie-Hamiltonians](/tutorials/sample-based-quantum-diagonalization)

* [Sample-basierte Krylov-Quantendiagonalisierung eines fermionischen Gittermodells](/tutorials/sample-based-krylov-quantum-diagonalization)

* [Quantum Approximate Optimization Algorithm](/tutorials/quantum-approximate-optimization-algorithm)

* [Fortgeschrittene Technike für QAOA](/tutorials/advanced-techniques-for-qaoa)

* [Pauli-Korrelationscodierung zur Reduzierung von Maxcut-Anforderungen](/tutorials/pauli-correlation-encoding-for-qaoa)

</details>

<details>
  <summary>**Schätzung von Observablen**</summary>

Die Tutorials konzentriere sich auf d'Schätzung von physikalisch bedeutsame Größe, wie Energie oder Korrelationswert, durch d'Vorbereitung von Quantenzuständ und d'Messung von Observablen. Zu de Technike ghöret sowohl variationelle als au Trotterisierte Schaltkreisansätz, wo d'Ausdrucksstärk vom Schaltkreis mit dor Effizienz von dor Schaltkreistiefe in Einklang bringet. Dr Schwerpunkt liegt auf Workflows, wo d'Anforderunge an Quantenressourcen verringeret und gleichzeitig d'Genauigkeit behaltet, und wo d'praktische Schätzung von Observablen in chemische und physikalische Systeme ermögliche.

* [Krylov-Quantendiagonalisierung von Gitter-Hamiltonians](/tutorials/krylov-quantum-diagonalization)

* [Nishimori-Phasenübergang](/tutorials/nishimori-phase-transition)

* [Grundzustandsenergieschätzung dor Heisenberg-Kette mit VQE](/tutorials/spin-chain-vqe)

* [Quantum Kernel Training](/tutorials/quantum-kernel-training)

* [Verbesserung dor Merkmalsklassifizierung mit projizierde Quantenkernels](/tutorials/projected-quantum-kernels)

* [CHSH-Ungleichung](/tutorials/chsh-inequality)

</details>

<details>
  <summary>**Fehlertolerante Algorithmen**</summary>

Dor Abschnitt enthält Algorithmen mit klar definierte theoretische Garantie, wo für d'Ausführung auf zukünftiger fehlerkorrigierter Quantenhardware entwickelt worre send. D'Schaltkreis oder dor Sampling-Overhead für die Algorithmen skaliere so, dass se net tiefeneffizient send, und demonstriere daher eher nen Quantenvorteil, wenn fehlertolerante Quantencomputer existiere. Die Tutorials zeige, wie d'Methode in idealisierte Umgebunge funktioniere, und demonstriere Beispiel im kleina Maßstab.

* [Shors Algorithmus](/tutorials/shors-algorithm)
* [Grovers Algorithmus](/tutorials/grovers-algorithm)

</details>

## Qiskit-Funktionalitäten nutzen

Dor Abschnitt stellt fortgeschrittene Funktionalitäte im Qiskit-Ökosystem vor, wo d'Leistung, Zuverlässigkeit und Geschwindigkeit bei dor Ausführung von Quantenalgorithmen verbesseret.

<details>
  <summary>**Workload-Optimierung**</summary>

D'Workload-Optimierung konzentriert sich entweder auf d'effiziente Orchestrierung von klassische und Quantenressourcen oder auf maßgschneiderte Methode zur Verbesserung von dor Manipulation von Quantenschaltkreis.

* [Benchmark für dynamische Schaltkreis mit gschnittene Bell-Paare](/tutorials/edc-cut-bell-pair-benchmarking)

* [Einführung in Fractional Gates](/tutorials/fractional-gates)

* [Einführung in de Qiskit AI-gstützde Transpiler-Service](/tutorials/ai-transpiler-introduction)

* [Transpilationsoptimierunge mit SABRE](/tutorials/transpilation-optimizations-with-sabre)

* [Kompilierungsmethode für Hamiltonian-Simulationsschaltkreis](/tutorials/compilation-methods-for-hamiltonian-simulation-circuits)

* [Weitreichende Verschränkung mit dynamische Schaltkreis](/tutorials/long-range-entanglement)

* [Simulation vom Kicked-Ising-Hamiltonian mit dynamische Schaltkreis](/tutorials/dc-hex-ising)

</details>

<details>
<summary>**Qiskit Functions**</summary>

Qiskit Functions send a Sammlung von vorgefertigte Fehlerverwaltungs- und Anwendungswerkzeugla, wo s'einfach machet, groß angelegte Experimente mit Schaltkreis, Moleküle, QUBOs und mehr z'entwerfe.

- Entwerfe Se neue Algorithmen mit **Circuit Functions** -- mit vorgefertigte Pipelines für Transpilation, Fehlerunterdrückung und Fehlerminderung.

  * [Fehlerminderung mit dor IBM Circuit Function](/tutorials/error-mitigation-with-qiskit-functions)

  * [Transverse-Field Ising-Modell mit Q-CTRLs Performance Management](/tutorials/transverse-field-ising-model)

  * [Quantum Phase Estimation mit Q-CTRLs Qiskit Functions](/tutorials/quantum-phase-estimation-qctrl)

  * [Simulation vom 2D-Tilted-Field-Ising mit dor QESEM-Funktion](/tutorials/qedma-2d-ising-with-qesem)

- Experimentiere Se mit domänenspezifische Probleme mit **Application Functions** -- mit vertraute Ein- und Ausgabe für klassische Solver.

  * [Quantum Portfolio Optimizer - A Qiskit Function von Global Data Quantum](/tutorials/global-data-quantum-optimizer)

  * [Binäre Optimierung höherer Ordnung mit Q-CTRLs Optimization Solver](/tutorials/solve-higher-order-binary-optimization-problems-with-q-ctrls-optimization-solver)

  * [Modellierung von nera strömende net-viskose Flüssigkeit mit QUICK-PDE](/tutorials/colibritd-pde)

  * [Dissoziations-PES-Kurve mit Qunova HiVQE](/tutorials/qunova-hivqe)

  * [Hybride quantengstützte Ensemble-Klassifikation (Grid-Stabilitäts-Workflow)](/tutorials/sml-classification)

  * [Lösung vom Market-Split-Problem mit Kipu Quantums Iskay Quantum Optimizer](/tutorials/solve-market-split-problem-with-iskay-quantum-optimizer)

</details>

<details>
  <summary>**Qiskit Addons**</summary>

Addons ermögliche fortgeschrittene Schaltkreismanipulation, wie s'Schneiden, s'Rückpropagiere von Observablen oder s'Approximiere von Schaltkreis, wo's de Benutzer ermögliche, Hardwarebeschränkunge z'umgehe, auf Koschte von mehr klassischem Rechenaufwand.

* [Multi-Produkt-Formele zur Reduzierung vom Trotter-Fehler](/tutorials/multi-product-formula)

* [Approximative Quantenkompilierung für Zeitentwicklungsschaltkreis](/tutorials/approximate-quantum-compilation-for-time-evolution)

* [Operator-Backpropagation (OBP) zur Schätzung von Erwartungswert](/tutorials/operator-back-propagation)

* [Wire-Cutting zur Schätzung von Erwartungswert](/tutorials/wire-cutting)

* [Circuit-Cutting für periodische Randbedingunge](/tutorials/periodic-boundary-conditions-with-circuit-cutting)

* [Circuit-Cutting zur Tiefenreduktion](/tutorials/depth-reduction-with-circuit-cutting)

* [Readout-Fehlerminderung für s'Sampler-Primitive mit M3](/tutorials/readout-error-mitigation-sampler)

</details>

<details>
  <summary>**Fehlerminderung**</summary>

Fehlerminderung adressiert d'Herausforderung von Rausche ohne vollständige Fehlertoleranz, indem genaue Erwartungswert durch kontrollierte Schaltkreismanipulation und Nachbearbeitung wiederhergestellt werre.

* [Utility-Scale-Fehlerminderung mit probabilistischer Fehlerverstärkung](/tutorials/probabilistic-error-amplification)

* [Kombinierung von Fehlerminderungsoptione mit em Estimator-Primitive](/tutorials/combine-error-mitigation-techniques)

* [Echtzeit-Benchmarking zur Qubit-Auswahl](/tutorials/real-time-benchmarking-for-qubit-selection)

</details>

<details>
  <summary>**Fehlererkennung**</summary>

Fehlererkennung identifiziert fehlerhafte Operatione, um durch Nachbearbeitung rauschfreie Ergebnis Shot-für-Shot zurückzuliefere.

* [Repetition Codes](/tutorials/repetition-codes)

* [Fehlererkennung mit wenig Overhead durch Raumzeit-Codes](/tutorials/ghz-spacetime-codes)

</details>
