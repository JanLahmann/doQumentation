---
title: "Kompilierugsmethoda für Hamilton-Simulationsschaltuga"
sidebar_label: "Kompilierugsmethoda für Hamilton-Simulationsschaltuga"
description: "Des Tutorial gibt an vergleichendr Überblick über drei Kompilierugsmethoda in Qiskit für Hamilton-Simulations-Workloads."
notebook_path: "docs/tutorials/compilation-methods-for-hamiltonian-simulation-circuits.ipynb"
---
{/* doqumentation-source-hash: ff66bde1 */}

<OpenInLabBanner notebookPath="docs/tutorials/compilation-methods-for-hamiltonian-simulation-circuits.ipynb" />



Gschätzte QPU-Nutzung: koi Ausführung isch in dem Tutorial gmacht worda, weil's sich auf dr Transpilationsprozess konzentriert.

{/* cspell:ignore Rustiq, nshuffles, edgecolors, edgecolor, Hamlib, Benchpress, Brugière, Goubault, Martiel, Dubal, Lishman, Ivrii, fontweight, fontsize, textprops, wedgeprops, startangle, autopct */}
## Hintergrund {#hintergrund}

D Quanteschaltugskompilierung isch a entscheidender Schritt im Quantencomputing-Workflow. Se umfasst d Transformation vomme hochrangiga Quantenalgorithmus in a physische Quanteschaltung, die de Einschränkuga vun dr Ziel-Quantehardware entspricht. Effektive Kompilierung ka d Leischtig vun Quantenalgorithme erheblich beeinfluga, indem se Schaltugsdief, Gate-Anzahl und Ausführugszeit reduziert. Des Tutorial untersuacht drei unterschiedliche Ansätz zur Quanteschaltugskompilierung in Qiskit und zeigt ihre Stärka und Anwenduga durch praktische Beispiele auf.

S Ziel vun dem Tutorial isch es, de Benutzer beizubringa, wie se drei Kompilierugsmethoda in Qiskit anwenda und bewerda: dr SABRE-Transpiler, dr AI-gstützte Transpiler und s Rustiq-Plugin. D Benutzer werdet lerna, wie se jede Methode effektiv eisezt und wie se d Leischtig über verschiedene Quanteschaltuga hinweg benchmarked. Am End vun dem Tutorial werdet d Benutzer in dr Lage sei, Kompilierugsstrategie basierend auf spezifische Optimierungszieler – wie d Reduzirug vun dr Schaltugsdief, d Minimierung vun dr Gate-Anzahl oder d Verbesserung vun dr Laufzeit – z wähla und azupasse.

### Was mr lerna werdet {#was-mr-lerna-werdet}
- **Wie mr dr Qiskit-Transpiler mit SABRE für Layout- und Routing-Optimierung vrwendet.**
- **Wie mr dr AI-Transpiler für fortgschrittene, automatisierte Schaltugoptimierung nutzt.**
- **Wie mr s Rustiq-Plugin für Schaltuga eisezt, die a präzise Synthese vun Operationa erfordered, insbesondere bei Hamilton-Simulationsaufgabe.**

Des Tutorial vrwendet drei Beispielschaltuga nach em [Qiskit Patterns](/guides/intro-to-patterns)-Workflow, um d Leischtig vun jedere Kompilierugsmethode z veranschaliche. Am End vun dem Tutorial werdet d Benutzer in dr Lage sei, d geignete Kompilierugsstrategie basierend auf ihre spezifische Anforderuga und Einschränkuga z wähla.

### Überblick über Kompilierugsmethoda {#ueberblick-ueber-kompilierugsmethoda}

#### 1. **Qiskit-Transpiler mit SABRE** {#1-qiskit-transpiler-with-sabre}
Dr Qiskit-Transpiler vrwendet dr SABRE (SWAP-based BidiREctional heuristic search)-Algorithmus zur Optimierung vun Schaltugslayout und -routing. SABRE konzentriert sich auf d Minimierung vun SWAP-Gates und derer Auswirkuga auf d Schaltugsdief, während Hardware-Konnektivitätsbeschränkuga eihalte werdet. Die Methode isch hoch vielseitig und für allgemoine Schaltugoptimierung geignet und bietet a Gleichgewicht zwischa Leischtig und Rechezeit. Um d neuschte Verbesseruga in SABRE z nutza, die in [\[1\]](https://arxiv.org/abs/2409.08368) detailliert beschrieba sind, ka mr d Anzahl vun de Versuach erhöha (zum Beispiel `layout_trials=400, swap_trials=400`). Für d Zweck vun dem Tutorial vrwendet mr d Standardwert für d Anzahl vun de Versuach, um mit em Standard-Transpiler vun Qiskit z vergleicha. D Vorteile und Parameter-Exploration vun SABRE werdet in amme separata [Deep-Dive-Tutorial](/tutorials/transpilation-optimizations-with-sabre) behandelt.

#### 2. **AI-Transpiler**

Dr AI-gstützte Transpiler in Qiskit vrwendet maschinelles Lernen, um optimale Transpilationsstrategie vorherzusaga, indem er Muster in dr Schaltugstruktur und Hardware-Einschränkuga analysiert, um d beste Sequenz vun Optimieruga für a gegebene Eingabe auszuwähla. Die Methode isch besonders effektiv für groß agelegte Quanteschaltuga und bietet a hohes Maß an Automatisierung und Agpassugsfähigkeit an diverse Problemtypa. Zusätzlich zur allgemoine Schaltugoptimierung ka dr AI-Transpiler mit em `AIPauliNetworkSynthesis`-Pass vrwendet werra, dr Pauli-Netzwerkschaltuga – Blöck, die aus H-, S-, SX-, CX-, RX-, RY- und RZ-Gates bestehet – anvisiert und an auf Reinforcement Learning basierenda Syntheseansatz anwendet. Weitere Informationa zum AI-Transpiler und seine Synthese-Strategie findet mr in [\[2\]](https://arxiv.org/abs/2405.13196) und [\[3\]](https://arxiv.org/abs/2503.14448).

#### 3. **Rustiq-Plugin**
S Rustiq-Plugin führt fortgschrittene Synthesetechnike speziell für `PauliEvolutionGate`-Operationa ei, die Pauli-Rotatiône repräsentiert, die häufig in trotterisierter Dynamik vrwendet werdet. Des Plugin isch wertvoll für Schaltuga, die Hamilton-Simulation implementiert, wie se in Quantenchemie- und Physikprobleme vrwendet werdet, bei dena genaue Pauli-Rotatiône für d effektive Simulation vun Problem-Hamiltonians wesentlich sind. Rustiq bietet präzise, niedrig-tife Schaltugssynthese für diese spezialisierta Operationa. Weitere Details zur Implementierung und Leischtig vun Rustiq findet mr in [\[4\]](https://arxiv.org/abs/2404.03280).

Durch d eingehende Untersuchung vun dena Kompilierugsmethoda bietet des Tutorial de Benutzern d Werkzeug, um d Leischtig vun ihre Quanteschaltuga z verbessera und dr Weg für effizientere und praktischere Quanteberechnuga z ebna.

## Anforderuga {#anforderuga}

Stellt vor em Beginn vun dem Tutorial sicher, dass folgendes installiert isch:
- Qiskit SDK v1.3 oder höher, mit Unterstützug für [Visualisierung](https://docs.quantum.ibm.com/api/qiskit/visualization)
- Qiskit Runtime v0.28 oder höher (`pip install qiskit-ibm-runtime`)
- Qiskit IBM Transpiler (`pip install qiskit-ibm-transpiler`)
- Qiskit AI Transpiler Lokalmodus (`pip install qiskit_ibm_ai_local_transpiler`)
- Networkx-Graphabibliothek (`pip install networkx`)

## Setup {#setup}

```python
# Added by doQumentation — installs packages not in the Binder environment
%pip install -q qiskit-ibm-transpiler
```

```python
from qiskit.circuit import QuantumCircuit
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit.circuit.library import (
    efficient_su2,
    PauliEvolutionGate,
)
from qiskit_ibm_transpiler import generate_ai_pass_manager
from qiskit.quantum_info import SparsePauliOp
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit.transpiler.passes.synthesis.high_level_synthesis import HLSConfig
from collections import Counter
from IPython.display import display
import time
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import json
import requests
import logging

# Suppress noisy loggers
logging.getLogger(
    "qiskit_ibm_transpiler.wrappers.ai_local_synthesis"
).setLevel(logging.ERROR)

seed = 42  # Seed for reproducibility
```

## Teil 1: Efficient SU2-Schaltung {#teil-1-efficient-su2-schaltung}

### Schritt 1: Klassische Eingabe auf as Quantenproblem abbildet {#schritt-1-klassische-eingaben-auf-ein-quantenproblem-abbilden}

In dem Abschnitt untersuacht mir d `efficient_su2`-Schaltung, an hardwareeffizienten Ansatz, dr häufig in variationelle Quantenalgorithme (wie VQE) und Quantum-Machine-Learning-Aufgabe vrwendet wird. D Schaltung besteht aus wechselnde Schichte vun Ein-Qubit-Rotatiône und verschränkende Gates, die in amme kreisförmige Muster aagordnet sind und dazu konzipiert sind, dr Quantezustandsraum effektiv z erkunda, während a überschaubare Dief beibehalte wird.

Mir fanget mit dr Konstruktion vunere `efficient_su2`-Schaltung a, um z demonstriera, wie verschiedene Kompilierugsmethoda verglicha werdet. Nach Teil 1 werdet mir onsere Analyse auf an größera Satz vun Schaltuga erweitera, um an umfassenden Benchmark zur Bewertig vun dr Leischtig verschiedener Kompilierugstechnike z ermögliche.

```python
qubit_size = list(range(10, 101, 10))
qc_su2_list = [
    efficient_su2(n, entanglement="circular", reps=1)
    .decompose()
    .copy(name=f"SU2_{n}")
    for n in qubit_size
]

# Draw the first circuit
qc_su2_list[0].draw(output="mpl")
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/f362cdac-94d8-4cc5-85f4-015c3d9eba3a-0.avif)

### Schritt 2: Problem für d Ausführung auf Quantehardware optimiera {#schritt-2-problem-fuer-die-ausfuehrung-auf-quantenhardware-optimieren}

Der Schritt isch dr Hauptfokus vun em Tutorial. Do wellet mir Quanteschaltuga für d effiziente Ausführung auf echter Quantehardware optimiera. Onsers primäres Ziel isch es, Schaltugsdief und Gate-Anzahl z reduzierd, die Schlüsselfaktora zur Verbesserung vun dr Ausführugstreue und zur Minderung vun Hardware-Rauscha sind.

- **SABRE-Transpiler**: Vrwendet dr Standard-Transpiler vun Qiskit mit em SABRE-Layout- und Routing-Algorithmus.
- **AI-Transpiler (Lokalmodus)**: Dr Standard-AI-gstützte Transpiler mit lokaler Inferenz und dr Standard-Synthesestrategie.
- **Rustiq-Plugin**: A Transpiler-Plugin für niedrig-tife Kompilierung, des auf Hamilton-Simulationsaufgabe zuegschnitten isch.

S Ziel vun dem Schritt isch es, d Ergebnis vun dena Methoda hinsichtlich Dief und Gate-Anzahl vun dr transpilierten Schaltung z vergleicha. A weitere wichtige Metrik, die mir berücksichtiget, isch d Transpilationslaufzeit. Durch d Analyse vun dena Metrika kenne mir d relativen Stärka vun jedere Methode bewerda und bestimma, welche d effizienteste Schaltung für d Ausführung auf dr ausgwählte Hardware produziert.

Hinweis: Für s anfängliche SU2-Schaltugsbeschpiel werdet mir nur dr SABRE-Transpiler mit em Standard-AI-Transpiler vergleicha. Im anschließende Benchmark mit Hamlib-Schaltuga werdet mir jedoch alle drei Transpilationsmethoda vergleicha.

```python
# QiskitRuntimeService.save_account(channel="ibm_quantum_platform", token="<YOUR-API-KEY>", overwrite=True, set_as_default=True)
service = QiskitRuntimeService(channel="ibm_quantum_platform")
backend = service.backend("ibm_torino")
print(f"Using backend: {backend}")
```

```text
qiskit_runtime_service._get_crn_from_instance_name:WARNING:2025-07-30 21:46:30,843: Multiple instances found. Using all matching instances.
```

```text
Using backend: <IBMBackend('ibm_torino')>
```

Qiskit-Transpiler mit SABRE:

```python
pm_sabre = generate_preset_pass_manager(
    optimization_level=3, backend=backend, seed_transpiler=seed
)
```

AI-Transpiler:

```python
# Standard AI transpiler pass manager, using the local mode
pm_ai = generate_ai_pass_manager(
    backend=backend, optimization_level=3, ai_optimization_level=3
)
```

Rustiq-Plugin:

```python
hls_config = HLSConfig(
    PauliEvolution=[
        (
            "rustiq",
            {
                "nshuffles": 400,
                "upto_phase": True,
                "fix_clifford": True,
                "preserve_order": False,
                "metric": "depth",
            },
        )
    ]
)
pm_rustiq = generate_preset_pass_manager(
    optimization_level=3,
    backend=backend,
    hls_config=hls_config,
    seed_transpiler=seed,
)
```

#### Transpiliera und Metrika erfassa {#transpilieren-und-metriken-erfassen}

Um d Leischtig vun de Kompilierugsmethoda z vergleicha, definiert mir a Funktion, die d Eigabeschaltung transpiliert und relevante Metrika auf konsistente Weis erfasst. Des umfasst d Gsamtschaltugsdief, d Gsamt-Gate-Anzahl und d Transpilationszeit.

Zusätzlich zu dena Standardmetrika zeichnet mir au d 2-Qubit-Gate-Dief auf, die a besonders wichtige Metrik zur Bewertig vun dr Ausführung auf Quantehardware isch. Im Gegasatz zur Gsamtdief, die alle Gates einschließt, spiegelt d 2-Qubit-Dief d tatsächliche Ausführugsdauer vun dr Schaltung auf Hardware genauer wider. Des liegt dra, dass 2-Qubit-Gates typischerweise s Zeit- und Fehlerbudget in de meischte Quantegeräte dominiert. Daher isch d Minimierung vun dr 2-Qubit-Dief entscheidend für d Verbesserung vun dr Fidelität und d Reduzirug vun Dekohärenzeffekte während dr Ausführung.

Mir werdet dene Funktion vrwenda, um d Leischtig vun de verschiedene Kompilierugsmethoda über mehrere Schaltuga hinweg z analysiera.

```python
def capture_transpilation_metrics(
    results, pass_manager, circuits, method_name
):
    """
    Capture transpilation metrics for a list of circuits and stores the results in a DataFrame.

    Args:
        results (pd.DataFrame): DataFrame to store the results.
        pass_manager: Pass manager used for transpilation.
        circuits (list): List of quantum circuits to transpile.
        method_name (str): Name of the transpilation method.

    Returns:
        list: List of transpiled circuits.
    """
    transpiled_circuits = []

    for i, qc in enumerate(circuits):
        # Transpile the circuit
        start_time = time.time()
        transpiled_qc = pass_manager.run(qc)
        end_time = time.time()

        # Needed for AI transpiler to be consistent with other methods
        transpiled_qc = transpiled_qc.decompose(gates_to_decompose=["swap"])

        # Collect metrics
        transpilation_time = end_time - start_time
        circuit_depth = transpiled_qc.depth(
            lambda x: x.operation.num_qubits == 2
        )
        circuit_size = transpiled_qc.size()

        # Append results to DataFrame
        results.loc[len(results)] = {
            "method": method_name,
            "qc_name": qc.name,
            "qc_index": i,
            "num_qubits": qc.num_qubits,
            "ops": transpiled_qc.count_ops(),
            "depth": circuit_depth,
            "size": circuit_size,
            "runtime": transpilation_time,
        }
        transpiled_circuits.append(transpiled_qc)
        print(
            f"Transpiled circuit index {i} ({qc.name}) in {transpilation_time:.2f} seconds with method {method_name}, "
            f"depth {circuit_depth}, and size {circuit_size}."
        )

    return transpiled_circuits
```

```python
results_su2 = pd.DataFrame(
    columns=[
        "method",
        "qc_name",
        "qc_index",
        "num_qubits",
        "ops",
        "depth",
        "size",
        "runtime",
    ]
)

tqc_sabre = capture_transpilation_metrics(
    results_su2, pm_sabre, qc_su2_list, "sabre"
)
tqc_ai = capture_transpilation_metrics(results_su2, pm_ai, qc_su2_list, "ai")
```

```text
Transpiled circuit index 0 (SU2_10) in 0.06 seconds with method sabre, depth 13, and size 167.
Transpiled circuit index 1 (SU2_20) in 0.24 seconds with method sabre, depth 20, and size 299.
Transpiled circuit index 2 (SU2_30) in 10.72 seconds with method sabre, depth 72, and size 627.
Transpiled circuit index 3 (SU2_40) in 16.16 seconds with method sabre, depth 40, and size 599.
Transpiled circuit index 4 (SU2_50) in 76.89 seconds with method sabre, depth 77, and size 855.
Transpiled circuit index 5 (SU2_60) in 86.12 seconds with method sabre, depth 60, and size 899.
Transpiled circuit index 6 (SU2_70) in 94.46 seconds with method sabre, depth 79, and size 1085.
Transpiled circuit index 7 (SU2_80) in 69.05 seconds with method sabre, depth 80, and size 1199.
Transpiled circuit index 8 (SU2_90) in 88.25 seconds with method sabre, depth 105, and size 1420.
Transpiled circuit index 9 (SU2_100) in 83.80 seconds with method sabre, depth 100, and size 1499.
Transpiled circuit index 0 (SU2_10) in 0.17 seconds with method ai, depth 10, and size 168.
Transpiled circuit index 1 (SU2_20) in 0.29 seconds with method ai, depth 20, and size 299.
Transpiled circuit index 2 (SU2_30) in 13.56 seconds with method ai, depth 36, and size 548.
Transpiled circuit index 3 (SU2_40) in 15.95 seconds with method ai, depth 40, and size 599.
Transpiled circuit index 4 (SU2_50) in 80.70 seconds with method ai, depth 54, and size 823.
Transpiled circuit index 5 (SU2_60) in 75.99 seconds with method ai, depth 60, and size 899.
Transpiled circuit index 6 (SU2_70) in 64.96 seconds with method ai, depth 74, and size 1087.
Transpiled circuit index 7 (SU2_80) in 68.25 seconds with method ai, depth 80, and size 1199.
Transpiled circuit index 8 (SU2_90) in 75.07 seconds with method ai, depth 90, and size 1404.
Transpiled circuit index 9 (SU2_100) in 63.97 seconds with method ai, depth 100, and size 1499.
```

Zeigt d transpilierta Ergebnis vunere vun de Schaltuga a.

```python
print("Sabre transpilation")
display(tqc_sabre[0].draw("mpl", fold=-1, idle_wires=False))
print("AI transpilation")
display(tqc_ai[0].draw("mpl", fold=-1, idle_wires=False))
```

```text
Sabre transpilation
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/37924fc2-8fb6-451a-b8f9-cd79573f2384-1.avif)

```text
AI transpilation
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/37924fc2-8fb6-451a-b8f9-cd79573f2384-3.avif)

Ergebnistabelle:

```python
summary_su2 = (
    results_su2.groupby("method")[["depth", "size", "runtime"]]
    .mean()
    .round(2)
)
print(summary_su2)

results_su2
```

```text
depth   size  runtime
method
ai       56.4  852.5    45.89
sabre    64.6  864.9    52.57
```

```text
method  qc_name  qc_index  num_qubits                                ops  \
0   sabre   SU2_10         0          10     {'rz': 81, 'sx': 70, 'cz': 16}
1   sabre   SU2_20         1          20   {'rz': 160, 'sx': 119, 'cz': 20}
2   sabre   SU2_30         2          30   {'sx': 295, 'rz': 242, 'cz': 90}
3   sabre   SU2_40         3          40   {'rz': 320, 'sx': 239, 'cz': 40}
4   sabre   SU2_50         4          50   {'rz': 402, 'sx': 367, 'cz': 86}
5   sabre   SU2_60         5          60   {'rz': 480, 'sx': 359, 'cz': 60}
6   sabre   SU2_70         6          70   {'rz': 562, 'sx': 441, 'cz': 82}
7   sabre   SU2_80         7          80   {'rz': 640, 'sx': 479, 'cz': 80}
8   sabre   SU2_90         8          90  {'rz': 721, 'sx': 585, 'cz': 114}
9   sabre  SU2_100         9         100  {'rz': 800, 'sx': 599, 'cz': 100}
10     ai   SU2_10         0          10     {'rz': 81, 'sx': 71, 'cz': 16}
11     ai   SU2_20         1          20   {'rz': 160, 'sx': 119, 'cz': 20}
12     ai   SU2_30         2          30   {'sx': 243, 'rz': 242, 'cz': 63}
13     ai   SU2_40         3          40   {'rz': 320, 'sx': 239, 'cz': 40}
14     ai   SU2_50         4          50   {'rz': 403, 'sx': 346, 'cz': 74}
15     ai   SU2_60         5          60   {'rz': 480, 'sx': 359, 'cz': 60}
16     ai   SU2_70         6          70   {'rz': 563, 'sx': 442, 'cz': 82}
17     ai   SU2_80         7          80   {'rz': 640, 'sx': 479, 'cz': 80}
18     ai   SU2_90         8          90  {'rz': 721, 'sx': 575, 'cz': 108}
19     ai  SU2_100         9         100  {'rz': 800, 'sx': 599, 'cz': 100}

    depth  size    runtime
0      13   167   0.058845
1      20   299   0.238217
2      72   627  10.723922
3      40   599  16.159262
4      77   855  76.886604
5      60   899  86.118255
6      79  1085  94.458287
7      80  1199  69.048184
8     105  1420  88.254809
9     100  1499  83.795482
10     10   168   0.171532
11     20   299   0.291691
12     36   548  13.555931
13     40   599  15.952733
14     54   823  80.702141
15     60   899  75.993404
16     74  1087  64.960162
17     80  1199  68.253280
18     90  1404  75.072412
19    100  1499  63.967446
```

#### Ergebnisgraph {#ergebnisgraph}

Weil mir a Funktion definiert hend, um Metrika konsistent z erfassa, werdet mir au oine definiera, um d Metrika grafisch darzuschtellet. Do werdet mir d Zwei-Qubit-Dief, Gate-Anzahl und Laufzeit für jede Kompilierugsmethode über d Schaltuga hinweg darschtellet.

```python
def plot_transpilation_metrics(results, overall_title, x_axis="qc_index"):
    """
    Plots transpilation metrics (depth, size, runtime) for different transpilation methods.

    Parameters:
        results (DataFrame): Data containing columns ['num_qubits', 'method', 'depth', 'size', 'runtime']
        overall_title (str): The title of the overall figure.
        x_axis (str): The x-axis label, either 'num_qubits' or 'qc_index'.
    """

    fig, axs = plt.subplots(1, 3, figsize=(24, 6))
    metrics = ["depth", "size", "runtime"]
    titles = ["Circuit Depth", "Circuit Size", "Transpilation Runtime"]
    y_labels = ["Depth", "Size (Gate Count)", "Runtime (s)"]

    methods = results["method"].unique()
    colors = plt.colormaps["tab10"]
    markers = ["o", "^", "s", "D", "P", "*", "X", "v"]
    color_list = [colors(i % colors.N) for i in range(len(methods))]
    color_map = {method: color_list[i] for i, method in enumerate(methods)}
    marker_map = {
        method: markers[i % len(markers)] for i, method in enumerate(methods)
    }
    jitter_factor = 0.1  # Small x-axis jitter for visibility
    handles, labels = [], []  # Unique handles for legend

    # Plot each metric
    for i, metric in enumerate(metrics):
        for method in methods:
            method_data = results[results["method"] == method]

            # Introduce slight jitter to avoid exact overlap
            jitter = np.random.uniform(
                -jitter_factor, jitter_factor, len(method_data)
            )

            scatter = axs[i].scatter(
                method_data[x_axis] + jitter,
                method_data[metric],
                color=color_map[method],
                label=method,
                marker=marker_map[method],
                alpha=0.7,
                edgecolors="black",
                s=80,
            )

            if method not in labels:
                handles.append(scatter)
                labels.append(method)

        axs[i].set_title(titles[i])
        axs[i].set_xlabel(x_axis)
        axs[i].set_ylabel(y_labels[i])
        axs[i].grid(axis="y", linestyle="--", alpha=0.7)
        axs[i].tick_params(axis="x", rotation=45)
        axs[i].set_xticks(sorted(results[x_axis].unique()))

    fig.suptitle(overall_title, fontsize=16)
    fig.legend(
        handles=handles,
        labels=labels,
        loc="upper right",
        bbox_to_anchor=(1.05, 1),
    )

    plt.tight_layout()
    plt.show()
```

```python
plot_transpilation_metrics(
    results_su2, "Transpilation Metrics for SU2 Circuits", x_axis="num_qubits"
)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/7f7b502a-8ed6-45fa-a698-02977149e283-0.avif)

#### Analyse vun de SU2-Schaltugskompilierugsergebnis {#analyse-der-su2-schaltungskompilierungsergebnisse}

In dem Experiment vergleichet mir zwei Transpilationsmethoda – Qiskits SABRE-Transpiler und dr AI-gstützte Transpiler – a amme Satz vun `efficient_su2`-Schaltuga. Weil dene Schaltuga koine `PauliEvolutionGate`-Operationa hend, isch s Rustiq-Plugin in dem Vergleich ned enthalte.

Im Durchschnitt schneidet dr AI-Transpiler hinsichtlich dr Schaltugsdief besser ab, mit anere Verbesserung vun mehr als 10% über d gsamt Bandbreite vun de SU2-Schaltuga hinweg. Für Gate-Anzahl (Schaltugsgröße) und Transpilationslaufzeit erzielet beide Methoda insgesamt ähnliche Ergebnis.

D Inspektion vun de einzelne Datepunkte offenbart jedoch a tiefere Einsicht:
- Für d meischte Qubit-Größa produziert sowohl SABRE als au AI nahezu identische Ergebnis, was drauf hindeutet, dass beide Methoda in viela Fälle zu ähnlich effizienta Lösuga konvergiert.
- Für bestimmte Schaltugsgröße, speziell bei 30, 50, 70 und 90 Qubits, findet dr AI-Transpiler deutlich flachere Schaltuga als SABRE. Des zeigt, dass dr lernbasierte Ansatz vun AI in dr Lage isch, optimalere Layouts oder Routing-Pfad in Fälle z entdecka, in dena d SABRE-Heuristik des ned tuet.

Des Vrhalte hebt a wichtige Erkenntnis hervor:
> Während SABRE und AI oft vergleichbare Ergebnis produziert, ka dr AI-Transpiler gelegentlich viel bessere Lösuga entdecka, insbesondere hinsichtlich dr Dief, was zu deutlich verbesserter Leischtig auf Hardware führe ka.

## Teil 2: Hamilton-Simulationsschaltung {#teil-2-hamilton-simulationsschaltung}

### Schritt 1: Untersuchung vun Schaltuga mit `PauliEvolutionGate` {#schritt-1-untersuchung-von-schaltungen-mit-paulievolutiongate}

In dem Abschnitt untersuacht mir Quanteschaltuga, die unter Vrwendung vun `PauliEvolutionGate` konstruiert worda sind, des a effiziente Simulation vun Hamiltonians ermöglicht. Mir werdet analysiera, wie verschiedene Kompilierugsmethoda dene Schaltuga über verschiedene Hamiltonians hinweg optimiert.

#### In dem Benchmark vrwendete Hamiltonians {#in-diesem-benchmark-verwendete-hamiltonians}

D in dem Benchmark vrwendete Hamiltonians beschreibet paarweise Interaktiona zwischa Qubits, einschließlich Terme wie $ZZ$, $XX$ und $YY$. Dene Hamiltonians werdet häufig in Quantenchemie, Festkörperphysik und Materialwissenschaft vrwendet, wo se Systeme vun interagierenda Teilcha modelliert.

Als Referenz kenne Benutzer an breiterere Satz vun Hamiltonians in dem Paper erkunda: [Efficient Hamiltonian Simulation on Noisy Quantum Devices](https://arxiv.org/pdf/2306.13126).

#### Benchmark-Quelle: Hamlib und Benchpress {#benchmark-quelle-hamlib-und-benchpress}

D in dem Benchmark vrwendete Schaltuga stammet aus em [Hamlib-Benchmark-Repository](https://github.com/SRI-International/QC-App-Oriented-Benchmarks/tree/master/hamlib), des realistische Hamilton-Simulations-Workloads enthält.

Dene gleiche Schaltuga sind zuvor mit [Benchpress](https://github.com/Qiskit/benchpress) benchmarked worda, amme Open-Source-Framework zur Bewertig vun dr Quanten-Transpilationsleischtig. Durch d Vrwendung vun dem standardisierta Satz vun Schaltuga kenne mir d Effektivität verschiedener Kompilierugsstrategie bei repräsentativen Simulationsproble direkt vergleicha.

Hamilton-Simulation isch a grundlegende Aufgabe im Quantencomputing mit Anwenduga in Molekülsimulatiône, Optimierungsproble und Quanten-Vielteilchenphysik. S Vrständnis, wie verschiedene Kompilierugsmethoda dene Schaltuga optimiert, ka de Benutzern helfa, d praktische Ausführung vun solche Schaltuga auf kurzfristige Quantegeräte z verbessera.

```python
# Obtain the Hamiltonian JSON from the benchpress repository
url = "https://raw.githubusercontent.com/Qiskit/benchpress/e7b29ef7be4cc0d70237b8fdc03edbd698908eff/benchpress/hamiltonian/hamlib/100_representative.json"
response = requests.get(url)
response.raise_for_status()  # Raise an error if download failed
ham_records = json.loads(response.text)
# Remove circuits that are too large for the backend
ham_records = [
    h for h in ham_records if h["ham_qubits"] <= backend.num_qubits
]
# Remove the circuits that are large to save transpilation time
ham_records = sorted(ham_records, key=lambda x: x["ham_terms"])[:35]

qc_ham_list = []
for h in ham_records:
    terms = h["ham_hamlib_hamiltonian_terms"]
    coeff = h["ham_hamlib_hamiltonian_coefficients"]
    num_qubits = h["ham_qubits"]
    name = h["ham_problem"]

    evo_gate = PauliEvolutionGate(SparsePauliOp(terms, coeff))

    qc_ham = QuantumCircuit(num_qubits)
    qc_ham.name = name

    qc_ham.append(evo_gate, range(num_qubits))
    qc_ham_list.append(qc_ham)
print(f"Number of Hamiltonian circuits: {len(qc_ham_list)}")

# Draw the first Hamiltonian circuit
qc_ham_list[0].draw("mpl", fold=-1)
```

```text
Number of Hamiltonian circuits: 35
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/66347c00-1607-4405-bb76-610690adf6b8-1.avif)

### Schritt 2: Problem für d Ausführung auf Quantehardware optimiera {#schritt-2-problem-fuer-die-ausfuehrung-auf-quantenhardware-optimieren-2}

Wie im vorherige Beispiel vrwendet mir dasselbe Backend, um Konsistenz in onsere Vergleiche sicherzuschtellet. Da d Pass-Manager (`pm_sabre`, `pm_ai` und `pm_rustiq`) bereits initialisiert worda sind, kenne mir direkt mit dr Transpilation vun de Hamilton-Schaltuga mit jedere Methode fortfahra.

Der Schritt konzentriert sich ausschließlich auf d Durchführung vun dr Transpilation und d Aufzeichnung vun de resultierenda Schaltugmetrika, einschließlich Dief, Gate-Anzahl und Transpilationslaufzeit. Durch d Analyse vun dena Ergebnis wellet mir d Effizienz vun jedere Transpilationsmethode für dena Schaltugtyp bestimma.

Transpiliera und Metrika erfassa:

```python
results_ham = pd.DataFrame(
    columns=[
        "method",
        "qc_name",
        "qc_index",
        "num_qubits",
        "ops",
        "depth",
        "size",
        "runtime",
    ]
)

tqc_sabre = capture_transpilation_metrics(
    results_ham, pm_sabre, qc_ham_list, "sabre"
)
tqc_ai = capture_transpilation_metrics(results_ham, pm_ai, qc_ham_list, "ai")
tqc_rustiq = capture_transpilation_metrics(
    results_ham, pm_rustiq, qc_ham_list, "rustiq"
)
```

```text
Transpiled circuit index 0 (all-vib-o3) in 0.02 seconds with method sabre, depth 6, and size 58.
Transpiled circuit index 1 (all-vib-c2h) in 1.10 seconds with method sabre, depth 2, and size 39.
Transpiled circuit index 2 (all-vib-bh) in 0.01 seconds with method sabre, depth 3, and size 30.
Transpiled circuit index 3 (all-vib-c2h) in 0.03 seconds with method sabre, depth 18, and size 115.
Transpiled circuit index 4 (graph-gnp_k-2) in 0.02 seconds with method sabre, depth 24, and size 129.
Transpiled circuit index 5 (all-vib-fccf) in 0.05 seconds with method sabre, depth 14, and size 134.
Transpiled circuit index 6 (all-vib-hno) in 8.39 seconds with method sabre, depth 6, and size 174.
Transpiled circuit index 7 (all-vib-bhf2) in 3.92 seconds with method sabre, depth 22, and size 220.
Transpiled circuit index 8 (LiH) in 0.03 seconds with method sabre, depth 67, and size 290.
Transpiled circuit index 9 (uf20-ham) in 0.04 seconds with method sabre, depth 50, and size 340.
Transpiled circuit index 10 (all-vib-fccf) in 0.62 seconds with method sabre, depth 30, and size 286.
Transpiled circuit index 11 (all-vib-fccf) in 0.04 seconds with method sabre, depth 67, and size 339.
Transpiled circuit index 12 (all-vib-ch2) in 0.04 seconds with method sabre, depth 87, and size 421.
Transpiled circuit index 13 (tfim) in 0.05 seconds with method sabre, depth 36, and size 222.
Transpiled circuit index 14 (all-vib-cyclo_propene) in 9.51 seconds with method sabre, depth 22, and size 345.
Transpiled circuit index 15 (graph-gnp_k-4) in 0.05 seconds with method sabre, depth 128, and size 704.
Transpiled circuit index 16 (all-vib-hc3h2cn) in 13.83 seconds with method sabre, depth 2, and size 242.
Transpiled circuit index 17 (TSP_Ncity-4) in 0.05 seconds with method sabre, depth 106, and size 609.
Transpiled circuit index 18 (tfim) in 0.29 seconds with method sabre, depth 73, and size 399.
Transpiled circuit index 19 (all-vib-h2co) in 21.97 seconds with method sabre, depth 30, and size 572.
Transpiled circuit index 20 (Be2) in 0.09 seconds with method sabre, depth 324, and size 1555.
Transpiled circuit index 21 (graph-complete_bipart) in 0.12 seconds with method sabre, depth 250, and size 1394.
Transpiled circuit index 22 (all-vib-f2) in 0.07 seconds with method sabre, depth 215, and size 1027.
Transpiled circuit index 23 (all-vib-cyclo_propene) in 41.22 seconds with method sabre, depth 30, and size 1144.
Transpiled circuit index 24 (TSP_Ncity-5) in 1.89 seconds with method sabre, depth 175, and size 1933.
Transpiled circuit index 25 (H2) in 0.32 seconds with method sabre, depth 1237, and size 5502.
Transpiled circuit index 26 (uuf100-ham) in 0.20 seconds with method sabre, depth 385, and size 4303.
Transpiled circuit index 27 (ham-graph-gnp_k-5) in 0.20 seconds with method sabre, depth 311, and size 3654.
Transpiled circuit index 28 (tfim) in 0.15 seconds with method sabre, depth 276, and size 3213.
Transpiled circuit index 29 (uuf100-ham) in 0.21 seconds with method sabre, depth 520, and size 5250.
Transpiled circuit index 30 (flat100-ham) in 0.15 seconds with method sabre, depth 131, and size 3157.
Transpiled circuit index 31 (uf100-ham) in 0.24 seconds with method sabre, depth 624, and size 7378.
Transpiled circuit index 32 (OH) in 0.88 seconds with method sabre, depth 2175, and size 9808.
Transpiled circuit index 33 (HF) in 0.66 seconds with method sabre, depth 2206, and size 9417.
Transpiled circuit index 34 (BH) in 0.89 seconds with method sabre, depth 2177, and size 9802.
Transpiled circuit index 0 (all-vib-o3) in 0.02 seconds with method ai, depth 6, and size 58.
Transpiled circuit index 1 (all-vib-c2h) in 1.11 seconds with method ai, depth 2, and size 39.
Transpiled circuit index 2 (all-vib-bh) in 0.01 seconds with method ai, depth 3, and size 30.
Transpiled circuit index 3 (all-vib-c2h) in 0.11 seconds with method ai, depth 18, and size 94.
Transpiled circuit index 4 (graph-gnp_k-2) in 0.11 seconds with method ai, depth 22, and size 129.
Transpiled circuit index 5 (all-vib-fccf) in 0.06 seconds with method ai, depth 22, and size 177.
Transpiled circuit index 6 (all-vib-hno) in 8.62 seconds with method ai, depth 10, and size 198.
Transpiled circuit index 7 (all-vib-bhf2) in 3.71 seconds with method ai, depth 18, and size 195.
Transpiled circuit index 8 (LiH) in 0.19 seconds with method ai, depth 62, and size 267.
Transpiled circuit index 9 (uf20-ham) in 0.22 seconds with method ai, depth 47, and size 321.
Transpiled circuit index 10 (all-vib-fccf) in 0.71 seconds with method ai, depth 38, and size 369.
Transpiled circuit index 11 (all-vib-fccf) in 0.24 seconds with method ai, depth 65, and size 315.
Transpiled circuit index 12 (all-vib-ch2) in 0.24 seconds with method ai, depth 91, and size 430.
Transpiled circuit index 13 (tfim) in 0.15 seconds with method ai, depth 12, and size 251.
Transpiled circuit index 14 (all-vib-cyclo_propene) in 8.50 seconds with method ai, depth 18, and size 311.
Transpiled circuit index 15 (graph-gnp_k-4) in 0.25 seconds with method ai, depth 117, and size 659.
Transpiled circuit index 16 (all-vib-hc3h2cn) in 16.11 seconds with method ai, depth 2, and size 242.
Transpiled circuit index 17 (TSP_Ncity-4) in 0.39 seconds with method ai, depth 98, and size 564.
Transpiled circuit index 18 (tfim) in 0.38 seconds with method ai, depth 23, and size 437.
Transpiled circuit index 19 (all-vib-h2co) in 24.97 seconds with method ai, depth 38, and size 707.
Transpiled circuit index 20 (Be2) in 1.07 seconds with method ai, depth 293, and size 1392.
Transpiled circuit index 21 (graph-complete_bipart) in 0.61 seconds with method ai, depth 229, and size 1437.
Transpiled circuit index 22 (all-vib-f2) in 0.57 seconds with method ai, depth 178, and size 964.
Transpiled circuit index 23 (all-vib-cyclo_propene) in 50.89 seconds with method ai, depth 34, and size 1425.
Transpiled circuit index 24 (TSP_Ncity-5) in 1.61 seconds with method ai, depth 171, and size 2020.
Transpiled circuit index 25 (H2) in 6.39 seconds with method ai, depth 1148, and size 5208.
Transpiled circuit index 26 (uuf100-ham) in 3.97 seconds with method ai, depth 376, and size 5048.
Transpiled circuit index 27 (ham-graph-gnp_k-5) in 3.54 seconds with method ai, depth 357, and size 4451.
Transpiled circuit index 28 (tfim) in 1.72 seconds with method ai, depth 216, and size 3026.
Transpiled circuit index 29 (uuf100-ham) in 4.45 seconds with method ai, depth 426, and size 5399.
Transpiled circuit index 30 (flat100-ham) in 7.02 seconds with method ai, depth 86, and size 3108.
Transpiled circuit index 31 (uf100-ham) in 12.85 seconds with method ai, depth 623, and size 8354.
Transpiled circuit index 32 (OH) in 15.19 seconds with method ai, depth 2084, and size 9543.
Transpiled circuit index 33 (HF) in 17.51 seconds with method ai, depth 2063, and size 9446.
Transpiled circuit index 34 (BH) in 15.33 seconds with method ai, depth 2094, and size 9730.
Transpiled circuit index 0 (all-vib-o3) in 0.02 seconds with method rustiq, depth 13, and size 83.
Transpiled circuit index 1 (all-vib-c2h) in 1.11 seconds with method rustiq, depth 2, and size 39.
Transpiled circuit index 2 (all-vib-bh) in 0.01 seconds with method rustiq, depth 3, and size 30.
Transpiled circuit index 3 (all-vib-c2h) in 0.01 seconds with method rustiq, depth 13, and size 79.
Transpiled circuit index 4 (graph-gnp_k-2) in 0.02 seconds with method rustiq, depth 31, and size 131.
Transpiled circuit index 5 (all-vib-fccf) in 0.04 seconds with method rustiq, depth 50, and size 306.
Transpiled circuit index 6 (all-vib-hno) in 14.03 seconds with method rustiq, depth 22, and size 276.
Transpiled circuit index 7 (all-vib-bhf2) in 3.15 seconds with method rustiq, depth 13, and size 155.
Transpiled circuit index 8 (LiH) in 0.03 seconds with method rustiq, depth 54, and size 270.
Transpiled circuit index 9 (uf20-ham) in 0.04 seconds with method rustiq, depth 65, and size 398.
Transpiled circuit index 10 (all-vib-fccf) in 0.16 seconds with method rustiq, depth 41, and size 516.
Transpiled circuit index 11 (all-vib-fccf) in 0.02 seconds with method rustiq, depth 34, and size 189.
Transpiled circuit index 12 (all-vib-ch2) in 0.03 seconds with method rustiq, depth 49, and size 240.
Transpiled circuit index 13 (tfim) in 0.05 seconds with method rustiq, depth 20, and size 366.
Transpiled circuit index 14 (all-vib-cyclo_propene) in 9.08 seconds with method rustiq, depth 16, and size 277.
Transpiled circuit index 15 (graph-gnp_k-4) in 0.04 seconds with method rustiq, depth 116, and size 612.
Transpiled circuit index 16 (all-vib-hc3h2cn) in 13.89 seconds with method rustiq, depth 2, and size 257.
Transpiled circuit index 17 (TSP_Ncity-4) in 0.05 seconds with method rustiq, depth 133, and size 737.
Transpiled circuit index 18 (tfim) in 0.11 seconds with method rustiq, depth 25, and size 680.
Transpiled circuit index 19 (all-vib-h2co) in 27.19 seconds with method rustiq, depth 66, and size 983.
Transpiled circuit index 20 (Be2) in 0.07 seconds with method rustiq, depth 215, and size 1030.
Transpiled circuit index 21 (graph-complete_bipart) in 0.14 seconds with method rustiq, depth 328, and size 1918.
Transpiled circuit index 22 (all-vib-f2) in 0.05 seconds with method rustiq, depth 114, and size 692.
Transpiled circuit index 23 (all-vib-cyclo_propene) in 62.25 seconds with method rustiq, depth 74, and size 2348.
Transpiled circuit index 24 (TSP_Ncity-5) in 0.20 seconds with method rustiq, depth 436, and size 3605.
Transpiled circuit index 25 (H2) in 0.21 seconds with method rustiq, depth 643, and size 3476.
Transpiled circuit index 26 (uuf100-ham) in 0.24 seconds with method rustiq, depth 678, and size 6120.
Transpiled circuit index 27 (ham-graph-gnp_k-5) in 0.22 seconds with method rustiq, depth 588, and size 5241.
Transpiled circuit index 28 (tfim) in 0.34 seconds with method rustiq, depth 340, and size 5901.
Transpiled circuit index 29 (uuf100-ham) in 0.33 seconds with method rustiq, depth 881, and size 7667.
Transpiled circuit index 30 (flat100-ham) in 0.31 seconds with method rustiq, depth 279, and size 4910.
Transpiled circuit index 31 (uf100-ham) in 0.38 seconds with method rustiq, depth 1138, and size 10607.
Transpiled circuit index 32 (OH) in 0.38 seconds with method rustiq, depth 1148, and size 6512.
Transpiled circuit index 33 (HF) in 0.37 seconds with method rustiq, depth 1090, and size 6256.
Transpiled circuit index 34 (BH) in 0.37 seconds with method rustiq, depth 1148, and size 6501.
```

Ergebnistabelle (Visualisierung wird überspronga, weil d Ausgabeschaltuga sehr groß sind):

```python
summary_ham = (
    results_ham.groupby("method")[["depth", "size", "runtime"]]
    .mean()
    .round(2)
)
print(summary_ham)

results_ham
```

```text
depth     size  runtime
method
ai      316.86  2181.26     5.97
rustiq  281.94  2268.80     3.86
sabre   337.97  2120.14     3.07
```

```text
method        qc_name  qc_index  num_qubits  \
0     sabre     all-vib-o3         0           4
1     sabre    all-vib-c2h         1           4
2     sabre     all-vib-bh         2           2
3     sabre    all-vib-c2h         3           3
4     sabre  graph-gnp_k-2         4           4
..      ...            ...       ...         ...
100  rustiq    flat100-ham        30          90
101  rustiq      uf100-ham        31          46
102  rustiq             OH        32          10
103  rustiq             HF        33          10
104  rustiq             BH        34          10

                                               ops  depth   size   runtime
0                    {'rz': 28, 'sx': 24, 'cz': 6}      6     58  0.016597
1            {'rz': 17, 'sx': 16, 'cz': 4, 'x': 2}      2     39  1.102089
2                    {'sx': 14, 'rz': 13, 'cz': 3}      3     30  0.011042
3           {'sx': 46, 'rz': 45, 'cz': 18, 'x': 6}     18    115  0.025816
4           {'sx': 49, 'rz': 47, 'cz': 24, 'x': 9}     24    129  0.023077
..                                             ...    ...    ...       ...
100    {'sx': 2709, 'cz': 1379, 'rz': 817, 'x': 5}    279   4910  0.309448
101   {'sx': 6180, 'cz': 3120, 'rz': 1303, 'x': 4}   1138  10607  0.380977
102  {'sx': 3330, 'cz': 1704, 'rz': 1455, 'x': 23}   1148   6512  0.383564
103  {'sx': 3213, 'cz': 1620, 'rz': 1406, 'x': 17}   1090   6256  0.368578
104  {'sx': 3331, 'cz': 1704, 'rz': 1447, 'x': 19}   1148   6501  0.374822

[105 rows x 8 columns]
```

Visualisiert d Leischtig basierend auf em Schaltugindex:

```python
plot_transpilation_metrics(
    results_ham, "Transpilation Metrics for Hamiltonian Circuits"
)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/4c6b810d-a4cf-4de3-aae6-c6c1cdd83d8f-0.avif)

Visualisiert dr Prozentsatz vun de Schaltuga, für die jede Methode am beschta abgschnitta hett.

```python
def analyze_and_plot_best_methods(results, metric):
    """
    Analyze the best-performing methods for a given metric and plot a pie chart.

    Parameters:
        results (DataFrame): The input DataFrame containing method performance data.
        metric (str): The metric to evaluate ("depth" or "size").
    """
    method_counts = Counter()
    for qc_idx, group in results.groupby("qc_index"):
        min_value = group[metric].min()

        # Find all methods that achieved this minimum value
        best_methods = group[group[metric] == min_value]["method"]
        # Update counts for all best methods (handling ties)
        method_counts.update(best_methods)
    best_method_counts = dict(
        sorted(method_counts.items(), key=lambda x: x[1], reverse=True)
    )

    # Print summary
    print(f"Best-performing methods based on {metric}:")
    for method, count in best_method_counts.items():
        print(f"    {method}: {count} circuit(s)")

    # Plot pie chart
    num_methods = len(best_method_counts)
    colors = plt.cm.viridis_r(range(0, 256, 256 // num_methods))
    plt.figure(figsize=(5, 5))
    plt.pie(
        best_method_counts.values(),
        labels=best_method_counts.keys(),
        autopct="%1.1f%%",
        startangle=140,
        wedgeprops={"edgecolor": "black"},
        textprops={"fontsize": 10},
        colors=colors,
    )
    plt.title(
        f"Percentage of Circuits Method Performed Best for {metric.capitalize()}",
        fontsize=12,
        fontweight="bold",
    )
    plt.show()

analyze_and_plot_best_methods(results_ham, "depth")
analyze_and_plot_best_methods(results_ham, "size")
```

```text
Best-performing methods based on depth:
    ai: 16 circuit(s)
    rustiq: 16 circuit(s)
    sabre: 10 circuit(s)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/01b4644e-ac91-483c-944b-924f8b41718d-1.avif)

```text
Best-performing methods based on size:
    sabre: 18 circuit(s)
    rustiq: 14 circuit(s)
    ai: 10 circuit(s)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/01b4644e-ac91-483c-944b-924f8b41718d-3.avif)

#### Analyse vun de Hamilton-Schaltugskompilierugsergebnis {#analyse-der-hamilton-schaltungskompilierungsergebnisse}

In dem Abschnitt evaluiert mir d Leischtig vun drei Transpilationsmethoda – SABRE, em AI-gstützta Transpiler und Rustiq – an Quanteschaltuga, die mit `PauliEvolutionGate` konstruiert worda sind, die häufig in Hamilton-Simulationsaufgabe vrwendet werdet.

Rustiq hett im Durchschnitt am beschta in Bezug auf d Schaltugsdief abgschnitta und hett a etwa 20% niedrigere Dief als SABRE erreicht. Des isch z erwarta, weil Rustiq speziell für d Synthese vun `PauliEvolutionGate`-Operationa mit optimierta, niedrig-tife Zerlegugsstrategie entwickelt worda isch. Darüber hinaus zeigt s Diefediagramm, dass Rustiq am effektivschte skaliert, wenn d Schaltuga an Größe und Komplexität zunehmet, und a deutlich geringere Dief als sowohl AI als au SABRE bei größera Schaltuga beibehaltet.

Dr AI-Transpiler hett starke und konsistente Leischtig für d Schaltugsdief gzeigt und hett SABRE konsistent über d meischte Schaltuga hinweg übertroffa. Er hett jedoch d höchste Laufzeit verursacht, insbesondere bei größera Schaltuga, was seine Praktikabilität in zeitkritische Workloads einschränka ka. Seine Skalierbarkeit bei dr Laufzeit bleibt a Schlüsselbeschränkung, obwohl er solide Verbesseruga bei dr Dief bietet.

SABRE hett zwar d höchste durchschnittliche Dief erzielt, aber d niedrigste durchschnittliche Gate-Anzahl, dicht gfolgt vun em AI-Transpiler. Des isch im Einklang mit em Design vun dr SABRE-Heuristik, die d Minimierung vun dr Gate-Anzahl direkt priorisiert. Rustiq hett trotz sinere Stärke bei dr Senkung vun dr Dief d höchste durchschnittliche Gate-Anzahl ghett, was a bemerkenswerta Kompromiss isch, den mr in Anwenduga berücksichtige sollt, bei dena Schaltugsgröße mehr zählt als Schaltugsdauer.

### Zusammenfassung {#zusammenfassung}

Während dr AI-Transpiler im Allgemoine bessere Ergebnis als SABRE liefert, insbesondere bei dr Schaltugsdief, sollt d Schlussfolgerung ned einfach "immer dr AI-Transpiler vrwenda" sei. Es gibt wichtige Nuancen z berücksichtige:

- **AI-Transpiler** isch typischerweise zuverlässig und liefert tiefenoptimierte Schaltuga, bringt aber Kompromisse bei dr Laufzeit mit sich und hett au andere Einschränkuga, einschließlich unterstützter Coupling-Maps und Synthese-Fähigkeita. Dene sind in dr [Qiskit Transpiler Service-Dokumentation](/guides/qiskit-transpiler-service) detailliert beschrieba.

- In mancha Fälle, insbesondere bei sehr großa oder hardwarespezifische Schaltuga, isch dr AI-Transpiler möglicherweise ned so effektiv. In dena Fälle bleibt dr Standard-SABRE-Transpiler äußerst zuverlässig und ka durch d Agpassung sinere Parameter weiter optimiert werra (gseat s [SABRE-Optimierugs-Tutorial](/tutorials/transpilation-optimizations-with-sabre)).

- Es isch au wichtig, d Schaltugstruktur bei dr Wahl vunere Methode z berücksichtige. Zum Beispiel isch `rustiq` speziell für Schaltuga mit `PauliEvolutionGate` konzipiert und liefert oft d beste Leischtig für Hamilton-Simulationsproble.

**Empfehlung:**
> Es gibt koi Einheitslösung für d Transpilationsstrategie. D Benutzer werdet ermuntert, d Struktur vun ihre Schaltung z vrschteha und mehrere Transpilationsmethoda z tesda – einschließlich AI, SABRE und spezialisierte Tools wie Rustiq – um d effizienteste Lösung für ires spezifisches Problem und ihre Hardware-Einschränkuga z finda.

### Schritt 3: Ausführung mit Qiskit Primitives {#schritt-3-ausfuehrung-mit-qiskit-primitives}
Weil sich des Tutorial auf Transpilation konzentriert, werdet koi Experimente auf amme Quantegeät ausgeführt. S Ziel isch es, d Optimieruga aus Schritt 2 z nutza, um a transpilierte Schaltung mit reduzierter Dief und Gate-Anzahl z erhalte.

### Schritt 4: Nachbearbeitig und Rückgabe vun em Ergebnis im gwünschta klassische Format {#schritt-4-nachbearbeitung-und-rueckgabe-des-ergebnisses-im-gewuenschten-klassischen-format}
Da es koi Ausführung für des Notebook gibt, gibt es au koi Ergebnis zur Nachbearbeitig.

## Referenza {#referenzen}

[1] "LightSABRE: A Lightweight and Enhanced SABRE Algorithm". H. Zou, M. Treinish, K. Hartman, A. Ivrii, J. Lishman et al. https://arxiv.org/abs/2409.08368

[2] "Practical and efficient quantum circuit synthesis and transpiling with Reinforcement Learning". D. Kremer, V. Villar, H. Paik, I. Duran, I. Faro, J. Cruz-Benito et al. https://arxiv.org/abs/2405.13196

[3] "Pauli Network Circuit Synthesis with Reinforcement Learning". A. Dubal, D. Kremer, S. Martiel, V. Villar, D. Wang, J. Cruz-Benito et al. https://arxiv.org/abs/2503.14448

[4] "Faster and shorter synthesis of Hamiltonian simulation circuits". T. Goubault de Brugière, S. Martiel et al. https://arxiv.org/abs/2404.03280
