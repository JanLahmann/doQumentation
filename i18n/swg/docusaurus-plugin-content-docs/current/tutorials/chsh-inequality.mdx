---
title: "CHSH-Ungleichung"
sidebar_label: "CHSH-Ungleichung"
description: "Führet en Experiment uff eme Quantecomputer aus, um d'Verletzung vo dr CHSH-Ungleichung mit em Estimator-Primitiv z'zeige."
notebook_path: "docs/tutorials/chsh-inequality.ipynb"
---
{/* doqumentation-source-hash: 05263e84 */}

<OpenInLabBanner notebookPath="docs/tutorials/chsh-inequality.ipynb" />



{/* cspell:ignore zorder */}

*Nutzungsschätzung: Zwoi Minuta uff eme Heron r2-Prozessor (HINWEIS: Des isch nur e Schätzung. Dei Laufzeit ka variiere.)*
## Hintergrund {#hintergrund}

In dem Tutorial führet mr en Experiment uff eme Quantecomputer aus, um d'Verletzung vo dr CHSH-Ungleichung mit em Estimator-Primitiv z'zeige.

D'CHSH-Ungleichung, benannt nach de Autore Clauser, Horne, Shimony und Holt, wird verwendet, um Bells Theorem (1969) experimentell z'beweise. Des Theorem besagt, dass lokali Theorien mit verborgene Variabla manche Konsequenze vo dr Verschränkung in dr Quantemechanik ned erklärn könnet. D'Verletzung vo dr CHSH-Ungleichung wird verwendet, um z'zeige, dass d'Quantemechanik mit lokale Theorien mit verborgene Variabla ned vereinbar isch. Des isch en wichtigs Experiment zum Verschtändnis vo de Grundlage vo dr Quantemechanik.

Dr Nobelpreis für Physik 2022 isch an Alain Aspect, John Clauser und Anton Zeilinger verliehe worre, unter anderem für ihre Pionierarbeit in dr Quanteinformationswissenschaft und insbesondere für ihre Experimente mit verschränkte Photone, wo d'Verletzung vo de Bellsche Ungleichunge demonstriert hend.
## Anforderunge {#anforderungen}

Stellt vor em Beginn vo dem Tutorial sicher, dass Ihr Folgendes installiert hend:

* Qiskit SDK v1.0 oder neuer, mit [visualization](https://docs.quantum.ibm.com/api/qiskit/visualization)-Unterstützung
* Qiskit Runtime (`pip install qiskit-ibm-runtime`) v0.22 oder neuer
## Setup {#setup}

```python
# General
import numpy as np

# Qiskit imports
from qiskit import QuantumCircuit
from qiskit.circuit import Parameter
from qiskit.quantum_info import SparsePauliOp
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

# Qiskit Runtime imports
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_runtime import EstimatorV2 as Estimator

# Plotting routines
import matplotlib.pyplot as plt
import matplotlib.ticker as tck
```

## Schritt 1: Klassischi Eingabe uff en Quanteproblem abbilden {#schritt-1-klassische-eingaben-auf-ein-quantenproblem-abbilden}
Für des Experiment erstelle mr en verschränkts Paar, wo mr jeds Qubit uff zwoi verschiedene Basa messe. Mir bezeichne d'Basa für s'erschte Qubit mit $A$ und $a$ und d'Basa für s'zweite Qubit mit $B$ und $b$. Des ermöglicht es uns, d'CHSH-Größe $S_1$ z'berechne:

$$
S_1 = A(B-b) + a(B+b).
$$

Jedi Observable isch entweder $+1$ oder $-1$. Klar isch, dass einer vo de Terme $B\pm b$ gleich $0$ sei muss und dr andere $\pm 2$ sei muss. Deshalb isch $S_1 = \pm 2$. Dr Durchschnittswert vo $S_1$ muss d'Ungleichung erfülle:

$$
|\langle S_1 \rangle|\leq 2.
$$

D'Entwicklung vo $S_1$ in Bezug uff $A$, $a$, $B$ und $b$ ergibt:

$$
|\langle S_1 \rangle| = |\langle AB \rangle - \langle Ab \rangle + \langle aB \rangle + \langle ab \rangle| \leq 2
$$

Ihr könnet e weiteri CHSH-Größe $S_2$ definiere:

$$
S_2 = A(B+b) - a(B-b),
$$

Des führt zu enr weitere Ungleichung:

$$
|\langle S_2 \rangle| = |\langle AB \rangle + \langle Ab \rangle - \langle aB \rangle + \langle ab \rangle| \leq 2
$$

Wenn d'Quantemechanik durch lokali Theorien mit verborgene Variabla beschriebe werre ka, müsset d'vorherige Ungleichunge wahr sei. Wie aber in dem Tutorial demonstriert wird, könnet dese Ungleichunge uff eme Quantecomputer verletzt werre. Deshalb isch d'Quantemechanik ned mit lokale Theorien mit verborgene Variabla vereinbar.
Falls Ihr mehr Theorie lerne wollet, erkundet [Entanglement in Action](/learning/courses/basics-of-quantum-information/entanglement-in-action/chsh-game) mit em John Watrous.
Ihr werdet en verschränkts Paar zwischen zwoi Qubits in eme Quantecomputer erstelle, indem Ihr de Bell-Zustand $|\Phi^+\rangle = \frac{|00\rangle + |11\rangle}{\sqrt{2}}$ erzeuget. Mit em Estimator-Primitiv könnet Ihr direkt d'benötigte Erwartungswerte ($\langle AB \rangle, \langle Ab \rangle, \langle aB \rangle$ und $\langle ab \rangle$) kriege, um d'Erwartungswerte vo de beide CHSH-Größe $\langle S_1\rangle$ und $\langle S_2\rangle$ z'berechne. Vor dr Einführung vom Estimator-Primitiv hend mr d'Erwartungswerte aus de Messergebnisse konstruiere müsse.

Ihr werdet s'zweite Qubit in de $Z$- und $X$-Basa messe. S'erschte Qubit wird ebefalls in orthogonale Basa gmesse, aber mit eme Winkel bezüglich vom zweite Qubit, den mir zwischen $0$ und $2\pi$ variiere werdet. Wie Ihr sehet, macht s'Estimator-Primitiv s'Ausführe vo parametrisierte Schaltkreis sehr eifach. Anstatt e Reihe vo CHSH-Schaltkreise z'erstelle, müsset Ihr nur *oine* CHSH-Schaltkreis mit eme Parameter erstelle, wo de Messwinkel angibt, und e Reihe vo Phasewerte für de Parameter.

Schließlich werdet Ihr d'Ergebnisse analysiere und gege de Messwinkel auftrage. Ihr werdet sehe, dass für ene bestimmte Bereich vo Messwinkeln d'Erwartungswerte vo de CHSH-Größe $|\langle S_1\rangle| > 2$ oder $|\langle S_2\rangle| > 2$ send, was d'Verletzung vo dr CHSH-Ungleichung demonstriert.

```python
# To run on hardware, select the backend with the fewest number of jobs in the queue
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=127
)
backend.name
```

```text
'ibm_kingston'
```

### En parametrisierte CHSH-Schaltkreis erstelle {#einen-parametrisierten-chsh-schaltkreis-erstellen}

Zerscht schreibe mr de Schaltkreis mit em Parameter $\theta$, den mr `theta` nenne. S'[`Estimator`-Primitiv](https://docs.quantum-computing.ibm.com/api/qiskit-ibm-runtime/qiskit_ibm_runtime.EstimatorV2) ka de Schaltkreisaufbau und d'Ausgabeanalyse riesig vereinfache, indem s'direkt Erwartungswerte vo Observabla liefert. Viel interessanti Probleme, insbesondere für kurzfristige Anwendunge uff verrauschet Systeme, könnet in Form vo Erwartungswerte formuliert werre. S'`Estimator` (V2)-Primitiv ka automatisch d'Messbasis basierend uff dr bereitgestellte Observable ändere.

```python
theta = Parameter("$\\theta$")

chsh_circuit = QuantumCircuit(2)
chsh_circuit.h(0)
chsh_circuit.cx(0, 1)
chsh_circuit.ry(theta, 0)
chsh_circuit.draw(output="mpl", idle_wires=False, style="iqp")
```

![Output of the previous code cell](/docs/images/tutorials/chsh-inequality/extracted-outputs/6c77e40a-0.avif)

### E Lischt vo Phasewerte erstelle, wo später zugewiese werdet {#eine-liste-von-phasenwerten-erstellen-die-später-zugewiesen-werden}

Nachdem Ihr de parametrisierte CHSH-Schaltkreis erstellt hend, erstellt Ihr e Lischt vo Phasewerte, wo em Schaltkreis im nächste Schritt zugewiese werdet. Ihr könnet de folgende Code verwende, um e Lischt vo 21 Phasewerte im Bereich vo $0$ bis $2 \pi$ mit gleichem Abstand z'erstelle, also $0$, $0.1 \pi$, $0.2 \pi$, ..., $1.9 \pi$, $2 \pi$.

```python
number_of_phases = 21
phases = np.linspace(0, 2 * np.pi, number_of_phases)
# Phases need to be expressed as list of lists in order to work
individual_phases = [[ph] for ph in phases]
```

### Observabla {#observablen}

Jetzt brauche mr Observabla, aus dene mr d'Erwartungswerte berechne könnet. In unserm Fall betrachte mr orthogonali Basa für jeds Qubit, wobei d'parametrisierte $Y$-Rotation für s'erschte Qubit d'Messbasis nahezu kontinuierlich in Bezug uff d'Basis vom zweite Qubit variiert. Mr wähle deshalb d'Observabla $ZZ$, $ZX$, $XZ$ und $XX$.

```python
# <CHSH1> = <AB> - <Ab> + <aB> + <ab> -> <ZZ> - <ZX> + <XZ> + <XX>
observable1 = SparsePauliOp.from_list(
    [("ZZ", 1), ("ZX", -1), ("XZ", 1), ("XX", 1)]
)

# <CHSH2> = <AB> + <Ab> - <aB> + <ab> -> <ZZ> + <ZX> - <XZ> + <XX>
observable2 = SparsePauliOp.from_list(
    [("ZZ", 1), ("ZX", 1), ("XZ", -1), ("XX", 1)]
)
```

## Schritt 2: Problem für d'Ausführung uff Quantehardware optimiere {#schritt-2-problem-für-die-ausführung-auf-quantenhardware-optimieren}
Um d'Gesamtausführungszeit vom Job z'reduziere, akzeptiere V2-Primitive nur Schaltkreise und Observabla, wo de vom Zielsystem unterstützte Anweisunge und dr Konnektivität entsprechet (bezeichnet als Instruction Set Architecture (ISA)-Schaltkreise und -Observabla).
### ISA-Schaltkreis {#isa-schaltkreis}

```python
target = backend.target
pm = generate_preset_pass_manager(target=target, optimization_level=3)

chsh_isa_circuit = pm.run(chsh_circuit)
chsh_isa_circuit.draw(output="mpl", idle_wires=False, style="iqp")
```

![Output of the previous code cell](/docs/images/tutorials/chsh-inequality/extracted-outputs/9a5561eb-0.avif)

### ISA-Observabla {#isa-observablen}
Ebenso müsse mr d'Observabla transformiere, um se backend-kompatibel z'mache, bevor mr Jobs mit [`Runtime Estimator V2`](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/estimator-v2#run) ausführe. Mr könnet d'Transformation mit dr `apply_layout`-Methode vom `SparsePauliOp`-Objekt durchführe.

```python
isa_observable1 = observable1.apply_layout(layout=chsh_isa_circuit.layout)
isa_observable2 = observable2.apply_layout(layout=chsh_isa_circuit.layout)
```

## Schritt 3: Ausführe mit Qiskit-Primitive {#schritt-3-ausführen-mit-qiskit-primitiven}

Um s'gesamte Experiment in eim einzige Aufruf vom [`Estimator`](https://docs.quantum-computing.ibm.com/api/qiskit-ibm-runtime/qiskit_ibm_runtime.EstimatorV2) auszuführe.
Mr könnet en [Qiskit Runtime `Estimator`](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/estimator-v2)-Primitiv erstelle, um unsere Erwartungswerte z'berechne. D'`EstimatorV2.run()`-Methode akzeptiert en Iterable vo `primitive unified blocs (PUBs)`. Jeds PUB isch en Iterable im Format `(circuit, observables, parameter_values: Optional, precision: Optional)`.

```python
# To run on a local simulator:
# Use the StatevectorEstimator from qiskit.primitives instead.

estimator = Estimator(mode=backend)

pub = (
    chsh_isa_circuit,  # ISA circuit
    [[isa_observable1], [isa_observable2]],  # ISA Observables
    individual_phases,  # Parameter values
)

job_result = estimator.run(pubs=[pub]).result()
```

## Schritt 4: Nachbearbeitung und Rückgab vom Ergebnis im gwünscht klassische Format {#schritt-4-nachbearbeitung-und-rückgabe-des-ergebnisses-im-gewünschten-klassischen-format}

Dr Estimator gibt Erwartungswerte für beide Observabla zruck, $\langle ZZ \rangle - \langle ZX \rangle + \langle XZ \rangle + \langle XX \rangle$ und $\langle ZZ \rangle + \langle ZX \rangle - \langle XZ \rangle + \langle XX \rangle$.

```python
chsh1_est = job_result[0].data.evs[0]
chsh2_est = job_result[0].data.evs[1]
```

```python
fig, ax = plt.subplots(figsize=(10, 6))

# results from hardware
ax.plot(phases / np.pi, chsh1_est, "o-", label="CHSH1", zorder=3)
ax.plot(phases / np.pi, chsh2_est, "o-", label="CHSH2", zorder=3)

# classical bound +-2
ax.axhline(y=2, color="0.9", linestyle="--")
ax.axhline(y=-2, color="0.9", linestyle="--")

# quantum bound, +-2√2
ax.axhline(y=np.sqrt(2) * 2, color="0.9", linestyle="-.")
ax.axhline(y=-np.sqrt(2) * 2, color="0.9", linestyle="-.")
ax.fill_between(phases / np.pi, 2, 2 * np.sqrt(2), color="0.6", alpha=0.7)
ax.fill_between(phases / np.pi, -2, -2 * np.sqrt(2), color="0.6", alpha=0.7)

# set x tick labels to the unit of pi
ax.xaxis.set_major_formatter(tck.FormatStrFormatter("%g $\\pi$"))
ax.xaxis.set_major_locator(tck.MultipleLocator(base=0.5))

# set labels, and legend
plt.xlabel("Theta")
plt.ylabel("CHSH witness")
plt.legend()
plt.show()
```

![Output of the previous code cell](/docs/images/tutorials/chsh-inequality/extracted-outputs/f6267448-0.avif)

In dr Abbildung grenze d'Linien und grau Bereiche d'Grenzen ab; d'äußerschte (strichpunktierte) Linien begrenzen d'Quantegrenzen ($\pm 2$), während d'innere (gestrichelten) Linien d'klassische Grenzen ($\pm 2\sqrt{2}$) begrenzen. Ihr könnet sehe, dass es Bereiche gibt, wo d'CHSH-Zeugegröße d'klassische Grenzen überschreitet. Herzliche Glückwunsch! Ihr hend erfolgreich d'Verletzung vo dr CHSH-Ungleichung in eme echte Quantesystem demonstriert!
## Tutorial-Umfrage {#tutorial-umfrage}

Bitte nemmet an derer kurze Umfrage teil, um Feedback zu dem Tutorial z'gebe. Dei Erkenntnisse helfet uns, unsere Inhaltsangebote und Benutzererfahrung z'verbessere.

[Link zur Umfrage](https://your.feedback.ibm.com/jfe/form/SV_3xxAgm1SF1wGp9k)
