---
title: "CHSH-Ungliektiet"
sidebar_label: "CHSH-Ungliektiet"
description: "Föhr en Experiment op'n Quantencomputer dör, üm de Verletzen vun de CHSH-Ungliektiet mit dat Estimator-Primitiv to wiesen."
notebook_path: "docs/tutorials/chsh-inequality.ipynb"
---

<OpenInLabBanner notebookPath="docs/tutorials/chsh-inequality.ipynb" />



{/* cspell:ignore zorder */}

*Bruukschätzung: Twee Minuten op'n Heron r2-Prozessor (HENWIES: Dat is bloots en Schätzung. Dien Looptiet kann afwieken.)*
## Achtergrund {#background}

In dit Tutorial föhrst du en Experiment op'n Quantencomputer dör, üm de Verletzen vun de CHSH-Ungliektiet mit dat Estimator-Primitiv to wiesen.

De CHSH-Ungliektiet, nömmt nah de Autoren Clauser, Horne, Shimony un Holt, warrt bruukt, üm Bells Theorem (1969) experimentell to bewiesen. Dit Theorem seggt, dat lokale Theorien mit verbörgen Variablen nich all Konsequenzen vun de Verschränkung in de Quantenmechanik verkloren künnt. De Verletzen vun de CHSH-Ungliektiet warrt bruukt, üm to wiesen, dat de Quantenmechanik mit lokale Theorien mit verbörgen Variablen nich vereinbor is. Dat is en wichtig Experiment för dat Verstahn vun de Grundlagen vun de Quantenmechanik.

De Nobelpries för Physik 2022 wöör an Alain Aspect, John Clauser un Anton Zeilinger vergeven, ünner annern för ehr Pioneerarbeit in de Quanteninformationswetenschop un besünners för ehr Experimenten mit verschränkte Photonen, de de Verletzen vun de Bellschen Ungliektiet wiest hebbt.
## Anforderungen {#requirements}

Vör du dit Tutorial anfängst, stell seker, dat du Folgendes installeert hest:

* Qiskit SDK v1.0 oder neger, mit [visualization](https://docs.quantum.ibm.com/api/qiskit/visualization)-Ünnerstütten
* Qiskit Runtime (`pip install qiskit-ibm-runtime`) v0.22 oder neger
## Inrichten {#setup}

```python
# General
import numpy as np

# Qiskit imports
from qiskit import QuantumCircuit
from qiskit.circuit import Parameter
from qiskit.quantum_info import SparsePauliOp
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

# Qiskit Runtime imports
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_runtime import EstimatorV2 as Estimator

# Plotting routines
import matplotlib.pyplot as plt
import matplotlib.ticker as tck
```

## Stap 1: Klassische Ingaven op en Quantenproblem afbilden {#step-1-map-classical-inputs-to-a-quantum-problem}
För dit Experiment maakt wi en verschränkt Poor, wo wi jeedeen Qubit op twee verscheden Basen meeten. Wi kennteken de Basen för dat eerste Qubit mit $A$ un $a$ un de Basen för dat tweete Qubit mit $B$ un $b$. Dat verlöövt uns, de CHSH-Grötte $S_1$ to berekenen:

$$
S_1 = A(B-b) + a(B+b).
$$

Jeedeen Observable is entweder $+1$ oder $-1$. Klor is, dat een vun de Termen $B\pm b$ glieks $0$ wesen mutt un de anner $\pm 2$ wesen mutt. Doröm is $S_1 = \pm 2$. De Dörsnittsweert vun $S_1$ mutt de Ungliektiet erfüllen:

$$
|\langle S_1 \rangle|\leq 2.
$$

Wenn wi $S_1$ in Bezug op $A$, $a$, $B$ un $b$ utrecken, kriegen wi:

$$
|\langle S_1 \rangle| = |\langle AB \rangle - \langle Ab \rangle + \langle aB \rangle + \langle ab \rangle| \leq 2
$$

Du kannst noch en wiedere CHSH-Grötte $S_2$ defineeren:

$$
S_2 = A(B+b) - a(B-b),
$$

Dat föhrt to en wiedere Ungliektiet:

$$
|\langle S_2 \rangle| = |\langle AB \rangle + \langle Ab \rangle - \langle aB \rangle + \langle ab \rangle| \leq 2
$$

Wenn de Quantenmechanik dör lokale Theorien mit verbörgen Variablen beschreven warrn kann, mööt de vörige Ungliektiet wohr wesen. Aver, as in dit Tutorial wiest warrt, künnt disse Ungliektiet op'n Quantencomputer verletzt warrn. Doröm is de Quantenmechanik nich mit lokale Theorien mit verbörgen Variablen vereinbor.
Wenn du mehr Theorie lehren willst, kiek di [Entanglement in Action](/learning/courses/basics-of-quantum-information/entanglement-in-action/chsh-game) mit John Watrous an.
Wi schüllt en verschränkt Poor twischen twee Qubits in'n Quantencomputer maken, indem wi den Bell-Tostand $|\Phi^+\rangle = \frac{|00\rangle + |11\rangle}{\sqrt{2}}$ erzeugen. Mit dat Estimator-Primitiv kannst du direkt de nödigen Verwachtungsweerten ($\langle AB \rangle, \langle Ab \rangle, \langle aB \rangle$ un $\langle ab \rangle$) kriegen, üm de Verwachtungsweerten vun de beiden CHSH-Grötten $\langle S_1\rangle$ un $\langle S_2\rangle$ to berekenen. Vör de Inföhren vun dat Estimator-Primitiv haddst du de Verwachtungsweerten ut de Meetresultaten konstrueeren musst.

Wi schüllt dat tweete Qubit in de $Z$- un $X$-Basen meeten. Dat eerste Qubit warrt ok in orthogonale Basen meeten, aver mit'n Winkel in Bezug op dat tweete Qubit, den wi twischen $0$ un $2\pi$ variëeren warrt. As du sehn wirst, maakt dat Estimator-Primitiv dat Utföhren vun parametriseerde Schaltkringe ganz eenfach. Anstatt en Reeg vun CHSH-Schaltkringe to maken, muttst du bloots *een* CHSH-Schaltkrieg mit'n Parameter maken, de den Meetwinkel angifft, un en Reeg vun Phasenweerten för den Parameter.

Toletzt warrt wi de Resultaten analyseeren un gegen den Meetwinkel opdragen. Du wirst sehn, dat för'n bestimmten Bereich vun Meetwinkeln de Verwachtungsweerten vun de CHSH-Grötten $|\langle S_1\rangle| > 2$ oder $|\langle S_2\rangle| > 2$ sünd, wat de Verletzen vun de CHSH-Ungliektiet wiest.

```python
# To run on hardware, select the backend with the fewest number of jobs in the queue
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=127
)
backend.name
```

```text
'ibm_kingston'
```

### En parametriseerden CHSH-Schaltkrieg maken {#create-a-parameterized-chsh-circuit}

Eerst schrieven wi den Schaltkrieg mit den Parameter $\theta$, den wi `theta` nöömt. Dat [`Estimator`-Primitiv](https://docs.quantum-computing.ibm.com/api/qiskit-ibm-runtime/qiskit_ibm_runtime.EstimatorV2) kann den Schaltkringsopbo un de Utgavenanalyse bannig vereinfachen, indem dat direkt Verwachtungsweerten vun Observablen levern deit. Völ interessante Problemen, besünners för kortfristige Anwendungen op ruschige Systemen, künnt in Form vun Verwachtungsweerten formuleert warrn. Dat `Estimator` (V2)-Primitiv kann automatisch de Meetbasis op Grundlag vun de bereedstellte Observable ännern.

```python
theta = Parameter("$\\theta$")

chsh_circuit = QuantumCircuit(2)
chsh_circuit.h(0)
chsh_circuit.cx(0, 1)
chsh_circuit.ry(theta, 0)
chsh_circuit.draw(output="mpl", idle_wires=False, style="iqp")
```

![Output of the previous code cell](/docs/images/tutorials/chsh-inequality/extracted-outputs/6c77e40a-0.avif)

### En List vun Phasenweerten maken, de later towiest warrt {#create-a-list-of-phase-values-to-be-assigned-later}

Nahdem du den parametriseerden CHSH-Schaltkrieg maakt hest, maakst du en List vun Phasenweerten, de den Schaltkrieg in den nächsten Stap towiest warrt. Du kannst den folgenden Kode bruken, üm en List vun 21 Phasenweerten vun $0$ bit $2 \pi$ mit glieken Afstand to maken, also $0$, $0.1 \pi$, $0.2 \pi$, ..., $1.9 \pi$, $2 \pi$.

```python
number_of_phases = 21
phases = np.linspace(0, 2 * np.pi, number_of_phases)
# Phases need to be expressed as list of lists in order to work
individual_phases = [[ph] for ph in phases]
```

### Observablen {#observables}

Nu bruken wi Observablen, ut de wi de Verwachtungsweerten berekenen künnt. In uns Fall bekieken wi orthogonale Basen för jeedeen Qubit, wobei de parametriseerde $Y$-Rotation för dat eerste Qubit de Meetbasis bienah kontinueerlich in Bezug op de Basis vun dat tweete Qubit variëert. Wi wählt doröm de Observablen $ZZ$, $ZX$, $XZ$ un $XX$.

```python
# <CHSH1> = <AB> - <Ab> + <aB> + <ab> -> <ZZ> - <ZX> + <XZ> + <XX>
observable1 = SparsePauliOp.from_list(
    [("ZZ", 1), ("ZX", -1), ("XZ", 1), ("XX", 1)]
)

# <CHSH2> = <AB> + <Ab> - <aB> + <ab> -> <ZZ> + <ZX> - <XZ> + <XX>
observable2 = SparsePauliOp.from_list(
    [("ZZ", 1), ("ZX", 1), ("XZ", -1), ("XX", 1)]
)
```

## Stap 2: Problem för de Utföhren op Quantenhardware optimieren {#step-2-optimize-problem-for-quantum-hardware-execution}
Üm de Gesamtutföhrenstiet vun den Job to reduzeeren, akzepteert V2-Primitiven bloots Schaltkringe un Observablen, de de vun dat Zielsystem ünnerstütten Anwiesen un de Konnektivität entsprecken (bezeichnt as Instruction Set Architecture (ISA)-Schaltkringe un -Observablen).
### ISA-Schaltkrieg {#isa-circuit}

```python
target = backend.target
pm = generate_preset_pass_manager(target=target, optimization_level=3)

chsh_isa_circuit = pm.run(chsh_circuit)
chsh_isa_circuit.draw(output="mpl", idle_wires=False, style="iqp")
```

![Output of the previous code cell](/docs/images/tutorials/chsh-inequality/extracted-outputs/9a5561eb-0.avif)

### ISA-Observablen {#isa-observables}
Ebenso mööt wi de Observablen transformeeren, üm se backend-kompatibel to maken, bevör wi Jobs mit [`Runtime Estimator V2`](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/estimator-v2#run) utföhren. Wi künnt de Transformation mit de `apply_layout`-Methode vun dat `SparsePauliOp`-Objekt döföhren.

```python
isa_observable1 = observable1.apply_layout(layout=chsh_isa_circuit.layout)
isa_observable2 = observable2.apply_layout(layout=chsh_isa_circuit.layout)
```

## Stap 3: Utföhren mit Qiskit-Primitiven {#step-3-execute-using-qiskit-primitives}

Üm dat hele Experiment in een enzelnen Oproop vun den [`Estimator`](https://docs.quantum-computing.ibm.com/api/qiskit-ibm-runtime/qiskit_ibm_runtime.EstimatorV2) uttöföhren.
Wi künnt en [Qiskit Runtime `Estimator`](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/estimator-v2)-Primitiv maken, üm uns Verwachtungsweerten to berekenen. De `EstimatorV2.run()`-Methode nimmt en Iterable vun `primitive unified blocs (PUBs)`. Jeedeen PUB is en Iterable in dat Format `(circuit, observables, parameter_values: Optional, precision: Optional)`.

```python
# To run on a local simulator:
# Use the StatevectorEstimator from qiskit.primitives instead.

estimator = Estimator(mode=backend)

pub = (
    chsh_isa_circuit,  # ISA circuit
    [[isa_observable1], [isa_observable2]],  # ISA Observables
    individual_phases,  # Parameter values
)

job_result = estimator.run(pubs=[pub]).result()
```

## Stap 4: Naverarbeiten un Trüchgaav vun dat Resultat in dat wünschte klassische Format {#step-4-post-process-and-return-result-in-desired-classical-format}

De Estimator gifft Verwachtungsweerten för beide Observablen trüch, $\langle ZZ \rangle - \langle ZX \rangle + \langle XZ \rangle + \langle XX \rangle$ un $\langle ZZ \rangle + \langle ZX \rangle - \langle XZ \rangle + \langle XX \rangle$.

```python
chsh1_est = job_result[0].data.evs[0]
chsh2_est = job_result[0].data.evs[1]
```

```python
fig, ax = plt.subplots(figsize=(10, 6))

# results from hardware
ax.plot(phases / np.pi, chsh1_est, "o-", label="CHSH1", zorder=3)
ax.plot(phases / np.pi, chsh2_est, "o-", label="CHSH2", zorder=3)

# classical bound +-2
ax.axhline(y=2, color="0.9", linestyle="--")
ax.axhline(y=-2, color="0.9", linestyle="--")

# quantum bound, +-2√2
ax.axhline(y=np.sqrt(2) * 2, color="0.9", linestyle="-.")
ax.axhline(y=-np.sqrt(2) * 2, color="0.9", linestyle="-.")
ax.fill_between(phases / np.pi, 2, 2 * np.sqrt(2), color="0.6", alpha=0.7)
ax.fill_between(phases / np.pi, -2, -2 * np.sqrt(2), color="0.6", alpha=0.7)

# set x tick labels to the unit of pi
ax.xaxis.set_major_formatter(tck.FormatStrFormatter("%g $\\pi$"))
ax.xaxis.set_major_locator(tck.MultipleLocator(base=0.5))

# set labels, and legend
plt.xlabel("Theta")
plt.ylabel("CHSH witness")
plt.legend()
plt.show()
```

![Output of the previous code cell](/docs/images/tutorials/chsh-inequality/extracted-outputs/f6267448-0.avif)

In de Afbilden grenzen de Lienen un grau Bereiche de Grenzen af; de bütterste (strich-punkteerte) Lienen begrenzen de Quantengrenzen ($\pm 2$), während de binneren (strichelte) Lienen de klassischen Grenzen ($\pm 2\sqrt{2}$) begrenzen. Du kannst sehn, dat dat Bereiche gifft, wo de CHSH-Tüüggrötte de klassischen Grenzen överschriett. Glückwunsch! Du hest mit Erfolg de Verletzen vun de CHSH-Ungliektiet in'n echten Quantensystem wiest!
## Tutorial-Ümmfraag {#tutorial-survey}

Bitte maak bi disse korte Ümmfraag mit, üm Feedback to dit Tutorial to geven. Dien Insiichten helpt uns, uns Inholdsangeboden un Brukererfohren to verbetern.

[Link to de Ümmfraag](https://your.feedback.ibm.com/jfe/form/SV_3xxAgm1SF1wGp9k)
