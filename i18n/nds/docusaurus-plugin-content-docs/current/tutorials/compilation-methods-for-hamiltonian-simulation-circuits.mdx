---
title: "Kompileer-Methoden för Hamiltonian-Simulatschoons-Schaltkresen"
sidebar_label: "Kompileer-Methoden för Hamiltonian-Simulatschoons-Schaltkresen"
description: "Düsse Tutorial gifft en vergliekenden Övverblick över dree Kompileer-Methoden in Qiskit för Hamiltonian-Simulatschoons-Workloads."
notebook_path: "docs/tutorials/compilation-methods-for-hamiltonian-simulation-circuits.ipynb"
---
{/* doqumentation-source-hash: ff66bde1 */}

<OpenInLabBanner notebookPath="docs/tutorials/compilation-methods-for-hamiltonian-simulation-circuits.ipynb" />



Schätzte QPU-Bruuktiid: In düssen Tutorial is keen Utföhrung maakt wurrn, weil dat Swerpunkt op'n Transpilatschoons-Prozess liggt.

{/* cspell:ignore Rustiq, nshuffles, edgecolors, edgecolor, Hamlib, Benchpress, Brugière, Goubault, Martiel, Dubal, Lishman, Ivrii, fontweight, fontsize, textprops, wedgeprops, startangle, autopct */}
## Achtergrund {#background}

De Kompileerung vun Quantenschaltkresen is en wichtigen Schritt in'n Quantencomputing-Workflow. Dorbi warrt en hoochnivelligi Quantenalgorithmus in en physikalischen Quantenschaltkreis ümwannelt, de de Begren­sungen vun de Zielhardware inhoolt. En effektive Kompileerung kann de Leistung vun Quantenalgorithmen markant verbätern, indeem Schaltkreisdeepte, Gate-Tall un Utföhrungstied verringert warrt. Düsse Tutorial utforscht dree verschedene Ansätz för de Kompileerung vun Quantenschaltkresen in Qiskit un wiest ehr Stärken un Toopassungen ahn hande Bispelen.

De Sinn vun düssen Tutorial is, Bruukers to lehrn, wo man dree Kompileer-Methoden in Qiskit anwennt un bewertet: den SABRE-Transpiler, den KI-ünner­stütten Transpiler un dat Rustiq-Plugin. Bruukers lehrt, wo man jede Methode effiziënt bruukt un wo man ehr Leistung quer dör verschedene Quantenschaltkresen benchmarkt. Am Enne vun düssen Tutorial warrt du in'n Stand wesen, Kompileer-Stratiegien noh spezifische Optimeerungs-Zielen — as Verringern vun Schaltkreisdeepte, Minimeerung vun Gate-Tall oder Verbätern vun de Lauftiid — uttowählen un torücht to sniiden.

### Wat du lehren deist {#what-you-will-learn}
- **Wo man den Qiskit-Transpiler mit SABRE för Layout- un Routing-Optimeerung bruukt.**
- **Wo man den KI-Transpiler för vörut automatiseerte Schaltkreis-Optimeerung insetzen deit.**
- **Wo man dat Rustiq-Plugin för Schaltkresen bruukt, de präzise Synthesis vun Operatschonen verlangt, besünners bi Hamiltonian-Simulatschoons-Opgaven.**

Düsse Tutorial bruukt dree Bispeel-Schaltkresen noh den [Qiskit-Patterns](/guides/intro-to-patterns)-Workflow, üm de Leistung vun jede Kompileer-Methode to illus­treeren. Am Enne vun düssen Tutorial bist du upstellt, de toogepaste Kompileer-Strategie noh dienen spezifischen Anforderungen un Begrensungen uttowählen.

### Övverblick över de Kompileer-Methoden {#compilation-methods-overview}

#### 1. **Qiskit-Transpiler mit SABRE** {#qiskit-transpiler-with-sabre}
De Qiskit-Transpiler bruukt den SABRE-Algorithmus (SWAP-based BidiREctional heuristic search) üm Schaltkreis-Layout un Routing to optimeren. SABRE konzentriert sik op dat Minimeerung vun SWAP-Gates un ehr Inwerken op de Schaltkreisdeepte, ünner Inholden vun de Hardware-Verbindungs-Begrensungen. Düsse Methode is hooggradig vielsietig un gannig för allgemeine Schaltkreis-Optimeerung, un giff en guden Kompromiss twischen Leistung un Rekenowand. Üm vun de niesten Verbäterungen in SABRE, beschreven in [\[1\]](https://arxiv.org/abs/2409.08368), profiteeren to döhren, kannst du de Tall vun Versuken erhögen (to'n Bispeel `layout_trials=400, swap_trials=400`). För düssen Tutorial bruukt wi de Standardweerten för de Versuk-Tall, üm mit Qiskits Standard-Transpiler to vergliek. De Vördelen un Parameterutfors­chung vun SABRE warrt in en aparten [Deepdive-Tutorial](/tutorials/transpilation-optimizations-with-sabre) behandelt.

#### 2. **KI-Transpiler** {#ai-transpiler}

De KI-ünnerstütte Transpiler in Qiskit bruukt maschinelles Lehrn, üm optimale Transpilatschoons-Stratiegien vorhertoseggen, indeem Muster in Schaltkreis-Struktuur un Hardware-Begrensungen analyseert warrt, üm de beste Sequenz vun Optimeerungen för en geevene Ingaav uttowählen. Düsse Methode is besünners effektiv för grootmaßtavige Quantenschaltkresen un beed en hoogh Graad an Automatiseerung un Anpassungsfähigkeit för verschiedenartige Problemtypen. Botter as de allgemeine Schaltkreis-Optimeerung kann de KI-Transpiler mit den `AIPauliNetworkSynthesis`-Pass bruukt warden, de op Pauli-Netzwerkschaltkresen — Blöcke ut H, S, SX, CX, RX, RY un RZ Gates — sikfokusseert un en op Verstärkungslehrn baseerden Synthesis-Ansatz anwennt. Mehr Informatschoon över den KI-Transpiler un siene Synthesis-Stratiegien findt sik in [\[2\]](https://arxiv.org/abs/2405.13196) un [\[3\]](https://arxiv.org/abs/2503.14448).

#### 3. **Rustiq-Plugin** {#rustiq-plugin}
Dat Rustiq-Plugin föhrt vörute Synthesis-Techniken speziëll för `PauliEvolutionGate`-Operatschonen en, de Pauli-Rotatschonen darstellt, de gemeensam in trotterisierten Dynamiken bruukt warrt. Düsse Plugin is wertbar för Schaltkresen, de Hamiltonian-Simulatschoon implementeert, as de in Quantenchemie- un Physik-Problemen bruukt warrt, wo nauwkaarige Pauli-Rotatschonen wesentlich sünd, üm Problem-Hamiltonians effiziënt to simuleren. Rustiq beed präzise, deeptenarme Schaltkreis-Synthesis för düsse spezialiseerden Operatschonen. Mehr Details över de Implementeerung un Leistung vun Rustiq findt sik in [\[4\]](https://arxiv.org/abs/2404.03280).

Dörch dat Utforschen vun düsse Kompileer-Methoden in Deepte gifft düsse Tutorial Bruukers de Warktüch an de Hand, üm de Leistung vun ehr Quantenschaltkresen to verbätern un den Weg för effiziëntere un praktischere Quantenberechnungen to banen.

## Anforderungen {#requirements}

Vörn Anfangen vun düssen Tutorial stell seker, dat du folgendes installiert hest:
- Qiskit SDK v1.3 oder nieger, mit [Visualiseerungs](https://docs.quantum.ibm.com/api/qiskit/visualization)-Ünnerstüttung
- Qiskit Runtime v0.28 oder nieger (`pip install qiskit-ibm-runtime`)
- Qiskit IBM Transpiler (`pip install qiskit-ibm-transpiler`)
- Qiskit AI Transpiler Local Mode (`pip install qiskit_ibm_ai_local_transpiler`)
- Networkx Graph-Bibliothek (`pip install networkx`)

## Upstellen {#setup}

```python
# Added by doQumentation — installs packages not in the Binder environment
%pip install -q qiskit-ibm-transpiler
```

```python
from qiskit.circuit import QuantumCircuit
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit.circuit.library import (
    efficient_su2,
    PauliEvolutionGate,
)
from qiskit_ibm_transpiler import generate_ai_pass_manager
from qiskit.quantum_info import SparsePauliOp
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit.transpiler.passes.synthesis.high_level_synthesis import HLSConfig
from collections import Counter
from IPython.display import display
import time
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import json
import requests
import logging

# Suppress noisy loggers
logging.getLogger(
    "qiskit_ibm_transpiler.wrappers.ai_local_synthesis"
).setLevel(logging.ERROR)

seed = 42  # Seed for reproducibility
```

## Deel 1: Efficient-SU2-Schaltkreis {#part-1-efficient-su2-circuit}

### Schritt 1: Klassische Ingaaven op en Quantenproblem afbillen {#step-1-map-classical-inputs-to-a-quantum-problem}

In düssen Afsnitt utforscht wi den `efficient_su2`-Schaltkreis, en hardware-effiziënten Ansatz, de gemeensam in variatschonellen Quantenalgorithmen (as VQE) un Quantenmaschinenlehrn-Opgaven bruukt warrt. De Schaltkreis besteiht ut afwisselnd Schichten vun Einzelqubit-Rotatschonen un verschränkenden Gates, de in en rundes Muster anordnet sünd, un is entworpen, üm den Quantentostands-Raum effiziënt to utforschen, ünner Inholden vun en handelliche Deepte.

Wi fangt dormit an, en `efficient_su2`-Schaltkreis to konstrueern, üm to wisen, wo man verschedene Kompileer-Methoden vergliekt. Noh Deel 1 warrt wi unsere Analysenop en grötteren Satz vun Schaltkresen utwiiden, wat en üm­fassendes Benchmark för dat Bewerten vun de Leistung vun verschiedenen Kompileer-Techniken mööglich maakt.

```python
qubit_size = list(range(10, 101, 10))
qc_su2_list = [
    efficient_su2(n, entanglement="circular", reps=1)
    .decompose()
    .copy(name=f"SU2_{n}")
    for n in qubit_size
]

# Draw the first circuit
qc_su2_list[0].draw(output="mpl")
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/f362cdac-94d8-4cc5-85f4-015c3d9eba3a-0.avif)

### Schritt 2: Problem för Quantenhardware-Utföhrung optimeren {#step-2-optimize-problem-for-quantum-hardware-execution}

Düsse Schritt is dat Hauptfokus vun'n Tutorial. Hier wiilt wi Quantenschaltkresen för en effiziënte Utföhrung op echter Quantenhardware optimeren. Unse Hauptziel is dat Verringern vun Schaltkreisdeepte un Gate-Tall — dat sünd de Slüttelfaktoren för dat Verbätern vun de Utföhrungs-Trüwheit un dat Mildern vun Hardware-Rüschen.

- **SABRE-Transpiler**: Bruukt Qiskits Standard-Transpiler mit den SABRE-Layout- un Routing-Algorithmus.
- **KI-Transpiler (lokaler Modus)**: Den Standard-KI-ünnerstütten Transpiler mit lokaler Inferenz un der Standard-Synthesis-Strategie.
- **Rustiq-Plugin**: En Transpiler-Plugin, dat för deeptenarme Kompileerung speziëll för Hamiltonian-Simulatschoons-Opgaven entworpen wurrn is.

Dat Ziel vun düssen Schritt is, de Resultaten vun düsse Methoden in Bezug op Schaltkreisdeepte un Gate-Tall vun'n transpilierten Schaltkreis to vergliek. En anners wichtigen Metrik, de wi berücksich­tigt, is de Transpilatschoons-Lauftiid. Dörch dat Analyseern vun düsse Metriken köhnt wi de relatieven Stärken vun jede Methode bewertten un besluten, welke de effiziëntesten Schaltkreis för de Utföhrung op de uterwählte Hardware prodüzeert.

Henwies: För dat anfängliche SU2-Schaltkreis-Bispeel verglikt wi allens den SABRE-Transpiler mit den Standard-KI-Transpiler. Bi dat nohfolgende Benchmark mit Hamlib-Schaltkresen warrt wi jichterwol all dree Transpilatschoons-Methoden vergliken.

```python
# QiskitRuntimeService.save_account(channel="ibm_quantum_platform", token="<YOUR-API-KEY>", overwrite=True, set_as_default=True)
service = QiskitRuntimeService(channel="ibm_quantum_platform")
backend = service.backend("ibm_torino")
print(f"Using backend: {backend}")
```

```text
qiskit_runtime_service._get_crn_from_instance_name:WARNING:2025-07-30 21:46:30,843: Multiple instances found. Using all matching instances.
```

```text
Using backend: <IBMBackend('ibm_torino')>
```

Qiskit-Transpiler mit SABRE:

```python
pm_sabre = generate_preset_pass_manager(
    optimization_level=3, backend=backend, seed_transpiler=seed
)
```

KI-Transpiler:

```python
# Standard AI transpiler pass manager, using the local mode
pm_ai = generate_ai_pass_manager(
    backend=backend, optimization_level=3, ai_optimization_level=3
)
```

Rustiq-Plugin:

```python
hls_config = HLSConfig(
    PauliEvolution=[
        (
            "rustiq",
            {
                "nshuffles": 400,
                "upto_phase": True,
                "fix_clifford": True,
                "preserve_order": False,
                "metric": "depth",
            },
        )
    ]
)
pm_rustiq = generate_preset_pass_manager(
    optimization_level=3,
    backend=backend,
    hls_config=hls_config,
    seed_transpiler=seed,
)
```

#### Transpileren un Metriken opholen {#transpile-and-capture-metrics}

Üm de Leistung vun de Kompileer-Methoden to vergliken, defineert wi en Funkschoon, de den Ingaav-Schaltkreis transpiliert un relevante Metriken op en konsistente Art un Wiese ophoolt. Dat hett de totale Schaltkreisdeepte, de gesamt Gate-Tall un de Transpilatschoons-Tiid.

Botter as düsse Standardmetriken nohmt wi ook de 2-Qubit-Gate-Deepte op, de en besünners wichtige Metrik bi't Bewerten vun de Utföhrung op Quantenhardware is. In Gegensatz to de totale Deepte, de all Gates umfattt, wedderspegelt de 2-Qubit-Deepte nauwer de *tatsächliche* Utföhrungs­dauer op'n Hardware. Dat liegt dooran, dat 2-Qubit-Gates in den meisten Quantengeräten de Tiid- un Fehler­budget domineet. Dat Minimieren vun de 2-Qubit-Deepte is doromm entscheidend för dat Verbätern vun de Trüwheit un dat Verringern vun Dekohärenz-Effekten tijdens de Utföhrung.

Wi bruukt düsse Funkschoon, üm de Leistung vun de verschiedenen Kompileer-Methoden quer dör mehrere Schaltkresen to analyseern.

```python
def capture_transpilation_metrics(
    results, pass_manager, circuits, method_name
):
    """
    Capture transpilation metrics for a list of circuits and stores the results in a DataFrame.

    Args:
        results (pd.DataFrame): DataFrame to store the results.
        pass_manager: Pass manager used for transpilation.
        circuits (list): List of quantum circuits to transpile.
        method_name (str): Name of the transpilation method.

    Returns:
        list: List of transpiled circuits.
    """
    transpiled_circuits = []

    for i, qc in enumerate(circuits):
        # Transpile the circuit
        start_time = time.time()
        transpiled_qc = pass_manager.run(qc)
        end_time = time.time()

        # Needed for AI transpiler to be consistent with other methods
        transpiled_qc = transpiled_qc.decompose(gates_to_decompose=["swap"])

        # Collect metrics
        transpilation_time = end_time - start_time
        circuit_depth = transpiled_qc.depth(
            lambda x: x.operation.num_qubits == 2
        )
        circuit_size = transpiled_qc.size()

        # Append results to DataFrame
        results.loc[len(results)] = {
            "method": method_name,
            "qc_name": qc.name,
            "qc_index": i,
            "num_qubits": qc.num_qubits,
            "ops": transpiled_qc.count_ops(),
            "depth": circuit_depth,
            "size": circuit_size,
            "runtime": transpilation_time,
        }
        transpiled_circuits.append(transpiled_qc)
        print(
            f"Transpiled circuit index {i} ({qc.name}) in {transpilation_time:.2f} seconds with method {method_name}, "
            f"depth {circuit_depth}, and size {circuit_size}."
        )

    return transpiled_circuits
```

```python
results_su2 = pd.DataFrame(
    columns=[
        "method",
        "qc_name",
        "qc_index",
        "num_qubits",
        "ops",
        "depth",
        "size",
        "runtime",
    ]
)

tqc_sabre = capture_transpilation_metrics(
    results_su2, pm_sabre, qc_su2_list, "sabre"
)
tqc_ai = capture_transpilation_metrics(results_su2, pm_ai, qc_su2_list, "ai")
```

```text
Transpiled circuit index 0 (SU2_10) in 0.06 seconds with method sabre, depth 13, and size 167.
Transpiled circuit index 1 (SU2_20) in 0.24 seconds with method sabre, depth 20, and size 299.
Transpiled circuit index 2 (SU2_30) in 10.72 seconds with method sabre, depth 72, and size 627.
Transpiled circuit index 3 (SU2_40) in 16.16 seconds with method sabre, depth 40, and size 599.
Transpiled circuit index 4 (SU2_50) in 76.89 seconds with method sabre, depth 77, and size 855.
Transpiled circuit index 5 (SU2_60) in 86.12 seconds with method sabre, depth 60, and size 899.
Transpiled circuit index 6 (SU2_70) in 94.46 seconds with method sabre, depth 79, and size 1085.
Transpiled circuit index 7 (SU2_80) in 69.05 seconds with method sabre, depth 80, and size 1199.
Transpiled circuit index 8 (SU2_90) in 88.25 seconds with method sabre, depth 105, and size 1420.
Transpiled circuit index 9 (SU2_100) in 83.80 seconds with method sabre, depth 100, and size 1499.
Transpiled circuit index 0 (SU2_10) in 0.17 seconds with method ai, depth 10, and size 168.
Transpiled circuit index 1 (SU2_20) in 0.29 seconds with method ai, depth 20, and size 299.
Transpiled circuit index 2 (SU2_30) in 13.56 seconds with method ai, depth 36, and size 548.
Transpiled circuit index 3 (SU2_40) in 15.95 seconds with method ai, depth 40, and size 599.
Transpiled circuit index 4 (SU2_50) in 80.70 seconds with method ai, depth 54, and size 823.
Transpiled circuit index 5 (SU2_60) in 75.99 seconds with method ai, depth 60, and size 899.
Transpiled circuit index 6 (SU2_70) in 64.96 seconds with method ai, depth 74, and size 1087.
Transpiled circuit index 7 (SU2_80) in 68.25 seconds with method ai, depth 80, and size 1199.
Transpiled circuit index 8 (SU2_90) in 75.07 seconds with method ai, depth 90, and size 1404.
Transpiled circuit index 9 (SU2_100) in 63.97 seconds with method ai, depth 100, and size 1499.
```

Antoogen vun de transpilierten Resultaten för een vun de Schaltkresen:

```python
print("Sabre transpilation")
display(tqc_sabre[0].draw("mpl", fold=-1, idle_wires=False))
print("AI transpilation")
display(tqc_ai[0].draw("mpl", fold=-1, idle_wires=False))
```

```text
Sabre transpilation
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/37924fc2-8fb6-451a-b8f9-cd79573f2384-1.avif)

```text
AI transpilation
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/37924fc2-8fb6-451a-b8f9-cd79573f2384-3.avif)

Ergebnistabelle:

```python
summary_su2 = (
    results_su2.groupby("method")[["depth", "size", "runtime"]]
    .mean()
    .round(2)
)
print(summary_su2)

results_su2
```

```text
depth   size  runtime
method
ai       56.4  852.5    45.89
sabre    64.6  864.9    52.57
```

```text
method  qc_name  qc_index  num_qubits                                ops  \
0   sabre   SU2_10         0          10     {'rz': 81, 'sx': 70, 'cz': 16}
1   sabre   SU2_20         1          20   {'rz': 160, 'sx': 119, 'cz': 20}
2   sabre   SU2_30         2          30   {'sx': 295, 'rz': 242, 'cz': 90}
3   sabre   SU2_40         3          40   {'rz': 320, 'sx': 239, 'cz': 40}
4   sabre   SU2_50         4          50   {'rz': 402, 'sx': 367, 'cz': 86}
5   sabre   SU2_60         5          60   {'rz': 480, 'sx': 359, 'cz': 60}
6   sabre   SU2_70         6          70   {'rz': 562, 'sx': 441, 'cz': 82}
7   sabre   SU2_80         7          80   {'rz': 640, 'sx': 479, 'cz': 80}
8   sabre   SU2_90         8          90  {'rz': 721, 'sx': 585, 'cz': 114}
9   sabre  SU2_100         9         100  {'rz': 800, 'sx': 599, 'cz': 100}
10     ai   SU2_10         0          10     {'rz': 81, 'sx': 71, 'cz': 16}
11     ai   SU2_20         1          20   {'rz': 160, 'sx': 119, 'cz': 20}
12     ai   SU2_30         2          30   {'sx': 243, 'rz': 242, 'cz': 63}
13     ai   SU2_40         3          40   {'rz': 320, 'sx': 239, 'cz': 40}
14     ai   SU2_50         4          50   {'rz': 403, 'sx': 346, 'cz': 74}
15     ai   SU2_60         5          60   {'rz': 480, 'sx': 359, 'cz': 60}
16     ai   SU2_70         6          70   {'rz': 563, 'sx': 442, 'cz': 82}
17     ai   SU2_80         7          80   {'rz': 640, 'sx': 479, 'cz': 80}
18     ai   SU2_90         8          90  {'rz': 721, 'sx': 575, 'cz': 108}
19     ai  SU2_100         9         100  {'rz': 800, 'sx': 599, 'cz': 100}

    depth  size    runtime
0      13   167   0.058845
1      20   299   0.238217
2      72   627  10.723922
3      40   599  16.159262
4      77   855  76.886604
5      60   899  86.118255
6      79  1085  94.458287
7      80  1199  69.048184
8     105  1420  88.254809
9     100  1499  83.795482
10     10   168   0.171532
11     20   299   0.291691
12     36   548  13.555931
13     40   599  15.952733
14     54   823  80.702141
15     60   899  75.993404
16     74  1087  64.960162
17     80  1199  68.253280
18     90  1404  75.072412
19    100  1499  63.967446
```

#### Ergebnisgrafik {#results-graph}

Wiel wi en Funkschoon to konsistentem Opholen vun Metriken defineert, defineert wi ook een to'n Grafischen Darstellen vun de Metriken. Hier plottet wi de 2-Qubit-Deepte, de Gate-Tall un de Lauftiid för jede Kompileer-Methode quer dör de Schaltkresen.

```python
def plot_transpilation_metrics(results, overall_title, x_axis="qc_index"):
    """
    Plots transpilation metrics (depth, size, runtime) for different transpilation methods.

    Parameters:
        results (DataFrame): Data containing columns ['num_qubits', 'method', 'depth', 'size', 'runtime']
        overall_title (str): The title of the overall figure.
        x_axis (str): The x-axis label, either 'num_qubits' or 'qc_index'.
    """

    fig, axs = plt.subplots(1, 3, figsize=(24, 6))
    metrics = ["depth", "size", "runtime"]
    titles = ["Circuit Depth", "Circuit Size", "Transpilation Runtime"]
    y_labels = ["Depth", "Size (Gate Count)", "Runtime (s)"]

    methods = results["method"].unique()
    colors = plt.colormaps["tab10"]
    markers = ["o", "^", "s", "D", "P", "*", "X", "v"]
    color_list = [colors(i % colors.N) for i in range(len(methods))]
    color_map = {method: color_list[i] for i, method in enumerate(methods)}
    marker_map = {
        method: markers[i % len(markers)] for i, method in enumerate(methods)
    }
    jitter_factor = 0.1  # Small x-axis jitter for visibility
    handles, labels = [], []  # Unique handles for legend

    # Plot each metric
    for i, metric in enumerate(metrics):
        for method in methods:
            method_data = results[results["method"] == method]

            # Introduce slight jitter to avoid exact overlap
            jitter = np.random.uniform(
                -jitter_factor, jitter_factor, len(method_data)
            )

            scatter = axs[i].scatter(
                method_data[x_axis] + jitter,
                method_data[metric],
                color=color_map[method],
                label=method,
                marker=marker_map[method],
                alpha=0.7,
                edgecolors="black",
                s=80,
            )

            if method not in labels:
                handles.append(scatter)
                labels.append(method)

        axs[i].set_title(titles[i])
        axs[i].set_xlabel(x_axis)
        axs[i].set_ylabel(y_labels[i])
        axs[i].grid(axis="y", linestyle="--", alpha=0.7)
        axs[i].tick_params(axis="x", rotation=45)
        axs[i].set_xticks(sorted(results[x_axis].unique()))

    fig.suptitle(overall_title, fontsize=16)
    fig.legend(
        handles=handles,
        labels=labels,
        loc="upper right",
        bbox_to_anchor=(1.05, 1),
    )

    plt.tight_layout()
    plt.show()
```

```python
plot_transpilation_metrics(
    results_su2, "Transpilation Metrics for SU2 Circuits", x_axis="num_qubits"
)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/7f7b502a-8ed6-45fa-a698-02977149e283-0.avif)

#### Analysen vun de SU2-Schaltkreis-Kompileer-Resultaten {#analysis-of-su2-circuit-compilation-results}

In düssen Experiment verglikt wi twee Transpilatschoons-Methoden — Qiskits SABRE-Transpiler un den KI-ünnerstütten Transpiler — op en Satz vun `efficient_su2`-Schaltkresen. Weil düsse Schaltkresen keen `PauliEvolutionGate`-Operatschonen enthöllt, is dat Rustiq-Plugin in düssen Vergliek nich mitnahmen wurrn.

Middlmäßig snitt de KI-Transpiler in Bezug op Schaltkreisdeepte bäter af, mit en Verbäterung vun mehr as 10 % quer dör de gesamte Bandbreed vun SU2-Schaltkresen. För Gate-Tall (Schaltkreisgrötte) un Transpilatschoons-Lauftiid leevern beide Methoden insgesamt ähnliche Resultaten.

Aber wenn man de einzelnen Datenpunkten nauer bekickt, warrt en deepere Inblick sichtbar:
- För de meisten Qubit-Grötten prodüzeert sowohl SABRE as ook KI nahezu identische Resultaten, wat dorop hindüüt, dat beide Methoden in vielen Fällen to ähnlich effiziënten Lösungen konvergeert.
- För bestimmte Schaltkreisgrötten — konkret bi 30, 50, 70 un 90 Qubits — finnt de KI-Transpiler markant flattigere Schaltkresen as SABRE. Dat wiest, dat KIs lehrbaseerter Ansatz in'n Stand is, optimaalere Layouts oder Routing-Wege to entdecken, in Fällen wo SABRE-Heuristik dat nich schafft.

Düsse Bevöörring hecht en wichtige Erkenntniss ünner:
> Wüllt SABRE un KI vaak vergliekbare Resultaten prodüzeert, kann de KI-Transpiler manchmal völ bätere Lösungen entdecken, besünners in Bezug op Deepte, wat to en markant verbäterte Leistung op'n Hardware führen kann.

## Deel 2: Hamiltonian-Simulatschoons-Schaltkreis {#part-2-hamiltonian-simulation-circuit}

### Schritt 1: Schaltkresen mit `PauliEvolutionGate` utforschen {#step-1-investigate-circuits-with-paulievolutiongate}

In düssen Afsnitt utforscht wi Quantenschaltkresen, de mit `PauliEvolutionGate` konstrueert wurrn sünd, dat de effiziënte Simulatschoon vun Hamiltonians ermöglicht. Wi analyseert, wo verschedene Kompileer-Methoden düsse Schaltkresen quer dör verschiedene Hamiltonians optimert.

#### Hamiltonians, de in'n Benchmark bruukt warrt {#hamiltonians-used-in-the-benchmark}

De Hamiltonians, de in düssen Benchmark bruukt warrt, beschrivt Paarweis-Wechselwirkungen twischen Qubits, ok Terme as $ZZ$, $XX$ un $YY$. Düsse Hamiltonians warrt gemeensam in Quantenchemie, Kondensierte-Materie-Physik un Materialwissenschaften bruukt, wo se Systemen vun wechselwirkenden Teilchen modelleert.

To Hinwies köhnt Bruukers en breedere Satz vun Hamiltonians in düssen Artikel utforschen: [Efficient Hamiltonian Simulation on Noisy Quantum Devices](https://arxiv.org/pdf/2306.13126).

#### Benchmark-Quelle: Hamlib un Benchpress {#benchmark-source-hamlib-and-benchpress}

De Schaltkresen, de in düssen Benchmark bruukt warrt, stammt ut dat [Hamlib-Benchmark-Repository](https://github.com/SRI-International/QC-App-Oriented-Benchmarks/tree/master/hamlib), dat realistische Hamiltonian-Simulatschoons-Workloads enthöllt.

Düsse sülven Schaltkresen wurrn vörher mit [Benchpress](https://github.com/Qiskit/benchpress) benchmarkt, en Open-Source-Rahmenwerk för dat Bewerten vun de Quantentranspilatschoons-Leistung. Dörch dat Bruuken vun düssen standardisierten Satz vun Schaltkresen köhnt wi de Effektivität vun verschiedenen Kompileer-Stratiegien op repräsentativen Simulatschoons-Problemen direkt vergliek.

Hamiltonian-Simulatschoon is en grundleggende Opgave in'n Quantencomputing, mit Toopassungen in Molekülsimulationen, Optimeerungsproblemen un Quanten-Vielteilchenphysik. Dat Verstehn, wo verschedene Kompileer-Methoden düsse Schaltkresen optimert, kann Bruukers helpen, de praktische Utföhrung vun solken Schaltkresen op Quantengeräten vun de niegen Tid to verbätern.

```python
# Obtain the Hamiltonian JSON from the benchpress repository
url = "https://raw.githubusercontent.com/Qiskit/benchpress/e7b29ef7be4cc0d70237b8fdc03edbd698908eff/benchpress/hamiltonian/hamlib/100_representative.json"
response = requests.get(url)
response.raise_for_status()  # Raise an error if download failed
ham_records = json.loads(response.text)
# Remove circuits that are too large for the backend
ham_records = [
    h for h in ham_records if h["ham_qubits"] <= backend.num_qubits
]
# Remove the circuits that are large to save transpilation time
ham_records = sorted(ham_records, key=lambda x: x["ham_terms"])[:35]

qc_ham_list = []
for h in ham_records:
    terms = h["ham_hamlib_hamiltonian_terms"]
    coeff = h["ham_hamlib_hamiltonian_coefficients"]
    num_qubits = h["ham_qubits"]
    name = h["ham_problem"]

    evo_gate = PauliEvolutionGate(SparsePauliOp(terms, coeff))

    qc_ham = QuantumCircuit(num_qubits)
    qc_ham.name = name

    qc_ham.append(evo_gate, range(num_qubits))
    qc_ham_list.append(qc_ham)
print(f"Number of Hamiltonian circuits: {len(qc_ham_list)}")

# Draw the first Hamiltonian circuit
qc_ham_list[0].draw("mpl", fold=-1)
```

```text
Number of Hamiltonian circuits: 35
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/66347c00-1607-4405-bb76-610690adf6b8-1.avif)

### Schritt 2: Problem för Quantenhardware-Utföhrung optimeren {#step-2-optimize-problem-for-quantum-hardware-execution-2}

As in't vörige Bispeel bruukt wi denselven Backend, üm Konsistenz in unsere Vergliken to sichern. Weil de Pass-Manager (`pm_sabre`, `pm_ai` un `pm_rustiq`) al initialiseert wurrn sünd, köhnt wi direkt dormit anfangen, de Hamiltonian-Schaltkresen mit jede Methode to transpileren.

Düsse Schritt konzentriert sik allens op dat Döhrföhren vun de Transpilatschoon un dat Opnehmen vun de resultierenden Schaltkreis-Metriken, ok Deepte, Gate-Tall un Transpilatschoons-Lauftiid. Dörch dat Analyseern vun düsse Resultaten wüllt wi de Effizienz vun jede Transpilatschoons-Methode för düssen Schaltkreistyp bestimmen.
Transpileren un Metriken opholen:

```python
results_ham = pd.DataFrame(
    columns=[
        "method",
        "qc_name",
        "qc_index",
        "num_qubits",
        "ops",
        "depth",
        "size",
        "runtime",
    ]
)

tqc_sabre = capture_transpilation_metrics(
    results_ham, pm_sabre, qc_ham_list, "sabre"
)
tqc_ai = capture_transpilation_metrics(results_ham, pm_ai, qc_ham_list, "ai")
tqc_rustiq = capture_transpilation_metrics(
    results_ham, pm_rustiq, qc_ham_list, "rustiq"
)
```

```text
Transpiled circuit index 0 (all-vib-o3) in 0.02 seconds with method sabre, depth 6, and size 58.
Transpiled circuit index 1 (all-vib-c2h) in 1.10 seconds with method sabre, depth 2, and size 39.
Transpiled circuit index 2 (all-vib-bh) in 0.01 seconds with method sabre, depth 3, and size 30.
Transpiled circuit index 3 (all-vib-c2h) in 0.03 seconds with method sabre, depth 18, and size 115.
Transpiled circuit index 4 (graph-gnp_k-2) in 0.02 seconds with method sabre, depth 24, and size 129.
Transpiled circuit index 5 (all-vib-fccf) in 0.05 seconds with method sabre, depth 14, and size 134.
Transpiled circuit index 6 (all-vib-hno) in 8.39 seconds with method sabre, depth 6, and size 174.
Transpiled circuit index 7 (all-vib-bhf2) in 3.92 seconds with method sabre, depth 22, and size 220.
Transpiled circuit index 8 (LiH) in 0.03 seconds with method sabre, depth 67, and size 290.
Transpiled circuit index 9 (uf20-ham) in 0.04 seconds with method sabre, depth 50, and size 340.
Transpiled circuit index 10 (all-vib-fccf) in 0.62 seconds with method sabre, depth 30, and size 286.
Transpiled circuit index 11 (all-vib-fccf) in 0.04 seconds with method sabre, depth 67, and size 339.
Transpiled circuit index 12 (all-vib-ch2) in 0.04 seconds with method sabre, depth 87, and size 421.
Transpiled circuit index 13 (tfim) in 0.05 seconds with method sabre, depth 36, and size 222.
Transpiled circuit index 14 (all-vib-cyclo_propene) in 9.51 seconds with method sabre, depth 22, and size 345.
Transpiled circuit index 15 (graph-gnp_k-4) in 0.05 seconds with method sabre, depth 128, and size 704.
Transpiled circuit index 16 (all-vib-hc3h2cn) in 13.83 seconds with method sabre, depth 2, and size 242.
Transpiled circuit index 17 (TSP_Ncity-4) in 0.05 seconds with method sabre, depth 106, and size 609.
Transpiled circuit index 18 (tfim) in 0.29 seconds with method sabre, depth 73, and size 399.
Transpiled circuit index 19 (all-vib-h2co) in 21.97 seconds with method sabre, depth 30, and size 572.
Transpiled circuit index 20 (Be2) in 0.09 seconds with method sabre, depth 324, and size 1555.
Transpiled circuit index 21 (graph-complete_bipart) in 0.12 seconds with method sabre, depth 250, and size 1394.
Transpiled circuit index 22 (all-vib-f2) in 0.07 seconds with method sabre, depth 215, and size 1027.
Transpiled circuit index 23 (all-vib-cyclo_propene) in 41.22 seconds with method sabre, depth 30, and size 1144.
Transpiled circuit index 24 (TSP_Ncity-5) in 1.89 seconds with method sabre, depth 175, and size 1933.
Transpiled circuit index 25 (H2) in 0.32 seconds with method sabre, depth 1237, and size 5502.
Transpiled circuit index 26 (uuf100-ham) in 0.20 seconds with method sabre, depth 385, and size 4303.
Transpiled circuit index 27 (ham-graph-gnp_k-5) in 0.20 seconds with method sabre, depth 311, and size 3654.
Transpiled circuit index 28 (tfim) in 0.15 seconds with method sabre, depth 276, and size 3213.
Transpiled circuit index 29 (uuf100-ham) in 0.21 seconds with method sabre, depth 520, and size 5250.
Transpiled circuit index 30 (flat100-ham) in 0.15 seconds with method sabre, depth 131, and size 3157.
Transpiled circuit index 31 (uf100-ham) in 0.24 seconds with method sabre, depth 624, and size 7378.
Transpiled circuit index 32 (OH) in 0.88 seconds with method sabre, depth 2175, and size 9808.
Transpiled circuit index 33 (HF) in 0.66 seconds with method sabre, depth 2206, and size 9417.
Transpiled circuit index 34 (BH) in 0.89 seconds with method sabre, depth 2177, and size 9802.
Transpiled circuit index 0 (all-vib-o3) in 0.02 seconds with method ai, depth 6, and size 58.
Transpiled circuit index 1 (all-vib-c2h) in 1.11 seconds with method ai, depth 2, and size 39.
Transpiled circuit index 2 (all-vib-bh) in 0.01 seconds with method ai, depth 3, and size 30.
Transpiled circuit index 3 (all-vib-c2h) in 0.11 seconds with method ai, depth 18, and size 94.
Transpiled circuit index 4 (graph-gnp_k-2) in 0.11 seconds with method ai, depth 22, and size 129.
Transpiled circuit index 5 (all-vib-fccf) in 0.06 seconds with method ai, depth 22, and size 177.
Transpiled circuit index 6 (all-vib-hno) in 8.62 seconds with method ai, depth 10, and size 198.
Transpiled circuit index 7 (all-vib-bhf2) in 3.71 seconds with method ai, depth 18, and size 195.
Transpiled circuit index 8 (LiH) in 0.19 seconds with method ai, depth 62, and size 267.
Transpiled circuit index 9 (uf20-ham) in 0.22 seconds with method ai, depth 47, and size 321.
Transpiled circuit index 10 (all-vib-fccf) in 0.71 seconds with method ai, depth 38, and size 369.
Transpiled circuit index 11 (all-vib-fccf) in 0.24 seconds with method ai, depth 65, and size 315.
Transpiled circuit index 12 (all-vib-ch2) in 0.24 seconds with method ai, depth 91, and size 430.
Transpiled circuit index 13 (tfim) in 0.15 seconds with method ai, depth 12, and size 251.
Transpiled circuit index 14 (all-vib-cyclo_propene) in 8.50 seconds with method ai, depth 18, and size 311.
Transpiled circuit index 15 (graph-gnp_k-4) in 0.25 seconds with method ai, depth 117, and size 659.
Transpiled circuit index 16 (all-vib-hc3h2cn) in 16.11 seconds with method ai, depth 2, and size 242.
Transpiled circuit index 17 (TSP_Ncity-4) in 0.39 seconds with method ai, depth 98, and size 564.
Transpiled circuit index 18 (tfim) in 0.38 seconds with method ai, depth 23, and size 437.
Transpiled circuit index 19 (all-vib-h2co) in 24.97 seconds with method ai, depth 38, and size 707.
Transpiled circuit index 20 (Be2) in 1.07 seconds with method ai, depth 293, and size 1392.
Transpiled circuit index 21 (graph-complete_bipart) in 0.61 seconds with method ai, depth 229, and size 1437.
Transpiled circuit index 22 (all-vib-f2) in 0.57 seconds with method ai, depth 178, and size 964.
Transpiled circuit index 23 (all-vib-cyclo_propene) in 50.89 seconds with method ai, depth 34, and size 1425.
Transpiled circuit index 24 (TSP_Ncity-5) in 1.61 seconds with method ai, depth 171, and size 2020.
Transpiled circuit index 25 (H2) in 6.39 seconds with method ai, depth 1148, and size 5208.
Transpiled circuit index 26 (uuf100-ham) in 3.97 seconds with method ai, depth 376, and size 5048.
Transpiled circuit index 27 (ham-graph-gnp_k-5) in 3.54 seconds with method ai, depth 357, and size 4451.
Transpiled circuit index 28 (tfim) in 1.72 seconds with method ai, depth 216, and size 3026.
Transpiled circuit index 29 (uuf100-ham) in 4.45 seconds with method ai, depth 426, and size 5399.
Transpiled circuit index 30 (flat100-ham) in 7.02 seconds with method ai, depth 86, and size 3108.
Transpiled circuit index 31 (uf100-ham) in 12.85 seconds with method ai, depth 623, and size 8354.
Transpiled circuit index 32 (OH) in 15.19 seconds with method ai, depth 2084, and size 9543.
Transpiled circuit index 33 (HF) in 17.51 seconds with method ai, depth 2063, and size 9446.
Transpiled circuit index 34 (BH) in 15.33 seconds with method ai, depth 2094, and size 9730.
Transpiled circuit index 0 (all-vib-o3) in 0.02 seconds with method rustiq, depth 13, and size 83.
Transpiled circuit index 1 (all-vib-c2h) in 1.11 seconds with method rustiq, depth 2, and size 39.
Transpiled circuit index 2 (all-vib-bh) in 0.01 seconds with method rustiq, depth 3, and size 30.
Transpiled circuit index 3 (all-vib-c2h) in 0.01 seconds with method rustiq, depth 13, and size 79.
Transpiled circuit index 4 (graph-gnp_k-2) in 0.02 seconds with method rustiq, depth 31, and size 131.
Transpiled circuit index 5 (all-vib-fccf) in 0.04 seconds with method rustiq, depth 50, and size 306.
Transpiled circuit index 6 (all-vib-hno) in 14.03 seconds with method rustiq, depth 22, and size 276.
Transpiled circuit index 7 (all-vib-bhf2) in 3.15 seconds with method rustiq, depth 13, and size 155.
Transpiled circuit index 8 (LiH) in 0.03 seconds with method rustiq, depth 54, and size 270.
Transpiled circuit index 9 (uf20-ham) in 0.04 seconds with method rustiq, depth 65, and size 398.
Transpiled circuit index 10 (all-vib-fccf) in 0.16 seconds with method rustiq, depth 41, and size 516.
Transpiled circuit index 11 (all-vib-fccf) in 0.02 seconds with method rustiq, depth 34, and size 189.
Transpiled circuit index 12 (all-vib-ch2) in 0.03 seconds with method rustiq, depth 49, and size 240.
Transpiled circuit index 13 (tfim) in 0.05 seconds with method rustiq, depth 20, and size 366.
Transpiled circuit index 14 (all-vib-cyclo_propene) in 9.08 seconds with method rustiq, depth 16, and size 277.
Transpiled circuit index 15 (graph-gnp_k-4) in 0.04 seconds with method rustiq, depth 116, and size 612.
Transpiled circuit index 16 (all-vib-hc3h2cn) in 13.89 seconds with method rustiq, depth 2, and size 257.
Transpiled circuit index 17 (TSP_Ncity-4) in 0.05 seconds with method rustiq, depth 133, and size 737.
Transpiled circuit index 18 (tfim) in 0.11 seconds with method rustiq, depth 25, and size 680.
Transpiled circuit index 19 (all-vib-h2co) in 27.19 seconds with method rustiq, depth 66, and size 983.
Transpiled circuit index 20 (Be2) in 0.07 seconds with method rustiq, depth 215, and size 1030.
Transpiled circuit index 21 (graph-complete_bipart) in 0.14 seconds with method rustiq, depth 328, and size 1918.
Transpiled circuit index 22 (all-vib-f2) in 0.05 seconds with method rustiq, depth 114, and size 692.
Transpiled circuit index 23 (all-vib-cyclo_propene) in 62.25 seconds with method rustiq, depth 74, and size 2348.
Transpiled circuit index 24 (TSP_Ncity-5) in 0.20 seconds with method rustiq, depth 436, and size 3605.
Transpiled circuit index 25 (H2) in 0.21 seconds with method rustiq, depth 643, and size 3476.
Transpiled circuit index 26 (uuf100-ham) in 0.24 seconds with method rustiq, depth 678, and size 6120.
Transpiled circuit index 27 (ham-graph-gnp_k-5) in 0.22 seconds with method rustiq, depth 588, and size 5241.
Transpiled circuit index 28 (tfim) in 0.34 seconds with method rustiq, depth 340, and size 5901.
Transpiled circuit index 29 (uuf100-ham) in 0.33 seconds with method rustiq, depth 881, and size 7667.
Transpiled circuit index 30 (flat100-ham) in 0.31 seconds with method rustiq, depth 279, and size 4910.
Transpiled circuit index 31 (uf100-ham) in 0.38 seconds with method rustiq, depth 1138, and size 10607.
Transpiled circuit index 32 (OH) in 0.38 seconds with method rustiq, depth 1148, and size 6512.
Transpiled circuit index 33 (HF) in 0.37 seconds with method rustiq, depth 1090, and size 6256.
Transpiled circuit index 34 (BH) in 0.37 seconds with method rustiq, depth 1148, and size 6501.
```

Ergebnis-Tabelle (Visualiseerung weglaten, weil de Ausgaawen-Schaltkresen sehr groot sünd):

```python
summary_ham = (
    results_ham.groupby("method")[["depth", "size", "runtime"]]
    .mean()
    .round(2)
)
print(summary_ham)

results_ham
```

```text
depth     size  runtime
method
ai      316.86  2181.26     5.97
rustiq  281.94  2268.80     3.86
sabre   337.97  2120.14     3.07
```

```text
method        qc_name  qc_index  num_qubits  \
0     sabre     all-vib-o3         0           4
1     sabre    all-vib-c2h         1           4
2     sabre     all-vib-bh         2           2
3     sabre    all-vib-c2h         3           3
4     sabre  graph-gnp_k-2         4           4
..      ...            ...       ...         ...
100  rustiq    flat100-ham        30          90
101  rustiq      uf100-ham        31          46
102  rustiq             OH        32          10
103  rustiq             HF        33          10
104  rustiq             BH        34          10

                                               ops  depth   size   runtime
0                    {'rz': 28, 'sx': 24, 'cz': 6}      6     58  0.016597
1            {'rz': 17, 'sx': 16, 'cz': 4, 'x': 2}      2     39  1.102089
2                    {'sx': 14, 'rz': 13, 'cz': 3}      3     30  0.011042
3           {'sx': 46, 'rz': 45, 'cz': 18, 'x': 6}     18    115  0.025816
4           {'sx': 49, 'rz': 47, 'cz': 24, 'x': 9}     24    129  0.023077
..                                             ...    ...    ...       ...
100    {'sx': 2709, 'cz': 1379, 'rz': 817, 'x': 5}    279   4910  0.309448
101   {'sx': 6180, 'cz': 3120, 'rz': 1303, 'x': 4}   1138  10607  0.380977
102  {'sx': 3330, 'cz': 1704, 'rz': 1455, 'x': 23}   1148   6512  0.383564
103  {'sx': 3213, 'cz': 1620, 'rz': 1406, 'x': 17}   1090   6256  0.368578
104  {'sx': 3331, 'cz': 1704, 'rz': 1447, 'x': 19}   1148   6501  0.374822

[105 rows x 8 columns]
```

Leistung noh Schaltkreis-Index visualiseern:

```python
plot_transpilation_metrics(
    results_ham, "Transpilation Metrics for Hamiltonian Circuits"
)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/4c6b810d-a4cf-4de3-aae6-c6c1cdd83d8f-0.avif)

Den Prozentsatz vun Schaltkresen, bi de jede Methode an besten afsnitt, visualiseern:

```python
def analyze_and_plot_best_methods(results, metric):
    """
    Analyze the best-performing methods for a given metric and plot a pie chart.

    Parameters:
        results (DataFrame): The input DataFrame containing method performance data.
        metric (str): The metric to evaluate ("depth" or "size").
    """
    method_counts = Counter()
    for qc_idx, group in results.groupby("qc_index"):
        min_value = group[metric].min()

        # Find all methods that achieved this minimum value
        best_methods = group[group[metric] == min_value]["method"]
        # Update counts for all best methods (handling ties)
        method_counts.update(best_methods)
    best_method_counts = dict(
        sorted(method_counts.items(), key=lambda x: x[1], reverse=True)
    )

    # Print summary
    print(f"Best-performing methods based on {metric}:")
    for method, count in best_method_counts.items():
        print(f"    {method}: {count} circuit(s)")

    # Plot pie chart
    num_methods = len(best_method_counts)
    colors = plt.cm.viridis_r(range(0, 256, 256 // num_methods))
    plt.figure(figsize=(5, 5))
    plt.pie(
        best_method_counts.values(),
        labels=best_method_counts.keys(),
        autopct="%1.1f%%",
        startangle=140,
        wedgeprops={"edgecolor": "black"},
        textprops={"fontsize": 10},
        colors=colors,
    )
    plt.title(
        f"Percentage of Circuits Method Performed Best for {metric.capitalize()}",
        fontsize=12,
        fontweight="bold",
    )
    plt.show()

analyze_and_plot_best_methods(results_ham, "depth")
analyze_and_plot_best_methods(results_ham, "size")
```

```text
Best-performing methods based on depth:
    ai: 16 circuit(s)
    rustiq: 16 circuit(s)
    sabre: 10 circuit(s)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/01b4644e-ac91-483c-944b-924f8b41718d-1.avif)

```text
Best-performing methods based on size:
    sabre: 18 circuit(s)
    rustiq: 14 circuit(s)
    ai: 10 circuit(s)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/01b4644e-ac91-483c-944b-924f8b41718d-3.avif)

#### Analysen vun de Hamiltonian-Schaltkreis-Kompileer-Resultaten {#analysis-of-hamiltonian-circuit-compilation-results}

In düssen Afsnitt bewertten wi de Leistung vun dree Transpilatschoons-Methoden — SABRE, den KI-ünnerstütten Transpiler un Rustiq — op Quantenschaltkresen, de mit `PauliEvolutionGate` konstrueert wurrn sünd, de gemeensam in Hamiltonian-Simulatschoons-Opgaven bruukt warrt.

Rustiq snitt middlmäßig in Bezug op Schaltkreisdeepte am besten af un ereecht ruchweg 20 % geringere Deepte as SABRE. Dat is erwartbar, weil Rustiq speziëll daraap utleggt is, `PauliEvolutionGate`-Operatschonen mit optimierten, deeptenarmen Zerlegungsstratiegien to synthesisern. Doröver torütt wiest de Deepte-Plot, dat Rustiq bi skalierenende Schaltkreisgrötte un -komplexität am effektivsten skaliert un markant geringere Deepte as sowohl KI as ook SABRE bi grötteren Schaltkresen inhollt.

De KI-Transpiler wisst en starke un konsistente Leistung bi de Schaltkreisdeepte un übertrüfft SABRE bi de meisten Schaltkresen. Jichterwol hett he de höchste Lauftiid, besünners bi grötteren Schaltkresen, wat siene Praktikabilität bi tidkritischen Workloads begren­sen kann. Siene Skalierbarkeit bi de Lauftiid blift en grundlegende Begren­sung, ook wenn he solid Verbäterungen bi de Deepte beed.

SABRE, wüllt dat de höchste middlmäßige Deepte prodüzeert, ereecht de geringste middlmäßige Gate-Tall, dicht gefollgt vun'n KI-Transpiler. Dat stimmt mit de Utleggen vun SABREs Heuristik övereen, de direkt op dat Minimeren vun Gate-Tall uttellt is. Rustiq, trotz siene Stärke bi't Verringern vun Deepte, hett de höchste middlmäßige Gate-Tall — dat is en bemerkenswertes Afwiegen, dat man bi Toopassungen in Betracht trecken mutt, wo Schaltkreisgrötte mehr as Schaltkreis­duur bedd.

### Tosamenfaten {#summary}

Wüllt de KI-Transpiler im Allgemeenen bätere Resultaten as SABRE leevert, besünners bi Schaltkreisdeepte, schull de Schlußfolgerung nich eenfach wesen, dat man "immer den KI-Transpiler bruukt". Dat gifft wichtige Nuancen to berücksich­tigen:

- **KI-Transpiler** is typischerwiese verlässlich un leevert deepte-optimierte Schaltkresen, aber he hett Afwiegungen bi de Lauftiid un ook annere Begrensungen, ok ünnerstütte Koppelungskarten un Synthesis-Fähigkeiten. Düsse warrt in de [Qiskit-Transpiler-Service-Dokumentatschoon](/guides/qiskit-transpiler-service) utförlich behandelt.

- In eenigen Fällen, besünners mit sehr groten oder hardware-spezifischen Schaltkresen, kann de KI-Transpiler weniger effektiv wesen. In düsse Fällen blift de Standard-SABRE-Transpiler hooggradig verlässlich un kann dörch Anpassen vun sienen Parametern wieter optimiert warden (sett de [SABRE-Optimeerungs-Tutorial](/tutorials/transpilation-optimizations-with-sabre)).

- Dat is ook wichtig, de Schaltkreis-Struktuur to berücksich­tigen, wenn man en Methode utkoost. To'n Bispeel is `rustiq` speziëll för Schaltkresen mit `PauliEvolutionGate` utleggt un leevert vaak de beste Leistung för Hamiltonian-Simulatschoons-Problemen.

**Empfehlung:**
> Dat gifft keen een-passt-för-all-Transpilatschoons-Strategie. Bruukers wart enmoot, de Struktuur vun ehr Schaltkreis to verstehn un mehrere Transpilatschoons-Methoden to testen — ok KI, SABRE un spezialiseerde Warktüch as Rustiq — üm de effiziënteste Lösung för ehr spezifisches Problem un Hardware-Begrensungen to finnen.

### Schritt 3: Utföhrung mit Qiskit-Primitiven {#step-3-execute-using-qiskit-primitives}
Weil düsse Tutorial sik op Transpilatschoon konzentriert, warrt keen Experimenten op en Quantengerät utföhrt. Dat Ziel is, de Optimeerungen ut Schritt 2 to nutzen, üm en transpilierten Schaltkreis mit verringerter Deepte un Gate-Tall to ökrigen.

### Schritt 4: Nohbearbeiden un Ergebnis in gewünschtem klassischen Format torückgeeven {#step-4-post-process-and-return-result-in-desired-classical-format}
Weil för düsse Nootbook keen Utföhrung stattfinnt, gifft dat keen Resultaten, de nohbearbeidet warden mutt.

## Referenzen {#references}

[1] "LightSABRE: A Lightweight and Enhanced SABRE Algorithm". H. Zou, M. Treinish, K. Hartman, A. Ivrii, J. Lishman et al. https://arxiv.org/abs/2409.08368

[2] "Practical and efficient quantum circuit synthesis and transpiling with Reinforcement Learning". D. Kremer, V. Villar, H. Paik, I. Duran, I. Faro, J. Cruz-Benito et al. https://arxiv.org/abs/2405.13196

[3] "Pauli Network Circuit Synthesis with Reinforcement Learning". A. Dubal,  D. Kremer, S. Martiel, V. Villar, D. Wang, J. Cruz-Benito et al. https://arxiv.org/abs/2503.14448

[4] "Faster and shorter synthesis of Hamiltonian simulation circuits". T. Goubault de Brugière, S. Martiel et al. https://arxiv.org/abs/2404.03280
