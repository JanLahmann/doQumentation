---
title: "Repetitioonskoden"
sidebar_label: "Repetitioonskoden"
description: "Dit Tutorial wiist, wo man eenfache Repetitioonskoden mit IBM Dynamic Circuits boot — en Bispeel för grundlegend Quantenfehlerkorektur (QEC)."
notebook_path: "docs/tutorials/repetition-codes.ipynb"
---
{/* doqumentation-source-hash: fc3a692b */}

<OpenInLabBanner notebookPath="docs/tutorials/repetition-codes.ipynb" />



*Verbruuksschätzing: weniger as 1 Minuut op en Heron-Prozessor (ANMERKUNG: Dat is blooß en Schätzing. Jo Loptied kann verscheden ween.)*

## Achtergrund {#background}

För echttiedige Quantenfehlerkorektur (QEC) bruukt man de Möglichkeit, den Programmfluss dynamisch to stüern, dormit Quantengaten op Messresultaten betingt ween köönt. Dit Tutorial föhrt den Bit-Flip-Code ut, wat en sehr eenfache Form vun QEC is. Dat wiist en dynamischen Quantenschaltkreis, de en kodeerten Qubit vör en enkeld Bit-Flip-Fehler schützen kann, un dorna warrt de Leisten vun den Bit-Flip-Code utwertet.

Man kann extra Ancilla-Qubits un Verschränkung bruken, üm *Stabilisators* to meten, de de kodeerden Quanteninformatschoon nich verännert, aver trotzdem Bescheed geven över bestimmte Fehlerklassen, de optreden köönt. En Quantenstabilisatorcode kodeert $k$ logische Qubits in $n$ physikalische Qubits. Stabilisatorkoden konzentreert sik vör allem op de Korektur vun en diskret Fehlermenge, de vun de Pauli-Gruppe $\Pi^n$ ünnerstütt warrt.

Mehr Informatschoon över QEC findt ji bi [Quantum Error Correction for Beginners.](https://arxiv.org/abs/0905.2794)
## Vöruttseringen {#requirements}

Vör de Start vun dit Tutorial stellt seker, dat ji dat Folgendet installeert hebbt:

- Qiskit SDK v2.0 oder later, mit [Visualiseering](https://docs.quantum.ibm.com/api/qiskit/visualization)-Ünnerstüttung
- Qiskit Runtime v0.40 oder later (`pip install qiskit-ibm-runtime`)
## Inrichtung {#setup}

```python
# Qiskit imports
from qiskit import (
    QuantumCircuit,
    QuantumRegister,
    ClassicalRegister,
)

# Qiskit Runtime
from qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler

from qiskit_ibm_runtime.circuit import MidCircuitMeasure

service = QiskitRuntimeService()
```

## Stapp 1. Klassische Ingaven op en Quantenproblem ümtekenen {#step-1-map-classical-inputs-to-a-quantum-problem}
### Einen Bit-Flip-Stabilisatorschaltkreis bouen {#build-a-bit-flip-stabilizer-circuit}

Den Bit-Flip-Code is een vun de eenfachsten Bispele vun en Stabilisatorcode. He schützt den Tostand vör en enkeld Bit-Flip-(X-)Fehler op een vun de Koderungsqubits. Betrachtet man de Wirkung vun den Bit-Flip-Fehler $X$, de $|0\rangle \rightarrow |1\rangle$ un $|1\rangle \rightarrow |0\rangle$ op een vun ünsen Qubits afbillt, denn kriegen wi $\epsilon = \{E_0, E_1, E_2 \} = \{IIX, IXI, XII\}$. De Code bruukt fief Qubits: dree warrt bruukt, üm den schützten Tostand to koderen, un de beiden annern warrt as Stabilisatormessungs-Ancillas innsett.

```python
# Choose the least busy backend that supports `measure_2`.

backend = service.least_busy(
    filters=lambda b: "measure_2" in b.supported_instructions,
    operational=True,
    simulator=False,
    dynamic_circuits=True,
)
```

```python
qreg_data = QuantumRegister(3)
qreg_measure = QuantumRegister(2)
creg_data = ClassicalRegister(3, name="data")
creg_syndrome = ClassicalRegister(2, name="syndrome")
state_data = qreg_data[0]
ancillas_data = qreg_data[1:]

def build_qc():
    """Build a typical error correction circuit"""
    return QuantumCircuit(qreg_data, qreg_measure, creg_data, creg_syndrome)

def initialize_qubits(circuit: QuantumCircuit):
    """Initialize qubit to |1>"""
    circuit.x(qreg_data[0])
    circuit.barrier(qreg_data)
    return circuit

def encode_bit_flip(circuit, state, ancillas) -> QuantumCircuit:
    """Encode bit-flip. This is done by simply adding a cx"""
    for ancilla in ancillas:
        circuit.cx(state, ancilla)
    circuit.barrier(state, *ancillas)
    return circuit

def measure_syndrome_bit(circuit, qreg_data, qreg_measure, creg_measure):
    """
    Measure the syndrome by measuring the parity.
    We reset our ancilla qubits after measuring the stabilizer
    so we can reuse them for repeated stabilizer measurements.
    Because we have already observed the state of the qubit,
    we can write the conditional reset protocol directly to
    avoid another round of qubit measurement if we used
    the `reset` instruction.
    """
    circuit.cx(qreg_data[0], qreg_measure[0])
    circuit.cx(qreg_data[1], qreg_measure[0])
    circuit.cx(qreg_data[0], qreg_measure[1])
    circuit.cx(qreg_data[2], qreg_measure[1])
    circuit.barrier(*qreg_data, *qreg_measure)
    circuit.append(MidCircuitMeasure(), [qreg_measure[0]], [creg_measure[0]])
    circuit.append(MidCircuitMeasure(), [qreg_measure[1]], [creg_measure[1]])

    with circuit.if_test((creg_measure[0], 1)):
        circuit.x(qreg_measure[0])
    with circuit.if_test((creg_measure[1], 1)):
        circuit.x(qreg_measure[1])
    circuit.barrier(*qreg_data, *qreg_measure)
    return circuit

def apply_correction_bit(circuit, qreg_data, creg_syndrome):
    """We can detect where an error occurred and correct our state"""
    with circuit.if_test((creg_syndrome, 3)):
        circuit.x(qreg_data[0])
    with circuit.if_test((creg_syndrome, 1)):
        circuit.x(qreg_data[1])
    with circuit.if_test((creg_syndrome, 2)):
        circuit.x(qreg_data[2])
    circuit.barrier(qreg_data)
    return circuit

def apply_final_readout(circuit, qreg_data, creg_data):
    """Read out the final measurements"""
    circuit.barrier(qreg_data)
    circuit.measure(qreg_data, creg_data)
    return circuit
```

```python
def build_error_correction_sequence(apply_correction: bool) -> QuantumCircuit:
    circuit = build_qc()
    circuit = initialize_qubits(circuit)
    circuit = encode_bit_flip(circuit, state_data, ancillas_data)
    circuit = measure_syndrome_bit(
        circuit, qreg_data, qreg_measure, creg_syndrome
    )

    if apply_correction:
        circuit = apply_correction_bit(circuit, qreg_data, creg_syndrome)

    circuit = apply_final_readout(circuit, qreg_data, creg_data)
    return circuit

circuit = build_error_correction_sequence(apply_correction=True)
circuit.draw(output="mpl", style="iqp", cregbundle=False)
```

![Output of the previous code cell](/docs/images/tutorials/repetition-codes/extracted-outputs/dbe02949-0.avif)

![Output of the previous code cell](/docs/images/tutorials/repetition-codes/extracted-outputs/dbe02949-1.avif)

## Stapp 2. Dat Problem för de Quantenutföhrung optimeren {#step-2-optimize-the-problem-for-quantum-execution}

Üm de Gesamttied vun de Jobutföhrung to verkürten, neemt Qiskit-Primitiven bloots Schaltkreise un Observables an, de to de Befehlen un de Konnektivität vun dat Zielsystem passt (bekannt as ISA-Schaltkreise un -Observables — ISA steiht för Instruction Set Architecture). [Mehr över Transpilation lehren.](/guides/transpile)
### ISA-Schaltkreise genereren {#generate-isa-circuits}

```python
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

pm = generate_preset_pass_manager(backend=backend, optimization_level=1)
 isa_circuit = pm.run(circuit)

isa_circuit.draw("mpl", style="iqp", idle_wires=False)
```

![Output of the previous code cell](/docs/images/tutorials/repetition-codes/extracted-outputs/67b55eef-0.avif)

![Output of the previous code cell](/docs/images/tutorials/repetition-codes/extracted-outputs/67b55eef-1.avif)

```python
no_correction_circuit = build_error_correction_sequence(
    apply_correction=False
)

isa_no_correction_circuit = pm.run(no_correction_circuit)
```

## Stapp 3. Mit Qiskit-Primitiven utföhren {#step-3-execute-using-qiskit-primitives}
Föhrt de Verschoon mit Korektur un en Verschoon ahn Korektur ut.

```python
sampler_no_correction = Sampler(backend)
job_no_correction = sampler_no_correction.run(
    [isa_no_correction_circuit], shots=1000
)
result_no_correction = job_no_correction.result()[0]
```

```python
sampler_with_correction = Sampler(backend)

job_with_correction = sampler_with_correction.run([isa_circuit], shots=1000)
result_with_correction = job_with_correction.result()[0]
```

```python
print(f"Data (no correction):\n{result_no_correction.data.data.get_counts()}")
print(
    f"Syndrome (no correction):\n{result_no_correction.data.syndrome.get_counts()}"
)
```

```text
Data (no correction):
{'111': 878, '011': 42, '110': 35, '101': 40, '100': 1, '001': 2, '000': 2}
Syndrome (no correction):
{'00': 942, '10': 33, '01': 22, '11': 3}
```

```python
print(f"Data (corrected):\n{result_with_correction.data.data.get_counts()}")
print(
    f"Syndrome (corrected):\n{result_with_correction.data.syndrome.get_counts()}"
)
```

```text
Data (corrected):
{'111': 889, '110': 25, '000': 11, '011': 45, '101': 17, '010': 10, '001': 2, '100': 1}
Syndrome (corrected):
{'00': 929, '01': 39, '10': 20, '11': 12}
```

## Stapp 4. Naoberbeitung: Resultat in klassisches Format ümsetten {#step-4-post-process-return-result-in-classical-format}

Man kann sehn, dat de Bit-Flip-Code veel Fehler opdeckt un korrigert hett, sodass insgesamt weniger Fehlers överblievt.

```python
def decode_result(data_counts, syndrome_counts):
    shots = sum(data_counts.values())
    success_trials = data_counts.get("000", 0) + data_counts.get("111", 0)
    failed_trials = shots - success_trials
    error_correction_events = shots - syndrome_counts.get("00", 0)
    print(
        f"Bit flip errors were detected/corrected on {error_correction_events}/{shots} trials."
    )
    print(
        f"A final parity error was detected on {failed_trials}/{shots} trials."
    )
```

```python
# non-corrected marginalized results
data_result = result_no_correction.data.data.get_counts()
marginalized_syndrome_result = result_no_correction.data.syndrome.get_counts()

print(
    f"Completed bit code experiment data measurement counts (no correction): {data_result}"
)
print(
    f"Completed bit code experiment syndrome measurement counts (no correction): {marginalized_syndrome_result}"
)
decode_result(data_result, marginalized_syndrome_result)
```

```text
Completed bit code experiment data measurement counts (no correction): {'111': 878, '011': 42, '110': 35, '101': 40, '100': 1, '001': 2, '000': 2}
Completed bit code experiment syndrome measurement counts (no correction): {'00': 942, '10': 33, '01': 22, '11': 3}
Bit flip errors were detected/corrected on 58/1000 trials.
A final parity error was detected on 120/1000 trials.
```

```python
# corrected marginalized results
corrected_data_result = result_with_correction.data.data.get_counts()
corrected_syndrome_result = result_with_correction.data.syndrome.get_counts()

print(
    f"Completed bit code experiment data measurement counts (corrected): {corrected_data_result}"
)
print(
    f"Completed bit code experiment syndrome measurement counts (corrected): {corrected_syndrome_result}"
)
decode_result(corrected_data_result, corrected_syndrome_result)
```

```text
Completed bit code experiment data measurement counts (corrected): {'111': 889, '110': 25, '000': 11, '011': 45, '101': 17, '010': 10, '001': 2, '100': 1}
Completed bit code experiment syndrome measurement counts (corrected): {'00': 929, '01': 39, '10': 20, '11': 12}
Bit flip errors were detected/corrected on 71/1000 trials.
A final parity error was detected on 100/1000 trials.
```

## Tutorial-Ümmfrog {#tutorial-survey}

Nimmt an disse körte Ümmfrog deel, üm Feedback to dit Tutorial to geven. Jo Anmerkungen helpt uns, ünsen Inholt un de Brukerorfahrung to verbettern.

[Link to survey](https://your.feedback.ibm.com/jfe/form/SV_5onAlfA2Y7ac1FA)
