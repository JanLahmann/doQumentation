---
title: "Mitiga√ß√£o de erros de leitura para a primitiva Sampler usando M3"
sidebar_label: "Mitiga√ß√£o de erros de leitura para a primitiva Sampler usando M3"
description: "Use o addon de mitiga√ß√£o de leitura M3 com a primitiva Sampler"
notebook_path: "docs/tutorials/readout-error-mitigation-sampler.ipynb"
---

<OpenInLabBanner notebookPath="docs/tutorials/readout-error-mitigation-sampler.ipynb" />



{/* cspell:ignore braket, Zgrm, newcommand, probs, quasis, topten */}

*Estimativa de uso: menos de um minuto em um processador Heron r2 (NOTA: Esta √© apenas uma estimativa. Seu tempo de execu√ß√£o pode variar.)*

## Contexto

Ao contr√°rio da primitiva Estimator, a primitiva Sampler n√£o possui suporte integrado para mitiga√ß√£o de erros.
V√°rios dos m√©todos suportados pelo Estimator s√£o especificamente projetados para valores esperados e, portanto, n√£o s√£o aplic√°veis √† primitiva Sampler. Uma exce√ß√£o √© a mitiga√ß√£o de erros de leitura, que √© um m√©todo altamente eficaz e tamb√©m aplic√°vel √† primitiva Sampler.

O [addon M3 do Qiskit](https://qiskit.github.io/qiskit-addon-mthree/) implementa um m√©todo eficiente para mitiga√ß√£o de erros de leitura. Este tutorial explica como usar o addon M3 do Qiskit para mitigar erros de leitura na primitiva Sampler.

### O que √© erro de leitura?

Imediatamente antes da medi√ß√£o, o estado de um registro de qubit √©
descrito por uma superposi√ß√£o de estados da base computacional,
ou por uma matriz de densidade.
A medi√ß√£o do registro de qubit em um registro de bit cl√°ssico ent√£o prossegue em duas etapas.
Primeiro, a medi√ß√£o qu√¢ntica propriamente dita √© realizada.
Isso significa que o estado do registro de qubit
√© projetado em um √∫nico estado de base que √© caracterizado
por uma sequ√™ncia de $1$s e $0$s.
A segunda etapa consiste em ler a string de bits que caracteriza esse estado de base
e escrev√™-la na mem√≥ria do computador cl√°ssico.
Chamamos essa etapa de *leitura* (readout).
Acontece que a segunda etapa (leitura) incorre em mais erros do que a primeira etapa (proje√ß√£o em estados de base).
Isso faz sentido quando voc√™ lembra que a leitura requer detectar um
estado qu√¢ntico microsc√≥pico e amplific√°-lo para o dom√≠nio macrosc√≥pico. Um ressonador de leitura √© acoplado ao
qubit (transmon), experimentando assim um deslocamento de frequ√™ncia muito pequeno. Um pulso de micro-ondas
√© ent√£o refletido no ressonador, por sua vez experimentando pequenas mudan√ßas em suas
caracter√≠sticas. O pulso refletido √© ent√£o amplificado e analisado. Este √© um processo delicado
e est√° sujeito a uma s√©rie de erros.

O ponto importante √© que, embora tanto a medi√ß√£o qu√¢ntica quanto a leitura estejam sujeitas a erros, esta
√∫ltima incorre no erro dominante, chamado erro de leitura, que √© o foco deste tutorial.
### Fundamentos te√≥ricos

Se a string de bits amostrada (armazenada na mem√≥ria cl√°ssica) difere da string de bits que caracteriza
o estado qu√¢ntico projetado, dizemos que ocorreu um erro de leitura.
Esses erros s√£o observados como aleat√≥rios e n√£o correlacionados de amostra para amostra.
Provou-se √∫til modelar o erro de leitura como um _canal cl√°ssico ruidoso_.
Ou seja, para cada par de
strings de bits $i$ e $j$, h√° uma probabilidade fixa de que um valor verdadeiro de $j$ ser√°
incorretamente lido como $i$.

Mais precisamente, para cada par de strings de bits $(i, j)$, h√° uma probabilidade (condicional) ${M}_{i,j}$
de que $i$ seja lido, dado que o valor verdadeiro √© $j.$
Ou seja,
$$
    {M}_{i,j} =  \Pr(\text{valor de leitura √© } i | \text{valor verdadeiro √© } j)
    \text{ para } i,j \in (0,...,2^n - 1), \tag{1}
$$
onde $n$ √© o n√∫mero de bits no registro de leitura.
Para concretude, assumimos que $i$ √© um inteiro decimal cuja representa√ß√£o bin√°ria √©
a string de bits que rotula os estados da base computacional.
Chamamos a matriz ${M}$ de $2^n \times 2^n$ de _matriz de atribui√ß√£o_.
Para um valor verdadeiro $j$ fixo, somar a probabilidade sobre todos os resultados ruidosos $i$ deve dar $1$. Ou seja
$$
    \sum_{i=0}^{2^n - 1} {M}_{i,j} = 1 \text{ para todo } j
$$
Uma matriz sem entradas negativas que satisfaz (1) √© chamada
_estoc√°stica √† esquerda_.
Uma matriz estoc√°stica √† esquerda tamb√©m √© chamada _estoc√°stica por coluna_ porque cada uma de suas colunas soma $1$.
Determinamos experimentalmente valores aproximados para cada elemento ${M}_{i,j}$
preparando repetidamente cada estado de base $|j \rangle$ e ent√£o computando as frequ√™ncias
de ocorr√™ncia das strings de bits amostradas.

Se um experimento envolve estimar uma distribui√ß√£o de probabilidade sobre strings de bits de sa√≠da por amostragem repetida,
ent√£o podemos usar ${M}$ para mitigar o erro de leitura no n√≠vel da distribui√ß√£o.
O primeiro passo √© repetir um circuito fixo de interesse muitas vezes,
criando um histograma de strings de bits amostradas.
O histograma normalizado √© a distribui√ß√£o de probabilidade medida sobre
as $2^n$ poss√≠veis strings de bits, que denotamos por ${\tilde{p}} \in \mathbb{R}^{2^n}$.
A probabilidade (estimada) ${{\tilde{p}}}_i$ de amostrar a string de bits $i$
√© igual √† soma sobre todas as strings de bits verdadeiras $j$, cada uma ponderada pela
probabilidade de que seja confundida com $i$.
Esta afirma√ß√£o na forma matricial √©
$$
    {\tilde{p}} = {M} {\vec{p}}, \tag{2},
$$
onde ${\vec{p}}$ √© a distribui√ß√£o verdadeira. Em palavras, o erro de leitura tem o efeito de multiplicar
a distribui√ß√£o ideal sobre strings de bits ${\vec{p}}$ pela matriz de atribui√ß√£o ${M}$ para
produzir a distribui√ß√£o observada ${\tilde{p}}$.
Medimos ${\tilde{p}}$ e ${M}$, mas n√£o temos acesso direto a ${\vec{p}}$. Em princ√≠pio, obteremos
a distribui√ß√£o verdadeira de strings de bits para nosso circuito
resolvendo a equa√ß√£o (2) para ${\vec{p}}$ numericamente.

Antes de prosseguirmos, vale notar algumas caracter√≠sticas importantes desta abordagem ing√™nua.

- Na pr√°tica, a equa√ß√£o (2) n√£o √© resolvida invertendo ${M}$. Rotinas de √°lgebra linear
  em bibliotecas de software empregam m√©todos que s√£o mais est√°veis, precisos e eficientes.
- Ao estimar ${M}$, assumimos que apenas erros de leitura ocorreram. Em particular,
  assumimos que n√£o houve erros de prepara√ß√£o de estado e medi√ß√£o qu√¢ntica ‚Äî
  ou pelo menos que eles foram mitigados de outra forma.
  Na medida em que esta √© uma boa suposi√ß√£o, ${M}$ realmente representa
  apenas o erro de leitura. Mas quando _usamos_ ${M}$ para corrigir uma distribui√ß√£o medida
  sobre strings de bits, n√£o fazemos tal suposi√ß√£o. Na verdade, esperamos que um circuito interessante
  introduza ru√≠do, por exemplo, erros de porta. A distribui√ß√£o "verdadeira"
  ainda inclui efeitos de quaisquer erros que n√£o sejam mitigados de outra forma.

Este m√©todo, embora √∫til em algumas circunst√¢ncias, sofre de algumas limita√ß√µes.

Os recursos de espa√ßo e tempo necess√°rios para estimar ${M}$ crescem exponencialmente em $n$:
- A estimativa de ${M}$ e ${\tilde{p}}$ est√° sujeita a erro estat√≠stico devido √† amostragem finita.
  Este ru√≠do pode ser tornado t√£o pequeno quanto desejado
  ao custo de mais disparos (at√© a escala de tempo de par√¢metros de hardware em deriva
  que resultam em erros sistem√°ticos em ${M}$).
  No entanto, se nenhuma suposi√ß√£o for feita sobre as strings de bits observadas
  ao realizar a mitiga√ß√£o, o n√∫mero de disparos necess√°rios para estimar ${M}$ cresce
  pelo menos exponencialmente em $n$.
- ${M}$ √© uma matriz $2^n \times 2^n$.
  Quando $n>10$, a quantidade de mem√≥ria necess√°ria para armazenar ${M}$ √©
  maior que a mem√≥ria dispon√≠vel em um laptop poderoso.

Outras limita√ß√µes s√£o:

- A distribui√ß√£o recuperada ${\vec{p}}$ pode ter uma
  ou mais probabilidades negativas (ainda somando um). Uma solu√ß√£o
  √© minimizar $||{M} {\vec{p}} - {\tilde{p}}||^2$ sujeito √† restri√ß√£o de que
  cada entrada em ${\vec{p}}$ seja n√£o negativa. No entanto, o tempo de execu√ß√£o de tal
  m√©todo √© ordens de magnitude mais longo do que resolver diretamente a equa√ß√£o (2).
- Este procedimento de mitiga√ß√£o funciona no n√≠vel de uma distribui√ß√£o de probabilidade
  sobre strings de bits. Em particular, ele n√£o pode corrigir um erro em uma
  string de bits observada individualmente.
### Addon M3 do Qiskit: Escalando para strings de bits mais longas

Resolver a equa√ß√£o (2) usando rotinas padr√£o de √°lgebra linear num√©rica √© limitado a strings de bits com no m√°ximo cerca de 10 bits. O M3, no entanto, pode lidar com strings de bits muito mais longas. Duas propriedades-chave do M3 que tornam isso poss√≠vel s√£o:
- Correla√ß√µes no erro de leitura de ordem tr√™s e superior entre cole√ß√µes de bits
  s√£o assumidas como negligenci√°veis e s√£o ignoradas. Em princ√≠pio, ao custo de mais disparos,
  pode-se estimar correla√ß√µes mais altas tamb√©m.
- Em vez de construir ${M}$ explicitamente, usamos uma matriz efetiva muito menor que registra
  probabilidades apenas para strings de bits coletadas ao construir ${\tilde{p}}$.

Em um n√≠vel alto, o procedimento funciona da seguinte forma.

Primeiro, constru√≠mos blocos de constru√ß√£o a partir dos quais podemos construir uma descri√ß√£o efetiva simplificada de ${M}$.
Ent√£o, executamos repetidamente o circuito de interesse e coletamos strings de bits que usamos para construir
tanto ${\tilde{p}}$ quanto, com a ajuda dos blocos de constru√ß√£o, um ${M}$ efetivo.

Mais precisamente,
- Matrizes de atribui√ß√£o de qubit √∫nico s√£o estimadas para cada qubit. Para fazer isso,
  preparamos repetidamente o registro de qubit no estado todo-zero $|0 ... 0 \rangle$ e depois no estado todo-um
  $|1 ... 1 \rangle$, e registramos a probabilidade para cada qubit de que seja lido
  incorretamente.
- Correla√ß√µes de ordem tr√™s e superior s√£o assumidas como negligenci√°veis e s√£o ignoradas.

  Em vez disso, constru√≠mos um n√∫mero $n$ de matrizes de atribui√ß√£o de qubit √∫nico $2 \times 2$,
  e um n√∫mero $n(n-1)/2$ de matrizes de atribui√ß√£o de dois qubits $4 \times 4$.
  Essas matrizes de atribui√ß√£o de um e dois qubits s√£o armazenadas para uso
  posterior.
- Ap√≥s amostrar repetidamente um circuito para construir ${\tilde{p}}$,
  constru√≠mos uma aproxima√ß√£o efetiva de ${M}$ usando apenas
  strings de bits que s√£o amostradas ao construir ${\tilde{p}}$. Esta matriz efetiva
  √© constru√≠da usando as matrizes de um e dois qubits descritas no item anterior.
  A dimens√£o linear desta matriz √© no m√°ximo da ordem do n√∫mero
  de disparos usados na constru√ß√£o de ${\tilde{p}}$, que √© muito menor que
  a dimens√£o $2^n$ da matriz de atribui√ß√£o completa ${M}$ .

Para detalhes t√©cnicos sobre o M3, voc√™ pode consultar [*Scalable Mitigation of Measurement Errors on Quantum Computers*](https://journals.aps.org/prxquantum/abstract/10.1103/PRXQuantum.2.040326).
### Aplica√ß√£o do M3 a um algoritmo qu√¢ntico
Aplicaremos a mitiga√ß√£o de leitura do M3 ao problema do deslocamento oculto. O problema do deslocamento oculto, e problemas intimamente relacionados como o [problema do subgrupo oculto](https://en.wikipedia.org/wiki/Hidden_subgroup_problem), foram originalmente concebidos em um contexto tolerante a falhas (mais precisamente, antes que os QPUs tolerantes a falhas fossem comprovados como poss√≠veis!). Mas eles tamb√©m s√£o estudados com processadores dispon√≠veis. Um exemplo de acelera√ß√£o exponencial algor√≠tmica obtida para uma variante do problema do deslocamento oculto obtido em QPUs IBM&reg; de 127 qubits pode ser encontrado [neste artigo](https://journals.aps.org/prx/accepted/a9074K06A8e1590147da9c69f8c4b64c28247be5a) ([vers√£o arXiv](https://arxiv.org/abs/2401.07934)).

No que segue, toda a aritm√©tica √© Booleana.
Ou seja, para $a, b \in \mathbb{Z}_2 = \{0, 1\}$, a adi√ß√£o, $a + b$ √© a fun√ß√£o XOR l√≥gica.
Al√©m disso, a multiplica√ß√£o $a \times b$ (ou $a b$) √© a fun√ß√£o AND l√≥gica. Para $x, y \in \{0, 1\}^n$,
$x + y$ √© definido pela aplica√ß√£o bit a bit de XOR.
O produto escalar $\cdot: {\mathbb{Z}_2^n} \rightarrow \mathbb{Z}_2$ √© definido
por $x \cdot y = \sum_i x_i y_i$.
#### Operador de Hadamard e transformada de Fourier

Na implementa√ß√£o de algoritmos qu√¢nticos, √© muito comum usar o operador de Hadamard como uma transformada de Fourier.
Os estados da base computacional √†s vezes s√£o chamados de _estados cl√°ssicos_. Eles est√£o em
uma rela√ß√£o um para um com as strings de bits cl√°ssicas.
O operador de Hadamard de $n$ qubits em estados cl√°ssicos pode ser visto como uma transformada de Fourier no hipercubo Booleano:
$$
H^{\otimes n} =  \frac{1}{\sqrt{2^n}} \sum_{x,y \in {\mathbb{Z}_2^n}} (-1)^{x \cdot y} {|{y}\rangle}{\langle{x}|}.
$$
Considere um estado ${|{s}\rangle}$ correspondente a uma string de bits fixa $s$.
Aplicando $H^{\otimes n}$, e usando ${\langle {x}|{s}\rangle} = \delta_{x,s}$,
vemos que a transformada de Fourier de ${|{s}\rangle}$ pode ser escrita como
$$
   H^{\otimes n} {|{s}\rangle} =  \frac{1}{\sqrt{2^n}} \sum_{y \in {\mathbb{Z}_2^n}} (-1)^{s \cdot y} {|{y}\rangle}.
$$

O Hadamard √© seu pr√≥prio inverso, ou seja,
 $H^{\otimes n} H^{\otimes n} = (H H)^{\otimes n} = I^{\otimes n}$.
Assim, a transformada de Fourier inversa √© o mesmo operador, $H^{\otimes n}$.
Explicitamente, temos,
$$
  {|{s}\rangle} =  H^{\otimes n} H^{\otimes n} {|{s}\rangle}  =  H^{\otimes n} \frac{1}{\sqrt{2^n}} \sum_{y \in {\mathbb{Z}_2^n}} (-1)^{s \cdot y} {|{y}\rangle}.
$$
#### O problema do deslocamento oculto

Consideramos um exemplo simples de um _problema de deslocamento oculto_.
O problema √© identificar um deslocamento constante na entrada de uma fun√ß√£o.
A fun√ß√£o que consideramos √© o produto escalar. √â o membro mais simples
de uma grande classe de fun√ß√µes que admitem uma acelera√ß√£o qu√¢ntica para o problema do deslocamento
oculto via t√©cnicas similares √†s apresentadas abaixo.

Seja $x,y \in {\mathbb{Z}_2^m}$ strings de bits de comprimento $m$.
Definimos ${f}: {\mathbb{Z}_2^m} \times {\mathbb{Z}_2^m} \rightarrow \{-1,1\}$ por
$$
  {f}(x, y) = (-1)^{x \cdot y}.
$$
  Seja $a,b \in {\mathbb{Z}_2^m}$ strings de bits fixas de comprimento $m$.
  Al√©m disso, definimos $g: {\mathbb{Z}_2^m} \times {\mathbb{Z}_2^m} \rightarrow \{-1,1\}$ por
$$
  g(x, y) = {f}(x+a, y+b) = (-1)^{(x+a) \cdot (y+b)},
  $$
  onde $a$ e $b$ s√£o par√¢metros (ocultos).
  S√£o nos dados duas caixas pretas, uma implementando $f$, e a outra $g$.
  Supomos que sabemos que elas computam as fun√ß√µes definidas acima, exceto que n√£o conhecemos
  nem $a$ nem $b$. O jogo √© determinar as strings de bits ocultas (deslocamentos)
  $a$ e $b$ fazendo consultas a $f$ e $g$. Est√° claro que se jogarmos o jogo classicamente,
  precisamos de $O(2m)$ consultas para determinar $a$ e $b$. Por exemplo, podemos consultar $g$ com todos os pares de strings tal que um elemento do par seja todo zeros, e o outro elemento tenha exatamente um elemento definido como $1$.
  Em cada consulta, aprendemos um elemento de $a$ ou $b$.
  No entanto, veremos que, se as caixas pretas s√£o implementadas como circuitos qu√¢nticos, podemos
  determinar $a$ e $b$ com uma √∫nica consulta a cada um de $f$ e $g$.

  No contexto de complexidade algor√≠tmica, uma caixa preta √© chamada de _or√°culo_.
  Al√©m de ser opaco, um or√°culo tem a propriedade de que ele consome a entrada e
  produz a sa√≠da instantaneamente, n√£o adicionando nada ao or√ßamento de complexidade do algoritmo
  no qual est√° incorporado. De fato, no caso em quest√£o, os or√°culos implementando $f$ e
  $g$ ser√£o vistos como eficientes.
#### Circuitos qu√¢nticos para $f$ e $g$

Precisamos dos seguintes ingredientes para implementar $f$ e $g$ como circuitos qu√¢nticos.

Para estados cl√°ssicos de qubit √∫nico ${|{x_1}\rangle}, {|{y_1}\rangle}$, com $x_1,y_1 \in \mathbb{Z}_2$,
a porta $Z$ controlada ${CZ}$ pode ser escrita como
$$
{CZ} {|{x_1}\rangle}{|{y_1}\rangle}{x_1} = (-1)^{x_1 y_1} {|{x_1}\rangle}{x_1}{|{y_1}\rangle}.
$$
Operaremos com $m$ portas CZ, uma em $(x_1, y_1)$, e uma em $(x_2, y_2)$, e assim por diante, at√© $(x_m, y_m)$.
Chamamos este operador de ${CZ}_{x,y}$.

$U_f = {CZ}_{x,y}$ √© uma vers√£o qu√¢ntica de ${f} = {f}(x,y)$:
$$
%\CZ_{x,y} {|#1\rangle}{z} =
U_f {|{x}\rangle}{|{y}\rangle} = {CZ}_{x,y} {|{x}\rangle}{|{y}\rangle} = (-1)^{x \cdot y}  {|{x}\rangle}{|{y}\rangle}.
$$

Tamb√©m precisamos implementar um deslocamento de string de bits.
Denotamos o operador no registro $x$ $X^{a_1}\cdots X^{a_m}$ por $X_a$
e da mesma forma no registro $y$ $X_b =  X^{b_1}\cdots X^{b_m}$.
Esses operadores aplicam $X$ onde quer que um √∫nico bit seja $1$, e a identidade $I$ onde quer que seja $0$.
Ent√£o temos
$$
 X_a X_b  {|{x}\rangle}{|{y}\rangle} = {|{x+a}\rangle}{|{y+b}\rangle}.
$$

A segunda caixa preta $g$ √© implementada pelo unit√°rio $U_g$, dado por
$$
%U_g {|{x}\rangle}{|{y}\rangle} = X_aX_b \CZ_{x,y} X_aX_b {|{x}\rangle}{|{y}\rangle}.
U_g = X_aX_b {CZ}_{x,y} X_aX_b.
$$
Para ver isso, aplicamos os operadores da direita para a esquerda ao estado ${|{x}\rangle}{|{y}\rangle}$.
Primeiro

$$
 X_a X_b  {|{x}\rangle}{|{y}\rangle} = {|{x+a}\rangle}{|{y+b}\rangle}.
$$

Ent√£o,
$$
  {CZ}_{x,y}  {|{x+a}\rangle}{|{y+b}\rangle} = (-1)^{(x+a)\cdot (y+b)} {|{x+a}\rangle}{|{y+b}\rangle}.
$$

Finalmente,

$$
  X^a X^b (-1)^{(x+a)\cdot (y+b)} {|{x+a}\rangle}{|{y+b}\rangle} = (-1)^{(x+a)\cdot (y+b)} {|{x}\rangle}{|{y}\rangle},
$$

que √© de fato a vers√£o qu√¢ntica de $f(x+a, y+b)$.
#### O algoritmo de deslocamento oculto

Agora juntamos as pe√ßas para resolver o problema do deslocamento oculto.
Come√ßamos aplicando Hadamards aos registros inicializados no estado todo-zero.
$$
H^{\otimes 2m} = H^{\otimes m} \otimes H^{\otimes m} {{|{0}\rangle}^{\otimes m}}{{|{0}\rangle}^{\otimes m}} = \frac{1}{\sqrt{2^{2m}}} \sum_{x, y \in {\mathbb{Z}_2^m}} (-1)^{x \cdot y} {|{x}\rangle}{|{y}\rangle}.
$$

Em seguida, consultamos o or√°culo $g$ para chegar a
$$
U_g H^{\otimes 2m} {{|{0}\rangle}^{\otimes m}}{{|{0}\rangle}^{\otimes m}}
= \frac{1}{\sqrt{2^{2m}}} \sum_{x, y \in {\mathbb{Z}_2^m}} (-1)^{(x+a) \cdot (y+b)} {|{x}\rangle}{|{y}\rangle}
$$
$$
\approx \frac{1}{\sqrt{2^{2m}}} \sum_{x, y \in {\mathbb{Z}_2^m}} (-1)^{x \cdot y + x \cdot b + y \cdot a} {|{x}\rangle}{|{y}\rangle}.
$$
Na √∫ltima linha, omitimos o fator de fase global constante $(-1)^{a \cdot b}$,
e denotamos igualdade at√© uma fase por $\approx$.
Em seguida, aplicar o or√°culo $f$ introduz outro fator de $(-1)^{x \cdot y}$, cancelando o que j√° est√°
presente. Ent√£o temos:
$$
U_f U_g H^{\otimes 2m} {{|{0}\rangle}^{\otimes m}}{{|{0}\rangle}^{\otimes m}}
\approx \frac{1}{\sqrt{2^{2m}}} \sum_{x, y \in {\mathbb{Z}_2^m}} (-1)^{x \cdot b + y \cdot a} {|{x}\rangle}{|{y}\rangle}.
$$
O passo final √© aplicar a transformada de Fourier inversa, $H^{\otimes 2m} = H^{\otimes m} \otimes H^{\otimes m}$,
resultando em
$$
H^{\otimes 2m} U_f U_g  H^{\otimes 2m} {{|{0}\rangle}^{\otimes m}}{{|{0}\rangle}^{\otimes m}}
\approx {|{b}\rangle}{|{a}\rangle}.
$$
O circuito est√° finalizado. Na aus√™ncia de ru√≠do, amostrar os registros qu√¢nticos
retornar√° as strings de bits $b, a$ com probabilidade $1$.

O produto interno Booleano √© um exemplo das chamadas fun√ß√µes bent.
N√£o definiremos fun√ß√µes bent aqui
mas apenas observamos que elas
"s√£o maximamente resistentes contra ataques que buscam explorar uma depend√™ncia das
sa√≠das em algum subespa√ßo linear das entradas."
Esta cita√ß√£o √© do artigo [_Quantum algorithms for highly non-linear Boolean functions_](https://arxiv.org/abs/0811.3208), que
apresenta algoritmos de deslocamento oculto eficientes para v√°rias classes de fun√ß√µes bent.
O algoritmo neste tutorial aparece na Se√ß√£o 3.1 do artigo.

No caso mais geral, o circuito para encontrar um deslocamento oculto $s \in \mathbb{Z}^n$ √©
$$
 H^{\otimes n} U_{\tilde{f}}  H^{\otimes n} U_g  H^{\otimes n} {|{0}\rangle}^{\otimes n} = {|{s}\rangle}.
$$
 No caso geral, $f$ e $g$ s√£o fun√ß√µes de uma √∫nica vari√°vel.
 Nosso exemplo do produto interno tem esta forma se deixarmos $f(x, y) \to f(z)$,
 com $z$ igual √† concatena√ß√£o de $x$ e $y$, e $s$ igual √† concatena√ß√£o
 de $a$ e $b$.
 O caso geral requer exatamente dois or√°culos: Um or√°culo para $g$ e um para $\tilde{f}$,
 onde o √∫ltimo √© uma fun√ß√£o conhecida como a _dual_ da fun√ß√£o bent $f$.
 A fun√ß√£o do produto interno tem a propriedade auto-dual $\tilde{f}=f$.

 Em nosso circuito para o deslocamento oculto no produto interno, omitimos a camada intermedi√°ria
 de Hadamards que aparece no circuito para o caso geral. Embora no caso geral
 esta camada seja necess√°ria, economizamos um pouco de profundidade ao omiti-la, √† custa de um pouco
 de p√≥s-processamento porque a sa√≠da √© ${|{b}\rangle}{|{a}\rangle}$ em vez do desejado ${|{a}\rangle}{|{b}\rangle}$.
## Requisitos

Antes de iniciar este tutorial, certifique-se de ter o seguinte instalado:

- Qiskit SDK v2.1 ou posterior, com suporte a [visualiza√ß√£o](https://docs.quantum.ibm.com/api/qiskit/visualization)
- Qiskit Runtime v0.41 ou posterior (`pip install qiskit-ibm-runtime`)
- Addon M3 do Qiskit v3.0 (`pip install mthree`)
## Configura√ß√£o

```python
# Added by doQumentation ‚Äî installs packages not in the Binder environment
%pip install -q mthree
```

```python
from collections.abc import Iterator, Sequence
from random import Random
from qiskit.circuit import (
    CircuitInstruction,
    QuantumCircuit,
    QuantumRegister,
    Qubit,
)
from qiskit.circuit.library import CZGate, HGate, XGate
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit_ibm_runtime import QiskitRuntimeService
import timeit
import matplotlib.pyplot as plt
from qiskit_ibm_runtime import SamplerV2 as Sampler
import mthree
```

## Passo 1: Mapear entradas cl√°ssicas para um problema qu√¢ntico
Primeiro, escrevemos as fun√ß√µes para implementar o problema do deslocamento oculto como um `QuantumCircuit`.

```python
def apply_hadamards(qubits: Sequence[Qubit]) -> Iterator[CircuitInstruction]:
    """Apply a Hadamard gate to every qubit."""
    for q in qubits:
        yield CircuitInstruction(HGate(), [q], [])

def apply_shift(
    qubits: Sequence[Qubit], shift: int
) -> Iterator[CircuitInstruction]:
    """Apply X gates where the bits of the shift are equal to 1."""
    for i, q in zip(range(shift.bit_length()), qubits):
        if shift >> i & 1:
            yield CircuitInstruction(XGate(), [q], [])

def oracle_f(qubits: Sequence[Qubit]) -> Iterator[CircuitInstruction]:
    """Apply the f oracle."""
    for i in range(0, len(qubits) - 1, 2):
        yield CircuitInstruction(CZGate(), [qubits[i], qubits[i + 1]])

def oracle_g(
    qubits: Sequence[Qubit], shift: int
) -> Iterator[CircuitInstruction]:

) -> Iterator[CircuitInstruction]:
    """Apply the g oracle."""
    yield from apply_shift(qubits, shift)
    yield from oracle_f(qubits)
    yield from apply_shift(qubits, shift)

def determine_hidden_shift(
    qubits: Sequence[Qubit], shift: int
) -> Iterator[CircuitInstruction]:
    """Determine the hidden shift."""
    yield from apply_hadamards(qubits)
    yield from oracle_g(qubits, shift)
    # We omit this layer in exchange for post processing
    # yield from apply_hadamards(qubits)
    yield from oracle_f(qubits)
    yield from apply_hadamards(qubits)

def run_hidden_shift_circuit(n_qubits, rng):
    hidden_shift = rng.getrandbits(n_qubits)

    qubits = QuantumRegister(n_qubits, name="q")
    circuit = QuantumCircuit.from_instructions(
        determine_hidden_shift(qubits, hidden_shift), qubits=qubits
    )
    circuit.measure_all()
    # Format the hidden shift as a string.
    hidden_shift_string = format(hidden_shift, f"0{n_qubits}b")
    return (circuit, hidden_shift, hidden_shift_string)

def display_circuit(circuit):
    return circuit.remove_final_measurements(inplace=False).draw(
        "mpl", idle_wires=False, scale=0.5, fold=-1
    )
```

Vamos come√ßar com um pequeno exemplo:

```python
n_qubits = 6
random_seed = 12345
rng = Random(random_seed)
circuit, hidden_shift, hidden_shift_string = run_hidden_shift_circuit(
    n_qubits, rng
)

print(f"Hidden shift string {hidden_shift_string}")

display_circuit(circuit)
```

```text
Hidden shift string 011010
```

![Output of the previous code cell](/docs/images/tutorials/readout-error-mitigation-sampler/extracted-outputs/8297843e-00c3-4bb5-9d33-a7e558d1698c-1.avif)

## Passo 2: Otimizar circuitos para execu√ß√£o em hardware qu√¢ntico

```python
job_tags = [
    f"shift {hidden_shift_string}",
    f"n_qubits {n_qubits}",
    f"seed = {random_seed}",
]
job_tags
```

```text
['shift 011010', 'n_qubits 6', 'seed = 12345']
```

```python
# Uncomment this to run the circuits on a quantum computer on IBMCloud.
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=100
)

# from qiskit_ibm_runtime.fake_provider import FakeMelbourneV2
# backend = FakeMelbourneV2()
# backend.refresh(service)

print(f"Using backend {backend.name}")

def get_isa_circuit(circuit, backend):
    pass_manager = generate_preset_pass_manager(
        optimization_level=3, backend=backend, seed_transpiler=1234
    )
    isa_circuit = pass_manager.run(circuit)
    return isa_circuit

isa_circuit = get_isa_circuit(circuit, backend)
display_circuit(isa_circuit)
```

```text
Using backend ibm_kingston
```

![Output of the previous code cell](/docs/images/tutorials/readout-error-mitigation-sampler/extracted-outputs/f2b77d93-c34a-43a4-b436-e7a25024a94a-1.avif)

## Passo 3: Executar circuitos usando primitivas Qiskit

```python
# submit job for solving the hidden shift problem using the Sampler primitive
NUM_SHOTS = 50_000

def run_sampler(backend, isa_circuit, num_shots):
    sampler = Sampler(mode=backend)
    sampler.options.environment.job_tags
    pubs = [(isa_circuit, None, NUM_SHOTS)]
    job = sampler.run(pubs)
    return job

def setup_mthree_mitigation(isa_circuit, backend):
    # retrieve the final qubit mapping so mthree knows which qubits to calibrate
    qubit_mapping = mthree.utils.final_measurement_mapping(isa_circuit)

    # submit jobs for readout error calibration
    mit = mthree.M3Mitigation(backend)
    mit.cals_from_system(qubit_mapping, rep_delay=None)

    return mit, qubit_mapping
```

```python
job = run_sampler(backend, isa_circuit, NUM_SHOTS)
mit, qubit_mapping = setup_mthree_mitigation(isa_circuit, backend)
```

## Passo 4: P√≥s-processar e retornar resultados em formato cl√°ssico

Na discuss√£o te√≥rica acima, determinamos que para a entrada $ab$, esperamos a sa√≠da $ba$.
Uma complica√ß√£o adicional √© que, para ter um circuito (pr√©-transpilado) mais simples, inserimos os gates CZ necess√°rios entre
pares vizinhos de qubits. Isso equivale a intercalar as bitstrings $a$ e $b$ como $a1 b1 a2 b2 \ldots$.
A string de sa√≠da $ba$ ser√° intercalada de maneira similar: $b1 a1 b2 a2 \ldots$. A fun√ß√£o `unscramble` abaixo
transforma a string de sa√≠da de $b1 a1 b2 a2 \ldots$ para $a1 b1 a2 b2 \ldots$ de modo que as strings de entrada e sa√≠da possam ser comparadas diretamente.

```python
# retrieve bitstring counts
def get_bitstring_counts(job):
    result = job.result()
    pub_result = result[0]
    counts = pub_result.data.meas.get_counts()
    return counts, pub_result
```

```python
counts, pub_result = get_bitstring_counts(job)
```

A dist√¢ncia de Hamming entre duas bitstrings √© o n√∫mero de √≠ndices nos quais os bits diferem.

```python
def hamming_distance(s1, s2):
    weight = 0
    for c1, c2 in zip(s1, s2):
        (c1, c2) = (int(c1), int(c2))
        if (c1 == 1 and c2 == 1) or (c1 == 0 and c2 == 0):
            weight += 1

    return weight
```

```python
# Replace string of form a1b1a2b2... with b1a1b2a1...
# That is, reverse order of successive pairs of bits.
def unscramble(bitstring):
    ps = [bitstring[i : i + 2][::-1] for i in range(0, len(bitstring), 2)]
    return "".join(ps)

def find_hidden_shift_bitstring(counts, hidden_shift_string):
    # convert counts to probabilities
    probs = {
        unscramble(bitstring): count / NUM_SHOTS
        for bitstring, count in counts.items()
    }

    # Retrieve the most probable bitstring.
    most_probable = max(probs, key=lambda x: probs[x])

    print(f"Expected hidden shift string: {hidden_shift_string}")
    if most_probable == hidden_shift_string:
        print("Most probable bitstring matches hidden shift üòä.")
    else:
        print("Most probable bitstring didn't match hidden shift ‚òπÔ∏è.")
    print("Top 10 bitstrings and their probabilities:")
    display(
        {
            k: (v, hamming_distance(hidden_shift_string, k))
            for k, v in sorted(
                probs.items(), key=lambda x: x[1], reverse=True
            )[:10]
        }
    )

    return probs, most_probable
```

```python
probs, most_probable = find_hidden_shift_bitstring(
    counts, hidden_shift_string
)
```

```text
Expected hidden shift string: 011010
Most probable bitstring matches hidden shift üòä.
Top 10 bitstrings and their probabilities:
```

```text
{'011010': (0.9743, 6),
 '001010': (0.00812, 5),
 '010010': (0.0063, 5),
 '011000': (0.00554, 5),
 '011011': (0.00492, 5),
 '011110': (0.00044, 5),
 '001000': (0.00012, 4),
 '010000': (8e-05, 4),
 '001011': (6e-05, 4),
 '000010': (6e-05, 4)}
```

Vamos registrar a probabilidade da bitstring mais prov√°vel antes de aplicar a mitiga√ß√£o de erro de leitura com M3.

```python
max_probability_before_M3 = probs[most_probable]
max_probability_before_M3
```

```text
0.9743
```

Agora aplicamos a corre√ß√£o de leitura aprendida pelo M3 √†s contagens.
A fun√ß√£o `apply_corrections` retorna uma distribui√ß√£o de quase-probabilidade. Esta √© uma lista de objetos `float` que somam $1$. Mas alguns valores podem ser negativos.

```python
def perform_mitigation(mit, counts, qubit_mapping):
    # mitigate readout error
    quasis = mit.apply_correction(counts, qubit_mapping)

    # print results
    most_probable_after_m3 = unscramble(max(quasis, key=lambda x: quasis[x]))

    is_hidden_shift_identified = most_probable_after_m3 == hidden_shift_string
    if is_hidden_shift_identified:
        print("Most probable bitstring matches hidden shift üòä.")
    else:
        print("Most probable bitstring didn't match hidden shift ‚òπÔ∏è.")
    print("Top 10 bitstrings and their quasi-probabilities:")
    topten = {
        unscramble(k): f"{v:.2e}"
        for k, v in sorted(quasis.items(), key=lambda x: x[1], reverse=True)[
            :10
        ]
    }
    max_probability_after_M3 = float(topten[most_probable_after_m3])
    display(topten)

    return max_probability_after_M3, is_hidden_shift_identified
```

```python
print(f"Expected hidden shift string: {hidden_shift_string}")
max_probability_after_M3, is_hidden_shift_identified = perform_mitigation(
    mit, counts, qubit_mapping
)
```

```text
Expected hidden shift string: 011010
Most probable bitstring matches hidden shift üòä.
Top 10 bitstrings and their quasi-probabilities:
```

```text
{'011010': '1.01e+00',
 '001010': '8.75e-04',
 '001000': '7.38e-05',
 '010000': '4.51e-05',
 '111000': '2.18e-05',
 '001011': '1.74e-05',
 '000010': '6.42e-06',
 '011001': '-7.18e-06',
 '011000': '-4.53e-04',
 '010010': '-1.28e-03'}
```

#### Comparar a identifica√ß√£o da string de deslocamento oculto antes e depois de aplicar a corre√ß√£o M3

```python
def compare_before_and_after_M3(
    max_probability_before_M3,
    max_probability_after_M3,
    is_hidden_shift_identified,
):
    is_probability_improved = (
        max_probability_after_M3 > max_probability_before_M3
    )
    print(f"Most probable probability before M3: {max_probability_before_M3}")
    print(f"Most probable probability after M3: {max_probability_after_M3}")
    if is_hidden_shift_identified and is_probability_improved:
        print("Readout error mitigation effective! üòä")
    else:
        print("Readout error mitigation not effective. ‚òπÔ∏è")
```

```python
compare_before_and_after_M3(
    max_probability_before_M3,
    max_probability_after_M3,
    is_hidden_shift_identified,
)
```

```text
Most probable probability before M3: 0.9743
Most probable probability after M3: 1.01
Readout error mitigation effective! üòä
```

### Plotar como o tempo de CPU exigido pelo M3 escala com shots

```python
# Collect samples for numbers of shots varying from 5000 to 25000.
shots_range = range(5000, NUM_SHOTS + 1, 2500)
times = []
for shots in shots_range:
    print(f"Applying M3 correction to {shots} shots...")
    t0 = timeit.default_timer()
    _ = mit.apply_correction(
        pub_result.data.meas.slice_shots(range(shots)).get_counts(),
        qubit_mapping,
    )
    t1 = timeit.default_timer()
    print(f"\tDone in {t1 - t0} seconds.")
    times.append(t1 - t0)

fig, ax = plt.subplots()
ax.plot(shots_range, times, "o--")
ax.set_xlabel("Shots")
ax.set_ylabel("Time (s)")
ax.set_title("Time to apply M3 correction")
```

```text
Applying M3 correction to 5000 shots...
	Done in 0.003321983851492405 seconds.
Applying M3 correction to 7500 shots...
	Done in 0.004425413906574249 seconds.
Applying M3 correction to 10000 shots...
	Done in 0.006366567220538855 seconds.
Applying M3 correction to 12500 shots...
	Done in 0.0071477219462394714 seconds.
Applying M3 correction to 15000 shots...
	Done in 0.00860048783943057 seconds.
Applying M3 correction to 17500 shots...
	Done in 0.010026784148067236 seconds.
Applying M3 correction to 20000 shots...
	Done in 0.011459112167358398 seconds.
Applying M3 correction to 22500 shots...
	Done in 0.012727141845971346 seconds.
Applying M3 correction to 25000 shots...
	Done in 0.01406092382967472 seconds.
Applying M3 correction to 27500 shots...
	Done in 0.01546052098274231 seconds.
Applying M3 correction to 30000 shots...
	Done in 0.016769016161561012 seconds.
Applying M3 correction to 32500 shots...
	Done in 0.019537431187927723 seconds.
Applying M3 correction to 35000 shots...
	Done in 0.019739801064133644 seconds.
Applying M3 correction to 37500 shots...
	Done in 0.021093040239065886 seconds.
Applying M3 correction to 40000 shots...
	Done in 0.022840639110654593 seconds.
Applying M3 correction to 42500 shots...
	Done in 0.023974396288394928 seconds.
Applying M3 correction to 45000 shots...
	Done in 0.026412792038172483 seconds.
Applying M3 correction to 47500 shots...
	Done in 0.026364430785179138 seconds.
Applying M3 correction to 50000 shots...
	Done in 0.02820305060595274 seconds.
```

```text
Text(0.5, 1.0, 'Time to apply M3 correction')
```

![Output of the previous code cell](/docs/images/tutorials/readout-error-mitigation-sampler/extracted-outputs/33addc38-f738-48ed-a29d-9790f446c036-2.avif)

#### Interpretando o gr√°fico

O gr√°fico acima mostra que o tempo necess√°rio para aplicar a corre√ß√£o M3 escala linearmente com o n√∫mero de shots.
## Aumentando a escala

```python
n_qubits = 80
rng = Random(12345)
circuit, hidden_shift, hidden_shift_string = run_hidden_shift_circuit(
    n_qubits, rng
)

print(f"Hidden shift string {hidden_shift_string}")
```

```text
Hidden shift string 00000010100110101011101110010001010000110011101001101010101001111001100110000111
```

```python
isa_circuit = get_isa_circuit(circuit, backend)
```

```python
job = run_sampler(backend, isa_circuit, NUM_SHOTS)
mit, qubit_mapping = setup_mthree_mitigation(isa_circuit, backend)
```

```python
counts, pub_result = get_bitstring_counts(job)
```

```python
probs, most_probable = find_hidden_shift_bitstring(
    counts, hidden_shift_string
)
```

```text
Expected hidden shift string: 00000010100110101011101110010001010000110011101001101010101001111001100110000111
Most probable bitstring matches hidden shift üòä.
Top 10 bitstrings and their probabilities:
```

```text
{'00000010100110101011101110010001010000110011101001101010101001111001100110000111': (0.50402,
  80),
 '00000010100110101011101110010001010000110011100001101010101001111001100110000111': (0.0396,
  79),
 '00000010100110101011101110010001010000110011101001101010101001111001100100000111': (0.0323,
  79),
 '00000010100110101011101110010001010000110011101001101010101001101001100110000111': (0.01936,
  79),
 '00000010100110101011101110010011010000110011101001101010101001111001100110000111': (0.01432,
  79),
 '00000010100110101011101110010001010000110011101001101010101001011001100110000111': (0.0101,
  79),
 '00000010100110101011101110010001010000110011101001101010101001110001100110000111': (0.00924,
  79),
 '00000010100110101011101110010001010000010011101001101010101001111001100110000111': (0.00908,
  79),
 '00000010100110101011100110010001010000110011101001101010101001111001100110000111': (0.00888,
  79),
 '00000010100110101011101110010001010000110011101001100010101001111001100110000111': (0.0082,
  79)}
```

Vemos que a string de deslocamento oculta correta foi encontrada. Al√©m disso, as nove bitstrings mais prov√°veis seguintes est√£o erradas em apenas uma posi√ß√£o.
Registre a probabilidade mais prov√°vel:

```python
max_probability_before_M3 = probs[most_probable]
max_probability_before_M3
```

```text
0.50402
```

```python
print(f"Expected hidden shift string: {hidden_shift_string}")
max_probability_after_M3, is_hidden_shift_identified = perform_mitigation(
    mit, counts, qubit_mapping
)
```

```text
Expected hidden shift string: 00000010100110101011101110010001010000110011101001101010101001111001100110000111
Most probable bitstring matches hidden shift üòä.
Top 10 bitstrings and their quasi-probabilities:
```

```text
{'00000010100110101011101110010001010000110011101001101010101001111001100110000111': '9.85e-01',
 '00000010100110101011101110010001010000110011100001101010101001111001100110000111': '6.84e-03',
 '00000010100110101011100110010001010000110011101001101010101001111001100110000111': '3.87e-03',
 '00000010100110101011101110010011010000110011101001101010101001111001100110000111': '3.42e-03',
 '00000010100110101011101110010001010000110011101001101010101001111001100100000111': '3.30e-03',
 '00000010100110101011101110010001010000110011101001101010101001110001100110000111': '3.28e-03',
 '00000010100010101011101110010001010000110011101001101010101001111001100110000111': '2.62e-03',
 '00000010100110101011101110010001010000110011101001101010101001101001100110000111': '2.43e-03',
 '00000010100110101011101110010000010000110011101001101010101001111001100110000111': '1.73e-03',
 '00000010100110101011101110010001010000110011101001101010101001111001000110000111': '1.63e-03'}
```

```python
compare_before_and_after_M3(
    max_probability_before_M3,
    max_probability_after_M3,
    is_hidden_shift_identified,
)
```

```text
Most probable probability before M3: 0.54348
Most probable probability after M3: 0.99
Readout error mitigation effective! üòä
```
