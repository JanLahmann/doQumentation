---
title: Tutoriais
sidebar_label: Visão geral
sidebar_position: 1
description: Navegue pelos tutoriais do IBM Quantum — executáveis no RasQberry, via Binder ou no seu próprio servidor Jupyter.
---
{/* doqumentation-source-hash: e0b80945 */}

# Tutoriais {#tutorials}

Use estes tutoriais para aprender como aplicar o Qiskit a casos de uso comuns de computação quântica.

- Comece com o conjunto de tutoriais na seção [Primeiros passos](#primeiros-passos) se esta é a sua primeira vez executando código em um computador quântico.
- A seção sobre [fluxos de trabalho em direção à vantagem](#explore-fluxos-de-trabalho-em-direção-à-vantagem) contém exemplos completos de uso de um computador quântico para resolver problemas do mundo real. Esses tutoriais focam em algoritmos que são candidatos promissores para alcançar vantagem computacional de um computador quântico sobre um computador clássico.
- A seção sobre [capacidades do Qiskit](#aproveite-as-capacidades-do-qiskit) contém exemplos que usam as técnicas mais recentes e avançadas do ecossistema Qiskit para melhorar parte ou todo um fluxo de trabalho específico.

## Primeiros passos {#get-started}

Esses tutoriais são para iniciantes que estão prontos para explorar a execução de algoritmos quânticos em um computador quântico.

* [Desigualdade CHSH](/tutorials/chsh-inequality)

## Explore fluxos de trabalho em direção à vantagem {#explore-workflows-toward-advantage}

Os tutoriais nesta seção cobrem demonstrações em larga escala de algoritmos quânticos.

<details>
  <summary>**Algoritmos de amostragem verificáveis**</summary>

Os algoritmos nesta categoria focam em circuitos quânticos cujas distribuições de saída codificam soluções para problemas estruturados com saída verificável. Verificabilidade significa que você pode verificar a consistência entre dados medidos, seja avaliando a string de bits escolhida ou sabendo que falsos positivos não ocorrem.

Os tutoriais destacam técnicas onde amostragem repetida permite a estimativa de quantidades específicas do problema (por exemplo, valores de função de custo ou pesos espectrais). Esses métodos são particularmente relevantes para tarefas de otimização e simulação com simetrias.

* [Diagonalização quântica baseada em amostragem de um Hamiltoniano químico](/tutorials/sample-based-quantum-diagonalization)

* [Diagonalização quântica de Krylov baseada em amostragem de um modelo de rede fermiônica](/tutorials/sample-based-krylov-quantum-diagonalization)

* [Algoritmo de otimização aproximada quântica](/tutorials/quantum-approximate-optimization-algorithm)

* [Técnicas avançadas para QAOA](/tutorials/advanced-techniques-for-qaoa)

* [Codificação de Correlação de Pauli para reduzir requisitos de Maxcut](/tutorials/pauli-correlation-encoding-for-qaoa)

</details>

<details>
  <summary>**Estimativa de observáveis**</summary>

Esses tutoriais focam em estimar quantidades fisicamente significativas, como energia ou valores de correlação, preparando estados quânticos e medindo observáveis. As técnicas incluem abordagens de circuito variacionais e trotterizadas que equilibram expressividade do circuito com eficiência de profundidade do circuito. A ênfase é colocada em fluxos de trabalho que reduzem demandas de recursos quânticos mantendo a precisão, e permitindo estimativa prática de observáveis em sistemas químicos e físicos.

* [Diagonalização quântica de Krylov de Hamiltonianos de rede](/tutorials/krylov-quantum-diagonalization)

* [Transição de fase de Nishimori](/tutorials/nishimori-phase-transition)

* [Estimativa de energia do estado fundamental da cadeia de Heisenberg com VQE](/tutorials/spin-chain-vqe)

* [Treinamento de kernel quântico](/tutorials/quantum-kernel-training)

* [Aprimore a classificação de características usando kernels quânticos projetados](/tutorials/projected-quantum-kernels)

* [Desigualdade CHSH](/tutorials/chsh-inequality)

</details>

<details>
  <summary>**Algoritmos tolerantes a falhas**</summary>

Esta seção apresenta algoritmos com garantias teóricas bem definidas que são projetados para executar em hardware quântico com correção de erros futuro. Os circuitos ou sobrecarga de amostragem para esses algoritmos escalam de uma maneira que não é eficiente em profundidade e, portanto, são mais propensos a demonstrar vantagem quântica quando computadores quânticos tolerantes a falhas existirem. Esses tutoriais ilustram como os métodos operam em configurações idealizadas e demonstram exemplos em pequena escala.

* [Algoritmo de Shor](/tutorials/shors-algorithm)
* [Algoritmo de Grover](/tutorials/grovers-algorithm)

</details>

## Aproveite as capacidades do Qiskit {#leverage-qiskit-capabilities}

Esta seção introduz capacidades avançadas dentro do ecossistema Qiskit que melhoram o desempenho, confiabilidade e velocidade ao executar algoritmos quânticos.

<details>
  <summary>**Otimização de carga de trabalho**</summary>

A otimização de carga de trabalho foca em orquestração eficiente de recursos clássicos e quânticos ou métodos personalizados para melhorar a manipulação de circuitos quânticos.

* [Benchmark de circuitos dinâmicos com pares de Bell cortados](/tutorials/edc-cut-bell-pair-benchmarking)

* [Introdução a portas fracionárias](/tutorials/fractional-gates)

* [Introdução ao serviço de transpilador com IA do Qiskit](/tutorials/ai-transpiler-introduction)

* [Otimizações de transpilação com SABRE](/tutorials/transpilation-optimizations-with-sabre)

* [Métodos de compilação para circuitos de simulação Hamiltoniana](/tutorials/compilation-methods-for-hamiltonian-simulation-circuits)

* [Emaranhamento de longo alcance com circuitos dinâmicos](/tutorials/long-range-entanglement)

* [Simulação de Hamiltoniano de Ising chutado com circuitos dinâmicos](/tutorials/dc-hex-ising)

</details>

<details>
<summary>**Funções Qiskit**</summary>

As Funções Qiskit são uma coleção de ferramentas de gerenciamento de erros e aplicações pré-empacotadas, facilitando o design de experimentos em larga escala com circuitos, moléculas, QUBOs e muito mais.

- Projete novos algoritmos com **Funções de circuito** -- com pipelines de transpilação, supressão de erros e mitigação de erros pré-construídos.

  * [Mitigação de erros com a função de circuito IBM](/tutorials/error-mitigation-with-qiskit-functions)

  * [Modelo de Ising de Campo Transversal com Gerenciamento de Desempenho da Q-CTRL](/tutorials/transverse-field-ising-model)

  * [Estimativa de Fase Quântica com Funções Qiskit da Q-CTRL](/tutorials/quantum-phase-estimation-qctrl)

  * [Simule Ising 2D com campo inclinado com a função QESEM](/tutorials/qedma-2d-ising-with-qesem)

- Experimente com problemas específicos de domínio com **Funções de aplicação** -- com entradas e saídas familiares aos solucionadores clássicos.

  * [Otimizador de Portfólio Quântico - Uma Função Qiskit da Global Data Quantum](/tutorials/global-data-quantum-optimizer)

  * [Otimização binária de ordem superior com o Solucionador de Otimização da Q-CTRL](/tutorials/solve-higher-order-binary-optimization-problems-with-q-ctrls-optimization-solver)

  * [Modele um fluido não viscoso em escoamento usando QUICK-PDE](/tutorials/colibritd-pde)

  * [Curvas PES de dissociação com Qunova HiVQE](/tutorials/qunova-hivqe)

  * [Classificação de ensemble híbrida aprimorada quanticamente (fluxo de trabalho de estabilidade de rede)](/tutorials/sml-classification)

  * [Resolva o problema de Market Split com o Iskay Quantum Optimizer da Kipu Quantum](/tutorials/solve-market-split-problem-with-iskay-quantum-optimizer)

</details>

<details>
  <summary>**Complementos Qiskit**</summary>

Os complementos permitem manipulação avançada de circuitos, como corte, retropropagação de observáveis ou aproximação de circuitos, que permitem aos usuários contornar limitações de hardware ao custo de sobrecarga computacional clássica aumentada.

* [Fórmulas multiproduto para reduzir erro de Trotter](/tutorials/multi-product-formula)

* [Compilação quântica aproximada para circuitos de evolução temporal](/tutorials/approximate-quantum-compilation-for-time-evolution)

* [Retropropagação de operadores (OBP) para estimativa de valores de expectativa](/tutorials/operator-back-propagation)

* [Corte de fios para estimativa de valores de expectativa](/tutorials/wire-cutting)

* [Corte de circuitos para condições de contorno periódicas](/tutorials/periodic-boundary-conditions-with-circuit-cutting)

* [Corte de circuitos para redução de profundidade](/tutorials/depth-reduction-with-circuit-cutting)

* [Mitigação de erros de leitura para a primitiva Sampler usando M3](/tutorials/readout-error-mitigation-sampler)

</details>

<details>
  <summary>**Mitigação de erros**</summary>

A mitigação de erros aborda o desafio do ruído sem tolerância total a falhas recuperando valores de expectativa precisos através de manipulação controlada de circuitos e pós-processamento.

* [Mitigação de erros em escala de utilidade com amplificação probabilística de erros](/tutorials/probabilistic-error-amplification)

* [Combine opções de mitigação de erros com a primitiva Estimator](/tutorials/combine-error-mitigation-techniques)

* [Benchmarking em tempo real para seleção de qubits](/tutorials/real-time-benchmarking-for-qubit-selection)

</details>

<details>
  <summary>**Detecção de erros**</summary>

A detecção de erros identifica operações com falha para retornar resultados livres de ruído shot por shot através de pós-processamento.

* [Códigos de repetição](/tutorials/repetition-codes)

* [Detecção de erros de baixa sobrecarga com códigos espaço-temporais](/tutorials/ghz-spacetime-codes)

</details>

