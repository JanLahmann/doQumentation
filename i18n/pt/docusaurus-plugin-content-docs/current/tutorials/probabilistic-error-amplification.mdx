---
title: "Mitigação de erros em escala de utilidade com amplificação probabilística de erros"
sidebar_label: "Mitigação de erros em escala de utilidade com amplificação probabilística de erros"
description: "Execute um experimento de mitigação de erros em escala de utilidade com extrapolação de ruído zero e amplificação probabilística de erros."
notebook_path: "docs/tutorials/probabilistic-error-amplification.ipynb"
---

<OpenInLabBanner notebookPath="docs/tutorials/probabilistic-error-amplification.ipynb" />



{/* cspell:ignore mapsto multigraph inds extrap sharex sharey pidx */}

*Estimativa de uso: 16 minutos em um processador Heron r2 (NOTA: Esta é apenas uma estimativa. Seu tempo de execução pode variar.)*
## Contexto {#background}

Este tutorial demonstra como executar um experimento de mitigação de erros em escala de utilidade com Qiskit Runtime usando uma versão experimental de *extrapolação de ruído zero* (ZNE) com *amplificação probabilística de erros* (PEA).

![kim_nature_fig.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/e1e67c34-9d4d-4a88-9340-f0b2f3676770.avif)
__Referência__: Y. Kim et al. *Evidence for the utility of quantum computing before fault tolerance.* [Nature 618.7965 (2023)](https://www.nature.com/articles/s41586-023-06096-3)
### Extrapolação de Ruído Zero (ZNE) {#zero-noise-extrapolation-zne}
A extrapolação de ruído zero (ZNE) é uma técnica de mitigação de erros que remove os efeitos de um ruído *desconhecido* durante a execução do circuito que pode ser escalado de forma *conhecida*.

Ela pressupõe que os valores esperados escalam com o ruído por uma função conhecida

$$
\langle A(\lambda) \rangle = \langle A(0) \rangle + \sum_{k=0}^{m} a_k \lambda^k + R
$$
onde $\lambda$ parametriza a intensidade do ruído e pode ser amplificado.
Podemos implementar ZNE com os seguintes passos:

1. Amplificar o ruído do circuito para vários fatores de ruído $\lambda_1, \lambda_2, ... $
2. Executar cada circuito com ruído amplificado para medir $\langle A(\lambda_1)\rangle, ...$
3. Extrapolar de volta ao limite de ruído zero $\langle A(0)\rangle$

![zne_stages.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/5e63d706-82d8-4212-b802-c9191ce53341.avif)
#### Amplificar ruído para ZNE {#amplify-noise-for-zne}
O principal desafio na implementação bem-sucedida de ZNE é ter um modelo preciso para o ruído no valor esperado e amplificar o ruído de forma conhecida.

Existem três maneiras comuns pelas quais a amplificação de erros é implementada para ZNE.

| **Estiramento de pulso** | **Dobramento de portas** | **Amplificação probabilística de erros** |
|-----------|-----------|-----------|
| Escala a duração do pulso via calibração | Repete portas em ciclos de identidade $U\mapsto U(U^{-1}U)^{\lambda-1}/2$ | Adiciona ruído via amostragem de canais de Pauli |
| ![zne_pulse_stretching.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/83188b57-e88f-43a1-a7bd-29327f46ecf5.avif) | ![zne_gate_folding.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/e1358d08-2632-4fd2-bf0f-f9384a2d3340.avif) | ![zne_pea.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/3d69d5bd-70e5-4eeb-aa02-fc0a62043010.avif) |
| Kandala et al. Nature (2019) | Shultz et al. PRA (2022) | Li & Benjamin PRX (2017) |
Para experimentos em escala de utilidade, a *amplificação probabilística de erros* (PEA) é a mais atraente.
- O estiramento de pulso pressupõe que o ruído da porta é proporcional à duração, o que tipicamente não é verdade. A calibração também é custosa.
- O dobramento de portas requer grandes fatores de estiramento que limitam muito a profundidade dos circuitos que podem ser executados.
- PEA pode ser aplicada a qualquer circuito que possa ser executado com fator de ruído nativo ($\lambda=1$), mas requer o aprendizado do modelo de ruído.
### Aprender o modelo de ruído para PEA {#learn-the-noise-model-for-pea}
PEA pressupõe o mesmo modelo de ruído baseado em camadas que o *cancelamento probabilístico de erros* (PEC); no entanto, evita a sobrecarga de amostragem que escala exponencialmente com o ruído do circuito.
| **Passo 1** | **Passo 2** | **Passo 3** |
|-----------|-----------|-----------|
| Aplica entrelaçamento de Pauli em camadas de portas de dois qubits | Repete pares de identidade de camadas e aprende o ruído | Deriva uma fidelidade (erro para cada canal de ruído) |
| ![pec_pauli_twirling.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/2eab5ff4-40fa-4a41-9f2c-74f5e22c4643.avif) | ![pec_learn_layer.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/8d0d64c3-65ad-4419-8ac9-4ec9633d39a0.avif) | ![pec_curve_fitting.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/c51bd42d-2463-4c78-807b-d284ca79296f.avif) |

__Referência__: E. van den Berg, Z. Minev, A. Kandala, and K. Temme, _Probabilistic error cancellation with sparse Pauli-Lindblad models on noisy quantum processors_ [arXiv:2201.09866](https://arxiv.org/abs/2201.09866)
## Requisitos {#requirements}

Antes de iniciar este tutorial, certifique-se de ter o seguinte instalado:

- Qiskit SDK v1.0 ou posterior, com suporte para [visualização](https://docs.quantum.ibm.com/api/qiskit/visualization)
- Qiskit Runtime v0.22 ou posterior (`pip install qiskit-ibm-runtime`)
## Configuração {#setup}

```python
from __future__ import annotations
from collections.abc import Sequence
from collections import defaultdict
import numpy as np
import rustworkx
import matplotlib.pyplot as plt

from qiskit.circuit import QuantumCircuit, Parameter
from qiskit.circuit.library import CXGate, CZGate, ECRGate
from qiskit.providers import Backend
from qiskit.visualization import plot_error_map
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit.quantum_info import SparsePauliOp
from qiskit.primitives import PubResult

from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_runtime import EstimatorV2 as Estimator
```

## Passo 1: Mapear entradas clássicas para um problema quântico {#step-1-map-classical-inputs-to-a-quantum-problem}
### Criar um circuito de modelo de Ising parametrizado {#create-a-parameterized-ising-model-circuit}
Primeiro, escolha um backend para executar. Esta demonstração é executada em um backend de 127 qubits, mas você pode modificar isso para qualquer backend disponível para você.

```python
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=127
)
backend
```

```text
<IBMBackend('ibm_kingston')>
```

#### Funções auxiliares para construção de circuito {#helper-functions-for-circuit-construction}
Em seguida, crie algumas funções auxiliares para construir os circuitos para a evolução temporal Trotterizada de um modelo de Ising de campo transversal bidimensional que adere à topologia do backend.

```python
"""Trotter circuit generation"""

def remove_qubit_couplings(
    couplings: Sequence[tuple[int, int]], qubits: Sequence[int] | None = None
) -> list[tuple[int, int]]:
    """Remove qubits from a coupling list.

    Args:
        couplings: A sequence of qubit couplings.
        qubits: Optional, the qubits to remove.

    Returns:
        The input couplings with the specified qubits removed.
    """
    if qubits is None:
        return couplings
    qubits = set(qubits)
    return [edge for edge in couplings if not qubits.intersection(edge)]

def coupling_qubits(
    *couplings: Sequence[tuple[int, int]],
    allowed_qubits: Sequence[int] | None = None,
) -> list[int]:
    """Return a sorted list of all qubits involved in one or more couplings lists.

    Args:
        couplings: one or more coupling lists.
        allowed_qubits: Optional, the allowed qubits to include. If None all
            qubits are allowed.

    Returns:
        The intersection of all qubits in the couplings and the allowed qubits.
    """
    qubits = set()
    for edges in couplings:
        for edge in edges:
            qubits.update(edge)
    if allowed_qubits is not None:
        qubits = qubits.intersection(allowed_qubits)
    return list(qubits)

def construct_layer_couplings(
    backend: Backend,
) -> list[list[tuple[int, int]]]:
    """Separate a coupling map into disjoint 2-qubit gate layers.

    Args:
        backend: A backend to construct layer couplings for.

    Returns:
        A list of disjoint layers of directed couplings for the input coupling map.
    """
    coupling_graph = backend.coupling_map.graph.to_undirected(
        multigraph=False
    )
    edge_coloring = rustworkx.graph_bipartite_edge_color(coupling_graph)

    layers = defaultdict(list)
    for edge_idx, color in edge_coloring.items():
        layers[color].append(
            coupling_graph.get_edge_endpoints_by_index(edge_idx)
        )
    layers = [sorted(layers[i]) for i in sorted(layers.keys())]

    return layers

def entangling_layer(
    gate_2q: str,
    couplings: Sequence[tuple[int, int]],
    qubits: Sequence[int] | None = None,
) -> QuantumCircuit:
    """Generating a entangling layer for the specified couplings.

    This corresponds to a Trotter layer for a ZZ Ising term with angle Pi/2.

    Args:
        gate_2q: The 2-qubit basis gate for the layer, should be "cx", "cz", or "ecr".
        couplings: A sequence of qubit couplings to add CX gates to.
        qubits: Optional, the physical qubits for the layer. Any couplings involving
            qubits not in this list will be removed. If None the range up to the largest
            qubit in the couplings will be used.

    Returns:
        The QuantumCircuit for the entangling layer.
    """
    # Get qubits and convert to set to order
    if qubits is None:
        qubits = range(1 + max(coupling_qubits(couplings)))
    qubits = set(qubits)

    # Mapping of physical qubit to virtual qubit
    qubit_mapping = {q: i for i, q in enumerate(qubits)}

    # Convert couplings to indices for virtual qubits
    indices = [
        [qubit_mapping[i] for i in edge]
        for edge in couplings
        if qubits.issuperset(edge)
    ]

    # Layer circuit on virtual qubits
    circuit = QuantumCircuit(len(qubits))

    # Get 2-qubit basis gate and pre and post rotation circuits
    gate2q = None
    pre = QuantumCircuit(2)
    post = QuantumCircuit(2)

    if gate_2q == "cx":
        gate2q = CXGate()
        # Pre-rotation
        pre.sdg(0)
        pre.z(1)
        pre.sx(1)
        pre.s(1)
        # Post-rotation
        post.sdg(1)
        post.sxdg(1)
        post.s(1)
    elif gate_2q == "ecr":
        gate2q = ECRGate()
        # Pre-rotation
        pre.z(0)
        pre.s(1)
        pre.sx(1)
        pre.s(1)
        # Post-rotation
        post.x(0)
        post.sdg(1)
        post.sxdg(1)
        post.s(1)
    elif gate_2q == "cz":
        gate2q = CZGate()
        # Identity pre-rotation
        # Post-rotation
        post.sdg([0, 1])
    else:
        raise ValueError(
            f"Invalid 2-qubit basis gate {gate_2q}, should be 'cx', 'cz', or 'ecr'"
        )

    # Add 1Q pre-rotations
    for inds in indices:
        circuit.compose(pre, qubits=inds, inplace=True)

    # Use barriers around 2-qubit basis gate to specify a layer for PEA noise learning
    circuit.barrier()
    for inds in indices:
        circuit.append(gate2q, (inds[0], inds[1]))
    circuit.barrier()

    # Add 1Q post-rotations after barrier
    for inds in indices:
        circuit.compose(post, qubits=inds, inplace=True)

    # Add physical qubits as metadata
    circuit.metadata["physical_qubits"] = tuple(qubits)

    return circuit

def trotter_circuit(
    theta: Parameter | float,
    layer_couplings: Sequence[Sequence[tuple[int, int]]],
    num_steps: int,
    gate_2q: str | None = "cx",
    backend: Backend | None = None,
    qubits: Sequence[int] | None = None,
) -> QuantumCircuit:
    """Generate a Trotter circuit for the 2D Ising

    Args:
        theta: The angle parameter for X.
        layer_couplings: A list of couplings for each entangling layer.
        num_steps: the number of Trotter steps.
        gate_2q: The 2-qubit basis gate to use in entangling layers.
            Can be "cx", "cz", "ecr", or None if a backend is provided.
        backend: A backend to get the 2-qubit basis gate from, if provided
            will override the basis_gate field.
        qubits: Optional, the allowed physical qubits to truncate the
            couplings to. If None the range up to the largest
            qubit in the couplings will be used.

    Returns:
        The Trotter circuit.
    """
    if backend is not None:
        try:
            basis_gates = backend.configuration().basis_gates
        except AttributeError:
            basis_gates = backend.basis_gates
        for gate in ["cx", "cz", "ecr"]:
            if gate in basis_gates:
                gate_2q = gate
                break

    # If no qubits, get the largest qubit from all layers and
    # specify the range so the same one is used for all layers.
    if qubits is None:
        qubits = range(1 + max(coupling_qubits(layer_couplings)))

    # Generate the entangling layers
    layers = [
        entangling_layer(gate_2q, couplings, qubits=qubits)
        for couplings in layer_couplings
    ]

    # Construct the circuit for a single Trotter step
    num_qubits = len(qubits)
    trotter_step = QuantumCircuit(num_qubits)
    trotter_step.rx(theta, range(num_qubits))
    for layer in layers:
        trotter_step.compose(layer, range(num_qubits), inplace=True)

    # Construct the circuit for the specified number of Trotter steps
    circuit = QuantumCircuit(num_qubits)
    for _ in range(num_steps):
        circuit.rx(theta, range(num_qubits))
        for layer in layers:
            circuit.compose(layer, range(num_qubits), inplace=True)

    circuit.metadata["physical_qubits"] = tuple(qubits)
    return circuit
```

#### Definir acoplamentos de camada de entrelaçamento {#define-entangling-layer-couplings}
Para implementar a simulação de Ising Trotterizada, defina três camadas de acoplamentos de portas de dois qubits para o dispositivo, a serem repetidas em cada um dos passos de Trotter. Estas definem as três camadas entrelaçadas para as quais você precisa aprender o ruído para implementar a mitigação.

```python
layer_couplings = construct_layer_couplings(backend)
for i, layer in enumerate(layer_couplings):
    print(f"Layer {i}:\n{layer}\n")
```

```text
Layer 0:
[(2, 3), (4, 5), (6, 7), (8, 9), (10, 11), (12, 13), (14, 15), (16, 23), (18, 31), (19, 35), (20, 21), (25, 37), (26, 27), (28, 29), (33, 39), (36, 41), (38, 49), (42, 43), (45, 46), (47, 57), (51, 52), (53, 54), (56, 63), (58, 71), (59, 75), (61, 62), (64, 65), (66, 67), (68, 69), (72, 73), (76, 81), (79, 93), (82, 83), (84, 85), (86, 87), (88, 89), (91, 98), (94, 95), (97, 107), (99, 115), (100, 101), (102, 103), (105, 117), (108, 109), (110, 111), (113, 114), (116, 121), (118, 129), (123, 136), (124, 125), (126, 127), (130, 131), (132, 133), (135, 139), (138, 151), (142, 143), (144, 145), (146, 147), (152, 153), (154, 155)]

Layer 1:
[(0, 1), (3, 16), (5, 6), (7, 8), (11, 18), (13, 14), (17, 27), (21, 22), (23, 24), (25, 26), (29, 38), (30, 31), (32, 33), (34, 35), (39, 53), (41, 42), (43, 56), (44, 45), (47, 48), (49, 50), (51, 58), (54, 55), (57, 67), (60, 61), (62, 63), (65, 66), (69, 78), (70, 71), (73, 79), (74, 75), (77, 85), (80, 81), (83, 84), (87, 97), (89, 90), (91, 92), (93, 94), (96, 103), (101, 116), (104, 105), (106, 107), (109, 118), (111, 112), (113, 119), (114, 115), (117, 125), (121, 122), (123, 124), (127, 137), (128, 129), (131, 138), (133, 134), (136, 143), (139, 155), (140, 141), (145, 146), (147, 148), (149, 150), (151, 152)]

Layer 2:
[(1, 2), (3, 4), (7, 17), (9, 10), (11, 12), (15, 19), (21, 36), (22, 23), (24, 25), (27, 28), (29, 30), (31, 32), (33, 34), (37, 45), (40, 41), (43, 44), (46, 47), (48, 49), (50, 51), (52, 53), (55, 59), (61, 76), (63, 64), (65, 77), (67, 68), (69, 70), (71, 72), (73, 74), (78, 89), (81, 82), (83, 96), (85, 86), (87, 88), (90, 91), (92, 93), (95, 99), (98, 111), (101, 102), (103, 104), (105, 106), (107, 108), (109, 110), (112, 113), (119, 133), (120, 121), (122, 123), (125, 126), (127, 128), (129, 130), (131, 132), (134, 135), (137, 147), (141, 142), (143, 144), (148, 149), (150, 151), (153, 154)]
```

#### Remover qubits ruins {#remove-bad-qubits}
Observe o mapa de acoplamento para o backend e veja se algum qubit se conecta a acoplamentos com erro alto. Remova esses qubits "ruins" do seu experimento.

```python
# Plot gate error map
# NOTE: These can change over time, so your results may look different
plot_error_map(backend)
```

![Output of the previous code cell](/docs/images/tutorials/probabilistic-error-amplification/extracted-outputs/401e2d48-1b39-40c8-bf32-7b439ae0980d-0.avif)

```python
bad_qubits = {
    56,
    63,
    67,
}  # qubits removed based on high coupling error (1.00)
good_qubits = list(set(range(backend.num_qubits)).difference(bad_qubits))
print("Physical qubits:\n", good_qubits)
```

```text
Physical qubits:
 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62, 64, 65, 66, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155]
```

#### Geração do circuito principal de Trotter {#main-trotter-circuit-generation}

```python
num_steps = 6
theta = Parameter("theta")
circuit = trotter_circuit(
    theta, layer_couplings, num_steps, qubits=good_qubits, backend=backend
)
```

### Criar uma lista de valores de parâmetros a serem atribuídos posteriormente {#create-a-list-of-parameter-values-to-be-assigned-later}

```python
num_params = 12

# 12 parameter values for Rx between [0, pi/2].
# Reshape to outer product broadcast with observables
parameter_values = np.linspace(0, np.pi / 2, num_params).reshape(
    (num_params, 1)
)
num_params = parameter_values.size
```

## Passo 2: Otimizar o problema para execução em hardware quântico {#step-2-optimize-problem-for-quantum-hardware-execution}

### Circuito ISA {#isa-circuit}
Antes de executar o circuito no hardware, otimize-o para execução no hardware. Este processo envolve algumas etapas:

- Escolher um layout de qubit que mapeia os qubits virtuais do seu circuito para qubits físicos no hardware.
- Inserir portas swap conforme necessário para rotear interações entre qubits que não estão conectados.
- Traduzir as portas em nosso circuito para instruções de [Arquitetura de Conjunto de Instruções (ISA)](/guides/transpile#instruction-set-architecture) que podem ser executadas diretamente no hardware.
- Realizar otimizações de circuito para minimizar a profundidade do circuito e a contagem de portas.

Embora o transpilador integrado no Qiskit possa realizar todas essas etapas, este tutorial demonstra a construção do circuito Trotter de escala utilitária de forma ground-up. Selecione os bons qubits físicos e defina camadas de emaranhamento em pares de qubits conectados desses qubits selecionados. No entanto, você ainda precisa traduzir portas não-ISA no circuito e aproveitar qualquer otimização de circuito oferecida pelo transpilador.

Transpile seu circuito para o backend escolhido criando um gerenciador de passagens e depois executando o gerenciador de passagens no circuito. Além disso, fixe o layout inicial do circuito aos `good_qubits` já selecionados. Uma maneira fácil de criar um gerenciador de passagens é usar a função [`generate_preset_pass_manager`](https://docs.quantum.ibm.com/api/qiskit/qiskit.transpiler.generate_preset_pass_manager). Consulte [Transpile com gerenciadores de passagens](/guides/transpile-with-pass-managers) para uma explicação mais detalhada sobre transpilação com gerenciadores de passagens.

```python
pm = generate_preset_pass_manager(
    backend=backend,
    initial_layout=good_qubits,
    layout_method="trivial",
    optimization_level=1,
)

isa_circuit = pm.run(circuit)
```

### Observáveis ISA {#isa-observables}
Em seguida, crie todos os observáveis $\langle Z \rangle$ de peso-1 para cada qubit virtual preenchendo o número necessário de termos $\langle I \rangle$.

```python
observables = []
num_qubits = len(good_qubits)
for q in range(num_qubits):
    observables.append(
        SparsePauliOp("I" * (num_qubits - q - 1) + "Z" + "I" * q)
    )
```

O processo de transpilação mapeou os qubits virtuais do seu circuito para qubits físicos no hardware. A informação sobre o layout de qubit é armazenada no atributo `layout` do circuito transpilado. Seu observável também é definido em termos dos qubits virtuais, então você precisa aplicar este layout ao observável. Isso é feito usando o método `apply_layout` de `SparsePauliOp`.

Observe que cada observável é envolvido em uma lista no seguinte bloco de código. Isso é feito para fazer _broadcast_ com valores de parâmetro para que cada observável de qubit seja medido para cada valor theta. As regras de broadcasting para primitivas podem ser encontradas [aqui](/guides/primitives).

```python
isa_observables = [
    [obs.apply_layout(layout=isa_circuit.layout)] for obs in observables
]
```

## Passo 3: Executar usando primitivas Qiskit {#step-3-execute-using-qiskit-primitives}

```python
pub = (isa_circuit, isa_observables, parameter_values)
```

### Configurar opções do Estimator {#configure-estimator-options}
Em seguida, configure as opções do `Estimator` necessárias para executar o experimento de mitigação. Isso inclui opções para o aprendizado de ruído das camadas de emaranhamento e para extrapolação ZNE.

Usamos a seguinte configuração:

```python
# Experiment options
num_randomizations = 700
num_randomizations_learning = 40
max_batch_circuits = 3 * num_params
shots_per_randomization = 64
learning_pair_depths = [0, 1, 2, 4, 6, 12, 24]
noise_factors = [1, 1.3, 1.6]
extrapolated_noise_factors = np.linspace(0, max(noise_factors), 20)

# Base option formatting
options = {
    # Builtin resilience settings for ZNE
    "resilience": {
        "measure_mitigation": True,
        "zne_mitigation": True,
        # TREX noise learning configuration
        "measure_noise_learning": {
            "num_randomizations": num_randomizations_learning,
            "shots_per_randomization": 1024,
        },
        # PEA noise model configuration
        "layer_noise_learning": {
            "max_layers_to_learn": 3,
            "layer_pair_depths": learning_pair_depths,
            "shots_per_randomization": shots_per_randomization,
            "num_randomizations": num_randomizations_learning,
        },
        "zne": {
            "amplifier": "pea",
            "noise_factors": noise_factors,
            "extrapolator": ("exponential", "linear"),
            "extrapolated_noise_factors": extrapolated_noise_factors.tolist(),
        },
    },
    # Randomization configuration
    "twirling": {
        "num_randomizations": num_randomizations,
        "shots_per_randomization": shots_per_randomization,
        "strategy": "active-circuit",
    },
    # Optional Dynamical Decoupling (DD)
    "dynamical_decoupling": {"enable": True, "sequence_type": "XY4"},
}
```

#### Explicação das opções ZNE {#explanation-of-zne-options}
O seguinte fornece detalhes sobre as opções adicionais no ramo experimental. Observe que essas opções e nomes não estão finalizados, e tudo aqui está sujeito a alterações antes de um lançamento oficial.

* __amplifier__: O método a ser usado ao amplificar ruído para os fatores de ruído pretendidos.
    Os valores permitidos são `"gate_folding"`, que amplifica repetindo portas de base de dois qubits,
    e `"pea"`, que amplifica por amostragem probabilística após aprender o
    modelo de ruído Pauli-twirled para camadas de portas de base de dois qubits twirled. Também existem opções `"gate_folding_front"` e `"gate_folding_back"` que são explicadas na [documentação da API](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/options-zne-options#amplifier)
* __extrapolated_noise_factors__: Especifique um ou mais valores de fator de ruído nos quais avaliar os
    modelos extrapolados. Se uma sequência de valores, os resultados retornados serão avaliados como array com o fator de ruído especificado avaliado para o modelo de extrapolação. Um valor
    de 0 corresponde à extrapolação de ruído zero.
### Executar o experimento {#run-the-experiment}

```python
estimator = Estimator(mode=backend, options=options)
job = estimator.run([pub])
```

```python
print(f"Job ID {job.job_id()}")
```

```text
Job ID d0mcsvik4jhc73afljrg
```

## Passo 4: Pós-processar e retornar resultado no formato clássico desejado {#step-4-post-process-and-return-result-in-desired-classical-format}
Uma vez que o experimento esteja finalizado, você pode visualizar seus resultados. Você busca os valores de expectativa brutos e mitigados e os compara com resultados exatos. Em seguida, plota os valores de expectativa, tanto mitigados (extrapolados) quanto brutos, calculados em média sobre todos os qubits para cada parâmetro. Finalmente, plota valores de expectativa para sua escolha de qubits individuais.

```python
primitive_result = job.result()
```

### Formas de resultado geral e metadados {#general-result-shapes-and-metadata}
O objeto `PrimitiveResult` contém uma estrutura tipo lista chamada `PubResult`. Como submetemos apenas um PUB ao estimador, o `PrimitiveResult` contém um único objeto `PubResult`.

Os valores de expectativa e erros padrão do resultado PUB (primitive unified bloc) são avaliados como array. Para trabalhos do estimador com ZNE, existem vários campos de dados de valores de expectativa e erros padrão disponíveis no contêiner `DataBin` do `PubResult`. Discutiremos brevemente os campos de dados para valores de expectativa aqui (campos de dados semelhantes estão disponíveis para erros padrão (`stds`) também).

1. `pub_result.data.evs`: Valores de expectativa correspondentes ao ruído zero (baseado na melhor extrapolação heurística).
    - O primeiro eixo é o índice de qubit virtual para o observável $\langle Z_i\rangle$ ($124$ qubits virtuais/observáveis)
    - O segundo eixo indexa o valor do parâmetro para $\theta$ ($12$ valores de parâmetro)
2. `pub_result.data.evs_extrapolated`: Valores de expectativa para fatores de ruído extrapolados para cada extrapolador. Este array tem dois eixos adicionais.
    - O terceiro eixo indexa os métodos de extrapolação ($2$ extrapoladores, `exponential` e `linear`)
    - O último eixo indexa os `extrapolated_noise_factors` ($20$ pontos de extrapolação especificados na opção)
3. `pub_result.data.evs_noise_factors`: Valores de expectativa brutos para cada fator de ruído.
   - O terceiro eixo indexa os `noise_factors` brutos ($3$ fatores)

```python
pub_result = primitive_result[0]

print(
    f"{pub_result.data.evs.shape=}\n"
    f"{pub_result.data.evs_extrapolated.shape=}\n"
    f"{pub_result.data.evs_noise_factors.shape=}\n"
)
```

```text
pub_result.data.evs.shape=(153, 12)
pub_result.data.evs_extrapolated.shape=(153, 12, 2, 20)
pub_result.data.evs_noise_factors.shape=(153, 12, 3)
```

Vários campos de metadados também estão disponíveis no `PrimitiveResult`. Os metadados incluem
- `resilience/zne/noise_factors`: Os fatores de ruído brutos
- `resilience/zne/extrapolator`: Os extrapoladores usados para cada resultado

```python
primitive_result.metadata
```

```text
{'dynamical_decoupling': {'enable': True,
  'sequence_type': 'XY4',
  'extra_slack_distribution': 'middle',
  'scheduling_method': 'alap'},
 'twirling': {'enable_gates': True,
  'enable_measure': True,
  'num_randomizations': 700,
  'shots_per_randomization': 64,
  'interleave_randomizations': True,
  'strategy': 'active-circuit'},
 'resilience': {'measure_mitigation': True,
  'zne_mitigation': True,
  'pec_mitigation': False,
  'zne': {'noise_factors': [1.0, 1.3, 1.6],
   'extrapolator': ['exponential', 'linear'],
   'extrapolated_noise_factors': [0.0,
    0.08421052631578947,
    0.16842105263157894,
    0.25263157894736843,
    0.3368421052631579,
    0.42105263157894735,
    0.5052631578947369,
    0.5894736842105263,
    0.6736842105263158,
    0.7578947368421053,
    0.8421052631578947,
    0.9263157894736842,
    1.0105263157894737,
    1.0947368421052632,
    1.1789473684210525,
    1.263157894736842,
    1.3473684210526315,
    1.431578947368421,
    1.5157894736842106,
    1.6]},
  'layer_noise_model': [LayerError(circuit=<qiskit.circuit.quantumcircuit.QuantumCircuit object at 0x168671910>, qubits=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62, 64, 65, 66, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155], error=PauliLindbladError(generators=['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...'], rates=[5.166055297806738e-08,
    0.0,
    0.0,
    4.0233584851234995e-11,
    0.0,
    5.030851862798119e-10,
    2.2854869071616697e-12,
    4.0233584851234995e-11,
    4.028090316943942e-11,
    0.0,
    2.2854869071616697e-12,
    5.030851862798119e-10,
    6.856460721485009e-12,
    8.516693264933983e-11,
    5.031084090063335e-10,
    3.9291159003926555e-12,
    3.9291159003926555e-12,
    5.031084090063335e-10,
    8.516693264933983e-11,
    6.856460721485009e-12,
    0.0,
    8.980726009353527e-12,
    5.031778135827763e-10,
    1.6093434131186102e-10,
    3.431658893877721e-12,
    1.0061702172126337e-09,
    4.570973812764296e-12,
    6.856460721485009e-12,
    6.856460721485009e-12,
    4.570973812764296e-12,
    1.0061702172126337e-09,
    3.431658893877721e-12,
    1.6093434131186102e-10,
    5.031778135827763e-10,
    8.980726009353527e-12,
    0.0,
    0.0,
    4.028090316943942e-11,
    2.2854869071616697e-12,
    8.046681047695954e-11,
    3.431658893877721e-12,
    5.0362553175216814e-10,
    4.571194192532887e-12,
    3.9291159003926555e-12,
    3.9291159003926555e-12,
    4.571194192532887e-12,
    5.0362553175216814e-10,
    3.431658893877721e-12,
    8.046681047695954e-11,
    2.2854869071616697e-12,
    4.028090316943942e-11,
    0.0])),
   LayerError(circuit=<qiskit.circuit.quantumcircuit.QuantumCircuit object at 0x168685690>, qubits=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62, 64, 65, 66, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155], error=PauliLindbladError(generators=['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...'], rates=[5.166055297806738e-08,
    0.0,
    0.0,
    4.0233584851234995e-11,
    0.0,
    5.030851862798119e-10,
    2.2854869071616697e-12,
    4.0233584851234995e-11,
    4.028090316943942e-11,
    0.0,
    2.2854869071616697e-12,
    5.030851862798119e-10,
    6.856460721485009e-12,
    8.516693264933983e-11,
    5.031084090063335e-10,
    3.9291159003926555e-12,
    3.9291159003926555e-12,
    5.031084090063335e-10,
    8.516693264933983e-11,
    6.856460721485009e-12,
    0.0,
    8.980726009353527e-12,
    5.031778135827763e-10,
    1.6093434131186102e-10,
    3.431658893877721e-12,
    1.0061702172126337e-09,
    4.570973812764296e-12,
    6.856460721485009e-12,
    6.856460721485009e-12,
    4.570973812764296e-12,
    1.0061702172126337e-09,
    3.431658893877721e-12,
    1.6093434131186102e-10,
    5.031778135827763e-10,
    8.980726009353527e-12,
    0.0,
    0.0,
    4.028090316943942e-11,
    2.2854869071616697e-12,
    8.046681047695954e-11,
    3.431658893877721e-12,
    5.0362553175216814e-10,
    4.571194192532887e-12,
    3.9291159003926555e-12,
    3.9291159003926555e-12,
    4.571194192532887e-12,
    5.0362553175216814e-10,
    3.431658893877721e-12,
    8.046681047695954e-11,
    2.2854869071616697e-12,
    4.028090316943942e-11,
    0.0])),
   LayerError(circuit=<qiskit.circuit.quantumcircuit.QuantumCircuit object at 0x168684c90>, qubits=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62, 64, 65, 66, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155], error=PauliLindbladError(generators=['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...'], rates=[5.166055297806738e-08,
    0.0,
    0.0,
    4.0233584851234995e-11,
    0.0,
    5.030851862798119e-10,
    2.2854869071616697e-12,
    4.0233584851234995e-11,
    4.028090316943942e-11,
    0.0,
    2.2854869071616697e-12,
    5.030851862798119e-10,
    6.856460721485009e-12,
    8.516693264933983e-11,
    5.031084090063335e-10,
    3.9291159003926555e-12,
    3.9291159003926555e-12,
    5.031084090063335e-10,
    8.516693264933983e-11,
    6.856460721485009e-12,
    0.0,
    8.980726009353527e-12,
    5.031778135827763e-10,
    1.6093434131186102e-10,
    3.431658893877721e-12,
    1.0061702172126337e-09,
    4.570973812764296e-12,
    6.856460721485009e-12,
    6.856460721485009e-12,
    4.570973812764296e-12,
    1.0061702172126337e-09,
    3.431658893877721e-12,
    1.6093434131186102e-10,
    5.031778135827763e-10,
    8.980726009353527e-12,
    0.0,
    0.0,
    4.028090316943942e-11,
    2.2854869071616697e-12,
    8.046681047695954e-11,
    3.431658893877721e-12,
    5.0362553175216814e-10,
    4.571194192532887e-12,
    3.9291159003926555e-12,
    3.9291159003926555e-12,
    4.571194192532887e-12,
    5.0362553175216814e-10,
    3.431658893877721e-12,
    8.046681047695954e-11,
    2.2854869071616697e-12,
    4.028090316943942e-11,
    0.0])],
  'pec': {}}}
```

O objeto `PubResult` possui metadados adicionais de resiliência sobre os modelos de ruído aprendidos usados na mitigação.

```python
# Print learned layer noise metadata
for field, value in pub_result.metadata["resilience"]["layer_noise"].items():
    print(f"{field}: {value}")
```

```text
noise_overhead: Infinity
total_mitigated_layers: 18
unique_mitigated_layers: 3
unique_mitigated_layers_noise_overhead: [1.4100369479435003e+44, 3.407263868699073e+112, 3.500660129782563e+37]
```

```python
# Exact data computed using the methods described in the original reference
# Y. Kim et al. "Evidence for the utility of quantum computing before fault tolerance" (Nature 618, 500–505 (2023))
# Directly used here for brevity
exact_data = np.array(
    [
        1,
        0.9899,
        0.9531,
        0.8809,
        0.7536,
        0.5677,
        0.3545,
        0.1607,
        0.0539,
        0.0103,
        0.0012,
        0.0,
    ]
)
```

### Plotar resultados da simulação Trotter {#plot-trotter-simulation-results}

O código a seguir cria um gráfico para comparar os resultados brutos e mitigados do experimento com a solução exata.

```python
"""Result visualization functions"""

def plot_trotter_results(
    pub_result: PubResult,
    angles: Sequence[float],
    plot_noise_factors: Sequence[float] | None = None,
    plot_extrapolator: Sequence[str] | None = None,
    exact: np.ndarray = None,
    close: bool = True,
):
    """Plot average magnetization from ZNE result data.
    Args:
        pub_result: The Estimator PubResult for the PEA experiment.
        angles: The Rx angle values for the experiment.
        plot_raw: If provided plot the unextrapolated data for the noise factors.
        plot_extrapolator: If provided plot all extrapolators, if False only plot
            the Automatic method.
        exact: Optional, the exact values to include in the plot. Should be a 1D
            array-like where the values represent exact magnetization.
        close: Close the Matplotlib figure before returning.
    Returns:
        The figure.
    """
    data = pub_result.data

    evs = data.evs
    num_qubits = evs.shape[0]
    num_params = evs.shape[1]
    angles = np.asarray(angles).ravel()
    if angles.shape != (num_params,):
        raise ValueError(
            f"Incorrect number of angles for input data {angles.size} != {num_params}"
        )

    # Take average magnetization of qubits and its standard error
    x_vals = angles / np.pi
    y_vals = np.mean(evs, axis=0)
    y_errs = np.std(evs, axis=0) / np.sqrt(num_qubits)

    fig, _ = plt.subplots(1, 1)

    # Plot auto method
    plt.errorbar(x_vals, y_vals, y_errs, fmt="o-", label="ZNE (automatic)")

    # Plot individual extrapolator results
    if plot_extrapolator:
        y_vals_extrap = np.mean(data.evs_extrapolated, axis=0)
        y_errs_extrap = np.std(data.evs_extrapolated, axis=0) / np.sqrt(
            num_qubits
        )
        for i, extrap in enumerate(plot_extrapolator):
            plt.errorbar(
                x_vals,
                y_vals_extrap[:, i, 0],
                y_errs_extrap[:, i, 0],
                fmt="s-.",
                alpha=0.5,
                label=f"ZNE ({extrap})",
            )

    # Plot raw results
    if plot_noise_factors:
        y_vals_raw = np.mean(data.evs_noise_factors, axis=0)
        y_errs_raw = np.std(data.evs_noise_factors, axis=0) / np.sqrt(
            num_qubits
        )
        for i, nf in enumerate(plot_noise_factors):
            plt.errorbar(
                x_vals,
                y_vals_raw[:, i],
                y_errs_raw[:, i],
                fmt="d:",
                alpha=0.5,
                label=f"Raw (nf={nf:.1f})",
            )

    # Plot exact data
    if exact is not None:
        plt.plot(x_vals, exact, "--", color="black", alpha=0.5, label="Exact")

    plt.ylim(-0.1, 1.2)
    plt.xlabel("θ/π")
    plt.ylabel(r"$\overline{\langle Z \rangle}$")
    plt.legend()
    plt.title(
        f"Error Mitigated Average Magnetization for Rx(θ) [{num_qubits}-qubit]"
    )
    if close:
        plt.close(fig)
    return fig
```

```python
zne_metadata = primitive_result.metadata["resilience"]["zne"]
# Plot Trotter simulation results
fig = plot_trotter_results(
    pub_result,
    parameter_values,
    plot_extrapolator=zne_metadata["extrapolator"],
    plot_noise_factors=zne_metadata["noise_factors"],
    exact=exact_data,
)
display(fig)
```

![Output of the previous code cell](/docs/images/tutorials/probabilistic-error-amplification/extracted-outputs/2e0f0e84-32ba-4655-91c1-8445016bbeb2-0.avif)

Enquanto os valores ruidosos (fator de ruído `nf=1.0`) mostram alto desvio dos valores exatos, os valores mitigados estão próximos aos valores exatos, demonstrando a utilidade da técnica de mitigação baseada em PEA.

### Plotar resultados de extrapolação para qubits individuais {#plot-extrapolation-results-for-individual-qubits}

Finalmente, o código a seguir cria um gráfico para mostrar as curvas de extrapolação para diferentes valores de theta em um qubit específico.

```python
def plot_qubit_zne_data(
    pub_result: PubResult,
    angles: Sequence[float],
    qubit: int,
    noise_factors: Sequence[float],
    extrapolator: Sequence[str] | None = None,
    extrapolated_noise_factors: Sequence[float] | None = None,
    num_cols: int | None = None,
    close: bool = True,
):
    """Plot ZNE extrapolation data for specific virtual qubit
    Args:
        pub_result: The Estimator PubResult for the PEA experiment.
        angles: The Rx theta angles used for the experiment.
        qubit: The virtual qubit index to plot.
        noise_factors: the raw noise factors.
        extrapolator: The extrapolator metadata for multiple extrapolators.
        extrapolated_noise_factors: The noise factors used for extrapolation.
        num_cols: The number of columns for the generated subplots.
        close: Close the Matplotlib figure before returning.
    Returns:
        The Matplotlib figure.
    """
    data = pub_result.data

    evs_auto = data.evs[qubit]
    stds_auto = data.stds[qubit]
    evs_extrap = data.evs_extrapolated[qubit]
    stds_extrap = data.stds_extrapolated[qubit]
    evs_raw = data.evs_noise_factors[qubit]
    stds_raw = data.stds_noise_factors[qubit]

    num_params = evs_auto.shape[0]
    angles = np.asarray(angles).ravel()
    if angles.shape != (num_params,):
        raise ValueError(
            f"Incorrect number of angles for input data {angles.size} != {num_params}"
        )

    # Make a square subplot
    num_cols = num_cols or int(np.ceil(np.sqrt(num_params)))
    num_rows = int(np.ceil(num_params / num_cols))
    fig, axes = plt.subplots(
        num_rows, num_cols, sharex=True, sharey=True, figsize=(12, 5)
    )
    fig.suptitle(f"ZNE data for virtual qubit {qubit}")

    for pidx, ax in zip(range(num_params), axes.flat):
        # Plot auto extrapolated
        ax.errorbar(
            0,
            evs_auto[pidx],
            stds_auto[pidx],
            fmt="o",
            label="PEA (automatic)",
        )

        # Plot extrapolators
        if (
            extrapolator is not None
            and extrapolated_noise_factors is not None
        ):
            for i, method in enumerate(extrapolator):
                ax.errorbar(
                    extrapolated_noise_factors,
                    evs_extrap[pidx, i],
                    stds_extrap[pidx, i],
                    fmt="-",
                    alpha=0.5,
                    label=f"PEA ({method})",
                )

        # Plot raw
        ax.errorbar(
            noise_factors, evs_raw[pidx], stds_raw[pidx], fmt="d", label="Raw"
        )

        ax.set_yticks([0, 0.5, 1, 1.5, 2])
        ax.set_ylim(0, max(1, 1.1 * max(evs_auto)))

        ax.set_xticks([0, *noise_factors])
        ax.set_title(f"θ/π = {angles[pidx]/np.pi:.2f}")
        if pidx == 0:
            ax.set_ylabel(r"$\langle Z_{" + str(qubit) + r"} \rangle$")
        if pidx == num_params - 1:
            ax.set_xlabel("Noise Factor")
            ax.legend()
    if close:
        plt.close(fig)
    return fig
```

```python
virtual_qubit = 1
plot_qubit_zne_data(
    pub_result=pub_result,
    angles=parameter_values,
    qubit=virtual_qubit,
    noise_factors=zne_metadata["noise_factors"],
    extrapolator=zne_metadata["extrapolator"],
    extrapolated_noise_factors=zne_metadata["extrapolated_noise_factors"],
)
```

![Output of the previous code cell](/docs/images/tutorials/probabilistic-error-amplification/extracted-outputs/6948475c-bc15-493f-8af9-f8e66d0e467c-0.avif)

## Pesquisa do tutorial {#tutorial-survey}

Por favor, responda esta breve pesquisa para fornecer feedback sobre este tutorial. Suas percepções nos ajudarão a melhorar nossas ofertas de conteúdo e experiência do usuário.
