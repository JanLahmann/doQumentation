---
title: "Códigos de repetição"
sidebar_label: "Códigos de repetição"
description: "Este tutorial demonstra como construir códigos de repetição básicos usando circuitos dinâmicos da IBM, um exemplo de correção de erro quântico (QEC) básica."
notebook_path: "docs/tutorials/repetition-codes.ipynb"
---
{/* doqumentation-source-hash: fc3a692b */}

<OpenInLabBanner notebookPath="docs/tutorials/repetition-codes.ipynb" />



*Estimativa de uso: menos de 1 minuto em um processador Heron (NOTA: Esta é apenas uma estimativa. Seu tempo de execução pode variar.)*

## Contexto {#background}

Para habilitar a correção de erro quântico (QEC) em tempo real, você precisa ser capaz de controlar dinamicamente o fluxo do programa quântico durante a execução para que as portas quânticas possam ser condicionadas aos resultados de medição. Este tutorial executa o código de bit-flip, que é uma forma muito simples de QEC. Ele demonstra um circuito quântico dinâmico que pode proteger um qubit codificado de um único erro de bit-flip e, em seguida, avalia o desempenho do código de bit-flip.

Você pode explorar qubits ancilla adicionais e emaranhamento para medir *estabilizadores* que não transformam informações quânticas codificadas, enquanto ainda informam sobre algumas classes de erros que podem ter ocorrido. Um código estabilizador quântico codifica $k$ qubits lógicos em $n$ qubits físicos. Os códigos estabilizadores se concentram criticamente na correção de um conjunto de erros discretos com suporte do grupo de Pauli $\Pi^n$.

Para mais informações sobre QEC, consulte [Quantum Error Correction for Beginners.](https://arxiv.org/abs/0905.2794)
## Requisitos {#requirements}

Antes de iniciar este tutorial, certifique-se de que você tem o seguinte instalado:

- Qiskit SDK v2.0 ou posterior, com suporte para [visualização](https://docs.quantum.ibm.com/api/qiskit/visualization)
- Qiskit Runtime v0.40 ou posterior (`pip install qiskit-ibm-runtime`)
## Configuração {#setup}

```python
# Qiskit imports
from qiskit import (
    QuantumCircuit,
    QuantumRegister,
    ClassicalRegister,
)

# Qiskit Runtime
from qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler

from qiskit_ibm_runtime.circuit import MidCircuitMeasure

service = QiskitRuntimeService()
```

## Passo 1. Mapear entradas clássicas para um problema quântico {#step-1-map-classical-inputs-to-a-quantum-problem}
### Construir um circuito estabilizador de bit-flip {#build-a-bit-flip-stabilizer-circuit}

O código de bit-flip está entre os exemplos mais simples de um código estabilizador. Ele protege o estado contra um único erro de bit-flip (X) em qualquer um dos qubits de codificação. Considere a ação do erro de bit-flip $X$, que mapeia $|0\rangle \rightarrow |1\rangle$ e $|1\rangle \rightarrow |0\rangle$ em qualquer um de nossos qubits, então temos $\epsilon = \{E_0, E_1, E_2 \} = \{IIX, IXI, XII\}$. O código requer cinco qubits: três são usados para codificar o estado protegido, e os dois restantes são usados como ancillas de medição de estabilizador.

```python
# Choose the least busy backend that supports `measure_2`.

backend = service.least_busy(
    filters=lambda b: "measure_2" in b.supported_instructions,
    operational=True,
    simulator=False,
    dynamic_circuits=True,
)
```

```python
qreg_data = QuantumRegister(3)
qreg_measure = QuantumRegister(2)
creg_data = ClassicalRegister(3, name="data")
creg_syndrome = ClassicalRegister(2, name="syndrome")
state_data = qreg_data[0]
ancillas_data = qreg_data[1:]

def build_qc():
    """Build a typical error correction circuit"""
    return QuantumCircuit(qreg_data, qreg_measure, creg_data, creg_syndrome)

def initialize_qubits(circuit: QuantumCircuit):
    """Initialize qubit to |1>"""
    circuit.x(qreg_data[0])
    circuit.barrier(qreg_data)
    return circuit

def encode_bit_flip(circuit, state, ancillas) -> QuantumCircuit:
    """Encode bit-flip. This is done by simply adding a cx"""
    for ancilla in ancillas:
        circuit.cx(state, ancilla)
    circuit.barrier(state, *ancillas)
    return circuit

def measure_syndrome_bit(circuit, qreg_data, qreg_measure, creg_measure):
    """
    Measure the syndrome by measuring the parity.
    We reset our ancilla qubits after measuring the stabilizer
    so we can reuse them for repeated stabilizer measurements.
    Because we have already observed the state of the qubit,
    we can write the conditional reset protocol directly to
    avoid another round of qubit measurement if we used
    the `reset` instruction.
    """
    circuit.cx(qreg_data[0], qreg_measure[0])
    circuit.cx(qreg_data[1], qreg_measure[0])
    circuit.cx(qreg_data[0], qreg_measure[1])
    circuit.cx(qreg_data[2], qreg_measure[1])
    circuit.barrier(*qreg_data, *qreg_measure)
    circuit.append(MidCircuitMeasure(), [qreg_measure[0]], [creg_measure[0]])
    circuit.append(MidCircuitMeasure(), [qreg_measure[1]], [creg_measure[1]])

    with circuit.if_test((creg_measure[0], 1)):
        circuit.x(qreg_measure[0])
    with circuit.if_test((creg_measure[1], 1)):
        circuit.x(qreg_measure[1])
    circuit.barrier(*qreg_data, *qreg_measure)
    return circuit

def apply_correction_bit(circuit, qreg_data, creg_syndrome):
    """We can detect where an error occurred and correct our state"""
    with circuit.if_test((creg_syndrome, 3)):
        circuit.x(qreg_data[0])
    with circuit.if_test((creg_syndrome, 1)):
        circuit.x(qreg_data[1])
    with circuit.if_test((creg_syndrome, 2)):
        circuit.x(qreg_data[2])
    circuit.barrier(qreg_data)
    return circuit

def apply_final_readout(circuit, qreg_data, creg_data):
    """Read out the final measurements"""
    circuit.barrier(qreg_data)
    circuit.measure(qreg_data, creg_data)
    return circuit
```

```python
def build_error_correction_sequence(apply_correction: bool) -> QuantumCircuit:
    circuit = build_qc()
    circuit = initialize_qubits(circuit)
    circuit = encode_bit_flip(circuit, state_data, ancillas_data)
    circuit = measure_syndrome_bit(
        circuit, qreg_data, qreg_measure, creg_syndrome
    )

    if apply_correction:
        circuit = apply_correction_bit(circuit, qreg_data, creg_syndrome)

    circuit = apply_final_readout(circuit, qreg_data, creg_data)
    return circuit

circuit = build_error_correction_sequence(apply_correction=True)
circuit.draw(output="mpl", style="iqp", cregbundle=False)
```

![Output of the previous code cell](/docs/images/tutorials/repetition-codes/extracted-outputs/dbe02949-0.avif)

![Output of the previous code cell](/docs/images/tutorials/repetition-codes/extracted-outputs/dbe02949-1.avif)

## Passo 2. Otimizar o problema para execução quântica {#step-2-optimize-the-problem-for-quantum-execution}

Para reduzir o tempo total de execução do trabalho, as primitivas Qiskit aceitam apenas circuitos e observáveis que estejam em conformidade com as instruções e conectividade suportadas pelo sistema alvo (referidos como circuitos e observáveis de arquitetura de conjunto de instruções (ISA)).  [Saiba mais sobre transpilação.](/guides/transpile)
### Gerar circuitos ISA {#generate-isa-circuits}

```python
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

pm = generate_preset_pass_manager(backend=backend, optimization_level=1)
isa_circuit = pm.run(circuit)

isa_circuit.draw("mpl", style="iqp", idle_wires=False)
```

![Output of the previous code cell](/docs/images/tutorials/repetition-codes/extracted-outputs/67b55eef-0.avif)

![Output of the previous code cell](/docs/images/tutorials/repetition-codes/extracted-outputs/67b55eef-1.avif)

```python
no_correction_circuit = build_error_correction_sequence(
    apply_correction=False
)

isa_no_correction_circuit = pm.run(no_correction_circuit)
```

## Passo 3. Executar usando primitivas Qiskit {#step-3-execute-using-qiskit-primitives}
Execute a versão com correção aplicada e uma sem correção.

```python
sampler_no_correction = Sampler(backend)
job_no_correction = sampler_no_correction.run(
    [isa_no_correction_circuit], shots=1000
)
result_no_correction = job_no_correction.result()[0]
```

```python
sampler_with_correction = Sampler(backend)

job_with_correction = sampler_with_correction.run([isa_circuit], shots=1000)
result_with_correction = job_with_correction.result()[0]
```

```python
print(f"Data (no correction):\n{result_no_correction.data.data.get_counts()}")
print(
    f"Syndrome (no correction):\n{result_no_correction.data.syndrome.get_counts()}"
)
```

```text
Data (no correction):
{'111': 878, '011': 42, '110': 35, '101': 40, '100': 1, '001': 2, '000': 2}
Syndrome (no correction):
{'00': 942, '10': 33, '01': 22, '11': 3}
```

```python
print(f"Data (corrected):\n{result_with_correction.data.data.get_counts()}")
print(
    f"Syndrome (corrected):\n{result_with_correction.data.syndrome.get_counts()}"
)
```

```text
Data (corrected):
{'111': 889, '110': 25, '000': 11, '011': 45, '101': 17, '010': 10, '001': 2, '100': 1}
Syndrome (corrected):
{'00': 929, '01': 39, '10': 20, '11': 12}
```

## Passo 4. Pós-processar, retornar resultado em formato clássico {#step-4-post-process-return-result-in-classical-format}

Você pode ver que o código de bit flip detectou e corrigiu muitos erros, resultando em menos erros no geral.

```python
def decode_result(data_counts, syndrome_counts):
    shots = sum(data_counts.values())
    success_trials = data_counts.get("000", 0) + data_counts.get("111", 0)
    failed_trials = shots - success_trials
    error_correction_events = shots - syndrome_counts.get("00", 0)
    print(
        f"Bit flip errors were detected/corrected on {error_correction_events}/{shots} trials."
    )
    print(
        f"A final parity error was detected on {failed_trials}/{shots} trials."
    )
```

```python
# non-corrected marginalized results
data_result = result_no_correction.data.data.get_counts()
marginalized_syndrome_result = result_no_correction.data.syndrome.get_counts()

print(
    f"Completed bit code experiment data measurement counts (no correction): {data_result}"
)
print(
    f"Completed bit code experiment syndrome measurement counts (no correction): {marginalized_syndrome_result}"
)
decode_result(data_result, marginalized_syndrome_result)
```

```text
Completed bit code experiment data measurement counts (no correction): {'111': 878, '011': 42, '110': 35, '101': 40, '100': 1, '001': 2, '000': 2}
Completed bit code experiment syndrome measurement counts (no correction): {'00': 942, '10': 33, '01': 22, '11': 3}
Bit flip errors were detected/corrected on 58/1000 trials.
A final parity error was detected on 120/1000 trials.
```

```python
# corrected marginalized results
corrected_data_result = result_with_correction.data.data.get_counts()
corrected_syndrome_result = result_with_correction.data.syndrome.get_counts()

print(
    f"Completed bit code experiment data measurement counts (corrected): {corrected_data_result}"
)
print(
    f"Completed bit code experiment syndrome measurement counts (corrected): {corrected_syndrome_result}"
)
decode_result(corrected_data_result, corrected_syndrome_result)
```

```text
Completed bit code experiment data measurement counts (corrected): {'111': 889, '110': 25, '000': 11, '011': 45, '101': 17, '010': 10, '001': 2, '100': 1}
Completed bit code experiment syndrome measurement counts (corrected): {'00': 929, '01': 39, '10': 20, '11': 12}
Bit flip errors were detected/corrected on 71/1000 trials.
A final parity error was detected on 100/1000 trials.
```

## Pesquisa do tutorial {#tutorial-survey}

Por favor, responda esta breve pesquisa para fornecer feedback sobre este tutorial. Suas percepções nos ajudarão a melhorar nossas ofertas de conteúdo e experiência do usuário.

[Link para a pesquisa](https://your.feedback.ibm.com/jfe/form/SV_5onAlfA2Y7ac1FA)
