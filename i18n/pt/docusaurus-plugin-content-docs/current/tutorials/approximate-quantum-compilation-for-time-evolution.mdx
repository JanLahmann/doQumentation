---
title: "Compilação quântica aproximada para circuitos de evolução temporal"
sidebar_label: "Compilação quântica aproximada para circuitos de evolução temporal"
description: "Este tutorial demonstra como implementar o AQC-Tensor com o Qiskit para melhorar o desempenho de circuitos quânticos"
notebook_path: "docs/tutorials/approximate-quantum-compilation-for-time-evolution.ipynb"
---
{/* doqumentation-source-hash: c66ea514 */}

<OpenInLabBanner notebookPath="docs/tutorials/approximate-quantum-compilation-for-time-evolution.ipynb" />



{/* cspell:ignore circo */}

*Estimativa de uso: Cinco minutos em um processador Eagle (NOTA: Esta é apenas uma estimativa. O tempo de execução pode variar.)*
## Contexto {#background}

Este tutorial demonstra como implementar a **Compilação Quântica Aproximada** usando redes tensoriais (AQC-Tensor) com o Qiskit para melhorar o desempenho de circuitos quânticos. Aplicamos o AQC-Tensor no contexto de uma evolução temporal Trotterizada para reduzir a profundidade do circuito enquanto mantemos a precisão da simulação, seguindo o framework Qiskit para preparação de estados e otimização. Você aprenderá como criar um circuito ansatz de baixa profundidade a partir de um circuito de Trotter inicial, otimizá-lo com redes tensoriais e prepará-lo para execução em hardware quântico.

O objetivo principal é simular a evolução temporal de um Hamiltoniano modelo com profundidade de circuito reduzida. Isso é alcançado usando o addon Qiskit **AQC-Tensor**, [qiskit-addon-aqc-tensor](https://github.com/Qiskit/qiskit-addon-aqc-tensor), que utiliza redes tensoriais, especificamente estados produto matricial (MPS), para comprimir e otimizar o circuito inicial. Por meio de ajustes iterativos, o circuito ansatz comprimido mantém a fidelidade com o circuito original, permanecendo viável para hardware quântico de curto prazo. Mais detalhes podem ser encontrados na [documentação](/guides/qiskit-addons-aqc) correspondente, com um [exemplo simples](/guides/qiskit-addons-aqc-get-started) para começar.

A Compilação Quântica Aproximada é particularmente vantajosa em simulações quânticas que excedem os tempos de coerência do hardware, pois permite que simulações complexas sejam executadas de forma mais eficiente. Este tutorial orienta você na configuração do fluxo de trabalho do AQC-Tensor no Qiskit, cobrindo a inicialização de um Hamiltoniano, a geração de circuitos de Trotter e a transpilação do circuito otimizado final para um dispositivo alvo.
## Requisitos {#requirements}

Antes de iniciar este tutorial, certifique-se de ter os seguintes pacotes instalados:

* Qiskit SDK v1.0 ou posterior, com suporte a [visualização](https://docs.quantum.ibm.com/api/qiskit/visualization)
* Qiskit Runtime v0.22 ou posterior (`pip install qiskit-ibm-runtime`)
* Addon Qiskit AQC-Tensor (`pip install 'qiskit-addon-aqc-tensor[aer,quimb-jax]'`)
## Configuração {#setup}

```python
# Added by doQumentation — installs packages not in the Binder environment
%pip install -q qiskit-addon-aqc-tensor quimb
```

```python
import numpy as np
import quimb.tensor
import datetime
import matplotlib.pyplot as plt

from scipy.optimize import OptimizeResult, minimize

from qiskit.quantum_info import SparsePauliOp, Pauli
from qiskit.transpiler import CouplingMap
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit import QuantumCircuit
from qiskit.synthesis import SuzukiTrotter

from qiskit_addon_utils.problem_generators import (
    generate_time_evolution_circuit,
)
from qiskit_addon_aqc_tensor.ansatz_generation import (
    generate_ansatz_from_circuit,
)
from qiskit_addon_aqc_tensor.objective import MaximizeStateFidelity
from qiskit_addon_aqc_tensor.simulation.quimb import QuimbSimulator
from qiskit_addon_aqc_tensor.simulation import tensornetwork_from_circuit
from qiskit_addon_aqc_tensor.simulation import compute_overlap

from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_runtime import EstimatorV2 as Estimator

from rustworkx.visualization import graphviz_draw
```

## Parte I. Exemplo em pequena escala {#part-i-small-scale-example}

A primeira parte deste tutorial usa um exemplo em pequena escala com 10 sítios para ilustrar o processo de mapeamento de um problema de simulação quântica para um circuito quântico executável. Aqui, exploraremos a dinâmica de um modelo XXZ de 10 sítios, o que nos permite construir e otimizar um circuito quântico gerenciável antes de escalar para sistemas maiores.

O modelo XXZ é amplamente estudado na física para examinar interações de spin e propriedades magnéticas. Configuramos o Hamiltoniano com condições de contorno abertas e interações dependentes do sítio entre sítios vizinhos ao longo da cadeia.

### Hamiltoniano do modelo e observável {#model-hamiltonian-and-observable}

O Hamiltoniano para nosso modelo XXZ de 10 sítios é definido como:
$$
\hat{\mathcal{H}}_{XXZ} = \sum_{i=1}^{L-1} J_{i,(i+1)}\left(X_i X_{(i+1)}+Y_i Y_{(i+1)}+ 2\cdot Z_i Z_{(i+1)} \right) \, ,
$$

onde $J_{i,(i+1)}$ é um coeficiente aleatório correspondente à aresta $(i, i+1)$, e $L=10$ é o número de sítios.

Ao simular a evolução desse sistema com profundidade de circuito reduzida, podemos obter insights sobre como usar o AQC-Tensor para comprimir e otimizar circuitos.
#### Configurar o Hamiltoniano e o observável {#set-up-the-hamiltonian-and-observable}

Antes de mapear nosso problema, precisamos configurar o mapa de acoplamento, o Hamiltoniano e o observável para o modelo XXZ de 10 sítios.

```python
# L is the number of sites, also the length of the 1D spin chain
L = 10

# Generate the coupling map
edge_list = [(i - 1, i) for i in range(1, L)]
# Generate an edge-coloring so we can make hw-efficient circuits
even_edges = edge_list[::2]
odd_edges = edge_list[1::2]
coupling_map = CouplingMap(edge_list)

# Generate random coefficients for our XXZ Hamiltonian
np.random.seed(0)
Js = np.random.rand(L - 1) + 0.5 * np.ones(L - 1)
hamiltonian = SparsePauliOp(Pauli("I" * L))
for i, edge in enumerate(even_edges + odd_edges):
    hamiltonian += SparsePauliOp.from_sparse_list(
        [
            ("XX", (edge), Js[i] / 2),
            ("YY", (edge), Js[i] / 2),
            ("ZZ", (edge), Js[i]),
        ],
        num_qubits=L,
    )

# Generate a ZZ observable between the two middle qubits
observable = SparsePauliOp.from_sparse_list(
    [("ZZ", (L // 2 - 1, L // 2), 1.0)], num_qubits=L
)

print("Hamiltonian:", hamiltonian)
print("Observable:", observable)
graphviz_draw(coupling_map.graph, method="circo")
```

```text
Hamiltonian: SparsePauliOp(['IIIIIIIIII', 'IIIIIIIIXX', 'IIIIIIIIYY', 'IIIIIIIIZZ', 'IIIIIIXXII', 'IIIIIIYYII', 'IIIIIIZZII', 'IIIIXXIIII', 'IIIIYYIIII', 'IIIIZZIIII', 'IIXXIIIIII', 'IIYYIIIIII', 'IIZZIIIIII', 'XXIIIIIIII', 'YYIIIIIIII', 'ZZIIIIIIII', 'IIIIIIIXXI', 'IIIIIIIYYI', 'IIIIIIIZZI', 'IIIIIXXIII', 'IIIIIYYIII', 'IIIIIZZIII', 'IIIXXIIIII', 'IIIYYIIIII', 'IIIZZIIIII', 'IXXIIIIIII', 'IYYIIIIIII', 'IZZIIIIIII'],
              coeffs=[1.        +0.j, 0.52440675+0.j, 0.52440675+0.j, 1.0488135 +0.j,
 0.60759468+0.j, 0.60759468+0.j, 1.21518937+0.j, 0.55138169+0.j,
 0.55138169+0.j, 1.10276338+0.j, 0.52244159+0.j, 0.52244159+0.j,
 1.04488318+0.j, 0.4618274 +0.j, 0.4618274 +0.j, 0.9236548 +0.j,
 0.57294706+0.j, 0.57294706+0.j, 1.14589411+0.j, 0.46879361+0.j,
 0.46879361+0.j, 0.93758721+0.j, 0.6958865 +0.j, 0.6958865 +0.j,
 1.391773  +0.j, 0.73183138+0.j, 0.73183138+0.j, 1.46366276+0.j])
Observable: SparsePauliOp(['IIIIZZIIII'],
              coeffs=[1.+0.j])
```

![Output of the previous code cell](/docs/images/tutorials/approximate-quantum-compilation-for-time-evolution/extracted-outputs/1ea0e102-23d5-4e6e-8ef8-e82843452b19-1.avif)

Com o Hamiltoniano definido, podemos prosseguir para construir o estado inicial.

```python
# Generate an initial state
initial_state = QuantumCircuit(L)
for i in range(L):
    if i % 2:
        initial_state.x(i)
```

### Etapa 1: Mapear entradas clássicas para um problema quântico {#step-1-map-classical-inputs-to-a-quantum-problem}

Agora que construímos o Hamiltoniano, definindo as interações spin-spin e os campos magnéticos externos que caracterizam o sistema, seguimos três etapas principais no fluxo de trabalho do AQC-Tensor:

1. **Gerar o circuito AQC otimizado**: Usando a Trotterização, aproximamos a evolução inicial, que é então comprimida para reduzir a profundidade do circuito.
2. **Criar o circuito de evolução temporal restante**: Capturar a evolução para o tempo restante além do segmento inicial.
3. **Combinar os circuitos**: Mesclar o circuito AQC otimizado com o circuito de evolução restante em um circuito de evolução temporal completo, pronto para execução.

Essa abordagem cria um ansatz de baixa profundidade para a evolução alvo, suportando uma simulação eficiente dentro das restrições de hardware quântico de curto prazo.
#### Determinar a porção da evolução temporal a simular classicamente {#determine-the-portion-of-time-evolution-to-simulate-classically}

Nosso objetivo é simular a evolução temporal do Hamiltoniano modelo definido anteriormente usando a evolução de Trotter. Para tornar esse processo eficiente para o hardware quântico, dividimos a evolução em dois segmentos:

- **Segmento Inicial**: Esta porção inicial da evolução, de $ t_i = 0.0 $ a $ t_f = 0.2 $, é simulável com MPS e pode ser eficientemente "compilada" usando o AQC-Tensor. Ao usar o [addon Qiskit AQC-Tensor](https://github.com/Qiskit/qiskit-addon-aqc-tensor), geramos um circuito comprimido para este segmento, referido como `aqc_target_circuit`. Como esse segmento será simulado em um simulador de rede tensorial, podemos usar um número maior de camadas de Trotter sem impactar significativamente os recursos de hardware. Definimos `aqc_target_num_trotter_steps = 32` para este segmento.

- **Segmento Subsequente**: Esta porção restante da evolução, de $ t = 0.2 $ a $ t = 0.4 $, será executada no hardware quântico, referida como `subsequent_circuit`. Dadas as limitações do hardware, buscamos usar o menor número possível de camadas de Trotter para manter uma profundidade de circuito gerenciável. Para este segmento, usamos `subsequent_num_trotter_steps = 3`.

#### Escolher o tempo de divisão {#choose-the-split-time}
Escolhemos $t = 0.2$ como o tempo de divisão para equilibrar a simulabilidade clássica com a viabilidade no hardware. No início da evolução, o entrelaçamento no modelo XXZ permanece baixo o suficiente para que métodos clássicos como o MPS possam aproximar com precisão.

Ao escolher um tempo de divisão, uma boa diretriz é selecionar um ponto onde o entrelaçamento ainda seja gerenciável classicamente, mas que capture o suficiente da evolução para simplificar a porção executada no hardware. Tentativa e erro podem ser necessários para encontrar o melhor equilíbrio para diferentes Hamiltonianos.

```python
# Generate the AQC target circuit (initial segment)
aqc_evolution_time = 0.2
aqc_target_num_trotter_steps = 32

aqc_target_circuit = initial_state.copy()
aqc_target_circuit.compose(
    generate_time_evolution_circuit(
        hamiltonian,
        synthesis=SuzukiTrotter(reps=aqc_target_num_trotter_steps),
        time=aqc_evolution_time,
    ),
    inplace=True,
)
```

```python
# Generate the subsequent circuit
subsequent_num_trotter_steps = 3
subsequent_evolution_time = 0.2

subsequent_circuit = generate_time_evolution_circuit(
    hamiltonian,
    synthesis=SuzukiTrotter(reps=subsequent_num_trotter_steps),
    time=subsequent_evolution_time,
)
subsequent_circuit.draw("mpl", fold=-1)
```

![Output of the previous code cell](/docs/images/tutorials/approximate-quantum-compilation-for-time-evolution/extracted-outputs/83039f82-97cb-4613-86c9-a8faf0839a02-0.avif)

Para permitir uma comparação significativa, vamos gerar dois circuitos adicionais:

- **Circuito de comparação AQC**: Este circuito evolui até `aqc_evolution_time`, mas usa a mesma duração de passo de Trotter que o `subsequent_circuit`. Ele serve como comparação ao `aqc_target_circuit`, mostrando a evolução que observaríamos sem usar um número maior de passos de Trotter. Vamos nos referir a esse circuito como `aqc_comparison_circuit`.

- **Circuito de referência**: Este circuito é usado como linha de base para obter o resultado exato. Ele simula a evolução completa usando redes tensoriais para calcular o resultado exato, fornecendo uma referência para avaliar a eficácia do AQC-Tensor. Vamos nos referir a esse circuito como `reference_circuit`.

```python
# Generate the AQC comparison circuit
aqc_comparison_num_trotter_steps = int(
    subsequent_num_trotter_steps
    / subsequent_evolution_time
    * aqc_evolution_time
)
print(
    "Number of Trotter steps for comparison:",
    aqc_comparison_num_trotter_steps,
)

aqc_comparison_circuit = generate_time_evolution_circuit(
    hamiltonian,
    synthesis=SuzukiTrotter(reps=aqc_comparison_num_trotter_steps),
    time=aqc_evolution_time,
)
```

```text
Number of Trotter steps for comparison: 3
```

```python
# Generate the reference circuit
evolution_time = 0.4
reps = 200

reference_circuit = initial_state.copy()
reference_circuit.compose(
    generate_time_evolution_circuit(
        hamiltonian,
        synthesis=SuzukiTrotter(reps=reps),
        time=evolution_time,
    ),
    inplace=True,
)
```

#### Gerar um ansatz e parâmetros iniciais a partir de um circuito de Trotter com menos etapas {#generate-an-ansatz-and-initial-parameters-from-a-trotter-circuit-with-fewer-steps}

Agora que construímos nossos quatro circuitos, vamos prosseguir com o fluxo de trabalho do AQC-Tensor. Primeiro, construímos um circuito "bom" que tem o mesmo tempo de evolução que o circuito alvo, mas com menos passos de Trotter (e, portanto, menos camadas).

Em seguida, passamos esse circuito "bom" para a função `generate_ansatz_from_circuit` do AQC-Tensor. Esta função analisa a conectividade de dois qubits do circuito e retorna duas coisas:

1. Um circuito ansatz geral e parametrizado com a mesma conectividade de dois qubits que o circuito de entrada.
2. Parâmetros que, quando inseridos no ansatz, produzem o circuito de entrada (bom).

Em breve, pegaremos esses parâmetros e os ajustaremos iterativamente para aproximar o circuito ansatz o máximo possível do MPS alvo.

```python
aqc_ansatz_num_trotter_steps = 1

aqc_good_circuit = initial_state.copy()
aqc_good_circuit.compose(
    generate_time_evolution_circuit(
        hamiltonian,
        synthesis=SuzukiTrotter(reps=aqc_ansatz_num_trotter_steps),
        time=aqc_evolution_time,
    ),
    inplace=True,
)

aqc_ansatz, aqc_initial_parameters = generate_ansatz_from_circuit(
    aqc_good_circuit
)
aqc_ansatz.draw("mpl", fold=-1)
```

![Output of the previous code cell](/docs/images/tutorials/approximate-quantum-compilation-for-time-evolution/extracted-outputs/b9e81c51-dc6f-4237-9aca-e1384f1897bc-0.avif)

```python
print(f"AQC Comparison circuit: depth {aqc_comparison_circuit.depth()}")
print(f"Target circuit:         depth {aqc_target_circuit.depth()}")
print(
    f"Ansatz circuit:         depth {aqc_ansatz.depth()}, with {len(aqc_initial_parameters)} parameters"
)
```

```text
AQC Comparison circuit: depth 36
Target circuit:         depth 385
Ansatz circuit:         depth 7, with 156 parameters
```

#### Escolher configurações para a simulação de rede tensorial {#choose-settings-for-tensor-network-simulation}

Aqui, usamos o simulador de circuito de estado produto matricial do Quimb, junto com o jax para fornecer o gradiente.

```python
simulator_settings = QuimbSimulator(
    quimb.tensor.CircuitMPS, autodiff_backend="jax"
)
```

Em seguida, construímos uma representação MPS do estado alvo que será aproximado usando o AQC-Tensor. Essa representação permite o tratamento eficiente do entrelaçamento, fornecendo uma descrição compacta do estado quântico para otimização posterior.

```python
aqc_target_mps = tensornetwork_from_circuit(
    aqc_target_circuit, simulator_settings
)
print("Target MPS maximum bond dimension:", aqc_target_mps.psi.max_bond())

# Obtains the reference MPS, where we can obtain the exact expectation value by examining the `local_expectation``
reference_mps = tensornetwork_from_circuit(
    reference_circuit, simulator_settings
)
reference_expval = reference_mps.local_expectation(
    quimb.pauli("Z") & quimb.pauli("Z"), (L // 2 - 1, L // 2)
).real.item()
print("Reference MPS maximum bond dimension:", reference_mps.psi.max_bond())
```

```text
Target MPS maximum bond dimension: 5
Reference MPS maximum bond dimension: 7
```

Observe que, ao escolher um número maior de passos de Trotter para o estado alvo, reduzimos efetivamente seu erro de Trotter em comparação com o circuito inicial. Podemos avaliar a fidelidade ($ |\langle \psi_1 | \psi_2 \rangle|^2 $) entre o estado preparado pelo circuito inicial e o estado alvo para quantificar essa diferença.

```python
good_mps = tensornetwork_from_circuit(aqc_good_circuit, simulator_settings)
starting_fidelity = abs(compute_overlap(good_mps, aqc_target_mps)) ** 2
print("Starting fidelity:", starting_fidelity)
```

```text
Starting fidelity: 0.9982464959067222
```

#### Otimizar os parâmetros do ansatz usando cálculos com MPS {#optimize-the-parameters-of-the-ansatz-using-mps-calculations}
Nesta etapa, otimizamos os parâmetros do ansatz minimizando uma função de custo simples, `MaximizeStateFidelity`, usando o otimizador L-BFGS do SciPy. Selecionamos um critério de parada para a fidelidade que garante que ela supere a fidelidade do circuito inicial sem o AQC-Tensor. Uma vez atingido esse limiar, o circuito comprimido exibirá tanto um erro de Trotter menor quanto uma profundidade reduzida em comparação com o circuito original. Usando tempo adicional de CPU, a otimização pode continuar para aumentar ainda mais a fidelidade.

```python
# Setting values for the optimization
aqc_stopping_fidelity = 1
aqc_max_iterations = 500

stopping_point = 1.0 - aqc_stopping_fidelity
objective = MaximizeStateFidelity(
    aqc_target_mps, aqc_ansatz, simulator_settings
)

def callback(intermediate_result: OptimizeResult):
    fidelity = 1 - intermediate_result.fun
    print(
        f"{datetime.datetime.now()} Intermediate result: Fidelity {fidelity:.8f}"
    )
    if intermediate_result.fun < stopping_point:
        # Good enough for now
        raise StopIteration

result = minimize(
    objective,
    aqc_initial_parameters,
    method="L-BFGS-B",
    jac=True,
    options={"maxiter": aqc_max_iterations},
    callback=callback,
)
if (
    result.status
    not in (
        0,
        1,
        99,
    )
):  # 0 => success; 1 => max iterations reached; 99 => early termination via StopIteration
    raise RuntimeError(
        f"Optimization failed: {result.message} (status={result.status})"
    )

print(f"Done after {result.nit} iterations.")
aqc_final_parameters = result.x
```

```text
2025-04-14 11:46:52.174235 Intermediate result: Fidelity 0.99795851
2025-04-14 11:46:52.218249 Intermediate result: Fidelity 0.99822826
2025-04-14 11:46:52.280924 Intermediate result: Fidelity 0.99829675
2025-04-14 11:46:52.356214 Intermediate result: Fidelity 0.99832474
2025-04-14 11:46:52.411609 Intermediate result: Fidelity 0.99836131
2025-04-14 11:46:52.453747 Intermediate result: Fidelity 0.99839954
2025-04-14 11:46:52.496184 Intermediate result: Fidelity 0.99846517
2025-04-14 11:46:52.542046 Intermediate result: Fidelity 0.99865029
2025-04-14 11:46:52.583679 Intermediate result: Fidelity 0.99872332
2025-04-14 11:46:52.628732 Intermediate result: Fidelity 0.99892359
2025-04-14 11:46:52.690386 Intermediate result: Fidelity 0.99900640
2025-04-14 11:46:52.759398 Intermediate result: Fidelity 0.99907169
2025-04-14 11:46:52.819496 Intermediate result: Fidelity 0.99911423
2025-04-14 11:46:52.884505 Intermediate result: Fidelity 0.99918716
2025-04-14 11:46:52.947919 Intermediate result: Fidelity 0.99921278
2025-04-14 11:46:53.012808 Intermediate result: Fidelity 0.99924853
2025-04-14 11:46:53.083626 Intermediate result: Fidelity 0.99928797
2025-04-14 11:46:53.153235 Intermediate result: Fidelity 0.99933028
2025-04-14 11:46:53.221371 Intermediate result: Fidelity 0.99935757
2025-04-14 11:46:53.286211 Intermediate result: Fidelity 0.99938140
2025-04-14 11:46:53.352391 Intermediate result: Fidelity 0.99940964
2025-04-14 11:46:53.420472 Intermediate result: Fidelity 0.99944051
2025-04-14 11:46:53.486279 Intermediate result: Fidelity 0.99946828
2025-04-14 11:46:53.552338 Intermediate result: Fidelity 0.99948723
2025-04-14 11:46:53.618688 Intermediate result: Fidelity 0.99951011
2025-04-14 11:46:53.690878 Intermediate result: Fidelity 0.99954718
2025-04-14 11:46:53.762725 Intermediate result: Fidelity 0.99956267
2025-04-14 11:46:53.829784 Intermediate result: Fidelity 0.99958949
2025-04-14 11:46:53.897477 Intermediate result: Fidelity 0.99960498
2025-04-14 11:46:53.954633 Intermediate result: Fidelity 0.99961308
2025-04-14 11:46:54.010125 Intermediate result: Fidelity 0.99962894
2025-04-14 11:46:54.064717 Intermediate result: Fidelity 0.99964121
2025-04-14 11:46:54.118892 Intermediate result: Fidelity 0.99964348
2025-04-14 11:46:54.183236 Intermediate result: Fidelity 0.99964860
2025-04-14 11:46:54.245521 Intermediate result: Fidelity 0.99965695
2025-04-14 11:46:54.305792 Intermediate result: Fidelity 0.99966398
2025-04-14 11:46:54.355819 Intermediate result: Fidelity 0.99967816
2025-04-14 11:46:54.409580 Intermediate result: Fidelity 0.99968293
2025-04-14 11:46:54.457979 Intermediate result: Fidelity 0.99968936
2025-04-14 11:46:54.505891 Intermediate result: Fidelity 0.99969223
2025-04-14 11:46:54.551084 Intermediate result: Fidelity 0.99970009
2025-04-14 11:46:54.601817 Intermediate result: Fidelity 0.99970724
2025-04-14 11:46:54.650097 Intermediate result: Fidelity 0.99970987
2025-04-14 11:46:54.714727 Intermediate result: Fidelity 0.99971237
2025-04-14 11:46:54.780052 Intermediate result: Fidelity 0.99971916
2025-04-14 11:46:54.871994 Intermediate result: Fidelity 0.99971940
2025-04-14 11:46:54.958244 Intermediate result: Fidelity 0.99972465
2025-04-14 11:46:55.011057 Intermediate result: Fidelity 0.99972763
2025-04-14 11:46:55.175339 Intermediate result: Fidelity 0.99972894
2025-04-14 11:46:56.688912 Intermediate result: Fidelity 0.99972894
Done after 50 iterations.
```

```python
parameters = [float(param) for param in aqc_final_parameters]
print("Final parameters:", parameters)
```

```text
Final parameters: [-7.853983035039254, 1.5707966468427772, 1.5707962768868613, -1.570798010835122, 1.570794480409574, 1.5707972214146968, -1.570796593027083, 1.5707968206822998, -1.5707959018046258, -1.5707991700969144, 1.5707965852600927, 4.712386891737442, -7.853980840717957, 1.5707967508132654, 1.5707943162503217, -1.5707955382023582, 1.5707958007156742, 1.570796096113293, -1.5707928509846847, 1.5707971042943747, -1.570797909276557, -1.5707941020637393, 1.5707980179540793, 4.712389823219363, -1.5707928752386107, 1.5707996426312891, -1.5707975640471001, -1.570794132802984, 1.5707944361599957, 4.712390747060803, 0.1048818190315936, 0.06686710468840577, -0.0668645844756557, -3.1415923537135466, 1.2374931269696063, 6.323169390432535e-07, 3.53229204771738e-08, 2.1091105688681484, 6.283186439944202, 0.12152258846156239, 0.07961752617254866, -0.07961775088604585, -1.6564278051174865e-06, 2.0771163596472384, 3.141592651630471, -6.283185775192653, 1.7691609006726954, 3.1415922910116216, 0.19837572065074083, 0.11114901449078964, -0.11115124544944892, -3.141591983034976, 0.8570788408766729, 4.201601390404146e-07, -3.141593736550978, 0.34652010942396333, 6.283186232785291, 0.13606356527241956, 0.03891676349289617, -0.03891524189533726, -1.5707965732853424, 1.5707968967088564, -0.3086133992238162, 1.5707957152428194, 1.5707968398959653, -0.32062737993080026, 0.11027416939993417, 0.0726167290795046, -0.07262020423334464, -2.3729431959735024e-06, 1.8204437429254703, 9.299060301196612e-07, -3.141592899563451, 2.103269568939461, 3.1415937539734626, 0.11536891854817125, 0.09099022308254198, -0.09098864958606581, -3.1415913307373127, 2.078429034357281, -1.509777998069368e-06, -3.1415922600663255, 1.5189162645358172, -3.1415878461323583, 0.09999070991480716, 0.04352011445148391, -0.04351849541849812, -1.570797642506462, 1.570795238023824, 0.8903442644396505, 1.5707962698006606, 1.5707946765132268, 0.9098791754570567, 0.10448284343424026, 0.07317037684936827, -0.07316718173961152, -3.141592682240966, 2.1665363080039612, -7.450882112394189e-07, -5.771181304929921e-07, 2.615334999517103, -3.1415914971653898, 0.1890887078648001, 0.13578163074571992, -0.13578078143610256, 7.156734195912883e-07, 1.7915385305413096, -5.188866034727312e-07, 1.2827742939197711e-06, 1.2348316581417487, 6.28318357406372, 0.08061187643781703, 0.03820789039271876, -0.03820731868804904, 1.5707964027727628, 1.570798734462218, 4.387336153720882, -1.570795722044763, 1.570798457375325, 4.450361734163248, 0.092360147257953, 0.06047700345049011, -0.06048592856713045, -3.141591214829027, 2.6593289993286047, -2.366937342261038e-07, 8.112162974032695e-08, 1.8907014631413432, 8.355881261853104e-07, 0.23303641819370874, 0.14331998953606456, -0.1433194488304741, -3.141591621822901, 0.7455776479558791, 3.1415914520163586, -3.1415933560496105, 0.7603938554148255, -1.6230983177616282e-06, 0.07186349688535713, 0.03197144517771341, -0.031971177878588546, -4.712389048748508, 1.5707948403165752, 1.2773619319829186, -1.5707990802172127, 1.5707957676951863, 1.289083769394045, 0.13644999397718796, 0.032761460443590046, -0.032762060585195645, -1.5707977610073176, 1.5707964181578042, -3.4826435600366983, -4.712389691708343, 1.570794277502252, 2.799088046133275]
```

Neste ponto, basta encontrar os parâmetros finais para o circuito ansatz. Em seguida, podemos combinar o circuito AQC otimizado com o circuito de evolução restante para criar um circuito completo de evolução temporal para execução em hardware quântico.

```python
aqc_final_circuit = aqc_ansatz.assign_parameters(aqc_final_parameters)
aqc_final_circuit.compose(subsequent_circuit, inplace=True)
aqc_final_circuit.draw("mpl", fold=-1)
```

![Output of the previous code cell](/docs/images/tutorials/approximate-quantum-compilation-for-time-evolution/extracted-outputs/813c9ced-6a2e-4345-bffc-7dae938e2015-0.avif)

Também precisamos combinar nosso `aqc_comparison_circuit` com o circuito de evolução restante. Esse circuito será usado para comparar o desempenho do circuito otimizado pelo AQC-Tensor com o circuito original.

```python
aqc_comparison_circuit.compose(subsequent_circuit, inplace=True)
aqc_comparison_circuit.draw("mpl", fold=-1)
```

![Output of the previous code cell](/docs/images/tutorials/approximate-quantum-compilation-for-time-evolution/extracted-outputs/86ba26ff-0bfa-47d0-b5ee-8944a8ddf274-0.avif)

### Etapa 2: Otimizar o problema para execução em hardware quântico {#step-2-optimize-problem-for-quantum-hardware-execution}
Selecione o hardware. Aqui utilizaremos qualquer dispositivo IBM Quantum&reg; disponível que possua pelo menos 127 qubits.

```python
service = QiskitRuntimeService()
backend = service.least_busy(min_num_qubits=127)
print(backend)
```

Transpilamos os PUBs (circuito e observáveis) para corresponder à ISA (Arquitetura do Conjunto de Instruções) do backend. Ao definir `optimization_level=3`, o transpilador otimiza o circuito para se adequar a uma cadeia unidimensional de qubits, reduzindo o ruído que impacta a fidelidade do circuito. Uma vez que os circuitos são transformados em um formato compatível com o backend, aplicamos uma transformação correspondente aos observáveis para garantir que eles se alinhem ao layout de qubits modificado.

```python
pass_manager = generate_preset_pass_manager(
    backend=backend, optimization_level=3
)
isa_circuit = pass_manager.run(aqc_final_circuit)
isa_observable = observable.apply_layout(isa_circuit.layout)
print("Observable info:", isa_observable)
print("Circuit depth:", isa_circuit.depth())
isa_circuit.draw("mpl", fold=-1, idle_wires=False)
```

```text
Observable info: SparsePauliOp(['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZ'],
              coeffs=[1.+0.j])
Circuit depth: 111
```

![Output of the previous code cell](/docs/images/tutorials/approximate-quantum-compilation-for-time-evolution/extracted-outputs/087fff8d-98b9-4f9a-8004-01a3b0166e12-1.avif)

Realize a transpilação para o circuito de comparação.

```python
isa_comparison_circuit = pass_manager.run(aqc_comparison_circuit)
isa_comparison_observable = observable.apply_layout(
    isa_comparison_circuit.layout
)
print("Observable info:", isa_comparison_observable)
print("Circuit depth:", isa_comparison_circuit.depth())
isa_comparison_circuit.draw("mpl", fold=-1, idle_wires=False)
```

```text
Observable info: SparsePauliOp(['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZ'],
              coeffs=[1.+0.j])
Circuit depth: 158
```

![Output of the previous code cell](/docs/images/tutorials/approximate-quantum-compilation-for-time-evolution/extracted-outputs/7c2e5fe7-21ce-461d-adaa-776f8d882163-1.avif)

### Etapa 3: Executar usando primitivas do Qiskit {#step-3-execute-using-qiskit-primitives}

Nesta etapa, executamos o circuito transpilado em hardware quântico (ou um backend simulado). Utilizando a classe `EstimatorV2` do `qiskit_ibm_runtime`, configuramos um estimador para executar o circuito e medir o observável especificado. O resultado do job fornece o resultado esperado para o observável, oferecendo informações sobre o desempenho do circuito no hardware alvo.

```python
estimator = Estimator(backend)
job = estimator.run([(isa_circuit, isa_observable)])
print("Job ID:", job.job_id())
job.result()
```

```text
Job ID: czyhqdxd8drg008hx0yg
```

```text
PrimitiveResult([PubResult(data=DataBin(evs=np.ndarray(<shape=(), dtype=float64>), stds=np.ndarray(<shape=(), dtype=float64>), ensemble_standard_error=np.ndarray(<shape=(), dtype=float64>)), metadata={'shots': 4096, 'target_precision': 0.015625, 'circuit_metadata': {}, 'resilience': {}, 'num_randomizations': 32})], metadata={'dynamical_decoupling': {'enable': False, 'sequence_type': 'XX', 'extra_slack_distribution': 'middle', 'scheduling_method': 'alap'}, 'twirling': {'enable_gates': False, 'enable_measure': True, 'num_randomizations': 'auto', 'shots_per_randomization': 'auto', 'interleave_randomizations': True, 'strategy': 'active-accum'}, 'resilience': {'measure_mitigation': True, 'zne_mitigation': False, 'pec_mitigation': False}, 'version': 2})
```

Realize a execução para o circuito de comparação.

```python
job_comparison = estimator.run([(isa_comparison_circuit, isa_observable)])
print("Job Comparison ID:", job.job_id())
job_comparison.result()
```

```text
Job Comparison ID: czyhqdxd8drg008hx0yg
```

```text
PrimitiveResult([PubResult(data=DataBin(evs=np.ndarray(<shape=(), dtype=float64>), stds=np.ndarray(<shape=(), dtype=float64>), ensemble_standard_error=np.ndarray(<shape=(), dtype=float64>)), metadata={'shots': 4096, 'target_precision': 0.015625, 'circuit_metadata': {}, 'resilience': {}, 'num_randomizations': 32})], metadata={'dynamical_decoupling': {'enable': False, 'sequence_type': 'XX', 'extra_slack_distribution': 'middle', 'scheduling_method': 'alap'}, 'twirling': {'enable_gates': False, 'enable_measure': True, 'num_randomizations': 'auto', 'shots_per_randomization': 'auto', 'interleave_randomizations': True, 'strategy': 'active-accum'}, 'resilience': {'measure_mitigation': True, 'zne_mitigation': False, 'pec_mitigation': False}, 'version': 2})
```

### Etapa 4: Pós-processar e retornar o resultado no formato clássico desejado {#step-4-post-process-and-return-result-in-desired-classical-format}

Neste caso, a reconstrução não é necessária. Podemos examinar o resultado diretamente acessando o valor esperado a partir da saída da execução.

```python
# AQC results
hw_results = job.result()
hw_results_dicts = [pub_result.data.__dict__ for pub_result in hw_results]
hw_expvals = [
    pub_result_data["evs"].tolist() for pub_result_data in hw_results_dicts
]
aqc_expval = hw_expvals[0]

# AQC comparison results
hw_comparison_results = job_comparison.result()
hw_comparison_results_dicts = [
    pub_result.data.__dict__ for pub_result in hw_comparison_results
]
hw_comparison_expvals = [
    pub_result_data["evs"].tolist()
    for pub_result_data in hw_comparison_results_dicts
]
aqc_compare_expval = hw_comparison_expvals[0]

print(f"Exact:         \t{reference_expval:.4f}")
print(
    f"AQC:           \t{aqc_expval:.4f}, |∆| = {np.abs(reference_expval- aqc_expval):.4f}"
)
print(
    f"AQC Comparison:\t{aqc_compare_expval:.4f}, |∆| = {np.abs(reference_expval- aqc_compare_expval):.4f}"
)
```

```text
Exact:         	-0.5252
AQC:           	-0.4903, |∆| = 0.0349
AQC Comparison:	0.5424, |∆| = 1.0676
```

Gráfico de barras para comparar os resultados dos circuitos AQC, de comparação e exato.

```python
plt.style.use("seaborn-v0_8")

labels = ["AQC Result", "AQC Comparison Result"]
values = [abs(aqc_expval), abs(aqc_compare_expval)]

plt.figure(figsize=(10, 6))
bars = plt.bar(labels, values, color=["tab:blue", "tab:purple"])
plt.axhline(
    y=abs(reference_expval), color="red", linestyle="--", label="Exact Result"
)
plt.xlabel("Results")
plt.ylabel("Absolute Expected Value")
plt.title("AQC Result vs AQC Comparison Result (Absolute Values)")
plt.legend()
for bar in bars:
    y_val = bar.get_height()
    plt.text(
        bar.get_x() + bar.get_width() / 2.0,
        y_val,
        round(y_val, 2),
        va="bottom",
    )
plt.show()
```

![Output of the previous code cell](/docs/images/tutorials/approximate-quantum-compilation-for-time-evolution/extracted-outputs/5f7b36a6-3666-4223-9c5d-d92bca741ad2-0.avif)

## Parte II: escalonando o problema {#part-ii-scale-it-up}

A segunda parte deste tutorial baseia-se no exemplo anterior, escalando para um sistema maior com 50 sítios e ilustrando como mapear problemas de simulação quântica mais complexos em circuitos quânticos executáveis. Aqui, exploramos a dinâmica de um modelo XXZ com 50 sítios, o que nos permite construir e otimizar um circuito quântico substancial que reflete tamanhos de sistema mais realistas.

O Hamiltoniano para o nosso modelo XXZ de 50 sítios é definido como:
$$
\hat{\mathcal{H}}_{XXZ} = \sum_{i=1}^{L-1} J_{i,(i+1)}\left(X_i X_{(i+1)}+Y_i Y_{(i+1)}+ 2\cdot Z_i Z_{(i+1)} \right) \, ,
$$

onde $J_{i,(i+1)}$ é um coeficiente aleatório correspondente à aresta $(i, i+1)$, e $L=50$ é o número de sítios.
Defina o mapa de acoplamento e as arestas para o Hamiltoniano.

```python
L = 50  # L = length of our 1D spin chain

# Generate the edge list for this spin-chain
edge_list = [(i - 1, i) for i in range(1, L)]
# Generate an edge-coloring so we can make hw-efficient circuits
even_edges = edge_list[::2]
odd_edges = edge_list[1::2]

# Instantiate a CouplingMap object
coupling_map = CouplingMap(edge_list)

# Generate random coefficients for our XXZ Hamiltonian
np.random.seed(0)
Js = np.random.rand(L - 1) + 0.5 * np.ones(L - 1)

hamiltonian = SparsePauliOp(Pauli("I" * L))
for i, edge in enumerate(even_edges + odd_edges):
    hamiltonian += SparsePauliOp.from_sparse_list(
        [
            ("XX", (edge), Js[i] / 2),
            ("YY", (edge), Js[i] / 2),
            ("ZZ", (edge), Js[i]),
        ],
        num_qubits=L,
    )

observable = SparsePauliOp.from_sparse_list(
    [("ZZ", (L // 2 - 1, L // 2), 1.0)], num_qubits=L
)

# Generate an initial state
L = hamiltonian.num_qubits
initial_state = QuantumCircuit(L)
for i in range(L):
    if i % 2:
        initial_state.x(i)
```

### Etapa 1: Mapear entradas clássicas para um problema quântico {#step-1-map-classical-inputs-to-a-quantum-problem}

Para este problema maior, começamos construindo o Hamiltoniano para o modelo XXZ de 50 sítios, definindo interações spin-spin e campos magnéticos externos em todos os sítios. Em seguida, seguimos três etapas principais:

1. **Gerar o circuito AQC otimizado**: Usar a Trotterização para aproximar a evolução inicial e, em seguida, comprimir esse segmento para reduzir a profundidade do circuito.
2. **Criar o circuito de evolução temporal restante**: Capturar a evolução temporal restante além do segmento inicial.
3. **Combinar os circuitos**: Mesclar o circuito AQC otimizado com o circuito de evolução restante para criar um circuito completo de evolução temporal pronto para execução.
Gere o circuito alvo do AQC (o segmento inicial).

```python
aqc_evolution_time = 0.2
aqc_target_num_trotter_steps = 32

aqc_target_circuit = initial_state.copy()
aqc_target_circuit.compose(
    generate_time_evolution_circuit(
        hamiltonian,
        synthesis=SuzukiTrotter(reps=aqc_target_num_trotter_steps),
        time=aqc_evolution_time,
    ),
    inplace=True,
)
```

Gere o circuito subsequente (o segmento restante).

```python
subsequent_num_trotter_steps = 3
subsequent_evolution_time = 0.2

subsequent_circuit = generate_time_evolution_circuit(
    hamiltonian,
    synthesis=SuzukiTrotter(reps=subsequent_num_trotter_steps),
    time=subsequent_evolution_time,
)
```

Gere o circuito de comparação do AQC (o segmento inicial, mas com o mesmo número de passos de Trotter que o circuito subsequente).

```python
# Generate the AQC comparison circuit
aqc_comparison_num_trotter_steps = int(
    subsequent_num_trotter_steps
    / subsequent_evolution_time
    * aqc_evolution_time
)
print(
    "Number of Trotter steps for comparison:",
    aqc_comparison_num_trotter_steps,
)

aqc_comparison_circuit = generate_time_evolution_circuit(
    hamiltonian,
    synthesis=SuzukiTrotter(reps=aqc_comparison_num_trotter_steps),
    time=aqc_evolution_time,
)
```

```text
Number of Trotter steps for comparison: 3
```

Gere o circuito de referência.

```python
evolution_time = 0.4
reps = 200

reference_circuit = initial_state.copy()
reference_circuit.compose(
    generate_time_evolution_circuit(
        hamiltonian,
        synthesis=SuzukiTrotter(reps=reps),
        time=evolution_time,
    ),
    inplace=True,
)
```

Gere um ansatz e parâmetros iniciais a partir de um circuito de Trotter com menos passos.

```python
aqc_ansatz_num_trotter_steps = 1

aqc_good_circuit = initial_state.copy()
aqc_good_circuit.compose(
    generate_time_evolution_circuit(
        hamiltonian,
        synthesis=SuzukiTrotter(reps=aqc_ansatz_num_trotter_steps),
        time=aqc_evolution_time,
    ),
    inplace=True,
)

aqc_ansatz, aqc_initial_parameters = generate_ansatz_from_circuit(
    aqc_good_circuit
)
```

```python
print(f"AQC Comparison circuit: depth {aqc_comparison_circuit.depth()}")
print(f"Target circuit:         depth {aqc_target_circuit.depth()}")
print(
    f"Ansatz circuit:         depth {aqc_ansatz.depth()}, with {len(aqc_initial_parameters)} parameters"
)
```

```text
AQC Comparison circuit: depth 36
Target circuit:         depth 385
Ansatz circuit:         depth 7, with 816 parameters
```

Defina as configurações para a simulação de redes tensoriais e, em seguida, construa uma representação de estado produto de matrizes (MPS) do estado alvo para a otimização. Em seguida, avalie a fidelidade entre o circuito inicial e o estado alvo para quantificar a diferença no erro de Trotter.

```python
simulator_settings = QuimbSimulator(
    quimb.tensor.CircuitMPS, autodiff_backend="jax"
)

# Build the matrix-product representation of the state to be approximated by AQC
aqc_target_mps = tensornetwork_from_circuit(
    aqc_target_circuit, simulator_settings
)
print("Target MPS maximum bond dimension:", aqc_target_mps.psi.max_bond())

# Obtains the reference MPS, where we can obtain the exact expectation value by examining the `local_expectation``
reference_mps = tensornetwork_from_circuit(
    reference_circuit, simulator_settings
)
reference_expval = reference_mps.local_expectation(

   quimb.pauli("Z") & quimb.pauli("Z"), (L // 2 - 1, L // 2)
).real.item()

# Compute the starting fidelity
good_mps = tensornetwork_from_circuit(aqc_good_circuit, simulator_settings)
starting_fidelity = abs(compute_overlap(good_mps, aqc_target_mps)) ** 2
print("Starting fidelity:", starting_fidelity)
```

```text
Target MPS maximum bond dimension: 5
Starting fidelity: 0.9926466919924161
```

Para otimizar os parâmetros do ansatz, minimizamos a função de custo `MaximizeStateFidelity` usando o otimizador L-BFGS do SciPy, com um critério de parada configurado para superar a fidelidade do circuito inicial sem o AQC-Tensor. Isso garante que o circuito comprimido tenha tanto menor erro de Trotter quanto profundidade reduzida.

```python
# Setting values for the optimization
aqc_stopping_fidelity = 1
aqc_max_iterations = 500

stopping_point = 1.0 - aqc_stopping_fidelity
objective = MaximizeStateFidelity(
    aqc_target_mps, aqc_ansatz, simulator_settings
)

def callback(intermediate_result: OptimizeResult):
    fidelity = 1 - intermediate_result.fun
    print(
        f"{datetime.datetime.now()} Intermediate result: Fidelity {fidelity:.8f}"
    )
    if intermediate_result.fun < stopping_point:
        # Good enough for now
        raise StopIteration

result = minimize(
    objective,
    aqc_initial_parameters,
    method="L-BFGS-B",
    jac=True,
    options={"maxiter": aqc_max_iterations},
    callback=callback,
)
if (
    result.status
    not in (
        0,
        1,
        99,
    )
):  # 0 => success; 1 => max iterations reached; 99 => early termination via StopIteration
    raise RuntimeError(
        f"Optimization failed: {result.message} (status={result.status})"
    )

print(f"Done after {result.nit} iterations.")
aqc_final_parameters = result.x
```

```text
2025-04-14 11:48:28.705807 Intermediate result: Fidelity 0.99795851
2025-04-14 11:48:28.743265 Intermediate result: Fidelity 0.99822826
2025-04-14 11:48:28.776629 Intermediate result: Fidelity 0.99829675
2025-04-14 11:48:28.816153 Intermediate result: Fidelity 0.99832474
2025-04-14 11:48:28.856437 Intermediate result: Fidelity 0.99836131
2025-04-14 11:48:28.896432 Intermediate result: Fidelity 0.99839954
2025-04-14 11:48:28.936670 Intermediate result: Fidelity 0.99846517
2025-04-14 11:48:28.982069 Intermediate result: Fidelity 0.99865029
2025-04-14 11:48:29.026130 Intermediate result: Fidelity 0.99872332
2025-04-14 11:48:29.067426 Intermediate result: Fidelity 0.99892359
2025-04-14 11:48:29.110742 Intermediate result: Fidelity 0.99900640
2025-04-14 11:48:29.161362 Intermediate result: Fidelity 0.99907169
2025-04-14 11:48:29.207933 Intermediate result: Fidelity 0.99911423
2025-04-14 11:48:29.266772 Intermediate result: Fidelity 0.99918716
2025-04-14 11:48:29.331727 Intermediate result: Fidelity 0.99921278
2025-04-14 11:48:29.401694 Intermediate result: Fidelity 0.99924853
2025-04-14 11:48:29.467980 Intermediate result: Fidelity 0.99928797
2025-04-14 11:48:29.533281 Intermediate result: Fidelity 0.99933028
2025-04-14 11:48:29.600833 Intermediate result: Fidelity 0.99935757
2025-04-14 11:48:29.670816 Intermediate result: Fidelity 0.99938140
2025-04-14 11:48:29.736928 Intermediate result: Fidelity 0.99940964
2025-04-14 11:48:29.802931 Intermediate result: Fidelity 0.99944051
2025-04-14 11:48:29.869177 Intermediate result: Fidelity 0.99946828
2025-04-14 11:48:29.940156 Intermediate result: Fidelity 0.99948723
2025-04-14 11:48:30.005751 Intermediate result: Fidelity 0.99951011
2025-04-14 11:48:30.070853 Intermediate result: Fidelity 0.99954718
2025-04-14 11:48:30.139171 Intermediate result: Fidelity 0.99956267
2025-04-14 11:48:30.210506 Intermediate result: Fidelity 0.99958949
2025-04-14 11:48:30.279647 Intermediate result: Fidelity 0.99960498
2025-04-14 11:48:30.348016 Intermediate result: Fidelity 0.99961308
2025-04-14 11:48:30.414311 Intermediate result: Fidelity 0.99962894
2025-04-14 11:48:30.488910 Intermediate result: Fidelity 0.99964121
2025-04-14 11:48:30.561298 Intermediate result: Fidelity 0.99964348
2025-04-14 11:48:30.632214 Intermediate result: Fidelity 0.99964860
2025-04-14 11:48:30.705703 Intermediate result: Fidelity 0.99965695
2025-04-14 11:48:30.775679 Intermediate result: Fidelity 0.99966398
2025-04-14 11:48:30.842629 Intermediate result: Fidelity 0.99967816
2025-04-14 11:48:30.912357 Intermediate result: Fidelity 0.99968293
2025-04-14 11:48:30.979420 Intermediate result: Fidelity 0.99968936
2025-04-14 11:48:31.049196 Intermediate result: Fidelity 0.99969223
2025-04-14 11:48:31.125391 Intermediate result: Fidelity 0.99970009
2025-04-14 11:48:31.201256 Intermediate result: Fidelity 0.99970724
2025-04-14 11:48:31.272424 Intermediate result: Fidelity 0.99970987
2025-04-14 11:48:31.338907 Intermediate result: Fidelity 0.99971237
2025-04-14 11:48:31.404800 Intermediate result: Fidelity 0.99971916
2025-04-14 11:48:31.475226 Intermediate result: Fidelity 0.99971940
2025-04-14 11:48:31.547746 Intermediate result: Fidelity 0.99972465
2025-04-14 11:48:31.622827 Intermediate result: Fidelity 0.99972763
2025-04-14 11:48:31.819516 Intermediate result: Fidelity 0.99972894
2025-04-14 11:48:33.444538 Intermediate result: Fidelity 0.99972894
Done after 50 iterations.
```

```python
parameters = [float(param) for param in aqc_final_parameters]
```

Construa o circuito final para transpilação, montando o ansatz otimizado com o restante do circuito de evolução temporal.

```python
aqc_final_circuit = aqc_ansatz.assign_parameters(aqc_final_parameters)
aqc_final_circuit.compose(subsequent_circuit, inplace=True)
```

```python
aqc_comparison_circuit.compose(subsequent_circuit, inplace=True)
```

### Passo 2: Otimizar o problema para execução em hardware quântico {#step-2-optimize-problem-for-quantum-hardware-execution}

Selecione o backend.

```python
service = QiskitRuntimeService()
backend = service.least_busy(min_num_qubits=127)
print(backend)
```

Transpile o circuito completo no hardware alvo, preparando-o para execução. O circuito ISA resultante pode então ser enviado para execução no backend.

```python
pass_manager = generate_preset_pass_manager(
    backend=backend, optimization_level=3
)
isa_circuit = pass_manager.run(aqc_final_circuit)
isa_observable = observable.apply_layout(isa_circuit.layout)
print("Observable info:", isa_observable)
print("Circuit depth:", isa_circuit.depth())
isa_circuit.draw("mpl", fold=-1, idle_wires=False)
```

```text
Observable info: SparsePauliOp(['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII'],
              coeffs=[1.+0.j])
Circuit depth: 122
```

![Output of the previous code cell](/docs/images/tutorials/approximate-quantum-compilation-for-time-evolution/extracted-outputs/85b4acc0-7121-416d-9bf5-b6d3135ae805-1.avif)

```python
isa_comparison_circuit = pass_manager.run(aqc_comparison_circuit)
isa_comparison_observable = observable.apply_layout(
    isa_comparison_circuit.layout
)
print("Observable info:", isa_comparison_observable)
print("Circuit depth:", isa_comparison_circuit.depth())
isa_comparison_circuit.draw("mpl", fold=-1, idle_wires=False)
```

```text
Observable info: SparsePauliOp(['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII'],
              coeffs=[1.+0.j])
Circuit depth: 158
```

![Output of the previous code cell](/docs/images/tutorials/approximate-quantum-compilation-for-time-evolution/extracted-outputs/b0d295c7-c816-4683-bb2a-0ce9898e5d88-1.avif)

### Passo 3: Executar usando primitivas do Qiskit {#step-3-execute-using-qiskit-primitives}

Neste passo, executamos o circuito transpilado em hardware quântico (ou em um backend simulado) usando o `EstimatorV2` do `qiskit_ibm_runtime` para medir o observável especificado. O resultado do job fornecerá informações valiosas sobre o desempenho do circuito no hardware alvo.

Para este exemplo em maior escala, exploraremos como utilizar o `EstimatorOptions` para gerenciar e controlar melhor os parâmetros do nosso experimento de hardware. Embora essas configurações sejam opcionais, são úteis para rastrear parâmetros do experimento e refinar opções de execução para resultados otimizados.

Para uma lista completa das opções de execução disponíveis, consulte a [documentação do qiskit-ibm-runtime](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/options-estimator-options).

```python
twirling_options = {
    "enable_gates": True,
    "enable_measure": True,
    "num_randomizations": 300,
    "shots_per_randomization": 100,
    "strategy": "active",
}

zne_options = {
    "amplifier": "gate_folding",
    "noise_factors": [1, 2, 3],
    "extrapolated_noise_factors": list(np.linspace(0, 3, 31)),
    "extrapolator": ["exponential", "linear", "fallback"],
}

meas_learning_options = {
    "num_randomizations": 512,
    "shots_per_randomization": 512,
}

resilience_options = {
    "measure_mitigation": True,
    "zne_mitigation": True,
    "zne": zne_options,
    "measure_noise_learning": meas_learning_options,
}

estimator_options = {
    "resilience": resilience_options,
    "twirling": twirling_options,
}

estimator = Estimator(backend, options=estimator_options)
```

```python
job = estimator.run([(isa_circuit, isa_observable)])
print("Job ID:", job.job_id())
job.result()
```

```text
Job ID: czyjx6crxz8g008f63r0
```

```text
PrimitiveResult([PubResult(data=DataBin(evs=np.ndarray(<shape=(), dtype=float64>), stds=np.ndarray(<shape=(), dtype=float64>), evs_noise_factors=np.ndarray(<shape=(3,), dtype=float64>), stds_noise_factors=np.ndarray(<shape=(3,), dtype=float64>), ensemble_stds_noise_factors=np.ndarray(<shape=(3,), dtype=float64>), evs_extrapolated=np.ndarray(<shape=(3, 31), dtype=float64>), stds_extrapolated=np.ndarray(<shape=(3, 31), dtype=float64>)), metadata={'shots': 30000, 'target_precision': 0.005773502691896258, 'circuit_metadata': {}, 'resilience': {'zne': {'extrapolator': 'exponential'}}, 'num_randomizations': 300})], metadata={'dynamical_decoupling': {'enable': False, 'sequence_type': 'XX', 'extra_slack_distribution': 'middle', 'scheduling_method': 'alap'}, 'twirling': {'enable_gates': True, 'enable_measure': True, 'num_randomizations': 300, 'shots_per_randomization': 100, 'interleave_randomizations': True, 'strategy': 'active'}, 'resilience': {'measure_mitigation': True, 'zne_mitigation': True, 'pec_mitigation': False, 'zne': {'noise_factors': [1, 2, 3], 'extrapolator': ['exponential', 'linear', 'fallback'], 'extrapolated_noise_factors': [0, 0.1, 0.2, 0.30000000000000004, 0.4, 0.5, 0.6000000000000001, 0.7000000000000001, 0.8, 0.9, 1, 1.1, 1.2000000000000002, 1.3, 1.4000000000000001, 1.5, 1.6, 1.7000000000000002, 1.8, 1.9000000000000001, 2, 2.1, 2.2, 2.3000000000000003, 2.4000000000000004, 2.5, 2.6, 2.7, 2.8000000000000003, 2.9000000000000004, 3]}}, 'version': 2})
```

```python
job_comparison = estimator.run([(isa_comparison_circuit, isa_observable)])
print("Job Comparison ID:", job.job_id())
job_comparison.result()
```

```text
Job Comparison ID: czyjx6crxz8g008f63r0
```

```text
PrimitiveResult([PubResult(data=DataBin(evs=np.ndarray(<shape=(), dtype=float64>), stds=np.ndarray(<shape=(), dtype=float64>), evs_noise_factors=np.ndarray(<shape=(3,), dtype=float64>), stds_noise_factors=np.ndarray(<shape=(3,), dtype=float64>), ensemble_stds_noise_factors=np.ndarray(<shape=(3,), dtype=float64>), evs_extrapolated=np.ndarray(<shape=(3, 31), dtype=float64>), stds_extrapolated=np.ndarray(<shape=(3, 31), dtype=float64>)), metadata={'shots': 30000, 'target_precision': 0.005773502691896258, 'circuit_metadata': {}, 'resilience': {'zne': {'extrapolator': 'exponential'}}, 'num_randomizations': 300})], metadata={'dynamical_decoupling': {'enable': False, 'sequence_type': 'XX', 'extra_slack_distribution': 'middle', 'scheduling_method': 'alap'}, 'twirling': {'enable_gates': True, 'enable_measure': True, 'num_randomizations': 300, 'shots_per_randomization': 100, 'interleave_randomizations': True, 'strategy': 'active'}, 'resilience': {'measure_mitigation': True, 'zne_mitigation': True, 'pec_mitigation': False, 'zne': {'noise_factors': [1, 2, 3], 'extrapolator': ['exponential', 'linear', 'fallback'], 'extrapolated_noise_factors': [0, 0.1, 0.2, 0.30000000000000004, 0.4, 0.5, 0.6000000000000001, 0.7000000000000001, 0.8, 0.9, 1, 1.1, 1.2000000000000002, 1.3, 1.4000000000000001, 1.5, 1.6, 1.7000000000000002, 1.8, 1.9000000000000001, 2, 2.1, 2.2, 2.3000000000000003, 2.4000000000000004, 2.5, 2.6, 2.7, 2.8000000000000003, 2.9000000000000004, 3]}}, 'version': 2})
```

### Passo 4: Pós-processar e retornar o resultado no formato clássico desejado {#step-4-post-process-and-return-result-in-desired-classical-format}

Aqui, nenhuma reconstrução é necessária, como antes; podemos acessar diretamente o valor esperado a partir da saída da execução para examinar o resultado.

```python
# AQC results
hw_results = job.result()
hw_results_dicts = [pub_result.data.__dict__ for pub_result in hw_results]
hw_expvals = [
    pub_result_data["evs"].tolist() for pub_result_data in hw_results_dicts
]
aqc_expval = hw_expvals[0]

# AQC comparison results
hw_comparison_results = job_comparison.result()
hw_comparison_results_dicts = [
    pub_result.data.__dict__ for pub_result in hw_comparison_results
]
hw_comparison_expvals = [
    pub_result_data["evs"].tolist()
    for pub_result_data in hw_comparison_results_dicts
]
aqc_compare_expval = hw_comparison_expvals[0]

print(f"Exact:         \t{reference_expval:.4f}")
print(
    f"AQC:           \t{aqc_expval:.4f}, |∆| = {np.abs(reference_expval- aqc_expval):.4f}"
)
print(
    f"AQC Comparison:\t{aqc_compare_expval:.4f}, |∆| = {np.abs(reference_expval- aqc_compare_expval):.4f}"
)
```

```text
Exact:         	-0.5888
AQC:           	-0.4809, |∆| = 0.1078
AQC Comparison:	1.1764, |∆| = 1.7652
```

Plote os resultados dos circuitos AQC, de comparação e exato para o modelo XXZ de 50 sítios.

```python
labels = ["AQC Result", "AQC Comparison Result"]
values = [abs(aqc_expval), abs(aqc_compare_expval)]

plt.figure(figsize=(10, 6))
bars = plt.bar(labels, values, color=["tab:blue", "tab:purple"])
plt.axhline(
    y=abs(reference_expval), color="red", linestyle="--", label="Exact Result"
)
plt.xlabel("Results")
plt.ylabel("Absolute Expected Value")
plt.title("AQC Result vs AQC Comparison Result (Absolute Values)")
plt.legend()
for bar in bars:
    y_val = bar.get_height()
    plt.text(
        bar.get_x() + bar.get_width() / 2.0,
        y_val,
        round(y_val, 2),
        va="bottom",
    )

plt.show()
```

![Output of the previous code cell](/docs/images/tutorials/approximate-quantum-compilation-for-time-evolution/extracted-outputs/01889c4d-16a4-458a-9211-08be8bcae1e4-0.avif)

## Conclusão {#conclusion}

Este tutorial demonstrou como usar a Compilação Quântica Aproximada com redes tensoriais (AQC-Tensor) para comprimir e otimizar circuitos destinados à simulação de dinâmica quântica em larga escala. Utilizando modelos de Heisenberg tanto pequenos quanto grandes, aplicamos o AQC-Tensor para reduzir a profundidade de circuito necessária para a evolução temporal Trotterizada. Ao gerar um ansatz parametrizado a partir de um circuito de Trotter simplificado e otimizá-lo com técnicas de estado produto de matrizes (MPS), obtivemos uma aproximação de baixa profundidade da evolução alvo que é ao mesmo tempo precisa e eficiente.

O fluxo de trabalho aqui apresentado destaca as principais vantagens do AQC-Tensor para o escalonamento de simulações quânticas:

- **Compressão significativa de circuitos**: o AQC-Tensor reduziu a profundidade de circuito necessária para a evolução temporal complexa, tornando-a mais viável nos dispositivos atuais.
- **Otimização eficiente**: a abordagem MPS forneceu uma estrutura robusta para a otimização de parâmetros, equilibrando fidelidade com eficiência computacional.
- **Execução pronta para hardware**: a transpilação do circuito final otimizado garantiu que ele atendesse às restrições do hardware quântico alvo.

À medida que dispositivos quânticos maiores e algoritmos mais avançados surgem, técnicas como o AQC-Tensor tornar-se-ão essenciais para executar simulações quânticas complexas em hardware de curto prazo, demonstrando um progresso promissor no gerenciamento de profundidade e fidelidade para aplicações quânticas escaláveis.

## Pesquisa sobre o tutorial {#tutorial-survey}

Por favor, responda a esta breve pesquisa para nos enviar seu feedback sobre este tutorial. Suas contribuições nos ajudarão a aprimorar nossos conteúdos e a experiência do usuário.

[Link to survey](https://your.feedback.ibm.com/jfe/form/SV_eF01c2sfeSt6cqq)
