---
title: "Einführung in'n Qiskit AI-jestütztn Transpiler-Service"
sidebar_label: "Einführung in'n Qiskit AI-jestütztn Transpiler-Service"
description: "In dem Notebook erkunden wa de wichtigsten Vorteile vom Qiskit AI-jestütztn Transpiler-Service un wie er sich mit traditionelln Methodn vajleicht."
notebook_path: "docs/tutorials/ai-transpiler-introduction.ipynb"
---

<OpenInLabBanner notebookPath="docs/tutorials/ai-transpiler-introduction.ipynb" />



{/* cspell:ignore fontsize idxmin */}

*Jeschätzte QPU-Nutzung: Keene (HINWEIS: Dieset Tutorial führt keene Jobs aus, weil et sich uff Transpilation konzentriert)*

## Hintergrund {#background}

Da **Qiskit AI-jestützte Transpiler-Service (QTS)** führt maschinellas Lernen in sowohl Routing- als ooch Synthese-Passes ein. Die KI-Modi wurden entwickelt, um de Grenzen von traditionella Transpilation zu übawindn, insbesondre bei jroß anjelegtn Schaltkreisn un komplexn Hardware-Topologien.

Ab **Juli 2025** wurde da **Transpiler-Service** uff die neue IBM Quantum&reg; Plattform migriert un steht nich mehr zur Verfügung. För de neusten Infos zum Status vom Transpiler-Service, kiek dir de [Transpiler-Service-Dokumentation](/guides/qiskit-transpiler-service) an. Den KI-Transpiler kannste trotzdem lokal nutzn, ähnlich wie dit standard Qiskit-Transpilation. Ersetze einfach `generate_preset_pass_manager()` durch `generate_ai_pass_manager()`. Diese Funktion baut 'nen Pass-Manager, der de KI-jestütztn Routing- un Synthese-Passes direkt in dein lokalen Transpilations-Workflow integriert.

### Wichtijste Funktionen von KI-Passes {#key-features-of-ai-passes}

- Routing-Passes: KI-jestütztes Routing kann Qubit-Pfade dynamisch anpassen, je nach konkretem Schaltkreis un Backend, un so de Notiwendigkeit von übermäßign SWAP-Gates reduzieren.
    - `AIRouting`: Layout-Auswahl un Schaltkreis-Routing

- Synthese-Passes: KI-Techniken optimiern de Zerlegung von Multi-Qubit-Gates un minimiern de Anzahl von Zwei-Qubit-Gates, die typischaweise fehleranfälliga sind.
    - `AICliffordSynthesis`: Clifford-Gate-Synthese
    - `AILinearFunctionSynthesis`: Lineare-Funktions-Schaltkreis-Synthese
    - `AIPermutationSynthesis`: Permutations-Schaltkreis-Synthese
    - `AIPauliNetworkSynthesis`: Pauli-Netzwerk-Schaltkreis-Synthese (nur im Qiskit Transpiler Service verfügbar, nich in da lokalen Umjebung)

- Vajleich mit traditionella Transpilation: Da standard Qiskit-Transpiler is 'n robustes Werkzeug, det 'ne breite Palette von Quantenschaltkreisn effektiv handhabn kann. Wenn Schaltkreise aba jrößa werdn oder Hardware-Konfigurationen komplexer, können KI-Passes zusätzliche Optimierungsjewinne liefan. Durch de Verwendung von jelernstn Modellen für Routing un Synthese verfeinert QTS Schaltkreis-Layouts weita un reduziert den Overhead für anspruchsvolle oda jroß anjelegte Quantenaufjabn.

Dieset Tutorial bewertet de KI-Modi mit sowohl Routing- als ooch Synthese-Passes un vajleicht de Erjebnisse mit traditionella Transpilation, um zu zeijn, wo KI Leistungsjewinne liefat.

Mehr Details zu den verfügbarn KI-Passes findeste in da [KI-Passes-Dokumentation](/guides/ai-transpiler-passes).

### Warum KI für Quantenschaltkreis-Transpilation nutzen? {#why-use-ai-for-quantum-circuit-transpilation}

Wenn Quantenschaltkreise in Jröße un Komplexität wachsn, komm traditionelle Transpilationsmethodn ans Limit, wenn et ums effiziente Optimiern von Layouts un Reduzieren von Gate-Zahlen jeht. Jrößre Schaltkreise, insbesondre die mit hunderten von Qubits, stellen durch Jeräte-Beschränkungen, bejrenzte Konnektivität un Qubit-Fehlaratn erhebliche Herausfordaungen an Routing un Synthese.

Jenau da kommt KI-jestützte Transpilation als mögliche Lösung ins Spiel. Durch de Nutzung von Maschinelles-Lernen-Techniken kann da KI-jestützte Transpiler in Qiskit klügere Entscheidungen beim Qubit-Routing un da Gate-Synthese treffn, wat zu bessa optiemierten jroß anjelegtn Quantenschaltkreisn führt.

### Kurze Benchmarking-Erjebnisse {#brief-benchmarking-results}
![Jraph zeijt KI-Transpiler-Leistung jejenüba Qiskit](/docs/images/tutorials/ai-transpiler-introduction/ai-transpiler-benchmarks.avif)

Bei Benchmarking-Tests hat da KI-Transpiler konsistent flachere, hochwertigere Schaltkreise produziert als da standard Qiskit-Transpiler. För diese Tests ham wa Qiskits standard Pass-Manager-Strategie jenutzt, konfiguriert mit [`generate_preset_passmanager`]. Obwohl diese Standardstrategie oft effektiv is, kann se bei jrößern oder komplexern Schaltkreisen schwächeln. Im Jejensatz dazu ham KI-jestützte Passes im Durchschnitt 24 % wenija Zwei-Qubit-Gates un 36 % wenija Schaltkreistiefe bei jroßn Schaltkreisn (100+ Qubits) erreicht, wenn se zu da Heavy-Hex-Topologie von IBM-Quantum-Hardware transpiliert wern. Mehr Infos zu diesen Benchmarks findste in diesem [Blog.](https://www.ibm.com/quantum/blog/qiskit-performance)

Dieset Tutorial erkundet de wichtijsten Vorteile von KI-Passes un wie se sich mit traditionelln Methodn vajleichen.

```python
# Added by doQumentation — installs packages not in the Binder environment
%pip install -q qiskit-ibm-transpiler
```

```python
# This cell is hidden from users;
# it just disables a linting rule.
# ruff: noqa: F811
```

## Voraussetzungen {#requirements}

Bevoa dit Tutorial losjeht, stell sicher, datte dit Foljendes installiert hast:

* Qiskit SDK v1.0 oda neua, mit [Visualisierungs](https://docs.quantum.ibm.com/api/qiskit/visualization)-Unterstützung
* Qiskit Runtime (`pip install qiskit-ibm-runtime`) v0.22 oda neua
* Qiskit IBM&reg; Transpiler mit KI-lokalem Modus (`pip install 'qiskit-ibm-transpiler[ai-local-mode]'`)
## Setup {#setup}

```python
from qiskit import QuantumCircuit
from qiskit.circuit.library import efficient_su2, PermutationGate
from qiskit.synthesis.qft import synth_qft_full
from qiskit.circuit.random import random_circuit, random_clifford_circuit
from qiskit.transpiler import generate_preset_pass_manager, CouplingMap
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_transpiler import generate_ai_pass_manager
from qiskit.synthesis.permutation import (
    synth_permutation_depth_lnn_kms,
    synth_permutation_basic,
)
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import time
import logging

seed = 42

# Used for generating permutation circuits in part two for comparison
def generate_permutation_circuit(width, pattern):
    circuit = QuantumCircuit(width)
    circuit.append(
        PermutationGate(pattern=pattern),
        qargs=range(width),
    )
    return circuit

# Creates a Bernstein-Vazirani circuit given the number of qubits
def create_bv_circuit(num_qubits):
    qc = QuantumCircuit(num_qubits, num_qubits - 1)
    qc.x(num_qubits - 1)
    qc.h(qc.qubits)
    for i in range(num_qubits - 1):
        qc.cx(i, num_qubits - 1)
    qc.h(qc.qubits[:-1])
    return qc

# Transpile a circuit with a given pass manager and return metrics
def transpile_with_metrics(pass_manager, circuit):
    start = time.time()
    qc_out = pass_manager.run(circuit)
    elapsed = time.time() - start

    depth_2q = qc_out.depth(lambda x: x.operation.num_qubits == 2)
    gate_count = qc_out.size()

    return qc_out, {
        "depth_2q": depth_2q,
        "gate_count": gate_count,
        "time_s": elapsed,
    }

# Used for collecting metrics for part 3 of synthesis methods
def synth_transpile_with_metrics(qc, pm, pattern_id, method):
    start = time.time()
    qc = pm.run(qc)
    elapsed = time.time() - start

    return {
        "Pattern": pattern_id,
        "Method": method,
        "Depth (2Q)": qc.depth(lambda x: x.operation.num_qubits == 2),
        "Gates": qc.size(),
        "Time (s)": elapsed,
    }

# Ignore logs like "INFO:qiskit_ibm_transpiler.wrappers.ai_local_synthesis:Running Linear Functions AI synthesis on local mode"

logging.getLogger(
    "qiskit_ibm_transpiler.wrappers.ai_local_synthesis"
).setLevel(logging.WARNING)
```

# Teil I. Qiskit-Patterns {#part-i-qiskit-patterns}

Nu kieckn wa uns an, wie ma'n KI-Transpiler-Service mit 'nem einfachn Quantenschaltkreis nutzt, unter Verwendung von Qiskit-Patterns. Det Wichtijste is, 'nen `PassManager` mit `generate_ai_pass_manager()` zu erstelln statt mit'm standard `generate_preset_pass_manager()`.
## Schritt 1: Klassische Eingaben uff'n Quantenproblem abbildn {#step-1-map-classical-inputs-to-a-quantum-problem}

In diesem Abschnitt testen wa'n KI-Transpiler am `efficient_su2`-Schaltkreis, 'nem weit verbreiteten hardware-effizienten Ansatz. Dieser Schaltkreis is besondas relevant für variationelle Quantenalgorithmen (zum Beispiel VQE) un Quantenmaschinelles-Lernen-Aufjabn, wat ihn zu 'nem idealen Testfall för die Bewertung von Transpilationsleistung macht.

Da `efficient_su2`-Schaltkreis besteht aus abwechselndnen Schichten von Einzel-Qubit-Rotationen un verschränkenden Gates wie CNOTs. Diese Schichten ermöjlichn 'ne flexible Erkundung vom Quantenzustandsraum, während de Gate-Tiefe handhabbar bleibt. Durch dit Optimiern von diesem Schaltkreis wollen wa Gate-Zahlen reduzieren, Treue verbessern un Rauschen minimieren. Det macht ihn zu 'nem starken Kandidaten för's Testn von da KI-Transpiler-Effizienz.

```python
# For our transpilation, we will use a large circuit of 101 qubits
qc = efficient_su2(90, entanglement="circular", reps=1).decompose()

# Draw a smaller version of the circuit to get a visual representation
qc_small = efficient_su2(5, entanglement="circular", reps=1).decompose()
qc_small.draw(output="mpl")
```

![Ausgabe von da vorherigen Code-Zelle](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/c6e9c2c0-e02c-4276-bae8-d5692e60b6b8-0.avif)

## Schritt 2: Problem für Quantenhardware-Ausführung optimiern {#step-2-optimize-problem-for-quantum-hardware-execution}

### 'N Backend aussuchen {#choose-a-backend}

Für dieset Beispiel nehm wa dit am wenigstn ausjelastete operationelle IBM-Quantum-Backend, det kein Simulator is un mindestens 100 Qubits hat:

**Hinweis:** Da dit am wenigstn ausjelastete Backend sich im Laufe da Zeit ändern kann, können bei verschiedenen Läufn unterschiedliche Jeräte ausgewählt werdn. Jeräte-spezifische Eigenschaften, wie Coupling Maps, können zu Unterschieden in den transpiliertn Schaltkreisen führn.

```python
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=100
)
cm = backend.coupling_map
print(f"Using backend: {backend.name}")
```

```text
Using backend: ibm_torino
```

### KI- un traditionelle Pass-Manager erstelln {#create-ai-and-traditional-pass-managers}
Um de Effektivität vom KI-Transpiler zu bewerten, führn wa zwei Transpilations-Läufe durch. Erst transpiliern wa'n Schaltkreis mit'm KI-Transpiler. Dann machn wa 'nen Vajleich, indem wa denselben Schaltkreis ohne KI-Transpiler transpiliern, mit traditionelln Methodn. Beide Transpilationsprozesse nutzen dieselbe Coupling Map vom jewähltn Backend un den auf 3 jesetzten Optimierungsgrad för 'nen fairen Vajleich.

Beide Methodn spiejeeln den Standardansatz zum Erstelln von `PassManager`-Instanzen zum Transpiliern von Schaltkreisn in Qiskit wider.

```python
pm_ai = generate_ai_pass_manager(
    optimization_level=3,
    ai_optimization_level=3,
    coupling_map=cm,
    include_ai_synthesis=True,  # used for part 3 when comparing synthesis methods
)

pm_no_ai = generate_preset_pass_manager(
    optimization_level=3,
    coupling_map=cm,
    seed_transpiler=seed,  # note that the AI pass manager does not currently support seeding
)
```

Schaltkreise transpiliern un die Zeiten aufzeichnn.

```python
# Transpile using standard (non-AI) pass manager
_, metrics_no_ai = transpile_with_metrics(pm_no_ai, qc)
print(
    f"Standard transpilation: Depth (2q) {metrics_no_ai['depth_2q']}, "
    f"Gate count {metrics_no_ai['gate_count']}, Time {metrics_no_ai['time_s']}"
)

# Transpile using AI pass manager
_, metrics_ai = transpile_with_metrics(pm_ai, qc)
print(
    f"AI transpilation      : Depth (2q) {metrics_ai['depth_2q']}, "
    f"Gate count {metrics_ai['gate_count']}, Time {metrics_ai['time_s']}"
)
```

```text
Standard transpilation: Depth (2q) 95, Gate count 458, Time 0.04650712013244629
AI transpilation      : Depth (2q) 90, Gate count 456, Time 0.9342479705810547
```

In diesem Test vajleichn wa de Leistung vom KI-Transpiler un da standard Transpilationsmethode am efficient_su2-Schaltkreis. Da KI-Transpiler erreicht 'ne merklich flachere Schaltkreistiefe, während de Gate-Zahl ähnlich bleibt.

- **Schaltkreistiefe:** Da KI-Transpiler produziert 'nen Schaltkreis mit niedrigerer Zwei-Qubit-Tiefe. Det is erwartet, da die KI-Passes darauf trainiert sind, de Tiefe zu optimiern, indem se Qubit-Interaktionsmuster lernen un Hardware-Konnektivität effektiva ausnutzn als regelbasierte Heuristiken.

- **Gate-Zahl:** De Gesamtzahl von Gates bleibt bei beiden Methodn ähnlich. Det stimmt mit den Erwartungen überein, da de standard SABRE-basierte Transpilation explizit die Swap-Zahl minimiert, die den Gate-Overhead dominiert. Da KI-Transpiler priorisiert statdessen de jesamt Tiefe un kann gelegentlich 'n paar zusätzliche Gates gegen 'nen kürzern Ausführungspfad eintauschen.

- **Transpilationszeit:** Da KI-Transpiler braucht länger als de standard Methode. Det liegt an den erhöhten Rechenkosten durch's Aufrufen von jelernstn Modellen beim Routing un da Synthese. Im Jejensatz dazu is da SABRE-basierte Transpiler nach'm Umschreibn un Optimiern in Rust deutlich schnella jeworden un liefat hocheffizientes heuristisches Routing im jroßen Maßstab.

Et is wichtig zu beachtn, datte diese Erjebnisse nur auf 'nem einzijn Schaltkreis basieren. Um 'n umfassendes Bild davon zu kriegen, wie da KI-Transpiler sich mit traditionelln Methodn vajleicht, muss ma 'ne Vielzahl von Schaltkreisen testn. Die Leistung von QTS kann stark variieren, je nach Art des Schaltkreises, der optimiert wird. Für 'nen breiterern Vajleich, kiek dir die oben jenanntn Benchmarks an oda besuch den [Blog.](https://www.ibm.com/quantum/blog/qiskit-performance)
## Schritt 3: Ausführung mit Qiskit-Primitives {#step-3-execute-using-qiskit-primitives}
Da dieset Tutorial sich auf Transpilation konzentriert, werdn keine Experimente auf'm Quantenjeät ausjeführt. Det Ziel is, die Optimierungen aus Schritt 2 zu nutzn, um 'nen transpiliertn Schaltkreis mit reduzierter Tiefe oda Gate-Zahl zu erhaltn.
## Schritt 4: Erjebnisse nachbearbeiten un im jewünschtn klassischen Format zurückjebn {#step-4-post-process-and-return-result-in-desired-classical-format}
Da es keine Ausführung för dieset Notebook jibt, jibt et ooch keine Erjebnisse zum Nachbearbeiten.
# Teil II. Transpilierte Schaltkreise analysieren un benchmarken {#part-ii-analyze-and-benchmark-the-transpiled-circuits}

In diesem Abschnitt zeijn wa, wie ma'n transpiliertn Schaltkreis analysiert un ihn detaillierter jejenüba da Originalversion benchmarkt. Wa konzentriern uns uff Metriken wie Schaltkreistiefe, Gate-Zahl un Transpilationszeit, um de Effektivität von da Optimierung zu bewerten. Außerdem diskutiern wa, wie de Erjebnisse bei verschiedenen Schaltkreistypen unterschiedlich ausfallen können, un jebn Einblicke in die breiter angelegte Leistung des Transpilers in verschiedenen Szenarien.

```python
# Circuits to benchmark
seed = 42
circuits = [
    {
        "name": "Random",
        "qc": random_circuit(num_qubits=30, depth=10, seed=seed),
    },
    {
        "name": "Clifford",
        "qc": random_clifford_circuit(
            num_qubits=40, num_gates=200, seed=seed
        ),
    },
    {
        "name": "QFT",
        "qc": synth_qft_full(num_qubits=20, do_swaps=False).decompose(),
    },
    {
        "name": "BV",
        "qc": create_bv_circuit(40),
    },
]

results = []

# Run the transpilation for each circuit and store the results
for circuit in circuits:
    qc_no_ai, metrics_no_ai = transpile_with_metrics(pm_no_ai, circuit["qc"])
    qc_ai, metrics_ai = transpile_with_metrics(pm_ai, circuit["qc"])

    print("Completed transpilation for", circuit["name"])

    results.append(
        {
            "Circuit": circuit["name"],
            "Depth 2Q (No AI)": metrics_no_ai["depth_2q"],
            "Gate Count (No AI)": metrics_no_ai["gate_count"],
            "Time (No AI)": metrics_no_ai["time_s"],
            "Depth 2Q (AI)": metrics_ai["depth_2q"],
            "Gate Count (AI)": metrics_ai["gate_count"],
            "Time (AI)": metrics_ai["time_s"],
        }
    )

df = pd.DataFrame(results)
df
```

```text
Completed transpilation for Random
Completed transpilation for Clifford
Completed transpilation for QFT
Completed transpilation for BV
```

```text
Circuit  Depth 2Q (No AI)  Gate Count (No AI)  Time (No AI)  \
0    Random                37                 221      0.039347
1  Clifford                36                 232      0.036633
2       QFT               165                 924      0.077458
3        BV                65                 155      0.024993

   Depth 2Q (AI)  Gate Count (AI)  Time (AI)
0             24              181   0.773718
1             43              267   1.097431
2            130              913   3.660771
3             70              155   0.345522
```

Durchschnittliche prozentuale Reduzierung för jede Metrik. Positive Werte sind Verbesserungen, negative sind Verschlechterungen.

```python
# Average reduction from non-AI to AI transpilation as a percentage
avg_reduction_depth = (
    (df["Depth 2Q (No AI)"] - df["Depth 2Q (AI)"]).mean()
    / df["Depth 2Q (No AI)"].mean()
    * 100
)
avg_reduction_gates = (
    (df["Gate Count (No AI)"] - df["Gate Count (AI)"]).mean()
    / df["Gate Count (No AI)"].mean()
    * 100
)
avg_reduction_time = (
    (df["Time (No AI)"] - df["Time (AI)"]).mean()
    / df["Time (No AI)"].mean()
    * 100
)

print(f"Average reduction in depth: {avg_reduction_depth:.2f}%")
print(f"Average reduction in gate count: {avg_reduction_gates:.2f}%")
print(f"Average reduction in transpilation time: {avg_reduction_time:.2f}%")
```

```text
Average reduction in depth: 11.88%
Average reduction in gate count: 1.04%
Average reduction in transpilation time: -3193.95%
```

```python
fig, axs = plt.subplots(1, 3, figsize=(21, 6))
df.plot(
    x="Circuit",
    y=["Depth 2Q (No AI)", "Depth 2Q (AI)"],
    kind="bar",
    ax=axs[0],
)
axs[0].set_title("Circuit Depth Comparison")
axs[0].set_ylabel("Depth")
axs[0].set_xlabel("Circuit")
axs[0].tick_params(axis="x", rotation=45)
df.plot(
    x="Circuit",
    y=["Gate Count (No AI)", "Gate Count (AI)"],
    kind="bar",
    ax=axs[1],
)
axs[1].set_title("Gate Count Comparison")
axs[1].set_ylabel("Gate Count")
axs[1].set_xlabel("Circuit")
axs[1].tick_params(axis="x", rotation=45)
df.plot(x="Circuit", y=["Time (No AI)", "Time (AI)"], kind="bar", ax=axs[2])
axs[2].set_title("Time Comparison")
axs[2].set_ylabel("Time (seconds)")
axs[2].set_xlabel("Circuit")
axs[2].tick_params(axis="x", rotation=45)
fig.suptitle(
    "Benchmarking AI transpilation vs Non-AI transpilation for various circuits"
)

plt.tight_layout()
plt.show()
```

![Ausgabe von da vorherigen Code-Zelle](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/79b8d5d9-0f9d-42ca-9583-8bec17430014-0.avif)

Die Leistung vom KI-Transpiler variiert stark je nach Art des Schaltkreises, da optimiert wird. In manchen Fälln erreicht er bemerkenswerte Reduzierungen in Schaltkreistiefe un Gate-Zahl im Vajleich zum standard Transpiler. Diese Verbesserungen kommen aba oft mit 'nem erheblichen Anstieg in da Laufzeit.

Bei bestimmten Schaltkreistypen kann da KI-Transpiler leicht bessere Erjebnisse in Bezug auf Schaltkreistiefe liefan, kann aba ooch zu 'nem Anstieg in da Gate-Zahl un 'ner erheblichen Laufzeitstrafe führn. Diese Beobachtungen deuten darauf hin, datte die Vorteile vom KI-Transpiler nich gleichmäßig üba alle Schaltkreistypen verteilt sind. Stattdessen hängt seine Effektivität von den spezifischen Eigenschaften des Schaltkreises ab, wat ihn för manche Anwendungsfälle jeeigneter macht als för andere.
## Wann solltn Nutza KI-jestützte Transpilation wähln? {#when-should-users-choose-ai-powered-transpilation}

Da KI-jestützte Transpiler in Qiskit glänzt in Szenarien, wo traditionelle Transpilationsmethodn schwächeln, insbesondre bei jroß anjelegtn un komplexn Quantenschaltkreisen. Für Schaltkreise mit hunderten von Qubits oda solche, die auf Hardware mit kompliziertn Coupling Maps zieln, bietet da KI-Transpiler überlegene Optimierung in Bezug auf Schaltkreistiefe, Gate-Zahl un Laufzeiteffizienz. In Benchmarking-Tests hat er traditionelle Methodn konsistent übertroffen un deutlich flachere Schaltkreise jeliefat un Gate-Zahlen reduziert, wat entscheidend för die Verbesserung von Leistung un die Milderung von Rauschen auf echter Quantenhardware is.

Nutza solln KI-jestützte Transpilation in Betracht ziehn, wenn se mit foljendem arbeiten:
- Jroße Schaltkreise, bei denen traditionelle Methodn mit dem Maßstab nich klarkommen.
- Komplexe Hardware-Topologien, bei denen Herausforderungen durch Jeräte-Konnektivität un Routing entstehen.
- Leistungsempfindliche Anwendungen, bei denen dit Reduzieren von Schaltkreistiefe un dit Verbessern von Treue entscheidend sind.
# Teil III. KI-jestützte Permutationsnetzwerk-Synthese erkunden {#part-iii-explore-ai-powered-permutation-network-synthesis}

Permutationsnetzwerke sind grundlegend im Quantencomputing, insbesondre för Systeme, die durch eingeschränkte Topologien beschränkt sind. Diese Netzwerke ermöglichen weitreichende Interaktionen, indem se Qubits dynamisch tauschen, um Alle-zu-alle-Konnektivität auf Hardware mit bejrenzter Konnektivität nachzuahmn. Solche Transformationen sind wesentlich för dit Implementiern von komplexn Quantenalgorithmen auf Near-Term-Jeräten, wo Interaktionen oft über nächste Nachbarn hinausgehen.

In diesem Abschnitt heben wa die Synthese von Permutationsnetzwerken als 'nen überzeugenden Anwendungsfall för'n KI-jestütztn Transpiler in Qiskit hervor. Speziell nutzt da `AIPermutationSynthesis`-Pass KI-jestützte Optimierung, um effiziente Schaltkreise för Qubit-Permutationsaufjabn zu erzeugen. Im Gegensatz dazu kämpfen generische Syntheseansätze oft damit, Gate-Zahl un Schaltkreistiefe in Einklang zu bringen, insbesondre in Szenarien mit dichten Qubit-Interaktionen oda beim Versuch, volle Konnektivität zu erreichen.

Wa werdn 'n Qiskit-Patterns-Beispiel durchjehn, dat die Synthese 'nes Permutationsnetzwerks zeijt, um Alle-zu-alle-Konnektivität für 'ne Menje von Qubits zu erreichen. Wa vajleichn de Leistung von `AIPermutationSynthesis` mit den standard Synthesemethodn in Qiskit. Dieset Beispiel zeijt, wie da KI-Transpiler för niedrigere Schaltkreistiefe un Gate-Zahl optimiert un hebt seine Vorteile in praktischen Quanten-Workflows hervor. Um den KI-Synthese-Pass zu aktiviern, nutzen wa die `generate_ai_pass_manager()`-Funktion mit dem auf `True` jesetzten `include_ai_synthesis`-Parameter.
## Schritt 1: Klassische Eingaben uff'n Quantenproblem abbildn {#step-1-map-classical-inputs-to-a-quantum-problem-2}

Um 'n klassisches Permutationsproblem auf 'nem Quantencomputer darzustelln, fangn wa damit an, de Struktur von den Quantenschaltkreisen zu definieren. Für dieset Beispiel:

1. Initialisierung vom Quantenschaltkreis:
   Wa allozieren 27 Qubits, um zum Backend zu passin, dat wa nutzen werdn un det 27 Qubits hat.

2. Permutationen anwendn:
   Wa generieren zehn zufällige Permutationsmuster (`pattern_1` bis `pattern_10`) mit 'nem festen Seed för Reproduzierbarkeit. Jedes Permutationsmuster wird auf 'nen separaten Quantenschaltkreis (`qc_1` bis `qc_10`) anjewendt.

3. Schaltkreis-Zerlegung:
   Jede Permutationsoperation wird in native Gate-Sätze zerlejt, die mit da Ziel-Quantenhardware kompatibel sind. Wa analysieren de Tiefe un die Anzahl von Zwei-Qubit-Gates (nichtlokale Gates) för jeden zerjelejten Schaltkreis.

De Erjebnisse jebn Einblicke in die Komplexität von da Darstellung von klassischen Permutationsproblemen auf 'nem Quantenjeät un demonstriern den Ressourcenbedarf för verschiedene Permutationsmuster.

```python
# Parameters
width = 27
num_circuits = 10

# Set random seed
np.random.seed(seed)

# Generate random patterns and circuits
patterns = [
    np.random.permutation(width).tolist() for _ in range(num_circuits)
]
circuits = {
    f"qc_{i}": generate_permutation_circuit(width, pattern)
    for i, pattern in enumerate(patterns, start=1)
}

# Display one of the circuits
circuits["qc_1"].decompose(reps=3).draw(output="mpl", fold=-1)
```

![Ausgabe von da vorherigen Code-Zelle](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/76a3e847-0808-4413-bd0c-c760cd2df3f4-0.avif)

## Schritt 2: Problem för Quantenhardware-Ausführung optimiern {#step-2-optimize-problem-for-quantum-hardware-execution-2}
In diesem Schritt machen wa weita mit da Optimierung durch KI-Synthese-Passes.

Für de KI-Synthese-Passes benötigt da `PassManager` nur die Coupling Map vom Backend. Et is aba wichtig zu beachtn, datte nich alle Coupling Maps kompatibel sind; nur die, auf denen da `AIPermutationSynthesis`-Pass trainiert wurde, funktioniern. Momentan unterstützt da `AIPermutationSynthesis`-Pass Blöcke von Jrößen 65, 33 un 27 Qubits. Für dieset Beispiel nutzn wa 'nen 27-Qubit-QPU.

Zum Vajleich bewertn wa die Leistung von KI-Synthese jejenüba generischen Permutations-Synthesemethodn in Qiskit, einschließlich:

- `synth_permutation_depth_lnn_kms`: Diese Methode synthetisiert 'nen Permutationsschaltkreis für 'ne lineare Nächste-Nachbar-Architektur (LNN) mit'm Kutin-Moulton-Smithline-Algorithmus (KMS). Se garantiert 'nen Schaltkreis mit 'ner Tiefe von höchstens $ n $ un 'ner Jröße von höchstens $ n(n-1)/2 $, wobei sowohl Tiefe als ooch Jröße in SWAP-Gates jemessen werdn.

- `synth_permutation_basic`: Det is 'ne geradlinige Implementierung, die Permutationsschaltkreise ohne Einschränkungen bei Konnektivität oda Optimierung för spezifische Architekturen synthetisiert. Se dient als Basislinie för den Vajleich mit fortjeschrittenerern Methodn.

Jede dieser Methodn stellt 'nen anderen Ansatz zur Synthese von Permutationsnetzwerken dar un liefat 'n umfassendes Benchmark jejenüba den KI-jestütztn Methodn.

Mehr Details zu Synthesemethodn in Qiskit findestet in da [Qiskit-API-Dokumentation](https://docs.quantum.ibm.com/api/qiskit/synthesis).
Define de Coupling Map, die den 27-Qubit-QPU darstellt.

```python
coupling_map = [
    [1, 0],
    [2, 1],
    [3, 2],
    [3, 5],
    [4, 1],
    [6, 7],
    [7, 4],
    [7, 10],
    [8, 5],
    [8, 9],
    [8, 11],
    [11, 14],
    [12, 10],
    [12, 13],
    [12, 15],
    [13, 14],
    [16, 14],
    [17, 18],
    [18, 15],
    [18, 21],
    [19, 16],
    [19, 22],
    [20, 19],
    [21, 23],
    [23, 24],
    [25, 22],
    [25, 24],
    [26, 25],
]
CouplingMap(coupling_map).draw()
```

![Ausgabe von da vorherigen Code-Zelle](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/84dff2c2-a496-4828-bb8e-08d373816a36-0.avif)

Jeden Permutationsschaltkreis mit den KI-Synthese-Passes un generischen Synthesemethodn transpiliern.

```python
results = []
pm_no_ai_synth = generate_preset_pass_manager(
    coupling_map=cm,
    optimization_level=1,  # set to 1 since we are using the synthesis methods
)

# Transpile and analyze all circuits
for i, (qc_name, qc) in enumerate(circuits.items(), start=1):
    pattern = patterns[i - 1]  # Get the corresponding pattern

    qc_depth_lnn_kms = synth_permutation_depth_lnn_kms(pattern)
    qc_basic = synth_permutation_basic(pattern)

    # AI synthesis
    results.append(
        synth_transpile_with_metrics(
            qc.decompose(reps=3),
            pm_ai,
            qc_name,
            "AI",
        )
    )

    # Depth-LNN-KMS Method
    results.append(
        synth_transpile_with_metrics(
            qc_depth_lnn_kms.decompose(reps=3),
            pm_no_ai_synth,
            qc_name,
            "Depth-LNN-KMS",
        )
    )

    # Basic Method
    results.append(
        synth_transpile_with_metrics(
            qc_basic.decompose(reps=3),
            pm_no_ai_synth,
            qc_name,
            "Basic",
        )
    )

results_df = pd.DataFrame(results)
```

Die Metriken (Tiefe, Gate-Zahl, Zeit) för jeden Schaltkreis nach da Transpilation aufzeichnn.

```python
# Calculate averages for each metric
average_metrics = results_df.groupby("Method")[
    ["Depth (2Q)", "Gates", "Time (s)"]
].mean()
average_metrics = average_metrics.round(3)  # Round to two decimal places
print("\n=== Average Metrics ===")
print(average_metrics)

# Identify the best non-AI method based on least average depth
non_ai_methods = [
    method for method in results_df["Method"].unique() if method != "AI"
]
best_non_ai_method = average_metrics.loc[non_ai_methods][
    "Depth (2Q)"
].idxmin()
print(
    f"\nBest Non-AI Method (based on least average depth): {best_non_ai_method}"
)

# Compare AI to the best non-AI method
ai_metrics = average_metrics.loc["AI"]
best_non_ai_metrics = average_metrics.loc[best_non_ai_method]

comparison = {
    "Metric": ["Depth (2Q)", "Gates", "Time (s)"],
    "AI": [
        ai_metrics["Depth (2Q)"],
        ai_metrics["Gates"],
        ai_metrics["Time (s)"],
    ],
    best_non_ai_method: [
        best_non_ai_metrics["Depth (2Q)"],
        best_non_ai_metrics["Gates"],
        best_non_ai_metrics["Time (s)"],
    ],
    "Improvement (AI vs Best Non-AI)": [
        ai_metrics["Depth (2Q)"] - best_non_ai_metrics["Depth (2Q)"],
        ai_metrics["Gates"] - best_non_ai_metrics["Gates"],
        ai_metrics["Time (s)"] - best_non_ai_metrics["Time (s)"],
    ],
}

comparison_df = pd.DataFrame(comparison)
print("\n=== Comparison of AI vs Best Non-AI Method ===")
comparison_df
```

```text
=== Average Metrics ===
               Depth (2Q)  Gates  Time (s)
Method
AI                   23.9   82.8     0.248
Basic                29.8   91.0     0.012
Depth-LNN-KMS        70.8  531.6     0.017

Best Non-AI Method (based on least average depth): Basic

=== Comparison of AI vs Best Non-AI Method ===
```

```text
Metric      AI   Basic  Improvement (AI vs Best Non-AI)
0  Depth (2Q)  23.900  29.800                           -5.900
1       Gates  82.800  91.000                           -8.200
2    Time (s)   0.248   0.012                            0.236
```

Die Erjebnisse zeijen, datte da KI-Transpiler alle anderen Qiskit-Synthesemethodn för diese Menje von zufälligen Permutationsschaltkreisen übertrifftt. Wichtijste Erkenntnisse:

1. Tiefe: Da KI-Transpiler erreicht die niedrijste durchschnittliche Tiefe, wat uff überlegene Optimierung von Schaltkreis-Layouts hinweist.
2. Gate-Zahl: Er reduziert die Anzahl von Gates im Vajleich zu anderen Methodn erheblich, wat die Ausführungstreue un Effizienz verbessert.
3. Transpilationszeit: Alle Methodn laufen in diesem Maßstab sehr schnell, wat se praktisch nutzbar macht. Da KI-Transpiler hat aba 'nen merklichen Laufzeitanstieg im Vajleich zu traditionelln Methodn aufgrund da Komplexität von den jenutzen KI-Modellen.

Diese Erjebnisse machen'n KI-Transpiler zum effektivsten Ansatz för diesen Benchmark, insbesondre för die Optimierung von Tiefe un Gate-Zahl.
Erjebnisse plotten, um die Leistung von den KI-Synthese-Passes jejenüba den generischen Synthesemethodn zu vajleichn.

```python
methods = results_df["Method"].unique()

fig, axs = plt.subplots(1, 3, figsize=(18, 5))

# Pivot the DataFrame and reorder columns to ensure AI is first
pivot_depth = results_df.pivot(
    index="Pattern", columns="Method", values="Depth (2Q)"
)[["AI", "Depth-LNN-KMS", "Basic"]]
pivot_gates = results_df.pivot(
    index="Pattern", columns="Method", values="Gates"
)[["AI", "Depth-LNN-KMS", "Basic"]]
pivot_time = results_df.pivot(
    index="Pattern", columns="Method", values="Time (s)"
)[["AI", "Depth-LNN-KMS", "Basic"]]

pivot_depth.plot(kind="bar", ax=axs[0], legend=False)
axs[0].set_title("Circuit Depth Comparison")
axs[0].set_ylabel("Depth")
axs[0].set_xlabel("Pattern")
axs[0].tick_params(axis="x", rotation=45)
pivot_gates.plot(kind="bar", ax=axs[1], legend=False)
axs[1].set_title("2Q Gate Count Comparison")
axs[1].set_ylabel("Number of 2Q Gates")
axs[1].set_xlabel("Pattern")
axs[1].tick_params(axis="x", rotation=45)
pivot_time.plot(
    kind="bar", ax=axs[2], legend=True, title="Legend"
)  # Show legend on the last plot
axs[2].set_title("Time Comparison")
axs[2].set_ylabel("Time (seconds)")
axs[2].set_xlabel("Pattern")
axs[2].tick_params(axis="x", rotation=45)
fig.suptitle(
    "Benchmarking AI Synthesis Methods vs Non-AI Synthesis Methods For Random Permutations Circuits",
    fontsize=16,
    y=1,
)

plt.tight_layout()
plt.show()
```

![Ausgabe von da vorherigen Code-Zelle](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/a326f268-0115-442c-8563-968676b66670-0.avif)

Dieser Jraph hebt de einzelnen Erjebnisse för jeden Schaltkreis (`qc_1` bis `qc_10`) bei verschiedenen Synthesemethodn hervor:

Obwohl diese Erjebnisse die Effektivität vom KI-Transpiler för Permutationsschaltkreise unterstreichen, is et wichtig, seine Einschränkungen zu beachtn. Die KI-Synthesemethode is momentan nur för bestimmte Coupling Maps verfügbar, wat ihre breitere Anwendbarkeit einschränkn kann. Diese Einschränkung sollt bedacht werdn, wenn man ihre Verwendung in verschiedenen Szenarien bewertet.

Insjesamt zeijt da KI-Transpiler vielversprechende Verbesserungen bei Tiefe un Gate-Zahl-Optimierung för diese spezifischen Schaltkreise, während er verjeichbare Transpilationszeiten beibehält.
## Schritt 3: Ausführung mit Qiskit-Primitives {#step-3-execute-using-qiskit-primitives-2}
Da dieset Tutorial sich auf Transpilation konzentriert, werdn keine Experimente auf'm Quantenjeät ausjeführt. Det Ziel is, die Optimierungen aus Schritt 2 zu nutzn, um 'nen transpiliertn Schaltkreis mit reduzierter Tiefe oda Gate-Zahl zu erhaltn.
## Schritt 4: Erjebnisse nachbearbeiten un im jewünschtn klassischen Format zurückjebn {#step-4-post-process-and-return-result-in-desired-classical-format-2}
Da es keine Ausführung för dieset Notebook jibt, jibt et ooch keine Erjebnisse zum Nachbearbeiten.
## Tutorial-Umfrage {#tutorial-survey}

Mach bitte diese kurze Umfrage, um Feedback zu dieset Tutorial zu jebn. Dein Feedback hilft uns, unsern Inhalt un die Nutza-Erfahrung zu verbessern.

[Link zur Umfrage](https://your.feedback.ibm.com/jfe/form/SV_0igXMtMCQfApgDI)
