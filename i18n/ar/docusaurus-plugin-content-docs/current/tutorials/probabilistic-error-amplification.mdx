---
title: "تخفيف الأخطاء على نطاق utility-scale باستخدام probabilistic error amplification"
sidebar_label: "تخفيف الأخطاء على نطاق utility-scale باستخدام probabilistic error amplification"
description: "تشغيل تجربة تخفيف أخطاء على نطاق utility-scale باستخدام zero noise extrapolation و probabilistic error amplification."
notebook_path: "docs/tutorials/probabilistic-error-amplification.ipynb"
---
{/* doqumentation-source-hash: b88e39b7 */}

<OpenInLabBanner notebookPath="docs/tutorials/probabilistic-error-amplification.ipynb" />



{/* cspell:ignore mapsto multigraph inds extrap sharex sharey pidx */}

*تقدير الاستخدام: 16 دقيقة على معالج Heron r2 (ملاحظة: هذا تقدير فحسب. قد يختلف وقت تشغيلك.)*
## الخلفية النظرية {#background}

يوضح هذا البرنامج التعليمي كيفية تشغيل تجربة تخفيف أخطاء على نطاق utility-scale باستخدام Qiskit Runtime، مع استخدام نسخة تجريبية من *zero noise extrapolation* (ZNE) مع *probabilistic error amplification* (PEA).

![kim_nature_fig.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/e1e67c34-9d4d-4a88-9340-f0b2f3676770.avif)
__المرجع__: Y. Kim et al. *Evidence for the utility of quantum computing before fault tolerance.* [Nature 618.7965 (2023)](https://www.nature.com/articles/s41586-023-06096-3)
### Zero-Noise Extrapolation (ZNE)
إن zero-noise extrapolation (ZNE) هي تقنية لتخفيف الأخطاء تُزيل تأثيرات الضوضاء *المجهولة* أثناء تنفيذ الدائرة، والتي يمكن تحجيمها بطريقة *معروفة*.

تفترض هذه التقنية أن قيم القيمة المتوقعة تتناسب مع الضوضاء وفق دالة معروفة

$$
\langle A(\lambda) \rangle = \langle A(0) \rangle + \sum_{k=0}^{m} a_k \lambda^k + R
$$
حيث يُحدِّد $\lambda$ شدة الضوضاء وبالإمكان تضخيمها.
يمكن تطبيق ZNE وفق الخطوات التالية:

1. تضخيم ضوضاء الدائرة لعدة عوامل ضوضاء $\lambda_1, \lambda_2, ... $
2. تشغيل كل دائرة مُضخَّمة الضوضاء لقياس $\langle A(\lambda_1)\rangle, ...$
3. الاستقراء نحو حد الضوضاء الصفرية $\langle A(0)\rangle$

![zne_stages.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/5e63d706-82d8-4212-b802-c9191ce53341.avif)
#### تضخيم الضوضاء لـ ZNE {#amplify-noise-for-zne}
يكمن التحدي الرئيسي في التطبيق الناجح لـ ZNE في امتلاك نموذج دقيق للضوضاء في قيمة التوقع وتضخيم الضوضاء بطريقة معروفة.

ثمة ثلاث طرق شائعة لتنفيذ تضخيم الأخطاء في ZNE.

| **Pulse stretching** | **Gate folding** | **Probabilistic error amplification** |
|-----------|-----------|-----------|
| Scale pulse duration via calibration | Repeat gates in identity cycles $U\mapsto U(U^{-1}U)^{\lambda-1}/2$ | Add noise via sampling Pauli channels |
| ![zne_pulse_stretching.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/83188b57-e88f-43a1-a7bd-29327f46ecf5.avif) | ![zne_gate_folding.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/e1358d08-2632-4fd2-bf0f-f9384a2d3340.avif) | ![zne_pea.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/3d69d5bd-70e5-4eeb-aa02-fc0a62043010.avif) |
| Kandala et al. Nature (2019) | Shultz et al. PRA (2022) | Li & Benjamin PRX (2017) |
في تجارب utility-scale، يُعدّ *probabilistic error amplification* (PEA) الأسلوب الأكثر جاذبية.
- يفترض pulse stretching أن ضوضاء البوابة تتناسب مع المدة الزمنية، وهو ما لا ينطبق عادةً على أرض الواقع. كما أن معايرته مكلفة.
- يتطلب gate folding عوامل تمديد كبيرة تُقيّد بشدة عمق الدوائر القابلة للتشغيل.
- يمكن تطبيق PEA على أي دائرة قابلة للتشغيل بعامل الضوضاء الأصلي ($\lambda=1$)، غير أنه يستلزم تعلّم نموذج الضوضاء.
### تعلّم نموذج الضوضاء لـ PEA {#learn-the-noise-model-for-pea}
يفترض PEA نموذج ضوضاء طبقي مشابهاً لما تستخدمه *probabilistic error cancellation* (PEC)، إلا أنه يتجنب تكاليف أخذ العينات التي تتصاعد أسياً مع ضوضاء الدائرة.
| **الخطوة 1** | **الخطوة 2** | **الخطوة 3** |
|-----------|-----------|-----------|
| Pauli twirl layers of two-qubit gates | Repeat identity pairs of layers and learn the noise | Derive a fidelity (error for each noise channel) |
| ![pec_pauli_twirling.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/2eab5ff4-40fa-4a41-9f2c-74f5e22c4643.avif) | ![pec_learn_layer.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/8d0d64c3-65ad-4419-8ac9-4ec9633d39a0.avif) | ![pec_curve_fitting.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/c51bd42d-2463-4c78-807b-d284ca79296f.avif) |

__المرجع__: E. van den Berg, Z. Minev, A. Kandala, and K. Temme, _Probabilistic error cancellation with sparse Pauli-Lindblad models on noisy quantum processors_ [arXiv:2201.09866](https://arxiv.org/abs/2201.09866)
## المتطلبات {#requirements}

قبل البدء بهذا البرنامج التعليمي، تأكد من تثبيت ما يلي:

- Qiskit SDK الإصدار v1.0 أو أحدث، مع دعم [visualization](https://docs.quantum.ibm.com/api/qiskit/visualization)
- Qiskit Runtime الإصدار v0.22 أو أحدث (`pip install qiskit-ibm-runtime`)
## الإعداد {#setup}

```python
from __future__ import annotations
from collections.abc import Sequence
from collections import defaultdict
import numpy as np
import rustworkx
import matplotlib.pyplot as plt

from qiskit.circuit import QuantumCircuit, Parameter
from qiskit.circuit.library import CXGate, CZGate, ECRGate
from qiskit.providers import Backend
from qiskit.visualization import plot_error_map
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit.quantum_info import SparsePauliOp
from qiskit.primitives import PubResult

from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_runtime import EstimatorV2 as Estimator
```

## الخطوة 1: تحويل المدخلات الكلاسيكية إلى مسألة كمومية {#step-1-map-classical-inputs-to-a-quantum-problem}
### إنشاء دائرة نموذج Ising ذات معاملات قابلة للضبط {#create-a-parameterized-ising-model-circuit}
أولاً، اختر نظام تشغيل backend للعمل عليه. يعمل هذا المثال التوضيحي على backend من 127 qubit، غير أنه يمكنك تعديله ليتناسب مع أي backend متاح لديك.

```python
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=127
)
backend
```

```text
<IBMBackend('ibm_kingston')>
```

#### دوال مساعدة لبناء الدائرة {#helper-functions-for-circuit-construction}
بعد ذلك، أنشئ بعض الدوال المساعدة لبناء الدوائر الخاصة بالتطور الزمني المُقسَّم بـ Trotter لنموذج Ising المستعرض ثنائي الأبعاد بما يتوافق مع تضولوجيا backend.

```python
"""Trotter circuit generation"""

def remove_qubit_couplings(
    couplings: Sequence[tuple[int, int]], qubits: Sequence[int] | None = None
) -> list[tuple[int, int]]:
    """Remove qubits from a coupling list.

    Args:
        couplings: A sequence of qubit couplings.
        qubits: Optional, the qubits to remove.

    Returns:
        The input couplings with the specified qubits removed.
    """
    if qubits is None:
        return couplings
    qubits = set(qubits)
    return [edge for edge in couplings if not qubits.intersection(edge)]

def coupling_qubits(
    *couplings: Sequence[tuple[int, int]],
    allowed_qubits: Sequence[int] | None = None,
) -> list[int]:
    """Return a sorted list of all qubits involved in one or more couplings lists.

    Args:
        couplings: one or more coupling lists.
        allowed_qubits: Optional, the allowed qubits to include. If None all
            qubits are allowed.

    Returns:
        The intersection of all qubits in the couplings and the allowed qubits.
    """
    qubits = set()
    for edges in couplings:
        for edge in edges:
            qubits.update(edge)
    if allowed_qubits is not None:
        qubits = qubits.intersection(allowed_qubits)
    return list(qubits)

def construct_layer_couplings(
    backend: Backend,
) -> list[list[tuple[int, int]]]:
    """Separate a coupling map into disjoint 2-qubit gate layers.

    Args:
        backend: A backend to construct layer couplings for.

    Returns:
        A list of disjoint layers of directed couplings for the input coupling map.
    """
    coupling_graph = backend.coupling_map.graph.to_undirected(
        multigraph=False
    )
    edge_coloring = rustworkx.graph_bipartite_edge_color(coupling_graph)

    layers = defaultdict(list)
    for edge_idx, color in edge_coloring.items():
        layers[color].append(
            coupling_graph.get_edge_endpoints_by_index(edge_idx)
        )
    layers = [sorted(layers[i]) for i in sorted(layers.keys())]

    return layers

def entangling_layer(
    gate_2q: str,
    couplings: Sequence[tuple[int, int]],
    qubits: Sequence[int] | None = None,
) -> QuantumCircuit:
    """Generating a entangling layer for the specified couplings.

    This corresponds to a Trotter layer for a ZZ Ising term with angle Pi/2.

    Args:
        gate_2q: The 2-qubit basis gate for the layer, should be "cx", "cz", or "ecr".
        couplings: A sequence of qubit couplings to add CX gates to.
        qubits: Optional, the physical qubits for the layer. Any couplings involving
            qubits not in this list will be removed. If None the range up to the largest
            qubit in the couplings will be used.

    Returns:
        The QuantumCircuit for the entangling layer.
    """
    # Get qubits and convert to set to order
    if qubits is None:
        qubits = range(1 + max(coupling_qubits(couplings)))
    qubits = set(qubits)

    # Mapping of physical qubit to virtual qubit
    qubit_mapping = {q: i for i, q in enumerate(qubits)}

    # Convert couplings to indices for virtual qubits
    indices = [
        [qubit_mapping[i] for i in edge]
        for edge in couplings
        if qubits.issuperset(edge)
    ]

    # Layer circuit on virtual qubits
    circuit = QuantumCircuit(len(qubits))

    # Get 2-qubit basis gate and pre and post rotation circuits
    gate2q = None
    pre = QuantumCircuit(2)
    post = QuantumCircuit(2)

    if gate_2q == "cx":
        gate2q = CXGate()
        # Pre-rotation
        pre.sdg(0)
        pre.z(1)
        pre.sx(1)
        pre.s(1)
        # Post-rotation
        post.sdg(1)
        post.sxdg(1)
        post.s(1)
    elif gate_2q == "ecr":
        gate2q = ECRGate()
        # Pre-rotation
        pre.z(0)
        pre.s(1)
        pre.sx(1)
        pre.s(1)
        # Post-rotation
        post.x(0)
        post.sdg(1)
        post.sxdg(1)
        post.s(1)
    elif gate_2q == "cz":
        gate2q = CZGate()
        # Identity pre-rotation
        # Post-rotation
        post.sdg([0, 1])
    else:
        raise ValueError(
            f"Invalid 2-qubit basis gate {gate_2q}, should be 'cx', 'cz', or 'ecr'"
        )

    # Add 1Q pre-rotations
    for inds in indices:
        circuit.compose(pre, qubits=inds, inplace=True)

    # Use barriers around 2-qubit basis gate to specify a layer for PEA noise learning
    circuit.barrier()
    for inds in indices:
        circuit.append(gate2q, (inds[0], inds[1]))
    circuit.barrier()

    # Add 1Q post-rotations after barrier
    for inds in indices:
        circuit.compose(post, qubits=inds, inplace=True)

    # Add physical qubits as metadata
    circuit.metadata["physical_qubits"] = tuple(qubits)

    return circuit

def trotter_circuit(
    theta: Parameter | float,
    layer_couplings: Sequence[Sequence[tuple[int, int]]],
    num_steps: int,
    gate_2q: str | None = "cx",
    backend: Backend | None = None,
    qubits: Sequence[int] | None = None,
) -> QuantumCircuit:
    """Generate a Trotter circuit for the 2D Ising

    Args:
        theta: The angle parameter for X.
        layer_couplings: A list of couplings for each entangling layer.
        num_steps: the number of Trotter steps.
        gate_2q: The 2-qubit basis gate to use in entangling layers.
            Can be "cx", "cz", "ecr", or None if a backend is provided.
        backend: A backend to get the 2-qubit basis gate from, if provided
            will override the basis_gate field.
        qubits: Optional, the allowed physical qubits to truncate the
            couplings to. If None the range up to the largest
            qubit in the couplings will be used.

    Returns:
        The Trotter circuit.
    """
    if backend is not None:
        try:
            basis_gates = backend.configuration().basis_gates
        except AttributeError:
            basis_gates = backend.basis_gates
        for gate in ["cx", "cz", "ecr"]:
            if gate in basis_gates:
                gate_2q = gate
                break

    # If no qubits, get the largest qubit from all layers and
    # specify the range so the same one is used for all layers.
    if qubits is None:
        qubits = range(1 + max(coupling_qubits(layer_couplings)))

    # Generate the entangling layers
    layers = [
        entangling_layer(gate_2q, couplings, qubits=qubits)
        for couplings in layer_couplings
    ]

    # Construct the circuit for a single Trotter step
    num_qubits = len(qubits)
    trotter_step = QuantumCircuit(num_qubits)
    trotter_step.rx(theta, range(num_qubits))
    for layer in layers:
        trotter_step.compose(layer, range(num_qubits), inplace=True)

    # Construct the circuit for the specified number of Trotter steps
    circuit = QuantumCircuit(num_qubits)
    for _ in range(num_steps):
        circuit.rx(theta, range(num_qubits))
        for layer in layers:
            circuit.compose(layer, range(num_qubits), inplace=True)

    circuit.metadata["physical_qubits"] = tuple(qubits)
    return circuit
```

#### تعريف ترابطات طبقة التشابك {#define-entangling-layer-couplings}
لتنفيذ محاكاة Ising المُقسَّمة بـ Trotter، عرِّف ثلاث طبقات من ترابطات بوابات ثنائية الـ qubit للجهاز، تتكرر عند كل خطوة من خطوات Trotter. تحدد هذه الطبقات الثلاث المُلتوية بـ Pauli التي تحتاج إلى تعلّم الضوضاء الخاصة بها لتطبيق التخفيف.

```python
layer_couplings = construct_layer_couplings(backend)
for i, layer in enumerate(layer_couplings):
    print(f"Layer {i}:\n{layer}\n")
```

```text
Layer 0:
[(2, 3), (4, 5), (6, 7), (8, 9), (10, 11), (12, 13), (14, 15), (16, 23), (18, 31), (19, 35), (20, 21), (25, 37), (26, 27), (28, 29), (33, 39), (36, 41), (38, 49), (42, 43), (45, 46), (47, 57), (51, 52), (53, 54), (56, 63), (58, 71), (59, 75), (61, 62), (64, 65), (66, 67), (68, 69), (72, 73), (76, 81), (79, 93), (82, 83), (84, 85), (86, 87), (88, 89), (91, 98), (94, 95), (97, 107), (99, 115), (100, 101), (102, 103), (105, 117), (108, 109), (110, 111), (113, 114), (116, 121), (118, 129), (123, 136), (124, 125), (126, 127), (130, 131), (132, 133), (135, 139), (138, 151), (142, 143), (144, 145), (146, 147), (152, 153), (154, 155)]

Layer 1:
[(0, 1), (3, 16), (5, 6), (7, 8), (11, 18), (13, 14), (17, 27), (21, 22), (23, 24), (25, 26), (29, 38), (30, 31), (32, 33), (34, 35), (39, 53), (41, 42), (43, 56), (44, 45), (47, 48), (49, 50), (51, 58), (54, 55), (57, 67), (60, 61), (62, 63), (65, 66), (69, 78), (70, 71), (73, 79), (74, 75), (77, 85), (80, 81), (83, 84), (87, 97), (89, 90), (91, 92), (93, 94), (96, 103), (101, 116), (104, 105), (106, 107), (109, 118), (111, 112), (113, 119), (114, 115), (117, 125), (121, 122), (123, 124), (127, 137), (128, 129), (131, 138), (133, 134), (136, 143), (139, 155), (140, 141), (145, 146), (147, 148), (149, 150), (151, 152)]

Layer 2:
[(1, 2), (3, 4), (7, 17), (9, 10), (11, 12), (15, 19), (21, 36), (22, 23), (24, 25), (27, 28), (29, 30), (31, 32), (33, 34), (37, 45), (40, 41), (43, 44), (46, 47), (48, 49), (50, 51), (52, 53), (55, 59), (61, 76), (63, 64), (65, 77), (67, 68), (69, 70), (71, 72), (73, 74), (78, 89), (81, 82), (83, 96), (85, 86), (87, 88), (90, 91), (92, 93), (95, 99), (98, 111), (101, 102), (103, 104), (105, 106), (107, 108), (109, 110), (112, 113), (119, 133), (120, 121), (122, 123), (125, 126), (127, 128), (129, 130), (131, 132), (134, 135), (137, 147), (141, 142), (143, 144), (148, 149), (150, 151), (153, 154)]
```

#### إزالة الـ qubit ذات الأداء الضعيف {#remove-bad-qubits}
ألقِ نظرة على خريطة الترابط الخاصة بـ backend وتحقق مما إذا كانت هناك أي qubits ترتبط بتوصيلات ذات معدل خطأ مرتفع. أزل هذه الـ qubits "الرديئة" من تجربتك.

```python
# Plot gate error map
# NOTE: These can change over time, so your results may look different
plot_error_map(backend)
```

![Output of the previous code cell](/docs/images/tutorials/probabilistic-error-amplification/extracted-outputs/401e2d48-1b39-40c8-bf32-7b439ae0980d-0.avif)

```python
bad_qubits = {
    56,
    63,
    67,
}  # qubits removed based on high coupling error (1.00)
good_qubits = list(set(range(backend.num_qubits)).difference(bad_qubits))
print("Physical qubits:\n", good_qubits)
```

```text
Physical qubits:
 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62, 64, 65, 66, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155]
```

#### توليد دائرة Trotter الرئيسية {#main-trotter-circuit-generation}

```python
num_steps = 6
theta = Parameter("theta")
circuit = trotter_circuit(
    theta, layer_couplings, num_steps, qubits=good_qubits, backend=backend
)
```

### إنشاء قائمة بقيم المعاملات لتعيينها لاحقاً {#create-a-list-of-parameter-values-to-be-assigned-later}

```python
num_params = 12

# 12 parameter values for Rx between [0, pi/2].
# Reshape to outer product broadcast with observables
parameter_values = np.linspace(0, np.pi / 2, num_params).reshape(
    (num_params, 1)
)
num_params = parameter_values.size
```

## الخطوة 2: تحسين المسألة لتنفيذها على الأجهزة الكمومية {#step-2-optimize-problem-for-quantum-hardware-execution}

## الخطوة 2: تحسين المسألة لتنفيذها على العتاد الكمي
### دائرة ISA {#isa-observables}
قبل تشغيل الدائرة على العتاد، يجب تحسينها للتنفيذ الفعلي. تشمل هذه العملية عدة خطوات:

- اختيار تخطيط للكيوبتات يُعيّن الكيوبتات الافتراضية في دائرتك إلى كيوبتات مادية على العتاد.
- إدراج بوابات swap عند الحاجة لتوجيه التفاعلات بين الكيوبتات غير المتصلة ببعضها.
- ترجمة البوابات في دائرتنا إلى تعليمات [بنية مجموعة التعليمات (ISA)](/guides/transpile#instruction-set-architecture) القابلة للتنفيذ مباشرةً على العتاد.
- إجراء تحسينات على الدائرة لتقليل عمق الدائرة وعدد البوابات.

على الرغم من أن المُحوِّل البرمجي المدمج في Qiskit قادر على تنفيذ جميع هذه الخطوات، يُبيّن هذا البرنامج التعليمي كيفية بناء دائرة Trotter على نطاق الأداة المساعدة من الصفر. اختر الكيوبتات المادية الجيدة وحدّد طبقات التشابك على أزواج الكيوبتات المتصلة من تلك الكيوبتات المختارة. مع ذلك، لا تزال بحاجة إلى ترجمة البوابات غير المتوافقة مع ISA في الدائرة والاستفادة من أي تحسينات للدائرة يوفرها المُحوِّل البرمجي.

حوِّل دائرتك للواجهة الخلفية المختارة عن طريق إنشاء مدير تمريرات ثم تشغيله على الدائرة. كذلك، ثبِّت التخطيط الأولي للدائرة على `good_qubits` المُحددة مسبقاً. الطريقة الأسهل لإنشاء مدير تمريرات هي استخدام الدالة [`generate_preset_pass_manager`](https://docs.quantum.ibm.com/api/qiskit/qiskit.transpiler.generate_preset_pass_manager). راجع [التحويل البرمجي باستخدام مديري التمريرات](/guides/transpile-with-pass-managers) للاطلاع على شرح أكثر تفصيلاً للتحويل البرمجي عبر مديري التمريرات.

```python
pm = generate_preset_pass_manager(
    backend=backend,
    initial_layout=good_qubits,
    layout_method="trivial",
    optimization_level=1,
)

isa_circuit = pm.run(circuit)
```

### المقاييس الرصدية لـ ISA
بعد ذلك، أنشئ جميع المقاييس الرصدية $\langle Z \rangle$ ذات الوزن-1 لكل كيوبت افتراضي عن طريق إضافة العدد الضروري من حدود $\langle I \rangle$.

```python
observables = []
num_qubits = len(good_qubits)
for q in range(num_qubits):
    observables.append(
        SparsePauliOp("I" * (num_qubits - q - 1) + "Z" + "I" * q)
    )
```

لقد عيّنت عملية التحويل البرمجي الكيوبتات الافتراضية في دائرتك إلى كيوبتات مادية على العتاد. تُخزَّن معلومات تخطيط الكيوبتات في خاصية `layout` الخاصة بالدائرة المُحوَّلة. نظراً لأن مقياسك الرصدي مُعرَّف أيضاً بدلالة الكيوبتات الافتراضية، فأنت بحاجة إلى تطبيق هذا التخطيط على المقياس الرصدي. يتم ذلك باستخدام أسلوب `apply_layout` الخاص بـ `SparsePauliOp`.

لاحظ أن كل مقياس رصدي مُغلَّف في قائمة في كتلة الكود التالية. يتم ذلك لـ _البث_ مع قيم المعاملات بحيث يُقاس كل مقياس رصدي للكيوبت لكل قيمة من قيم theta. يمكن الاطلاع على قواعد البث الخاصة بالأوليات [هنا](/guides/primitives).

```python
isa_observables = [
    [obs.apply_layout(layout=isa_circuit.layout)] for obs in observables
]
```

## الخطوة 3: التنفيذ باستخدام أوليات Qiskit

```python
pub = (isa_circuit, isa_observables, parameter_values)
```

### ضبط خيارات Estimator
بعد ذلك، اضبط خيارات `Estimator` اللازمة لتشغيل تجربة التخفيف. يشمل ذلك خيارات تعلُّم الضوضاء لطبقات التشابك، وللاستقراء باستخدام ZNE.

نستخدم الإعداد التالي:

```python
# Experiment options
num_randomizations = 700
num_randomizations_learning = 40
max_batch_circuits = 3 * num_params
shots_per_randomization = 64
learning_pair_depths = [0, 1, 2, 4, 6, 12, 24]
noise_factors = [1, 1.3, 1.6]
extrapolated_noise_factors = np.linspace(0, max(noise_factors), 20)

# Base option formatting
options = {
    # Builtin resilience settings for ZNE
    "resilience": {
        "measure_mitigation": True,
        "zne_mitigation": True,
        # TREX noise learning configuration
        "measure_noise_learning": {
            "num_randomizations": num_randomizations_learning,
            "shots_per_randomization": 1024,
        },
        # PEA noise model configuration
        "layer_noise_learning": {
            "max_layers_to_learn": 3,
            "layer_pair_depths": learning_pair_depths,
            "shots_per_randomization": shots_per_randomization,
            "num_randomizations": num_randomizations_learning,
        },
        "zne": {
            "amplifier": "pea",
            "noise_factors": noise_factors,
            "extrapolator": ("exponential", "linear"),
            "extrapolated_noise_factors": extrapolated_noise_factors.tolist(),
        },
    },
    # Randomization configuration
    "twirling": {
        "num_randomizations": num_randomizations,
        "shots_per_randomization": shots_per_randomization,
        "strategy": "active-circuit",
    },
    # Optional Dynamical Decoupling (DD)
    "dynamical_decoupling": {"enable": True, "sequence_type": "XY4"},
}
```

#### شرح خيارات ZNE
يوضح ما يلي تفاصيل الخيارات الإضافية في الفرع التجريبي. لاحظ أن هذه الخيارات وأسماءها غير نهائية، وكل ما هنا قابل للتغيير قبل الإصدار الرسمي.

* __amplifier__: الأسلوب المستخدم عند تضخيم الضوضاء إلى معاملات الضوضاء المقصودة.
    القيم المسموح بها هي `"gate_folding"` التي تُضخِّم بتكرار بوابات الأساس ثنائية الكيوبت،
    و`"pea"` التي تُضخِّم بالأخذ العشوائي الاحتمالي بعد تعلُّم نموذج ضوضاء Pauli-twirled
    لطبقات بوابات الأساس ثنائية الكيوبت المُلتوية. توجد أيضاً خيارات `"gate_folding_front"` و`"gate_folding_back"` المشروحة في [توثيق API](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/options-zne-options#amplifier)
* __extrapolated_noise_factors__: حدِّد قيمة واحدة أو أكثر من قيم معاملات الضوضاء التي تريد تقييم
    نماذج الاستقراء عندها. في حالة وجود سلسلة من القيم، ستكون النتائج المُعادة ذات قيم مصفوفية مع تقييم معامل الضوضاء المُحدد لنموذج الاستقراء. القيمة
    0 تقابل الاستقراء نحو الضوضاء الصفرية.
### تشغيل التجربة

```python
estimator = Estimator(mode=backend, options=options)
job = estimator.run([pub])
```

```python
print(f"Job ID {job.job_id()}")
```

```text
Job ID d0mcsvik4jhc73afljrg
```

## الخطوة 4: المعالجة اللاحقة وإعادة النتيجة بالصيغة الكلاسيكية المطلوبة
بمجرد انتهاء التجربة، يمكنك عرض نتائجك. يمكنك استرداد قيم التوقع الخام والمُخفَّفة ومقارنتها بالنتائج الدقيقة. بعد ذلك، ارسم قيم التوقع، المُخفَّفة (المُستقرَأة) والخام معاً، كمتوسط على جميع الكيوبتات لكل معامل. أخيراً، ارسم قيم التوقع للكيوبتات الفردية التي تختارها.

```python
primitive_result = job.result()
```

### الأشكال العامة للنتائج والبيانات الوصفية {#plot-trotter-simulation-results}
يحتوي كائن `PrimitiveResult` على بنية تشبه القائمة تُسمى `PubResult`. نظراً لأننا نُرسل PUB واحداً فقط إلى Estimator، فإن `PrimitiveResult` يحتوي على كائن `PubResult` واحد.

قيم التوقع والأخطاء المعيارية لنتيجة PUB (الكتلة الموحدة الأولية) ذات قيم مصفوفية. في وظائف Estimator مع ZNE، تتوفر عدة حقول بيانات لقيم التوقع والأخطاء المعيارية في حاوية `DataBin` الخاصة بـ `PubResult`. سنناقش باختصار حقول البيانات لقيم التوقع هنا (تتوفر حقول بيانات مماثلة للأخطاء المعيارية (`stds`) أيضاً).

1. `pub_result.data.evs`: قيم التوقع المقابلة للضوضاء الصفرية (استناداً إلى أفضل استقراء وفق الاستدلال العملي).
    - المحور الأول هو مؤشر الكيوبت الافتراضي للمقياس الرصدي $\langle Z_i\rangle$ ($124$ كيوبتاً افتراضياً/مقياساً رصدياً)
    - المحور الثاني يُرتِّب قيمة المعامل لـ $\theta$ ($12$ قيمة للمعامل)
2. `pub_result.data.evs_extrapolated`: قيم التوقع لمعاملات الضوضاء المُستقرأة لكل مستقرئ. يحتوي هذا المصفوف على محورين إضافيين.
    - المحور الثالث يُرتِّب أساليب الاستقراء ($2$ مستقرئين، `exponential` و`linear`)
    - المحور الأخير يُرتِّب `extrapolated_noise_factors` ($20$ نقطة استقراء مُحددة في الخيار)
3. `pub_result.data.evs_noise_factors`: قيم التوقع الخام لكل معامل ضوضاء.
   - المحور الثالث يُرتِّب `noise_factors` الخام ($3$ معاملات)

```python
pub_result = primitive_result[0]

print(
    f"{pub_result.data.evs.shape=}\n"
    f"{pub_result.data.evs_extrapolated.shape=}\n"
    f"{pub_result.data.evs_noise_factors.shape=}\n"
)
```

```text
pub_result.data.evs.shape=(153, 12)
pub_result.data.evs_extrapolated.shape=(153, 12, 2, 20)
pub_result.data.evs_noise_factors.shape=(153, 12, 3)
```

تتوفر أيضاً عدة حقول بيانات وصفية في `PrimitiveResult`. تشمل البيانات الوصفية:
- `resilience/zne/noise_factors`: معاملات الضوضاء الخام
- `resilience/zne/extrapolator`: المستقرئون المستخدمون لكل نتيجة

```python
primitive_result.metadata
```

```text
{'dynamical_decoupling': {'enable': True,
  'sequence_type': 'XY4',
  'extra_slack_distribution': 'middle',
  'scheduling_method': 'alap'},
 'twirling': {'enable_gates': True,
  'enable_measure': True,
  'num_randomizations': 700,
  'shots_per_randomization': 64,
  'interleave_randomizations': True,
  'strategy': 'active-circuit'},
 'resilience': {'measure_mitigation': True,
  'zne_mitigation': True,
  'pec_mitigation': False,
  'zne': {'noise_factors': [1.0, 1.3, 1.6],
   'extrapolator': ['exponential', 'linear'],
   'extrapolated_noise_factors': [0.0,
    0.08421052631578947,
    0.16842105263157894,
    0.25263157894736843,
    0.3368421052631579,
    0.42105263157894735,
    0.5052631578947369,
    0.5894736842105263,
    0.6736842105263158,
    0.7578947368421053,
    0.8421052631578947,
    0.9263157894736842,
    1.0105263157894737,
    1.0947368421052632,
    1.1789473684210525,
    1.263157894736842,
    1.3473684210526315,
    1.431578947368421,
    1.5157894736842106,
    1.6]},
  'layer_noise_model': [LayerError(circuit=<qiskit.circuit.quantumcircuit.QuantumCircuit object at 0x168671910>, qubits=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62, 64, 65, 66, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155], error=PauliLindbladError(generators=['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...', ...], rates=[0.00023, 0.00022, 0.00011, 0.00042, 0.0, 0.0, 9e-05, 0.00019, 0.0, 0.0, 0.0, 0.0, 0.00018, 0.0, 0.0, 5e-05, 0.0, 0.0001, 6e-05, 0.00017, 5e-05, 0.0, 0.0, 0.00023, 1e-05, 5e-05, 0.0, 4e-05, 7e-05, 4e-05, 0.00032, 0.0001, 4e-05, 7e-05, 0.00021, 0.00029, 0.00021, 0.00023, 0.00015, 0.00011, 0.0, 7e-05, 1e-05, 4e-05, 0.00014, 0.0, 0.0, 0.00101, 3e-05, 0.0, 0.0, 7e-05, 2e-05, 7e-05, 0.0002, 0.00014, 7e-05, 2e-05, 0.00024, 0.00066, 0.00019, 0.00018, 7e-05, 0.0001, 2e-05, 2e-05, 0.0, 0.0, 7e-05, 0.0, 7e-05, 0.00057, 4e-05, 8e-05, 0.0, 7e-05, 5e-05, 3e-05, 0.00034, 7e-05, 3e-05, 5e-05, 0.00032, 0.00361, 0.00015, 0.00014, 1e-05, 0.00013, 0.0, 0.00012, 0.0, 0.0, 0.0, 0.0, 0.00021, 0.001, 0.0001, 0.0, 0.0, 0.00055, 0.0001, 0.0, 0.00123, 0.0009, 0.0, 0.0001, 0.00127, 0.00392, 0.00031, 2e-05, 0.00036, 0.0, 0.00018, 0.0, 0.0, 0.0, 0.0, 0.00014, 0.0001, 0.0, 0.0005, 0.00023, 0.0, 0.0008, 5e-05, 5e-05, 0.00093, 0.00067, 5e-05, 5e-05, 0.00085, 0.00051, 0.00011, 0.00025, 2e-05, 0.00034, 4e-05, 0.0, 0.0, 0.00019, 6e-05, 0.0, 0.0, 0.00019, 0.0, 8e-05, 0.0, 0.00022, 9e-05, 0.0, 0.00038, 0.00022, 0.0, 9e-05, 0.00037, 7e-05, 0.00038, 0.00025, 6e-05, 0.0, 0.00015, 0.0, 6e-05, 3e-05, 0.0, 0.00012, 0.0, 0.0001, 0.0, 1e-05, 4e-05, 0.00027, 0.00014, 0.0, 0.00029, 0.00016, 0.0, 0.00014, 0.00029, 0.00582, 0.00022, 0.00016, 0.0002, 2e-05, 2e-05, 4e-05, 0.0, 8e-05, 3e-05, 0.0, 0.0, 3e-05, 7e-05, 0.0, 0.00012, 0.00024, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00013, 0.00015, 0.00038, 0.00016, 0.0, 0.0, 0.00036, 0.0, 4e-05, 0.0, 0.00038, 0.0, 4e-05, 1e-05, 0.0006, 0.0, 0.0, 0.0, 0.00011, 2e-05, 0.0, 0.00012, 0.00022, 0.0, 1e-05, 0.0, 0.00029, 0.0, 0.00012, 0.0, 0.0001, 0.00016, 0.00046, 0.00019, 0.0002, 0.0, 0.00047, 0.00017, 0.0, 0.0002, 0.00051, 0.0014, 0.0001, 0.00016, 0.00016, 0.00029, 0.00015, 1e-05, 1e-05, 0.00029, 0.0, 0.00015, 0.0, 0.00032, 0.0, 0.0, 6e-05, 2e-05, 7e-05, 2e-05, 0.00026, 0.0, 2e-05, 0.00015, 6e-05, 2e-05, 7e-05, 0.00027, 1e-05, 3e-05, 5e-05, 0.0, 7e-05, 0.00011, 0.00015, 0.0, 1e-05, 4e-05, 0.00055, 2e-05, 5e-05, 0.0, 0.0002, 5e-05, 8e-05, 2e-05, 0.00109, 0.0, 0.0, 9e-05, 0.00189, 0.0, 0.00012, 1e-05, 0.00181, 0.00017, 0.0, 0.0, 0.00502, 0.0, 8e-05, 0.00019, 0.0, 0.0, 0.00035, 0.0, 0.0, 0.00013, 0.0, 0.00016, 0.00032, 0.0, 1e-05, 2e-05, 0.0, 2e-05, 0.0, 0.00018, 0.0001, 2e-05, 0.00023, 7e-05, 0.0, 9e-05, 0.00011, 2e-05, 0.0001, 0.00031, 0.00045, 4e-05, 2e-05, 0.0001, 0.00036, 0.00028, 0.0002, 0.00056, 6e-05, 0.0, 0.0, 0.00043, 0.0, 0.0, 6e-05, 0.00038, 0.0, 3e-05, 0.0001, 8e-05, 4e-05, 0.00016, 0.00032, 0.00011, 0.00016, 4e-05, 0.00034, 0.00103, 0.00063, 0.00049, 0.00018, 0.00094, 2e-05, 0.00011, 0.0, 0.00047, 0.0001, 0.0, 0.00016, 0.00136, 5e-05, 0.0, 0.0, 0.0, 0.0, 9e-05, 0.00051, 0.0, 0.00018, 9e-05, 0.0, 9e-05, 0.0, 0.0003, 0.00019, 0.0, 0.0, 0.00425, 0.0004, 0.00043, 0.00032, 0.0, 0.0, 0.00016, 0.00183, 0.0, 0.00012, 0.0, 0.00161, 0.00024, 0.0, 0.0, 0.00024, 0.0, 1e-05, 9e-05, 0.0, 0.0, 0.0002, 4e-05, 0.0, 5e-05, 8e-05, 8e-05, 9e-05, 2e-05, 7e-05, 4e-05, 0.00028, 0.0, 0.00011, 0.0, 0.00019, 0.00013, 4e-05, 0.0, 0.00015, 4e-05, 1e-05, 2e-05, 0.00015, 3e-05, 0.0, 0.00028, 0.0, 2e-05, 0.0001, 0.0, 0.0, 3e-05, 0.0001, 0.00011, 1e-05, 0.0, 0.00433, 0.00025, 0.00023, 0.00046, 0.0, 0.0, 6e-05, 9e-05, 0.00013, 0.0, 0.0, 7e-05, 0.0, 0.00018, 7e-05, 0.00026, 0.0, 0.0, 0.0, 5e-05, 7e-05, 0.0, 0.00029, 2e-05, 0.0, 7e-05, 0.00029, 0.00115, 0.00215, 0.00234, 0.00049, 0.00038, 0.0, 0.00012, 0.0, 0.00019, 5e-05, 0.0, 0.0001, 0.00048, 2e-05, 0.0, 0.0, 2e-05, 1e-05, 0.0001, 0.00022, 1e-05, 0.0001, 1e-05, 0.0002, 0.00033, 0.0004, 0.00036, 0.00022, 0.00068, 0.00095, 0.00373, 0.0003, 0.0, 0.0, 0.00056, 0.00014, 0.0, 1e-05, 0.00039, 0.0, 0.0, 0.0005, 0.0, 9e-05, 0.0, 0.0046, 0.00023, 0.00032, 0.00043, 0.0, 8e-05, 0.0, 0.00035, 9e-05, 0.0, 0.0, 0.00025, 0.0, 0.0, 7e-05, 0.00195, 3e-05, 2e-05, 0.0, 0.00043, 0.0, 0.00017, 0.00054, 0.00036, 0.00017, 0.0, 0.00054, 0.00424, 0.00044, 0.00032, 0.00014, 0.00021, 0.0, 4e-05, 0.0, 0.0002, 9e-05, 0.0, 0.0, 0.00019, 2e-05, 0.00014, 0.0, 0.0, 0.00024, 0.0, 0.0, 4e-05, 7e-05, 0.0, 0.0, 0.0, 0.0001, 0.0, 1e-05, 0.0, 0.00017, 0.01108, 0.0, 0.00016, 0.0, 6e-05, 8e-05, 0.0, 0.0003, 0.00016, 0.0, 0.0003, 1e-05, 0.0, 0.00016, 0.0002, 0.00042, 0.00026, 0.00031, 0.0003, 0.0, 0.0, 0.0, 0.00028, 0.00019, 0.0, 0.00018, 0.0, 0.00055, 0.0, 0.0, 0.0, 0.00061, 0.0, 0.0, 0.0, 0.00036, 1e-05, 6e-05, 0.0, 0.00047, 0.00029, 0.0, 6e-05, 0.00019, 5e-05, 6e-05, 0.00042, 5e-05, 4e-05, 3e-05, 0.0, 6e-05, 5e-05, 0.00036, 7e-05, 0.0, 0.00017, 0.0, 0.0005, 0.00035, 0.00031, 4e-05, 3e-05, 0.0, 0.0003, 0.0, 0.0, 2e-05, 0.0, 0.0001, 9e-05, 0.0, 0.00017, 0.0, 7e-05, 7e-05, 0.0001, 0.0, 0.0, 6e-05, 0.00015, 0.0, 0.0, 4e-05, 0.00353, 0.0, 9e-05, 0.0, 7e-05, 2e-05, 0.0, 0.00022, 0.00017, 0.0, 2e-05, 0.0003, 8e-05, 0.00039, 0.00025, 0.00059, 0.00028, 0.0, 0.00016, 0.00013, 0.00014, 0.0, 0.0, 0.00021, 0.00012, 0.0, 0.0, 0.0, 0.00013, 0.00021, 0.00327, 8e-05, 2e-05, 8e-05, 1e-05, 0.0, 0.00011, 3e-05, 0.00022, 0.0, 0.00023, 0.0, 0.0, 0.00022, 0.00017, 0.00053, 0.00072, 0.00068, 4e-05, 0.00028, 0.0, 1e-05, 0.00014, 0.00016, 1e-05, 0.00016, 4e-05, 0.00034, 0.00019, 0.0, 0.0, 0.00185, 0.00013, 0.0, 0.00186, 0.00218, 0.0, 0.00013, 0.00218, 0.00392, 0.00057, 0.00043, 0.00024, 0.00012, 8e-05, 0.0, 0.0, 0.0, 0.0, 3e-05, 8e-05, 0.00053, 0.00016, 3e-05, 0.0, 0.0, 0.0, 7e-05, 5e-05, 1e-05, 5e-05, 0.0001, 5e-05, 0.0, 0.0001, 0.0, 0.0, 0.00101, 0.00112, 0.00422, 1e-05, 0.0, 1e-05, 0.00013, 0.00045, 0.0, 0.0, 0.0, 0.00456, 0.0, 0.0, 0.0, 0.00057, 7e-05, 0.0, 0.00057, 0.00036, 0.0, 7e-05, 0.00036, 0.00175, 0.0005, 0.00055, 0.0004, 0.00032, 0.00016, 0.00094, 0.00041, 0.0, 0.00012, 0.00066, 0.00017, 0.00012, 0.0, 0.00063, 0.00595, 0.00032, 0.00016, 0.00077, 0.00057, 0.0001, 8e-05, 0.0, 0.00079, 0.0, 0.0, 0.00011, 0.00037, 1e-05, 0.00015, 7e-05, 0.00025, 0.00023, 0.00027, 0.00012, 9e-05, 0.0, 0.00046, 0.0, 0.0, 9e-05, 0.00035, 0.00168, 0.00025, 0.00023, 0.0004, 3e-05, 3e-05, 1e-05, 0.0001, 0.00012, 0.0, 0.0001, 1e-05, 0.0, 5e-05, 0.0, 0.00026, 0.0, 1e-05, 9e-05, 0.00031, 9e-05, 0.0, 0.0, 0.0, 9e-05, 1e-05, 0.0002, 0.0, 3e-05, 8e-05, 0.00019, 0.00021, 0.0001, 0.00018, 8e-05, 0.0, 3e-05, 9e-05, 0.00016, 0.0, 9e-05, 9e-05, 0.0, 5e-05, 0.0, 0.0, 5e-05, 5e-05, 0.0, 5e-05, 0.00012, 0.0, 0.00031, 0.0, 0.0, 0.00012, 0.00052, 0.00409, 0.00034, 0.00014, 0.00072, 0.00091, 0.00011, 0.0, 0.00012, 0.00043, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00027, 0.00033, 0.0, 5e-05, 3e-05, 4e-05, 3e-05, 4e-05, 0.0, 0.00023, 3e-05, 5e-05, 0.00041, 0.0, 0.0, 0.00017, 0.00611, 0.00012, 0.00021, 0.00031, 0.0, 6e-05, 0.0, 0.00024, 0.0, 4e-05, 0.00024, 0.00024, 0.00012, 6e-05, 2e-05, 0.00184, 0.00023, 0.0, 2e-05, 0.00029, 0.0, 0.0001, 0.0001, 0.0, 0.0, 0.0, 0.00015, 0.00018, 0.00014, 0.00013, 0.00011, 0.00133, 0.0, 0.00012, 0.0, 0.00087, 0.00011, 0.0, 0.00022, 0.0008, 0.00014, 0.00013, 0.00013, 0.0, 0.0, 0.0, 0.00031, 7e-05, 0.00012, 7e-05, 0.0, 0.00059, 0.0, 0.00024, 1e-05, 0.00042, 0.00029, 0.00017, 0.0, 7e-05, 0.00012, 0.00043, 0.0, 0.0, 0.00015, 6e-05, 0.00012, 7e-05, 0.00031, 0.0, 0.00018, 0.0, 0.0008, 0.00052, 0.00043, 0.00036, 1e-05, 3e-05, 0.0, 0.00027, 0.0, 0.0, 0.0, 0.0, 0.00014, 7e-05, 1e-05, 0.00012, 0.00014, 0.0, 0.0, 0.00012, 0.0, 9e-05, 0.00047, 0.0, 9e-05, 0.0, 0.00027, 0.00046, 0.00027, 0.0002, 0.00015, 0.00022, 0.0, 8e-05, 0.00019, 0.00017, 8e-05, 0.0, 1e-05, 0.00048, 1e-05, 0.00028, 0.0, 0.00141, 0.0, 0.0, 0.00025, 0.00016, 4e-05, 0.00208, 0.00073, 0.0, 0.00025, 0.00014, 4e-05, 0.00016, 0.00174, 0.00053, 0.0002, 0.0, 0.0, 0.00049, 0.00026, 0.00026, 0.0, 0.00011, 0.0, 0.00018, 1e-05, 0.00016, 0.0, 0.00011, 0.00023, 0.00016, 0.00062, 1e-05, 0.00037, 0.0001, 6e-05, 0.00045, 0.00017, 6e-05, 0.0001, 0.00042, 0.00058, 0.00027, 0.0003, 0.00049, 0.0002, 0.0, 4e-05, 0.0, 4e-05, 1e-05, 3e-05, 5e-05, 0.00089, 0.0, 0.0, 4e-05, 0.0, 0.0, 0.00014, 0.0, 0.0, 9e-05, 0.00027, 0.0, 0.0002, 0.0, 0.0, 9e-05, 0.0, 0.00021, 0.00014, 0.0, 3e-05, 0.0, 0.00024, 0.00013, 0.0003, 0.00016, 3e-05, 0.0, 0.0, 0.00031, 6e-05, 2e-05, 0.0, 0.00039, 5e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00159, 0.00012, 3e-05, 0.00026, 0.00087, 0.0, 1e-05, 9e-05, 0.00077, 0.00015, 0.0, 0.00018, 0.00094, 0.0, 0.0002, 0.0004, 0.00028, 0.0, 0.0, 0.00028, 0.0, 0.0, 0.0, 0.0002, 0.0, 0.0, 0.00033, 0.0, 0.0, 3e-05, 0.00015, 0.00028, 0.00028, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00044, 0.0, 0.00011, 0.00022, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00156, 0.00155, 0.0, 0.00038, 0.0, 0.0, 5e-05, 1e-05, 0.00014, 0.0, 7e-05, 0.00028, 8e-05, 0.0, 0.00011, 0.00023, 0.0, 0.00013, 0.0, 0.00019, 7e-05, 0.0, 3e-05, 0.00056, 0.0, 4e-05, 0.0, 0.00053, 0.00021, 0.00034, 0.00053, 0.00058, 0.00034, 0.00021, 0.00058, 0.00102, 1e-05, 0.00014, 0.00102, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00037, 0.00037, 0.00021, 0.00012, 5e-05, 0.0, 0.00037, 0.0, 0.0, 5e-05, 0.00024, 0.00028, 0.00037, 0.00037, 0.00013, 0.00022, 0.00011, 1e-05, 0.0, 0.00021, 0.0, 0.0, 0.00011, 0.00013, 8e-05, 0.0, 1e-05, 0.00029, 0.0, 8e-05, 0.0, 0.0, 0.0001, 0.00043, 0.00018, 5e-05, 9e-05, 3e-05, 0.0001, 0.0, 0.00041, 0.00012, 0.0, 0.0001, 9e-05, 0.00035, 0.00032, 0.00027, 0.00059, 1e-05, 6e-05, 0.0, 0.00024, 6e-05, 0.0, 0.0001, 0.00036, 0.0, 0.0, 0.0001, 0.00013, 0.0, 0.0, 0.00016, 0.00012, 3e-05, 7e-05, 0.0, 0.00011, 6e-05, 5e-05, 5e-05, 0.00058, 0.0, 8e-05, 0.0, 0.0004, 2e-05, 1e-05, 0.0001, 0.00043, 0.00011, 0.0, 0.0, 0.00031, 0.0, 3e-05, 0.00032, 0.0, 0.0, 1e-05, 0.0002, 3e-05, 0.0, 0.00023, 0.0, 0.0, 0.0, 0.0, 0.00037, 0.00028, 3e-05, 0.0, 0.0, 1e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00091, 0.0, 3e-05, 8e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00102, 0.00091, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00351, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.42262, 0.0, 0.19471, 0.0, 0.8064, 0.0, 0.57953, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.72255, 0.0, 0.61733, 0.56765, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.25836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.26103, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.48452, 0.00018, 7e-05, 0.0, 2e-05, 6e-05, 0.0, 0.0002, 0.0, 0.00056, 0.0, 5e-05, 0.0, 0.00025, 3e-05, 0.0, 0.0003, 8e-05, 0.0, 3e-05, 0.00014, 0.00024, 0.00042, 0.0003, 6e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.28441, 0.0, 0.0, 0.0, 0.07122, 0.0, 0.0, 0.0, 0.36139, 0.0, 0.0, 0.0, 0.00067, 0.00072, 0.00012, 0.00431, 0.0, 0.0, 0.00505, 0.0, 0.0, 0.0004, 0.00379, 0.0, 0.0, 0.00437, 0.0, 0.0, 0.00017, 0.00169, 0.00027, 0.00025, 0.0005, 2e-05, 0.00016, 0.0, 0.00051, 0.0, 0.0, 0.00014, 0.0, 0.0, 0.00015, 0.0002, 0.0, 0.00034, 0.00027, 0.0, 8e-05, 0.00016, 0.0, 6e-05, 0.0, 0.0001, 1e-05, 0.00015, 0.0, 8e-05, 0.0, 2e-05, 0.00013, 8e-05, 0.0, 0.0, 0.00014, 0.0, 0.0, 2e-05, 0.00053, 0.0, 0.0, 5e-05, 0.0, 5e-05, 0.0, 0.00013, 4e-05, 0.0, 0.00037, 0.0, 0.0, 6e-05, 0.00011, 0.0, 4e-05, 0.00034, 0.0, 0.0, 0.0, 0.00015, 0.00021, 0.00017, 0.00036, 0.00015, 6e-05, 7e-05, 9e-05, 0.0, 1e-05, 6e-05, 0.0, 0.0, 0.00011, 0.00012, 5e-05, 0.00059, 4e-05, 0.00029, 0.00059, 0.00055, 0.00029, 4e-05, 0.00055, 0.00048, 0.00037, 7e-05, 0.00039, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.35497, 0.10255, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.00343, 0.0, 0.0, 1.00343, 0.0, 0.0, 0.0, 0.0, 1.79398, 0.45751, 0.0, 2.48969, 0.0, 0.0, 0.0, 0.0, 0.2536, 0.0, 0.0, 0.0, 0.58887, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00105, 0.0, 0.0, 0.0, 0.00092, 0.0, 0.0, 0.0, 0.00212, 0.0, 0.0, 0.0, 0.00064, 0.00028, 0.00014, 0.00065, 0.0004, 0.00014, 0.00028, 0.0004, 0.00087, 0.00041, 0.00017, 0.00044, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.14893, 0.0, 0.0, 0.0, 0.56032, 0.0, 0.0, 0.0, 0.0, 0.00051, 0.00048, 0.0, 0.0, 0.00048, 0.00051, 0.0, 0.0, 0.00105, 0.00092, 0.00045, 0.00023, 0.0001, 0.0, 0.00031, 6e-05, 3e-05, 0.00011, 0.00021, 0.0, 0.00012, 3e-05, 8e-05, 8e-05, 3e-05, 2e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00172, 0.00023, 0.0002, 0.00015, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.65411, 0.0, 0.0, 0.83803, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.58306, 0.0, 0.42915, 0.0, 0.0, 0.0, 0.0, 0.0, 1.86157, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.51166, 0.0, 0.0, 0.0, 0.0, 0.0, 0.51166, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.01221, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0006, 0.0, 0.0, 0.0, 0.00052, 0.0, 0.0, 0.0, 0.0015, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.14893, 0.03192, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0025, 0.0, 0.0, 0.0, 0.00182, 0.0, 0.0, 0.00032, 0.00263, 0.0, 0.0, 0.00024, 0.00736, 0.0, 0.0, 0.0, 2e-05, 0.0, 0.0, 0.0, 0.0, 0.00015, 2e-05, 6e-05, 0.0, 0.0, 0.0, 0.00015, 0.0, 6e-05, 0.00366, 0.0, 0.0, 0.0, 0.00213, 0.00288, 0.0]))),
   LayerError(circuit=<qiskit.circuit.quantumcircuit.QuantumCircuit object at 0x169b1da90>, qubits=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62, 64, 65, 66, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155], error=PauliLindbladError(generators=['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...', ...], rates=[0.00023, 0.00024, 0.0002, 0.00015, 2e-05, 0.0, 0.00017, 0.00014, 0.0, 2e-05, 0.00019, 9e-05, 0.00023, 0.00024, 3e-05, 0.00012, 2e-05, 0.0, 0.0, 0.0002, 0.0, 4e-05, 0.0, 0.0001, 0.0, 2e-05, 0.0, 0.00023, 9e-05, 0.0, 0.0, 0.00029, 0.0, 1e-05, 3e-05, 0.00029, 0.0, 4e-05, 2e-05, 0.0002, 0.00012, 0.0, 0.0, 0.00022, 0.0, 0.0, 0.0001, 0.00036, 5e-05, 2e-05, 3e-05, 0.00012, 7e-05, 0.0, 0.0, 7e-05, 0.0, 0.0001, 0.0, 0.0057, 0.0, 0.0, 3e-05, 0.0001, 0.00012, 0.0, 0.00014, 0.00014, 0.0, 0.00012, 0.00019, 0.00049, 0.00019, 0.00017, 0.0, 0.00021, 4e-05, 5e-05, 0.00013, 0.00018, 0.0, 0.0, 0.0, 0.00523, 0.0, 0.0, 0.00013, 1e-05, 0.00014, 0.0, 0.00028, 0.0, 0.0, 0.00014, 0.00019, 3e-05, 0.00057, 0.0002, 0.00052, 0.00144, 0.0, 0.0, 5e-05, 0.00099, 0.00028, 1e-05, 2e-05, 0.00158, 0.0, 0.00018, 0.0, 0.00018, 5e-05, 6e-05, 1e-05, 3e-05, 0.0, 3e-05, 0.00014, 0.00034, 0.0, 0.0, 0.00019, 0.00023, 0.0, 3e-05, 0.0, 0.0, 1e-05, 6e-05, 0.0, 0.00103, 0.0, 0.0, 0.00012, 0.00045, 0.0, 5e-05, 0.0, 0.00037, 2e-05, 0.0, 5e-05, 0.00014, 4e-05, 0.0, 0.0, 0.0, 0.00011, 0.0, 8e-05, 6e-05, 6e-05, 2e-05, 0.0, 0.00071, 0.0, 5e-05, 0.0, 0.0001, 0.00012, 0.0, 0.00021, 0.00016, 0.0, 0.00012, 0.00031, 2e-05, 0.00019, 0.00014, 0.00021, 0.00014, 0.00011, 0.0, 9e-05, 0.00012, 0.0, 0.00011, 0.0, 0.00018, 0.0, 3e-05, 0.0, 9e-05, 6e-05, 0.0, 0.00015, 0.00025, 0.0, 6e-05, 0.00025, 0.00037, 0.00049, 0.00035, 0.0001, 0.0, 2e-05, 0.0, 0.00014, 0.0002, 0.0, 2e-05, 0.0, 0.00022, 0.00012, 0.0, 6e-05, 0.00024, 1e-05, 0.00015, 0.00043, 0.00018, 0.00015, 1e-05, 0.00042, 0.00048, 0.00031, 0.00013, 0.0002, 0.00038, 3e-05, 7e-05, 3e-05, 0.00033, 0.0, 9e-05, 0.0, 0.00011, 0.0, 0.0, 5e-05, 8e-05, 0.00039, 0.00046, 0.0
```
 'version': 2}
```

يحتوي كائن `PubResult` على بيانات وصفية إضافية تتعلق بالصمود لنماذج الضوضاء المُتعلَّمة المستخدمة في التخفيف.

```python
# Print learned layer noise metadata
for field, value in pub_result.metadata["resilience"]["layer_noise"].items():
    print(f"{field}: {value}")
```

```text
noise_overhead: Infinity
total_mitigated_layers: 18
unique_mitigated_layers: 3
unique_mitigated_layers_noise_overhead: [1.4100369479435003e+44, 3.407263868699073e+112, 3.500660129782563e+37]
```

```python
# Exact data computed using the methods described in the original reference
# Y. Kim et al. "Evidence for the utility of quantum computing before fault tolerance" (Nature 618, 500–505 (2023))
# Directly used here for brevity
exact_data = np.array(
    [
        1,
        0.9899,
        0.9531,
        0.8809,
        0.7536,
        0.5677,
        0.3545,
        0.1607,
        0.0539,
        0.0103,
        0.0012,
        0.0,
    ]
)
```

### رسم نتائج محاكاة Trotter

الكود التالي ينشئ رسماً بيانياً لمقارنة النتائج الخام والمُخففة للتجربة بالحل الدقيق.

```python
"""Result visualization functions"""

def plot_trotter_results(
    pub_result: PubResult,
    angles: Sequence[float],
    plot_noise_factors: Sequence[float] | None = None,
    plot_extrapolator: Sequence[str] | None = None,
    exact: np.ndarray = None,
    close: bool = True,
):
    """Plot average magnetization from ZNE result data.
    Args:
        pub_result: The Estimator PubResult for the PEA experiment.
        angles: The Rx angle values for the experiment.
        plot_raw: If provided plot the unextrapolated data for the noise factors.
        plot_extrapolator: If provided plot all extrapolators, if False only plot
            the Automatic method.
        exact: Optional, the exact values to include in the plot. Should be a 1D
            array-like where the values represent exact magnetization.
        close: Close the Matplotlib figure before returning.
    Returns:
        The figure.
    """
    data = pub_result.data

    evs = data.evs
    num_qubits = evs.shape[0]
    num_params = evs.shape[1]
    angles = np.asarray(angles).ravel()
    if angles.shape != (num_params,):
        raise ValueError(
            f"Incorrect number of angles for input data {angles.size} != {num_params}"
        )

    # Take average magnetization of qubits and its standard error
    x_vals = angles / np.pi
    y_vals = np.mean(evs, axis=0)
    y_errs = np.std(evs, axis=0) / np.sqrt(num_qubits)

    fig, _ = plt.subplots(1, 1)

    # Plot auto method
    plt.errorbar(x_vals, y_vals, y_errs, fmt="o-", label="ZNE (automatic)")

    # Plot individual extrapolator results
    if plot_extrapolator:
        y_vals_extrap = np.mean(data.evs_extrapolated, axis=0)
        y_errs_extrap = np.std(data.evs_extrapolated, axis=0) / np.sqrt(
            num_qubits
        )
        for i, extrap in enumerate(plot_extrapolator):
            plt.errorbar(
                x_vals,
                y_vals_extrap[:, i, 0],
                y_errs_extrap[:, i, 0],
                fmt="s-.",
                alpha=0.5,
                label=f"ZNE ({extrap})",
            )

    # Plot raw results
    if plot_noise_factors:
        y_vals_raw = np.mean(data.evs_noise_factors, axis=0)
        y_errs_raw = np.std(data.evs_noise_factors, axis=0) / np.sqrt(
            num_qubits
        )
        for i, nf in enumerate(plot_noise_factors):
            plt.errorbar(
                x_vals,
                y_vals_raw[:, i],
                y_errs_raw[:, i],
                fmt="d:",
                alpha=0.5,
                label=f"Raw (nf={nf:.1f})",
            )

    # Plot exact data
    if exact is not None:
        plt.plot(x_vals, exact, "--", color="black", alpha=0.5, label="Exact")

    plt.ylim(-0.1, 1.2)
    plt.xlabel("θ/π")
    plt.ylabel(r"$\overline{\langle Z \rangle}$")
    plt.legend()
    plt.title(
        f"Error Mitigated Average Magnetization for Rx(θ) [{num_qubits}-qubit]"
    )
    if close:
        plt.close(fig)
    return fig
```

```python
zne_metadata = primitive_result.metadata["resilience"]["zne"]
# Plot Trotter simulation results
fig = plot_trotter_results(
    pub_result,
    parameter_values,
    plot_extrapolator=zne_metadata["extrapolator"],
    plot_noise_factors=zne_metadata["noise_factors"],
    exact=exact_data,
)
display(fig)
```

![Output of the previous code cell](/docs/images/tutorials/probabilistic-error-amplification/extracted-outputs/2e0f0e84-32ba-4655-91c1-8445016bbeb2-0.avif)

بينما تُظهر القيم الصاخبة (معامل الضوضاء `nf=1.0`) انحرافاً كبيراً عن القيم الدقيقة، فإن القيم المُخففة قريبة من القيم الدقيقة، مما يُثبت فائدة أسلوب التخفيف المستند إلى PEA.
### رسم نتائج الاستقراء لكيوبتات فردية

أخيراً، الكود التالي ينشئ رسماً بيانياً يعرض منحنيات الاستقراء لقيم مختلفة من theta على كيوبت محدد.

```python
def plot_qubit_zne_data(
    pub_result: PubResult,
    angles: Sequence[float],
    qubit: int,
    noise_factors: Sequence[float],
    extrapolator: Sequence[str] | None = None,
    extrapolated_noise_factors: Sequence[float] | None = None,
    num_cols: int | None = None,
    close: bool = True,
):
    """Plot ZNE extrapolation data for specific virtual qubit
    Args:
        pub_result: The Estimator PubResult for the PEA experiment.
        angles: The Rx theta angles used for the experiment.
        qubit: The virtual qubit index to plot.
        noise_factors: the raw noise factors.
        extrapolator: The extrapolator metadata for multiple extrapolators.
        extrapolated_noise_factors: The noise factors used for extrapolation.
        num_cols: The number of columns for the generated subplots.
        close: Close the Matplotlib figure before returning.
    Returns:
        The Matplotlib figure.
    """
    data = pub_result.data

    evs_auto = data.evs[qubit]
    stds_auto = data.stds[qubit]
    evs_extrap = data.evs_extrapolated[qubit]
    stds_extrap = data.stds_extrapolated[qubit]
    evs_raw = data.evs_noise_factors[qubit]
    stds_raw = data.stds_noise_factors[qubit]

    num_params = evs_auto.shape[0]
    angles = np.asarray(angles).ravel()
    if angles.shape != (num_params,):
        raise ValueError(
            f"Incorrect number of angles for input data {angles.size} != {num_params}"
        )

    # Make a square subplot
    num_cols = num_cols or int(np.ceil(np.sqrt(num_params)))
    num_rows = int(np.ceil(num_params / num_cols))
    fig, axes = plt.subplots(
        num_rows, num_cols, sharex=True, sharey=True, figsize=(12, 5)
    )
    fig.suptitle(f"ZNE data for virtual qubit {qubit}")

    for pidx, ax in zip(range(num_params), axes.flat):
        # Plot auto extrapolated
        ax.errorbar(
            0,
            evs_auto[pidx],
            stds_auto[pidx],
            fmt="o",
            label="PEA (automatic)",
        )

        # Plot extrapolators
        if (
            extrapolator is not None
            and extrapolated_noise_factors is not None
        ):
            for i, method in enumerate(extrapolator):
                ax.errorbar(
                    extrapolated_noise_factors,
                    evs_extrap[pidx, i],
                    stds_extrap[pidx, i],
                    fmt="-",
                    alpha=0.5,
                    label=f"PEA ({method})",
                )

        # Plot raw
        ax.errorbar(
            noise_factors, evs_raw[pidx], stds_raw[pidx], fmt="d", label="Raw"
        )

        ax.set_yticks([0, 0.5, 1, 1.5, 2])
        ax.set_ylim(0, max(1, 1.1 * max(evs_auto)))

        ax.set_xticks([0, *noise_factors])
        ax.set_title(f"θ/π = {angles[pidx]/np.pi:.2f}")
        if pidx == 0:
            ax.set_ylabel(r"$\langle Z_{" + str(qubit) + r"} \rangle$")
        if pidx == num_params - 1:
            ax.set_xlabel("Noise Factor")
            ax.legend()
    if close:
        plt.close(fig)
    return fig
```

```python
virtual_qubit = 1
plot_qubit_zne_data(
    pub_result=pub_result,
    angles=parameter_values,
    qubit=virtual_qubit,
    noise_factors=zne_metadata["noise_factors"],
    extrapolator=zne_metadata["extrapolator"],
    extrapolated_noise_factors=zne_metadata["extrapolated_noise_factors"],
)
```

![Output of the previous code cell](/docs/images/tutorials/probabilistic-error-amplification/extracted-outputs/6948475c-bc15-493f-8af9-f8e66d0e467c-0.avif)

## استطلاع حول البرنامج التعليمي

يُرجى المشاركة في هذا الاستطلاع القصير لتقديم ملاحظاتك حول هذا البرنامج التعليمي. ستساعدنا ملاحظاتك في تحسين محتوانا التعليمي وتجربة المستخدم.

### رسم نتائج الاستقراء للكيوبتات الفردية

أخيرًا، يُنشئ الكود التالي رسمًا بيانيًا يعرض منحنيات الاستقراء لقيم مختلفة من theta على كيوبت محدد.

```python
def plot_qubit_zne_data(
    pub_result: PubResult,
    angles: Sequence[float],
    qubit: int,
    noise_factors: Sequence[float],
    extrapolator: Sequence[str] | None = None,
    extrapolated_noise_factors: Sequence[float] | None = None,
    num_cols: int | None = None,
    close: bool = True,
):
    """Plot ZNE extrapolation data for specific virtual qubit
    Args:
        pub_result: The Estimator PubResult for the PEA experiment.
        angles: The Rx theta angles used for the experiment.
        qubit: The virtual qubit index to plot.
        noise_factors: the raw noise factors.
        extrapolator: The extrapolator metadata for multiple extrapolators.
        extrapolated_noise_factors: The noise factors used for extrapolation.
        num_cols: The number of columns for the generated subplots.
        close: Close the Matplotlib figure before returning.
    Returns:
        The Matplotlib figure.
    """
    data = pub_result.data

    evs_auto = data.evs[qubit]
    stds_auto = data.stds[qubit]
    evs_extrap = data.evs_extrapolated[qubit]
    stds_extrap = data.stds_extrapolated[qubit]
    evs_raw = data.evs_noise_factors[qubit]
    stds_raw = data.stds_noise_factors[qubit]

    num_params = evs_auto.shape[0]
    angles = np.asarray(angles).ravel()
    if angles.shape != (num_params,):
        raise ValueError(
            f"Incorrect number of angles for input data {angles.size} != {num_params}"
        )

    # Make a square subplot
    num_cols = num_cols or int(np.ceil(np.sqrt(num_params)))
    num_rows = int(np.ceil(num_params / num_cols))
    fig, axes = plt.subplots(
        num_rows, num_cols, sharex=True, sharey=True, figsize=(12, 5)
    )
    fig.suptitle(f"ZNE data for virtual qubit {qubit}")

    for pidx, ax in zip(range(num_params), axes.flat):
        # Plot auto extrapolated
        ax.errorbar(
            0,
            evs_auto[pidx],
            stds_auto[pidx],
            fmt="o",
            label="PEA (automatic)",
        )

        # Plot extrapolators
        if (
            extrapolator is not None
            and extrapolated_noise_factors is not None
        ):
            for i, method in enumerate(extrapolator):
                ax.errorbar(
                    extrapolated_noise_factors,
                    evs_extrap[pidx, i],
                    stds_extrap[pidx, i],
                    fmt="-",
                    alpha=0.5,
                    label=f"PEA ({method})",
                )

        # Plot raw
        ax.errorbar(
            noise_factors, evs_raw[pidx], stds_raw[pidx], fmt="d", label="Raw"
        )

        ax.set_yticks([0, 0.5, 1, 1.5, 2])
        ax.set_ylim(0, max(1, 1.1 * max(evs_auto)))

        ax.set_xticks([0, *noise_factors])
        ax.set_title(f"θ/π = {angles[pidx]/np.pi:.2f}")
        if pidx == 0:
            ax.set_ylabel(r"$\langle Z_{" + str(qubit) + r"} \rangle$")
        if pidx == num_params - 1:
            ax.set_xlabel("Noise Factor")
            ax.legend()
    if close:
        plt.close(fig)
    return fig
```

```python
virtual_qubit = 1
plot_qubit_zne_data(
    pub_result=pub_result,
    angles=parameter_values,
    qubit=virtual_qubit,
    noise_factors=zne_metadata["noise_factors"],
    extrapolator=zne_metadata["extrapolator"],
    extrapolated_noise_factors=zne_metadata["extrapolated_noise_factors"],
)
```

![Output of the previous code cell](/docs/images/tutorials/probabilistic-error-amplification/extracted-outputs/6948475c-bc15-493f-8af9-f8e66d0e467c-0.avif)

## استبيان البرنامج التعليمي

يُرجى الإجابة على هذا الاستبيان القصير لتقديم ملاحظاتك حول هذا البرنامج التعليمي. ستساعدنا آراؤك في تحسين محتوانا وتجربة المستخدم.
