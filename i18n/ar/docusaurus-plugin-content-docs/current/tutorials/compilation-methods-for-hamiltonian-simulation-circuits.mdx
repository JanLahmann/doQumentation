---
title: "أساليب التحويل البرمجي لدوائر محاكاة هاميلتونيان"
sidebar_label: "أساليب التحويل البرمجي لدوائر محاكاة هاميلتونيان"
description: "يقدم هذا البرنامج التعليمي نظرة مقارنة شاملة لثلاثة أساليب للتحويل البرمجي في Qiskit لأعباء عمل محاكاة هاميلتونيان."
notebook_path: "docs/tutorials/compilation-methods-for-hamiltonian-simulation-circuits.ipynb"
---
{/* doqumentation-source-hash: ff66bde1 */}

<OpenInLabBanner notebookPath="docs/tutorials/compilation-methods-for-hamiltonian-simulation-circuits.ipynb" />



الاستخدام التقديري لـ QPU: لم يُنفَّذ أي كود في هذا البرنامج التعليمي لأنه يركز على عملية التحويل البرمجي (transpilation).

{/* cspell:ignore Rustiq, nshuffles, edgecolors, edgecolor, Hamlib, Benchpress, Brugière, Goubault, Martiel, Dubal, Lishman, Ivrii, fontweight, fontsize, textprops, wedgeprops, startangle, autopct */}
## الخلفية {#background}

يُعدّ التحويل البرمجي للدوائر الكمومية خطوةً محوريةً في سير عمل الحوسبة الكمومية. تتضمن هذه الخطوة تحويل خوارزمية كمومية عالية المستوى إلى دائرة كمومية مادية تلتزم بقيود الأجهزة الكمومية المستهدفة. يمكن للتحويل البرمجي الفعّال أن يؤثر تأثيراً كبيراً في أداء الخوارزميات الكمومية من خلال تقليص عمق الدائرة، وعدد البوابات، ووقت التنفيذ. يستكشف هذا البرنامج التعليمي ثلاثة مناهج مختلفة للتحويل البرمجي للدوائر الكمومية في Qiskit، ويعرض نقاط قوة كل منها وتطبيقاته من خلال أمثلة عملية.

يهدف هذا البرنامج التعليمي إلى تعليم المستخدمين كيفية تطبيق وتقييم ثلاثة أساليب للتحويل البرمجي في Qiskit: محوّل SABRE، ومحوّل الذكاء الاصطناعي، وإضافة Rustiq. سيتعلم المستخدمون كيفية استخدام كل أسلوب بفعالية، وكيفية قياس أدائه عبر دوائر كمومية مختلفة. بنهاية هذا البرنامج التعليمي، سيكون المستخدمون قادرين على اختيار استراتيجيات التحويل البرمجي وتخصيصها بناءً على أهداف تحسين محددة، كتقليل عمق الدائرة، أو تقليص عدد البوابات، أو تحسين وقت التشغيل.

### ما ستتعلمه {#what-you-will-learn}
- **كيفية استخدام محوّل Qiskit مع SABRE لتحسين التخطيط والتوجيه.**
- **كيفية الاستفادة من محوّل الذكاء الاصطناعي لتحسين الدوائر بشكل متقدم وآلي.**
- **كيفية توظيف إضافة Rustiq للدوائر التي تستلزم تركيباً دقيقاً للعمليات، ولا سيما في مهام محاكاة هاميلتونيان.**

يستخدم هذا البرنامج التعليمي ثلاث دوائر نموذجية وفق سير عمل [أنماط Qiskit](/guides/intro-to-patterns) لتوضيح أداء كل أسلوب من أساليب التحويل البرمجي. بنهاية هذا البرنامج التعليمي، سيكون المستخدمون مؤهلين لاختيار استراتيجية التحويل البرمجي المناسبة بناءً على متطلباتهم وقيودهم الخاصة.

### نظرة عامة على أساليب التحويل البرمجي {#compilation-methods-overview}

#### 1. **محوّل Qiskit مع SABRE** {#1-qiskit-transpiler-with-sabre}
يستخدم محوّل Qiskit خوارزمية SABRE (البحث الاستدلالي ثنائي الاتجاه المبني على SWAP) لتحسين تخطيط الدائرة وتوجيهها. تركز SABRE على تقليل بوابات SWAP وتأثيرها على عمق الدائرة مع الالتزام بقيود الاتصالية في الأجهزة. هذا الأسلوب متعدد الاستخدامات ومناسب لتحسين الدوائر ذات الأغراض العامة، إذ يوفر توازناً بين الأداء ووقت الحساب. للاستفادة من أحدث التحسينات في SABRE، المفصّلة في [\[1\]](https://arxiv.org/abs/2409.08368)، يمكنك زيادة عدد المحاولات (على سبيل المثال، `layout_trials=400, swap_trials=400`). لأغراض هذا البرنامج التعليمي، سنستخدم القيم الافتراضية لعدد المحاولات للمقارنة مع محوّل Qiskit الافتراضي. تُغطى مزايا SABRE واستكشاف معاملاتها في [برنامج تعليمي متعمق مستقل](/tutorials/transpilation-optimizations-with-sabre).

#### 2. **محوّل الذكاء الاصطناعي** {#2-ai-transpiler}

يستخدم محوّل الذكاء الاصطناعي في Qiskit التعلم الآلي للتنبؤ بأمثل استراتيجيات التحويل البرمجي، وذلك بتحليل الأنماط في بنية الدائرة وقيود الأجهزة لاختيار أفضل تسلسل من التحسينات لمدخل معين. هذا الأسلوب فعّال بشكل خاص للدوائر الكمومية واسعة النطاق، ويتسم بدرجة عالية من الأتمتة والقدرة على التكيف مع أنواع متنوعة من المسائل. إضافةً إلى تحسين الدوائر العام، يمكن استخدام محوّل الذكاء الاصطناعي مع مرحلة `AIPauliNetworkSynthesis`، التي تستهدف دوائر شبكة Pauli — وهي كتل مكوّنة من بوابات H وS وSX وCX وRX وRY وRZ — وتُطبّق منهجية تركيب مبنية على التعلم المعزز. لمزيد من المعلومات حول محوّل الذكاء الاصطناعي واستراتيجيات التركيب الخاصة به، راجع [\[2\]](https://arxiv.org/abs/2405.13196) و[\[3\]](https://arxiv.org/abs/2503.14448).

#### 3. **إضافة Rustiq** {#3-rustiq-plugin}
تُدخل إضافة Rustiq تقنيات تركيب متقدمة خاصةً بعمليات `PauliEvolutionGate`، التي تمثّل تدويرات Pauli المستخدمة على نطاق واسع في ديناميكيات Trotter. هذه الإضافة ذات قيمة للدوائر التي تنفّذ محاكاة هاميلتونيان، كتلك المستخدمة في مسائل الكيمياء الكمومية والفيزياء، حيث تُعدّ تدويرات Pauli الدقيقة ضرورية لمحاكاة هاميلتونيانات المسائل بفعالية. تتميز Rustiq بتركيب دوائر دقيق وذو عمق منخفض لهذه العمليات المتخصصة. لمزيد من التفاصيل حول تنفيذ Rustiq وأدائها، يُرجى الرجوع إلى [\[4\]](https://arxiv.org/abs/2404.03280).

من خلال الاستكشاف المعمّق لأساليب التحويل البرمجي هذه، يزوّد هذا البرنامج التعليمي المستخدمين بالأدوات اللازمة لتحسين أداء دوائرهم الكمومية، مما يمهّد الطريق نحو حوسبة كمومية أكثر كفاءةً وقابليةً للتطبيق.
## المتطلبات {#requirements}

قبل البدء بهذا البرنامج التعليمي، تأكد من تثبيت المكونات التالية:
- Qiskit SDK الإصدار 1.3 أو أحدث، مع دعم [التصور المرئي](https://docs.quantum.ibm.com/api/qiskit/visualization)
- Qiskit Runtime الإصدار 0.28 أو أحدث (`pip install qiskit-ibm-runtime`)
- Qiskit IBM Transpiler (`pip install qiskit-ibm-transpiler`)
- وضع Qiskit AI Transpiler المحلي (`pip install qiskit_ibm_ai_local_transpiler`)
- مكتبة الرسوم البيانية Networkx (`pip install networkx`)
## الإعداد {#setup}

```python
# Added by doQumentation — installs packages not in the Binder environment
%pip install -q qiskit-ibm-transpiler
```

```python
from qiskit.circuit import QuantumCircuit
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit.circuit.library import (
    efficient_su2,
    PauliEvolutionGate,
)
from qiskit_ibm_transpiler import generate_ai_pass_manager
from qiskit.quantum_info import SparsePauliOp
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit.transpiler.passes.synthesis.high_level_synthesis import HLSConfig
from collections import Counter
from IPython.display import display
import time
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import json
import requests
import logging

# Suppress noisy loggers
logging.getLogger(
    "qiskit_ibm_transpiler.wrappers.ai_local_synthesis"
).setLevel(logging.ERROR)

seed = 42  # Seed for reproducibility
```

## الجزء الأول: دائرة SU2 الفعّالة {#part-1-efficient-su2-circuit}

### الخطوة الأولى: تعيين المدخلات الكلاسيكية إلى مسألة كمومية {#step-1-map-classical-inputs-to-a-quantum-problem}

في هذا القسم، نستكشف دائرة `efficient_su2`، وهي نموذج ansatz فعّال على مستوى الأجهزة يُستخدم على نطاق واسع في الخوارزميات الكمومية التنويعية (كـ VQE) ومهام التعلم الآلي الكمومي. تتألف الدائرة من طبقات متناوبة من تدويرات أحادية الكيوبت وبوابات التشابك مرتّبة في نمط دائري، مُصمَّمة لاستكشاف فضاء الحالة الكمومية بفعالية مع الحفاظ على عمق قابل للإدارة.

سنبدأ ببناء دائرة `efficient_su2` واحدة لتوضيح كيفية مقارنة أساليب التحويل البرمجي المختلفة. بعد الجزء الأول، سنوسّع تحليلنا ليشمل مجموعةً أكبر من الدوائر، مما يُتيح إجراء اختبار مرجعي شامل لتقييم أداء أساليب التحويل البرمجي المتنوعة.

```python
qubit_size = list(range(10, 101, 10))
qc_su2_list = [
    efficient_su2(n, entanglement="circular", reps=1)
    .decompose()
    .copy(name=f"SU2_{n}")
    for n in qubit_size
]

# Draw the first circuit
qc_su2_list[0].draw(output="mpl")
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/f362cdac-94d8-4cc5-85f4-015c3d9eba3a-0.avif)

### الخطوة الثانية: تحسين المسألة لتنفيذها على الأجهزة الكمومية {#step-2-optimize-problem-for-quantum-hardware-execution}

تُشكّل هذه الخطوة المحور الرئيسي للبرنامج التعليمي. هنا، نسعى إلى تحسين الدوائر الكمومية لتنفيذها بكفاءة على الأجهزة الكمومية الحقيقية. هدفنا الأساسي هو تقليل عمق الدائرة وعدد البوابات، وهما عاملان رئيسيان في تحسين دقة التنفيذ والتخفيف من الضوضاء في الأجهزة.

- **محوّل SABRE**: يستخدم محوّل Qiskit الافتراضي مع خوارزمية SABRE للتخطيط والتوجيه.
- **محوّل الذكاء الاصطناعي (الوضع المحلي)**: المحوّل القياسي المدعوم بالذكاء الاصطناعي باستخدام الاستنتاج المحلي واستراتيجية التركيب الافتراضية.
- **إضافة Rustiq**: إضافة محوّل مُصمَّمة للتحويل البرمجي ذي العمق المنخفض، مُكيَّفة لمهام محاكاة هاميلتونيان.

الهدف من هذه الخطوة هو مقارنة نتائج هذه الأساليب من حيث عمق الدائرة المُحوَّلة وعدد بواباتها. مقياس مهم آخر نأخذه في الاعتبار هو وقت تشغيل التحويل البرمجي. بتحليل هذه المقاييس، يمكننا تقييم نقاط القوة النسبية لكل أسلوب وتحديد أيها ينتج الدائرة الأكثر كفاءةً للتنفيذ على الأجهزة المحددة.

ملاحظة: في مثال دائرة SU2 الأولي، سنقتصر على مقارنة محوّل SABRE بمحوّل الذكاء الاصطناعي الافتراضي. أما في الاختبار المرجعي اللاحق باستخدام دوائر Hamlib، فسنقارن الأساليب الثلاثة جميعها.

```python
# QiskitRuntimeService.save_account(channel="ibm_quantum_platform", token="<YOUR-API-KEY>", overwrite=True, set_as_default=True)
service = QiskitRuntimeService(channel="ibm_quantum_platform")
backend = service.backend("ibm_torino")
print(f"Using backend: {backend}")
```

```text
qiskit_runtime_service._get_crn_from_instance_name:WARNING:2025-07-30 21:46:30,843: Multiple instances found. Using all matching instances.
```

```text
Using backend: <IBMBackend('ibm_torino')>
```

محوّل Qiskit مع SABRE:

```python
pm_sabre = generate_preset_pass_manager(
    optimization_level=3, backend=backend, seed_transpiler=seed
)
```

محوّل الذكاء الاصطناعي:

```python
# Standard AI transpiler pass manager, using the local mode
pm_ai = generate_ai_pass_manager(
    backend=backend, optimization_level=3, ai_optimization_level=3
)
```

إضافة Rustiq:

```python
hls_config = HLSConfig(
    PauliEvolution=[
        (
            "rustiq",
            {
                "nshuffles": 400,
                "upto_phase": True,
                "fix_clifford": True,
                "preserve_order": False,
                "metric": "depth",
            },
        )
    ]
)
pm_rustiq = generate_preset_pass_manager(
    optimization_level=3,
    backend=backend,
    hls_config=hls_config,
    seed_transpiler=seed,
)
```

#### التحويل البرمجي وجمع المقاييس {#transpile-and-capture-metrics}

لمقارنة أداء أساليب التحويل البرمجي، نعرّف دالةً تُحوِّل الدائرة المدخلة برمجياً وتجمع المقاييس ذات الصلة بأسلوب متسق. يشمل ذلك عمق الدائرة الكلي، وعدد البوابات الإجمالي، ووقت التحويل البرمجي.

إضافةً إلى هذه المقاييس القياسية، نسجّل أيضاً عمق بوابات ثنائية الكيوبت، وهو مقياس بالغ الأهمية لتقييم التنفيذ على الأجهزة الكمومية. على خلاف العمق الكلي الذي يشمل جميع البوابات، يعكس عمق ثنائي الكيوبت مدة التنفيذ الفعلية للدائرة على الأجهزة بدقة أكبر. ويعود ذلك إلى أن بوابات ثنائية الكيوبت تهيمن عادةً على ميزانية الوقت والخطأ في معظم الأجهزة الكمومية. ولهذا، يُعدّ تقليل عمق ثنائي الكيوبت أمراً حاسماً لتحسين الدقة والحدّ من تأثيرات التخلّل (decoherence) أثناء التنفيذ.

سنستخدم هذه الدالة لتحليل أداء أساليب التحويل البرمجي المختلفة عبر دوائر متعددة.

```python
def capture_transpilation_metrics(
    results, pass_manager, circuits, method_name
):
    """
    Capture transpilation metrics for a list of circuits and stores the results in a DataFrame.

    Args:
        results (pd.DataFrame): DataFrame to store the results.
        pass_manager: Pass manager used for transpilation.
        circuits (list): List of quantum circuits to transpile.
        method_name (str): Name of the transpilation method.

    Returns:
        list: List of transpiled circuits.
    """
    transpiled_circuits = []

    for i, qc in enumerate(circuits):
        # Transpile the circuit
        start_time = time.time()
        transpiled_qc = pass_manager.run(qc)
        end_time = time.time()

        # Needed for AI transpiler to be consistent with other methods
        transpiled_qc = transpiled_qc.decompose(gates_to_decompose=["swap"])

        # Collect metrics
        transpilation_time = end_time - start_time
        circuit_depth = transpiled_qc.depth(
            lambda x: x.operation.num_qubits == 2
        )
        circuit_size = transpiled_qc.size()

        # Append results to DataFrame
        results.loc[len(results)] = {
            "method": method_name,
            "qc_name": qc.name,
            "qc_index": i,
            "num_qubits": qc.num_qubits,
            "ops": transpiled_qc.count_ops(),
            "depth": circuit_depth,
            "size": circuit_size,
            "runtime": transpilation_time,
        }
        transpiled_circuits.append(transpiled_qc)
        print(
            f"Transpiled circuit index {i} ({qc.name}) in {transpilation_time:.2f} seconds with method {method_name}, "
            f"depth {circuit_depth}, and size {circuit_size}."
        )

    return transpiled_circuits
```

```python
results_su2 = pd.DataFrame(
    columns=[
        "method",
        "qc_name",
        "qc_index",
        "num_qubits",
        "ops",
        "depth",
        "size",
        "runtime",
    ]
)

tqc_sabre = capture_transpilation_metrics(
    results_su2, pm_sabre, qc_su2_list, "sabre"
)
tqc_ai = capture_transpilation_metrics(results_su2, pm_ai, qc_su2_list, "ai")
```

```text
Transpiled circuit index 0 (SU2_10) in 0.06 seconds with method sabre, depth 13, and size 167.
Transpiled circuit index 1 (SU2_20) in 0.24 seconds with method sabre, depth 20, and size 299.
Transpiled circuit index 2 (SU2_30) in 10.72 seconds with method sabre, depth 72, and size 627.
Transpiled circuit index 3 (SU2_40) in 16.16 seconds with method sabre, depth 40, and size 599.
Transpiled circuit index 4 (SU2_50) in 76.89 seconds with method sabre, depth 77, and size 855.
Transpiled circuit index 5 (SU2_60) in 86.12 seconds with method sabre, depth 60, and size 899.
Transpiled circuit index 6 (SU2_70) in 94.46 seconds with method sabre, depth 79, and size 1085.
Transpiled circuit index 7 (SU2_80) in 69.05 seconds with method sabre, depth 80, and size 1199.
Transpiled circuit index 8 (SU2_90) in 88.25 seconds with method sabre, depth 105, and size 1420.
Transpiled circuit index 9 (SU2_100) in 83.80 seconds with method sabre, depth 100, and size 1499.
Transpiled circuit index 0 (SU2_10) in 0.17 seconds with method ai, depth 10, and size 168.
Transpiled circuit index 1 (SU2_20) in 0.29 seconds with method ai, depth 20, and size 299.
Transpiled circuit index 2 (SU2_30) in 13.56 seconds with method ai, depth 36, and size 548.
Transpiled circuit index 3 (SU2_40) in 15.95 seconds with method ai, depth 40, and size 599.
Transpiled circuit index 4 (SU2_50) in 80.70 seconds with method ai, depth 54, and size 823.
Transpiled circuit index 5 (SU2_60) in 75.99 seconds with method ai, depth 60, and size 899.
Transpiled circuit index 6 (SU2_70) in 64.96 seconds with method ai, depth 74, and size 1087.
Transpiled circuit index 7 (SU2_80) in 68.25 seconds with method ai, depth 80, and size 1199.
Transpiled circuit index 8 (SU2_90) in 75.07 seconds with method ai, depth 90, and size 1404.
Transpiled circuit index 9 (SU2_100) in 63.97 seconds with method ai, depth 100, and size 1499.
```

عرض نتائج التحويل البرمجي لإحدى الدوائر.

```python
print("Sabre transpilation")
display(tqc_sabre[0].draw("mpl", fold=-1, idle_wires=False))
print("AI transpilation")
display(tqc_ai[0].draw("mpl", fold=-1, idle_wires=False))
```

```text
Sabre transpilation
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/37924fc2-8fb6-451a-b8f9-cd79573f2384-1.avif)

```text
AI transpilation
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/37924fc2-8fb6-451a-b8f9-cd79573f2384-3.avif)

جدول النتائج:

```python
summary_su2 = (
    results_su2.groupby("method")[["depth", "size", "runtime"]]
    .mean()
    .round(2)
)
print(summary_su2)

results_su2
```

```text
depth   size  runtime
method
ai       56.4  852.5    45.89
sabre    64.6  864.9    52.57
```

```text
method  qc_name  qc_index  num_qubits                                ops  \
0   sabre   SU2_10         0          10     {'rz': 81, 'sx': 70, 'cz': 16}
1   sabre   SU2_20         1          20   {'rz': 160, 'sx': 119, 'cz': 20}
2   sabre   SU2_30         2          30   {'sx': 295, 'rz': 242, 'cz': 90}
3   sabre   SU2_40         3          40   {'rz': 320, 'sx': 239, 'cz': 40}
4   sabre   SU2_50         4          50   {'rz': 402, 'sx': 367, 'cz': 86}
5   sabre   SU2_60         5          60   {'rz': 480, 'sx': 359, 'cz': 60}
6   sabre   SU2_70         6          70   {'rz': 562, 'sx': 441, 'cz': 82}
7   sabre   SU2_80         7          80   {'rz': 640, 'sx': 479, 'cz': 80}
8   sabre   SU2_90         8          90  {'rz': 721, 'sx': 585, 'cz': 114}
9   sabre  SU2_100         9         100  {'rz': 800, 'sx': 599, 'cz': 100}
10     ai   SU2_10         0          10     {'rz': 81, 'sx': 71, 'cz': 16}
11     ai   SU2_20         1          20   {'rz': 160, 'sx': 119, 'cz': 20}
12     ai   SU2_30         2          30   {'sx': 243, 'rz': 242, 'cz': 63}
13     ai   SU2_40         3          40   {'rz': 320, 'sx': 239, 'cz': 40}
14     ai   SU2_50         4          50   {'rz': 403, 'sx': 346, 'cz': 74}
15     ai   SU2_60         5          60   {'rz': 480, 'sx': 359, 'cz': 60}
16     ai   SU2_70         6          70   {'rz': 563, 'sx': 442, 'cz': 82}
17     ai   SU2_80         7          80   {'rz': 640, 'sx': 479, 'cz': 80}
18     ai   SU2_90         8          90  {'rz': 721, 'sx': 575, 'cz': 108}
19     ai  SU2_100         9         100  {'rz': 800, 'sx': 599, 'cz': 100}

    depth  size    runtime
0      13   167   0.058845
1      20   299   0.238217
2      72   627  10.723922
3      40   599  16.159262
4      77   855  76.886604
5      60   899  86.118255
6      79  1085  94.458287
7      80  1199  69.048184
8     105  1420  88.254809
9     100  1499  83.795482
10     10   168   0.171532
11     20   299   0.291691
12     36   548  13.555931
13     40   599  15.952733
14     54   823  80.702141
15     60   899  75.993404
16     74  1087  64.960162
17     80  1199  68.253280
18     90  1404  75.072412
19    100  1499  63.967446
```

#### الرسم البياني للنتائج {#results-graph}

بما أننا عرّفنا دالةً لجمع المقاييس بصورة متسقة، سنعرّف أيضاً دالةً لرسمها بيانياً. هنا، سنرسم عمق ثنائي الكيوبت، وعدد البوابات، ووقت التشغيل لكل أسلوب من أساليب التحويل البرمجي عبر الدوائر المختلفة.

```python
def plot_transpilation_metrics(results, overall_title, x_axis="qc_index"):
    """
    Plots transpilation metrics (depth, size, runtime) for different transpilation methods.

    Parameters:
        results (DataFrame): Data containing columns ['num_qubits', 'method', 'depth', 'size', 'runtime']
        overall_title (str): The title of the overall figure.
        x_axis (str): The x-axis label, either 'num_qubits' or 'qc_index'.
    """

    fig, axs = plt.subplots(1, 3, figsize=(24, 6))
    metrics = ["depth", "size", "runtime"]
    titles = ["Circuit Depth", "Circuit Size", "Transpilation Runtime"]
    y_labels = ["Depth", "Size (Gate Count)", "Runtime (s)"]

    methods = results["method"].unique()
    colors = plt.colormaps["tab10"]
    markers = ["o", "^", "s", "D", "P", "*", "X", "v"]
    color_list = [colors(i % colors.N) for i in range(len(methods))]
    color_map = {method: color_list[i] for i, method in enumerate(methods)}
    marker_map = {
        method: markers[i % len(markers)] for i, method in enumerate(methods)
    }
    jitter_factor = 0.1  # Small x-axis jitter for visibility
    handles, labels = [], []  # Unique handles for legend

    # Plot each metric
```

```python
    # Plot each metric
    for i, metric in enumerate(metrics):
        for method in methods:
            method_data = results[results["method"] == method]

            # Introduce slight jitter to avoid exact overlap
            jitter = np.random.uniform(
                -jitter_factor, jitter_factor, len(method_data)
            )

            scatter = axs[i].scatter(
                method_data[x_axis] + jitter,
                method_data[metric],
                color=color_map[method],
                label=method,
                marker=marker_map[method],
                alpha=0.7,
                edgecolors="black",
                s=80,
            )

            if method not in labels:
                handles.append(scatter)
                labels.append(method)

        axs[i].set_title(titles[i])
        axs[i].set_xlabel(x_axis)
        axs[i].set_ylabel(y_labels[i])
        axs[i].grid(axis="y", linestyle="--", alpha=0.7)
        axs[i].tick_params(axis="x", rotation=45)
        axs[i].set_xticks(sorted(results[x_axis].unique()))

    fig.suptitle(overall_title, fontsize=16)
    fig.legend(
        handles=handles,
        labels=labels,
        loc="upper right",
        bbox_to_anchor=(1.05, 1),
    )

    plt.tight_layout()
    plt.show()
```

```python
plot_transpilation_metrics(
    results_su2, "Transpilation Metrics for SU2 Circuits", x_axis="num_qubits"
)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/7f7b502a-8ed6-45fa-a698-02977149e283-0.avif)

#### تحليل نتائج تصريف دوائر SU2 {#analysis-of-su2-circuit-compilation-results}

في هذه التجربة، نقارن طريقتَي تصريف — مُصرِّف SABRE الخاص بـ Qiskit والمُصرِّف المُدعوم بالذكاء الاصطناعي — على مجموعة من دوائر `efficient_su2`. وبما أن هذه الدوائر لا تتضمن أي عمليات `PauliEvolutionGate`، فلن يُدرج مكوِّن Rustiq في هذه المقارنة.

في المتوسط، يُحقق مُصرِّف الذكاء الاصطناعي أداءً أفضل من حيث عمق الدائرة، إذ يتجاوز التحسين نسبة 10% عبر النطاق الكامل لدوائر SU2. أما فيما يتعلق بعدد البوابات (حجم الدائرة) ووقت التشغيل، فإن كلتا الطريقتين تُنتجان نتائج متقاربة بشكل عام.

غير أن فحص نقاط البيانات الفردية يكشف عن رؤية أعمق:
- بالنسبة لمعظم أحجام القبَّات (qubits)، تُنتج كلٌّ من SABRE والذكاء الاصطناعي نتائج شبه متطابقة، مما يُشير إلى أن كلتا الطريقتين تتقاربان في كثير من الحالات نحو حلول ذات كفاءة متماثلة.
- بالنسبة لأحجام دوائر بعينها، وتحديداً عند 30 و50 و70 و90 قبَّة، يعثر مُصرِّف الذكاء الاصطناعي على دوائر أكثر ضحالة بشكل ملحوظ مقارنةً بـ SABRE. يدل ذلك على أن النهج القائم على التعلم لدى الذكاء الاصطناعي قادر على اكتشاف تخطيطات أو مسارات توجيه أمثل في الحالات التي لا يُفلح فيها الأسلوب الاستكشافي لـ SABRE.

يُبرز هذا السلوك استنتاجاً جوهرياً:
> في حين تُنتج SABRE والذكاء الاصطناعي في الغالب نتائج متقاربة، يستطيع مُصرِّف الذكاء الاصطناعي أحياناً اكتشاف حلول أفضل بكثير، لا سيما من حيث العمق، مما قد يؤدي إلى تحسين ملحوظ في الأداء على الأجهزة الفعلية.

## الجزء الثاني: دائرة محاكاة هاميلتونيان {#part-2-hamiltonian-simulation-circuit}

### الخطوة 1: فحص الدوائر باستخدام `PauliEvolutionGate` {#step-1-investigate-circuits-with-paulievolutiongate}

في هذا القسم، ندرس الدوائر الكمومية المُنشأة باستخدام `PauliEvolutionGate`، الذي يُتيح محاكاة فعَّالة لهاميلتونيانات متعددة. سنحلل كيفية قيام طرق التصريف المختلفة بتحسين هذه الدوائر عبر مختلف هاميلتونيانات.

#### هاميلتونيانات المستخدمة في المقياس المرجعي {#hamiltonians-used-in-the-benchmark}

تصف هاميلتونيانات المستخدمة في هذا المقياس التفاعلات الثنائية بين القبَّات، بما فيها حدود من قبيل $ZZ$ و$XX$ و$YY$. وتُستخدم هذه الهاميلتونيانات على نطاق واسع في الكيمياء الكمومية وفيزياء المادة المكثفة وعلوم المواد، حيث تُنمذج أنظمةً من الجسيمات المتفاعلة.

للاستزادة، يمكن للمستخدمين الاطلاع على مجموعة أوسع من الهاميلتونيانات في هذه الورقة البحثية: [Efficient Hamiltonian Simulation on Noisy Quantum Devices](https://arxiv.org/pdf/2306.13126).

#### مصدر المقياس المرجعي: Hamlib وBenchpress {#benchmark-source-hamlib-and-benchpress}

الدوائر المستخدمة في هذا المقياس مستقاة من [مستودع مقياس Hamlib المرجعي](https://github.com/SRI-International/QC-App-Oriented-Benchmarks/tree/master/hamlib)، الذي يحتوي على أعباء عمل واقعية لمحاكاة هاميلتونيان.

سبق أن خضعت هذه الدوائر ذاتها للقياس المرجعي باستخدام [Benchpress](https://github.com/Qiskit/benchpress)، وهو إطار عمل مفتوح المصدر لتقييم أداء التصريف الكمومي. بالاستعانة بهذه المجموعة المعيارية من الدوائر، يمكننا مقارنة فاعلية استراتيجيات التصريف المختلفة مقارنةً مباشرةً على مسائل محاكاة تمثيلية.

تُعدّ محاكاة هاميلتونيان مهمةً أساسية في الحوسبة الكمومية، وتجد تطبيقاتها في محاكاة الجزيئات ومسائل التحسين وفيزياء الأجسام الكمومية متعددة الجسيمات. إن فهم كيفية تحسين طرق التصريف المختلفة لهذه الدوائر يُساعد المستخدمين على رفع كفاءة تنفيذها على الأجهزة الكمومية قصيرة المدى.

```python
# Obtain the Hamiltonian JSON from the benchpress repository
url = "https://raw.githubusercontent.com/Qiskit/benchpress/e7b29ef7be4cc0d70237b8fdc03edbd698908eff/benchpress/hamiltonian/hamlib/100_representative.json"
response = requests.get(url)
response.raise_for_status()  # Raise an error if download failed
ham_records = json.loads(response.text)
# Remove circuits that are too large for the backend
ham_records = [
    h for h in ham_records if h["ham_qubits"] <= backend.num_qubits
]
# Remove the circuits that are large to save transpilation time
ham_records = sorted(ham_records, key=lambda x: x["ham_terms"])[:35]

qc_ham_list = []
for h in ham_records:
    terms = h["ham_hamlib_hamiltonian_terms"]
    coeff = h["ham_hamlib_hamiltonian_coefficients"]
    num_qubits = h["ham_qubits"]
    name = h["ham_problem"]

    evo_gate = PauliEvolutionGate(SparsePauliOp(terms, coeff))

    qc_ham = QuantumCircuit(num_qubits)
    qc_ham.name = name

    qc_ham.append(evo_gate, range(num_qubits))
    qc_ham_list.append(qc_ham)
print(f"Number of Hamiltonian circuits: {len(qc_ham_list)}")

# Draw the first Hamiltonian circuit
qc_ham_list[0].draw("mpl", fold=-1)
```

```text
Number of Hamiltonian circuits: 35
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/66347c00-1607-4405-bb76-610690adf6b8-1.avif)

### الخطوة 2: تحسين المسألة لتنفيذها على الأجهزة الكمومية {#step-2-optimize-problem-for-quantum-hardware-execution}

كما في المثال السابق، سنستخدم الخلفية ذاتها لضمان الاتساق في مقارناتنا. وبما أن مديري التمريرات (`pm_sabre` و`pm_ai` و`pm_rustiq`) قد جرى تهيئتهم مسبقاً، يمكننا المضي مباشرةً في تصريف دوائر هاميلتونيان باستخدام كل طريقة.

تنصبّ هذه الخطوة على إجراء عملية التصريف وتسجيل مقاييس الدائرة الناتجة، بما فيها العمق وعدد البوابات ووقت تشغيل التصريف. من خلال تحليل هذه النتائج، نهدف إلى تحديد مدى كفاءة كل طريقة تصريف على هذا النوع من الدوائر.

تصريف الدوائر وتسجيل المقاييس:

```python
results_ham = pd.DataFrame(
    columns=[
        "method",
        "qc_name",
        "qc_index",
        "num_qubits",
        "ops",
        "depth",
        "size",
        "runtime",
    ]
)

tqc_sabre = capture_transpilation_metrics(
    results_ham, pm_sabre, qc_ham_list, "sabre"
)
tqc_ai = capture_transpilation_metrics(results_ham, pm_ai, qc_ham_list, "ai")
tqc_rustiq = capture_transpilation_metrics(
    results_ham, pm_rustiq, qc_ham_list, "rustiq"
)
```

```text
Transpiled circuit index 0 (all-vib-o3) in 0.02 seconds with method sabre, depth 6, and size 58.
Transpiled circuit index 1 (all-vib-c2h) in 1.10 seconds with method sabre, depth 2, and size 39.
Transpiled circuit index 2 (all-vib-bh) in 0.01 seconds with method sabre, depth 3, and size 30.
Transpiled circuit index 3 (all-vib-c2h) in 0.03 seconds with method sabre, depth 18, and size 115.
Transpiled circuit index 4 (graph-gnp_k-2) in 0.02 seconds with method sabre, depth 24, and size 129.
Transpiled circuit index 5 (all-vib-fccf) in 0.05 seconds with method sabre, depth 14, and size 134.
Transpiled circuit index 6 (all-vib-hno) in 8.39 seconds with method sabre, depth 6, and size 174.
Transpiled circuit index 7 (all-vib-bhf2) in 3.92 seconds with method sabre, depth 22, and size 220.
Transpiled circuit index 8 (LiH) in 0.03 seconds with method sabre, depth 67, and size 290.
Transpiled circuit index 9 (uf20-ham) in 0.04 seconds with method sabre, depth 50, and size 340.
Transpiled circuit index 10 (all-vib-fccf) in 0.62 seconds with method sabre, depth 30, and size 286.
Transpiled circuit index 11 (all-vib-fccf) in 0.04 seconds with method sabre, depth 67, and size 339.
Transpiled circuit index 12 (all-vib-ch2) in 0.04 seconds with method sabre, depth 87, and size 421.
Transpiled circuit index 13 (tfim) in 0.05 seconds with method sabre, depth 36, and size 222.
Transpiled circuit index 14 (all-vib-cyclo_propene) in 9.51 seconds with method sabre, depth 22, and size 345.
Transpiled circuit index 15 (graph-gnp_k-4) in 0.05 seconds with method sabre, depth 128, and size 704.
Transpiled circuit index 16 (all-vib-hc3h2cn) in 13.83 seconds with method sabre, depth 2, and size 242.
Transpiled circuit index 17 (TSP_Ncity-4) in 0.05 seconds with method sabre, depth 106, and size 609.
Transpiled circuit index 18 (tfim) in 0.29 seconds with method sabre, depth 73, and size 399.
Transpiled circuit index 19 (all-vib-h2co) in 21.97 seconds with method sabre, depth 30, and size 572.
Transpiled circuit index 20 (Be2) in 0.09 seconds with method sabre, depth 324, and size 1555.
Transpiled circuit index 21 (graph-complete_bipart) in 0.12 seconds with method sabre, depth 250, and size 1394.
Transpiled circuit index 22 (all-vib-f2) in 0.07 seconds with method sabre, depth 215, and size 1027.
Transpiled circuit index 23 (all-vib-cyclo_propene) in 41.22 seconds with method sabre, depth 30, and size 1144.
Transpiled circuit index 24 (TSP_Ncity-5) in 1.89 seconds with method sabre, depth 175, and size 1933.
Transpiled circuit index 25 (H2) in 0.32 seconds with method sabre, depth 1237, and size 5502.
Transpiled circuit index 26 (uuf100-ham) in 0.20 seconds with method sabre, depth 385, and size 4303.
Transpiled circuit index 27 (ham-graph-gnp_k-5) in 0.20 seconds with method sabre, depth 311, and size 3654.
Transpiled circuit index 28 (tfim) in 0.15 seconds with method sabre, depth 276, and size 3213.
Transpiled circuit index 29 (uuf100-ham) in 0.21 seconds with method sabre, depth 520, and size 5250.
Transpiled circuit index 30 (flat100-ham) in 0.15 seconds with method sabre, depth 131, and size 3157.
Transpiled circuit index 31 (uf100-ham) in 0.24 seconds with method sabre, depth 624, and size 7378.
Transpiled circuit index 32 (OH) in 0.88 seconds with method sabre, depth 2175, and size 9808.
Transpiled circuit index 33 (HF) in 0.66 seconds with method sabre, depth 2206, and size 9417.
Transpiled circuit index 34 (BH) in 0.89 seconds with method sabre, depth 2177, and size 9802.
Transpiled circuit index 0 (all-vib-o3) in 0.02 seconds with method ai, depth 6, and size 58.
Transpiled circuit index 1 (all-vib-c2h) in 1.11 seconds with method ai, depth 2, and size 39.
Transpiled circuit index 2 (all-vib-bh) in 0.01 seconds with method ai, depth 3, and size 30.
Transpiled circuit index 3 (all-vib-c2h) in 0.11 seconds with method ai, depth 18, and size 94.
Transpiled circuit index 4 (graph-gnp_k-2) in 0.11 seconds with method ai, depth 22, and size 129.
Transpiled circuit index 5 (all-vib-fccf) in 0.06 seconds with method ai, depth 22, and size 177.
Transpiled circuit index 6 (all-vib-hno) in 8.62 seconds with method ai, depth 10, and size 198.
Transpiled circuit index 7 (all-vib-bhf2) in 3.71 seconds with method ai, depth 18, and size 195.
Transpiled circuit index 8 (LiH) in 0.19 seconds with method ai, depth 62, and size 267.
Transpiled circuit index 9 (uf20-ham) in 0.04 seconds with method ai, depth 47, and size 321.
Transpiled circuit index 10 (all-vib-fccf) in 0.71 seconds with method ai, depth 38, and size 369.
Transpiled circuit index 11 (all-vib-fccf) in 0.24 seconds with method ai, depth 65, and size 315.
Transpiled circuit index 12 (all-vib-ch2) in 0.24 seconds with method ai, depth 91, and size 430.
Transpiled circuit index 13 (tfim) in 0.15 seconds with method ai, depth 12, and size 251.
Transpiled circuit index 14 (all-vib-cyclo_propene) in 8.50 seconds with method ai, depth 18, and size 311.
Transpiled circuit index 15 (graph-gnp_k-4) in 0.25 seconds with method ai, depth 117, and size 659.
Transpiled circuit index 16 (all-vib-hc3h2cn) in 16.11 seconds with method ai, depth 2, and size 242.
Transpiled circuit index 17 (TSP_Ncity-4) in 0.39 seconds with method ai, depth 98, and size 564.
Transpiled circuit index 18 (tfim) in 0.38 seconds with method ai, depth 23, and size 437.
Transpiled circuit index 19 (all-vib-h2co) in 24.97 seconds with method ai, depth 38, and size 707.
Transpiled circuit index 20 (Be2) in 1.07 seconds with method ai, depth 293, and size 1392.
Transpiled circuit index 21 (graph-complete_bipart) in 0.61 seconds with method ai, depth 229, and size 1437.
Transpiled circuit index 22 (all-vib-f2) in 0.57 seconds with method ai, depth 178, and size 964.
Transpiled circuit index 23 (all-vib-cyclo_propene) in 50.89 seconds with method ai, depth 34, and size 1425.
Transpiled circuit index 24 (TSP_Ncity-5) in 1.61 seconds with method ai, depth 171, and size 2020.
Transpiled circuit index 25 (H2) in 6.39 seconds with method ai, depth 1148, and size 5208.
Transpiled circuit index 26 (uuf100-ham) in 3.97 seconds with method ai, depth 376, and size 5048.
Transpiled circuit index 27 (ham-graph-gnp_k-5) in 3.54 seconds with method ai, depth 357, and size 4451.
Transpiled circuit index 28 (tfim) in 1.72 seconds with method ai, depth 216, and size 3026.
Transpiled circuit index 29 (uuf100-ham) in 4.45 seconds with method ai, depth 426, and size 5399.
Transpiled circuit index 30 (flat100-ham) in 7.02 seconds with method ai, depth 86, and size 3108.
Transpiled circuit index 31 (uf100-ham) in 12.85 seconds with method ai, depth 623, and size 8354.
Transpiled circuit index 32 (OH) in 15.19 seconds with method ai, depth 2084, and size 9543.
Transpiled circuit index 33 (HF) in 17.51 seconds with method ai, depth 2063, and size 9446.
Transpiled circuit index 34 (BH) in 15.33 seconds with method ai, depth 2094, and size 9730.
Transpiled circuit index 0 (all-vib-o3) in 0.02 seconds with method rustiq, depth 13, and size 83.
Transpiled circuit index 1 (all-vib-c2h) in 1.11 seconds with method rustiq, depth 2, and size 39.
Transpiled circuit index 2 (all-vib-bh) in 0.01 seconds with method rustiq, depth 3, and size 30.
Transpiled circuit index 3 (all-vib-c2h) in 0.01 seconds with method rustiq, depth 13, and size 79.
Transpiled circuit index 4 (graph-gnp_k-2) in 0.02 seconds with method rustiq, depth 31, and size 131.
Transpiled circuit index 5 (all-vib-fccf) in 0.04 seconds with method rustiq, depth 50, and size 306.
Transpiled circuit index 6 (all-vib-hno) in 14.03 seconds with method rustiq, depth 22, and size 276.
Transpiled circuit index 7 (all-vib-bhf2) in 3.15 seconds with method rustiq, depth 13, and size 155.
Transpiled circuit index 8 (LiH) in 0.03 seconds with method rustiq, depth 54, and size 270.
Transpiled circuit index 9 (uf20-ham) in 0.04 seconds with method rustiq, depth 65, and size 398.
Transpiled circuit index 10 (all-vib-fccf) in 0.16 seconds with method rustiq, depth 41, and size 516.
Transpiled circuit index 11 (all-vib-fccf) in 0.02 seconds with method rustiq, depth 34, and size 189.
Transpiled circuit index 12 (all-vib-ch2) in 0.03 seconds with method rustiq, depth 49, and size 240.
Transpiled circuit index 13 (tfim) in 0.05 seconds with method rustiq, depth 20, and size 366.
Transpiled circuit index 14 (all-vib-cyclo_propene) in 9.08 seconds with method rustiq, depth 16, and size 277.
Transpiled circuit index 15 (graph-gnp_k-4) in 0.04 seconds with method rustiq, depth 116, and size 612.
Transpiled circuit index 16 (all-vib-hc3h2cn) in 13.89 seconds with method rustiq, depth 2, and size 257.
Transpiled circuit index 17 (TSP_Ncity-4) in 0.05 seconds with method rustiq, depth 133, and size 737.
Transpiled circuit index 18 (tfim) in 0.11 seconds with method rustiq, depth 25, and size 680.
Transpiled circuit index 19 (all-vib-h2co) in 27.19 seconds with method rustiq, depth 66, and size 983.
Transpiled circuit index 20 (Be2) in 0.07 seconds with method rustiq, depth 215, and size 1030.
Transpiled circuit index 21 (graph-complete_bipart) in 0.14 seconds with method rustiq, depth 328, and size 1918.
Transpiled circuit index 22 (all-vib-f2) in 0.05 seconds with method rustiq, depth 114, and size 692.
Transpiled circuit index 23 (all-vib-cyclo_propene) in 62.25 seconds with method rustiq, depth 74, and size 2348.
Transpiled circuit index 24 (TSP_Ncity-5) in 0.20 seconds with method rustiq, depth 436, and size 3605.
Transpiled circuit index 25 (H2) in 0.21 seconds with method rustiq, depth 643, and size 3476.
Transpiled circuit index 26 (uuf100-ham) in 0.24 seconds with method rustiq, depth 678, and size 6120.
Transpiled circuit index 27 (ham-graph-gnp_k-5) in 0.22 seconds with method rustiq, depth 588, and size 5241.
Transpiled circuit index 28 (tfim) in 0.34 seconds with method rustiq, depth 340, and size 5901.
Transpiled circuit index 29 (uuf100-ham) in 0.33 seconds with method rustiq, depth 881, and size 7667.
Transpiled circuit index 30 (flat100-ham) in 0.31 seconds with method rustiq, depth 279, and size 4910.
Transpiled circuit index 31 (uf100-ham) in 0.38 seconds with method rustiq, depth 1138, and size 10607.
Transpiled circuit index 32 (OH) in 0.38 seconds with method rustiq, depth 1148, and size 6512.
Transpiled circuit index 33 (HF) in 0.37 seconds with method rustiq, depth 1090, and size 6256.
Transpiled circuit index 34 (BH) in 0.37 seconds with method rustiq, depth 1148, and size 6501.
```

جدول النتائج (يُستغنى عن التمثيل البصري نظراً لكِبَر حجم الدوائر الناتجة):

```python
summary_ham = (
    results_ham.groupby("method")[["depth", "size", "runtime"]]
    .mean()
    .round(2)
)
print(summary_ham)

results_ham
```

```text
depth     size  runtime
method
ai      316.86  2181.26     5.97
rustiq  281.94  2268.80     3.86
sabre   337.97  2120.14     3.07
```

```text
method        qc_name  qc_index  num_qubits  \
0     sabre     all-vib-o3         0           4
1     sabre    all-vib-c2h         1           4
2     sabre     all-vib-bh         2           2
3     sabre    all-vib-c2h         3           3
4     sabre  graph-gnp_k-2         4           4
..      ...            ...       ...         ...
100  rustiq    flat100-ham        30          90
101  rustiq      uf100-ham        31          46
102  rustiq             OH        32          10
103  rustiq             HF        33          10
104  rustiq             BH        34          10

                                               ops  depth   size   runtime
0                    {'rz': 28, 'sx': 24, 'cz': 6}      6     58  0.016597
1            {'rz': 17, 'sx': 16, 'cz': 4, 'x': 2}      2     39  1.102089
2                    {'sx': 14, 'rz': 13, 'cz': 3}      3     30  0.011042
3           {'sx': 46, 'rz': 45, 'cz': 18, 'x': 6}     18    115  0.025816
4           {'sx': 49, 'rz': 47, 'cz': 24, 'x': 9}     24    129  0.023077
..                                             ...    ...    ...       ...
100    {'sx': 2709, 'cz': 1379, 'rz': 817, 'x': 5}    279   4910  0.309448
101   {'sx': 6180, 'cz': 3120, 'rz': 1303, 'x': 4}   1138  10607  0.380977
102  {'sx': 3330, 'cz': 1704, 'rz': 1455, 'x': 23}   1148   6512  0.383564
103  {'sx': 3213, 'cz': 1620, 'rz': 1406, 'x': 17}   1090   6256  0.368578
104  {'sx': 3331, 'cz': 1704, 'rz': 1447, 'x': 19}   1148   6501  0.374822

[105 rows x 8 columns]
```

تمثيل الأداء بحسب فهرس الدائرة:

```python
plot_transpilation_metrics(
    results_ham, "Transpilation Metrics for Hamiltonian Circuits"
)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/4c6b810d-a4cf-4de3-aae6-c6c1cdd83d8f-0.avif)

تمثيل نسبة الدوائر التي حققت فيها كل طريقة أفضل أداء.

```python
def analyze_and_plot_best_methods(results, metric):
    """
    Analyze the best-performing methods for a given metric and plot a pie chart.

    Parameters:
        results (DataFrame): The input DataFrame containing method performance data.
        metric (str): The metric to evaluate ("depth" or "size").
    """
    method_counts = Counter()
    for qc_idx, group in results.groupby("qc_index"):
        min_value = group[metric].min()

        # Find all methods that achieved this minimum value
        best_methods = group[group[metric] == min_value]["method"]
        # Update counts for all best methods (handling ties)
        method_counts.update(best_methods)
    best_method_counts = dict(
        sorted(method_counts.items(), key=lambda x: x[1], reverse=True)
    )

    # Print summary
    print(f"Best-performing methods based on {metric}:")
    for method, count in best_method_counts.items():
        print(f"    {method}: {count} circuit(s)")

    # Plot pie chart
    num_methods = len(best_method_counts)
    colors = plt.cm.viridis_r(range(0, 256, 256 // num_methods))
    plt.figure(figsize=(5, 5))
    plt.pie(
        best_method_counts.values(),
        labels=best_method_counts.keys(),
        autopct="%1.1f%%",
        startangle=140,
        wedgeprops={"edgecolor": "black"},
        textprops={"fontsize": 10},
        colors=colors,
    )
    plt.title(
        f"Percentage of Circuits Method Performed Best for {metric.capitalize()}",
        fontsize=12,
        fontweight="bold",
    )
    plt.show()

analyze_and_plot_best_methods(results_ham, "depth")
analyze_and_plot_best_methods(results_ham, "size")
```

```text
Best-performing methods based on depth:
    ai: 16 circuit(s)
    rustiq: 16 circuit(s)
    sabre: 10 circuit(s)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/01b4644e-ac91-483c-944b-924f8b41718d-1.avif)

```text
Best-performing methods based on size:
    sabre: 18 circuit(s)
    rustiq: 14 circuit(s)
    ai: 10 circuit(s)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/01b4644e-ac91-483c-944b-924f8b41718d-3.avif)

#### تحليل نتائج تصريف دوائر هاميلتونيان {#analysis-of-hamiltonian-circuit-compilation-results}

في هذا القسم، نُقيِّم أداء ثلاث طرق تصريف — SABRE ومُصرِّف الذكاء الاصطناعي وRustiq — على الدوائر الكمومية المُنشأة باستخدام `PauliEvolutionGate`، والتي تُستخدم على نطاق واسع في مهام محاكاة هاميلتونيان.

حقق Rustiq أفضل أداء في المتوسط من حيث عمق الدائرة**، إذ بلغ تحسينه نحو 20% مقارنةً بـ SABRE. وهذا أمر متوقع، إذ صُمِّم Rustiq تحديداً لتركيب عمليات `PauliEvolutionGate` باستراتيجيات تحليل محسَّنة وذات عمق منخفض. علاوةً على ذلك، يُظهر مخطط العمق أنه مع تصاعد حجم الدوائر وتعقيدها، يتوسع Rustiq بفاعلية أكبر، محافظاً على عمق أقل بشكل ملحوظ مقارنةً بالذكاء الاصطناعي وSABRE على الدوائر الكبيرة.

أبدى مُصرِّف الذكاء الاصطناعي أداءً قوياً ومتسقاً فيما يتعلق بعمق الدائرة، متفوقاً باستمرار على SABRE في معظم الدوائر. غير أنه تكبَّد أعلى وقت تشغيل، لا سيما على الدوائر الكبيرة، مما قد يُقيِّد جدواه العملية في أعباء العمل الحساسة للوقت. وتبقى قابليته للتوسع من حيث وقت التشغيل قيداً جوهرياً، على الرغم من تحسيناته الملموسة في مجال العمق.

أما SABRE، فرغم تسجيله أعلى متوسط لعمق الدائرة، فقد حقق أدنى متوسط لعدد البوابات، تلاه مُصرِّف الذكاء الاصطناعي عن قرب. يتسق هذا مع تصميم الأسلوب الاستكشافي لـ SABRE، الذي يُولي الأولوية لتقليل عدد البوابات مباشرةً. في المقابل، يمتلك Rustiq رغم تميزه في تخفيض العمق أعلى متوسط لعدد البوابات، وهي مقايضة جديرة بالاعتبار في التطبيقات التي يُعدّ فيها حجم الدائرة أهم من مدتها الزمنية.

### ملخص {#summary}

في حين يُقدم مُصرِّف الذكاء الاصطناعي بوجه عام نتائج أفضل من SABRE، لا سيما من حيث عمق الدائرة، لا ينبغي أن يكون الاستنتاج ببساطة "استخدم دائماً مُصرِّف الذكاء الاصطناعي". ثمة فروق دقيقة مهمة ينبغي مراعاتها:

- **مُصرِّف الذكاء الاصطناعي** موثوق بشكل عام ويُنتج دوائر محسَّنة من حيث العمق، لكنه ينطوي على مقايضات تتعلق بوقت التشغيل، فضلاً عن قيود أخرى تشمل خرائط الاقتران المدعومة وإمكانات التركيب. وتُفصَّل هذه التفاصيل في [توثيق Qiskit Transpiler Service](/guides/qiskit-transpiler-service).

- في بعض الحالات، لا سيما مع الدوائر الكبيرة جداً أو الدوائر المُصمَّمة لأجهزة بعينها، قد لا يكون مُصرِّف الذكاء الاصطناعي بالغ الفاعلية. في هذه الحالات، يظل مُصرِّف SABRE الافتراضي موثوقاً للغاية، ويمكن تحسينه بضبط معاملاته (راجع [درس تحسينات SABRE](/tutorials/transpilation-optimizations-with-sabre)).

- من المهم أيضاً مراعاة بنية الدائرة عند اختيار الطريقة المناسبة. على سبيل المثال، صُمِّم `rustiq` خصيصاً للدوائر التي تتضمن `PauliEvolutionGate`، وغالباً ما يُحقق أفضل أداء في مسائل محاكاة هاميلتونيان.

**التوصية:**
> لا توجد استراتيجية تصريف واحدة تناسب جميع الحالات. يُشجَّع المستخدمون على فهم بنية دوائرهم واختبار طرق تصريف متعددة — بما فيها الذكاء الاصطناعي وSABRE والأدوات المتخصصة مثل Rustiq — للعثور على الحل الأكثر كفاءةً لمسألتهم المحددة وقيود أجهزتهم.

### الخطوة 3: التنفيذ باستخدام Qiskit primitives {#step-3-execute-using-qiskit-primitives}

بما أن هذا الدرس يتمحور حول التصريف، لا تُنفَّذ أي تجارب على جهاز كمومي فعلي. يتمثل الهدف في الاستفادة من تحسينات الخطوة 2 للحصول على دائرة مُصرَّفة ذات عمق وعدد بوابات مخفَّضَين.

### الخطوة 4: المعالجة اللاحقة وإرجاع النتيجة بالتنسيق الكلاسيكي المطلوب {#step-4-post-process-and-return-result-in-desired-classical-format}

نظراً لعدم وجود تنفيذ في هذا الدفتر، لا توجد نتائج تستدعي المعالجة اللاحقة.

## المراجع {#references}

[1] "LightSABRE: A Lightweight and Enhanced SABRE Algorithm". H. Zou, M. Treinish, K. Hartman, A. Ivrii, J. Lishman et al. https://arxiv.org/abs/2409.08368

[2] "Practical and efficient quantum circuit synthesis and transpiling with Reinforcement Learning". D. Kremer, V. Villar, H. Paik, I. Duran, I. Faro, J. Cruz-Benito et al. https://arxiv.org/abs/2405.13196

[3] "Pauli Network Circuit Synthesis with Reinforcement Learning". A. Dubal,  D. Kremer, S. Martiel, V. Villar, D. Wang, J. Cruz-Benito et al. https://arxiv.org/abs/2503.14448
