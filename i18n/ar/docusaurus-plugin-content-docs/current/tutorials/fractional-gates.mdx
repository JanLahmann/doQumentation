---
title: "مقدمة إلى البوابات الكسرية"
sidebar_label: "مقدمة إلى البوابات الكسرية"
description: "البوابات الكسرية هي بوابات كمومية ذات معاملات تُتيح التنفيذ المباشر للدوران بزوايا اعتباطية، مما يُقلل من عمق الدوائر الكمومية ومدتها."
notebook_path: "docs/tutorials/fractional-gates.ipynb"
---
{/* doqumentation-source-hash: 498896d0 */}

<OpenInLabBanner notebookPath="docs/tutorials/fractional-gates.ipynb" />



*تقدير الاستخدام: أقل من 30 ثانية على معالج Heron r2 (ملاحظة: هذا تقدير فحسب. قد يختلف وقت التشغيل الفعلي.)*
## الخلفية النظرية {#background}

### البوابات الكسرية على وحدات المعالجة الكمومية من IBM {#fractional-gates-on-ibm-qpus}

البوابات الكسرية هي بوابات كمومية ذات معاملات تُتيح التنفيذ المباشر للدوران بزوايا اعتباطية (ضمن حدود محددة)،
مما يُلغي الحاجة إلى تحليلها إلى بوابات أساسية متعددة.
من خلال استغلال التفاعلات الأصيلة بين البتات الكمومية الفيزيائية، يمكن للمستخدمين تطبيق وحدات unitaries معينة بكفاءة أعلى على الأجهزة.

تدعم وحدات المعالجة الكمومية IBM Quantum&reg; Heron البوابات الكسرية التالية:
- $R_{ZZ}(\theta)$ لقيم $0 < \theta < \pi / 2$
- $R_X(\theta)$ لأي قيمة حقيقية $\theta$

يمكن لهذه البوابات أن تُقلل بشكل ملحوظ من عمق الدوائر الكمومية ومدتها.
وهي مفيدة بصفة خاصة في التطبيقات التي تعتمد بشكل كبير على $R_{ZZ}$ و $R_X$،
مثل محاكاة هاميلتوني، وخوارزمية التحسين الكمومي التقريبي (QAOA)، وطرق النواة الكمومية.
في هذا البرنامج التعليمي، نركز على النواة الكمومية كمثال تطبيقي عملي.
### القيود {#limitations}

البوابات الكسرية ميزة تجريبية في الوقت الراهن وتأتي مع بعض القيود:
- يقتصر نطاق زاوية $R_{ZZ}$ على القيم في المجال $0 < \theta < \pi / 2$.
- لا يُدعم استخدام البوابات الكسرية مع [الدوائر الديناميكية](/guides/classical-feedforward-and-control-flow)، أو [تشابك Pauli](/guides/error-mitigation-and-suppression-techniques#pauli-twirling)، أو [إلغاء الأخطاء الاحتمالي](/guides/error-mitigation-and-suppression-techniques#probabilistic-error-cancellation-pec) (PEC)، أو [استقراء الضوضاء الصفري](/guides/error-mitigation-and-suppression-techniques#zero-noise-extrapolation-zne) (ZNE) (باستخدام [تضخيم الأخطاء الاحتمالي](/guides/error-mitigation-and-suppression-techniques#probabilistic-error-amplification-pea) (PEA)).

تتطلب البوابات الكسرية سير عمل مختلفاً مقارنةً بالنهج المعياري.
يشرح هذا البرنامج التعليمي كيفية التعامل مع البوابات الكسرية من خلال تطبيق عملي.

راجع ما يلي للمزيد من التفاصيل حول البوابات الكسرية.
- [البوابات الكسرية](/guides/fractional-gates)
- [متى *لا* تستخدم البوابات الكسرية](/guides/fractional-gates#when-not-to-use)
## نظرة عامة {#overview}
يتبع سير العمل الخاص باستخدام البوابات الكسرية بشكل عام نمط [أنماط Qiskit](/guides/intro-to-patterns).
الفارق الرئيسي هو أن جميع زوايا RZZ يجب أن تستوفي الشرط $0 < \theta \leq \pi/2$.
ثمة نهجان لضمان استيفاء هذا الشرط.
يُركز هذا البرنامج التعليمي على النهج الثاني ويوصي به.

```python
# Added by doQumentation — installs packages not in the Binder environment
%pip install -q qiskit-basis-constructor
```

### 1. توليد قيم المعاملات التي تستوفي قيد زاوية RZZ {#1-generate-parameter-values-that-satisfy-the-rzz-angle-constraint}

إذا كنت متأكداً من أن جميع زوايا RZZ تقع ضمن النطاق الصحيح، فيمكنك اتباع سير عمل أنماط Qiskit المعياري.
في هذه الحالة، تُمرر قيم المعاملات ببساطة كجزء من PUB. يسير سير العمل على النحو التالي.

```python
pm = generate_preset_pass_manager(backend=backend, ...)
t_circuit = pm.run(circuit)
t_observable = observable.apply_layout(t_circuit.layout)
sampler.run([(t_circuit, parameter_values)])
estimator.run([(t_circuit, t_observable, parameter_values)])
```

إذا حاولت إرسال PUB يتضمن بوابة RZZ بزاوية خارج النطاق الصحيح، فستواجه رسالة خطأ من هذا القبيل:
```
'The instruction rzz is supported only for angles in the range [0, pi/2], but an angle (20.0) outside of this range has been requested; via parameter value(s) γ[0]=10.0, substituted in parameter expression 2.0*γ[0].'
```
لتجنب هذا الخطأ، ينبغي النظر في النهج الثاني الموضح أدناه.
### 2. تعيين قيم المعاملات للدوائر قبل عملية التحويل {#2-assign-parameter-values-to-circuits-before-transpilation}

توفر حزمة `qiskit-ibm-runtime` مرحلة تحويل متخصصة تُسمى [`FoldRzzAngle`](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/transpiler-passes-fold-rzz-angle).
تقوم هذه المرحلة بتحويل الدوائر الكمومية بحيث تستوفي جميع زوايا RZZ قيد زاوية RZZ.
إذا زوّدت الـ backend إلى `generate_preset_pass_manager` أو `transpile`، يُطبّق Qiskit تلقائياً `FoldRzzAngle` على الدوائر الكمومية.
يستلزم ذلك تعيين قيم المعاملات للدوائر الكمومية قبل عملية التحويل.
يسير سير العمل على النحو التالي.

```python
pm = generate_preset_pass_manager(backend=backend, ...)
b_circuit = circuit.assign_parameters(parameter_values)
t_circuit = pm.run(b_circuit)
t_observable = observable.apply_layout(t_circuit.layout)
sampler.run([(t_circuit,)])
estimator.run([(t_circuit, t_observable)])
```

لاحظ أن سير العمل هذا يُكبّد تكلفة حسابية أعلى مقارنةً بالنهج الأول، إذ ينطوي على تعيين قيم المعاملات للدوائر الكمومية وتخزين الدوائر المرتبطة بالمعاملات محلياً.
علاوة على ذلك، ثمة مشكلة معروفة في Qiskit حيث قد تفشل عملية تحويل بوابات RZZ في سيناريوهات معينة. للاطلاع على حل بديل، يُرجى الرجوع إلى قسم [استكشاف الأخطاء وإصلاحها](#troubleshooting).
يوضح هذا البرنامج التعليمي كيفية استخدام البوابات الكسرية عبر النهج الثاني من خلال مثال مستوحى من طريقة النواة الكمومية.
لفهم أعمق لحالات الاستخدام الأمثل للنوى الكمومية، نوصي بقراءة [Liu, Arunachalam & Temme (2021).](https://www.nature.com/articles/s41567-021-01287-z)

يمكنك أيضاً العمل على البرنامج التعليمي [تدريب النواة الكمومية](/tutorials/quantum-kernel-training) ودرس [النوى الكمومية](/learning/courses/quantum-machine-learning/quantum-kernel-methods) في دورة تعلم الآلة الكمومية على IBM Quantum Learning.
### المتطلبات {#requirements}

قبل البدء في هذا البرنامج التعليمي، تأكد من تثبيت ما يلي:
- Qiskit SDK الإصدار v2.0 أو أحدث، مع دعم [التصور البصري](https://docs.quantum.ibm.com/api/qiskit/visualization)
- Qiskit Runtime الإصدار v0.37 أو أحدث (`pip install qiskit-ibm-runtime`)
- Qiskit Basis Constructor (`pip install qiskit_basis_constructor`)
### الإعداد {#setup}

```python
import matplotlib.pyplot as plt
import numpy as np
from qiskit import QuantumCircuit, generate_preset_pass_manager
from qiskit.circuit import ParameterVector
from qiskit.circuit.library import unitary_overlap
from qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2
```

### تفعيل البوابات الكسرية والتحقق من البوابات الأساسية {#enable-fractional-gates-and-check-basis-gates}

لاستخدام البوابات الكسرية، يمكنك الحصول على backend يدعمها عبر ضبط الخيار `use_fractional_gates=True`.
إذا كان الـ backend يدعم البوابات الكسرية، فستجد `rzz` و `rx` مُدرجتين ضمن بواباته الأساسية.

```python
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=133
)  # backend should be a heron device or later
backend_name = backend.name
backend_c = service.backend(backend_name)  # w/o fractional gates
backend_f = service.backend(
    backend_name, use_fractional_gates=True
)  # w/ fractional gates
print(f"Backend: {backend_name}")
print(f"No fractional gates: {backend_c.basis_gates}")
print(f"With fractional gates: {backend_f.basis_gates}")
if "rzz" not in backend_f.basis_gates:
    print(f"Backend {backend_name} does not support fractional gates")
```

```text
Backend: ibm_fez
No fractional gates: ['cz', 'id', 'rz', 'sx', 'x']
With fractional gates: ['cz', 'id', 'rx', 'rz', 'rzz', 'sx', 'x']
```

## سير العمل مع البوابات الكسرية {#workflow-with-fractional-gates}
### الخطوة 1: تعيين المدخلات الكلاسيكية إلى مسألة كمومية {#step-1-map-classical-inputs-to-quantum-problem}

#### دائرة النواة الكمومية {#quantum-kernel-circuit}
في هذا القسم، نستكشف دائرة النواة الكمومية باستخدام بوابات RZZ لتقديم سير العمل الخاص بالبوابات الكسرية.

نبدأ ببناء دائرة كمومية لحساب عناصر مصفوفة النواة بصورة فردية.
يتم ذلك من خلال دمج دوائر ZZ feature map مع تداخل وحدوي (unitary overlap).
تأخذ دالة النواة متجهات في فضاء الخريطة المميزة وتُعيد حاصل ضربها الداخلي كعنصر في مصفوفة النواة:
$$K(x, y) = \langle \Phi(x) | \Phi(y) \rangle,$$
حيث يمثل $|\Phi(x)\rangle$ الحالة الكمومية المعيّنة بالخريطة المميزة.

نبني يدوياً دائرة ZZ feature map باستخدام بوابات RZZ.
على الرغم من أن Qiskit يوفر `zz_feature_map` مدمجة، إلا أنها لا تدعم حالياً بوابات RZZ اعتباراً من Qiskit v2.0.2 ([انظر المشكلة](https://github.com/Qiskit/qiskit/issues/14469)).

بعد ذلك، نحسب دالة النواة لمدخلات متطابقة - على سبيل المثال، $K(x, x) = 1$.
على أجهزة الحوسبة الكمومية المشوشة، قد تكون هذه القيمة أقل من 1 بسبب الضوضاء.
نتيجة أقرب إلى 1 تُشير إلى ضوضاء أقل في التنفيذ.
في هذا البرنامج التعليمي، نُشير إلى هذه القيمة بـ *الإخلاص* (fidelity)، المُعرَّف بأنه
$$\text{fidelity} = K(x, x).$$

```python
optimization_level = 2
shots = 2000
reps = 3
rng = np.random.default_rng(seed=123)
```

```python
def my_zz_feature_map(num_qubits: int, reps: int = 1) -> QuantumCircuit:
    x = ParameterVector("x", num_qubits * reps)
    qc = QuantumCircuit(num_qubits)
    qc.h(range(num_qubits))
    for k in range(reps):
        K = k * num_qubits
        for i in range(num_qubits):
            qc.rz(x[i + K], i)
        pairs = [(i, i + 1) for i in range(num_qubits - 1)]
        for i, j in pairs[0::2] + pairs[1::2]:
            qc.rzz((np.pi - x[i + K]) * (np.pi - x[j + K]), i, j)
    return qc

def quantum_kernel(num_qubits: int, reps: int = 1) -> QuantumCircuit:
    qc = my_zz_feature_map(num_qubits, reps=reps)
    inner_product = unitary_overlap(qc, qc, "x", "y", insert_barrier=True)
    inner_product.measure_all()
    return inner_product

def random_parameters(inner_product: QuantumCircuit) -> np.ndarray:
    return np.tile(rng.random(inner_product.num_parameters // 2), 2)

def fidelity(result) -> float:
    ba = result.data.meas
    return ba.get_int_counts().get(0, 0) / ba.num_shots
```

تُولَّد دوائر النواة الكمومية وقيم معاملاتها المقابلة لأنظمة تتراوح من 4 إلى 40 بتة كمومية، ثم يُقيَّم إخلاصها لاحقاً.

```python
qubits = list(range(4, 44, 4))
circuits = [quantum_kernel(i, reps=reps) for i in qubits]
params = [random_parameters(circ) for circ in circuits]
```

تُعرض دائرة البتات الكمومية الأربع في الشكل أدناه.

```python
circuits[0].draw("mpl", fold=-1)
```

![Output of the previous code cell](/docs/images/tutorials/fractional-gates/extracted-outputs/b3d6341a-0.avif)

في سير عمل أنماط Qiskit المعياري، تُمرَّر قيم المعاملات عادةً إلى Sampler أو Estimator كجزء من PUB.
غير أنه عند استخدام backend يدعم البوابات الكسرية، يجب تعيين قيم المعاملات هذه صراحةً إلى الدائرة الكمومية قبل عملية التحويل.

```python
b_qc = [
    circ.assign_parameters(param) for circ, param in zip(circuits, params)
]
b_qc[0].draw("mpl", fold=-1)
```

![Output of the previous code cell](/docs/images/tutorials/fractional-gates/extracted-outputs/6c9c1977-0.avif)

### الخطوة 2: تحسين المسألة لتنفيذها على الأجهزة الكمومية {#step-2-optimize-problem-for-quantum-hardware-execution}
نُحوّل بعد ذلك الدائرة باستخدام مدير المراحل وفق نمط Qiskit المعياري.
من خلال تزويد `generate_preset_pass_manager` بـ backend يدعم البوابات الكسرية، تُضاف تلقائياً مرحلة متخصصة تُسمى `FoldRzzAngle`.
تُعدّل هذه المرحلة الدائرة لتستوفي قيود زاوية RZZ.
ونتيجةً لذلك، تتحول بوابات RZZ ذات القيم السالبة في الشكل السابق إلى قيم موجبة، مع إضافة بعض بوابات X.

```python
backend_f = service.backend(name=backend_name, use_fractional_gates=True)
# pm_f includes `FoldRzzAngle` pass
pm_f = generate_preset_pass_manager(
    optimization_level=optimization_level, backend=backend_f
)
```

```python
t_qc_f = pm_f.run(b_qc)
print(t_qc_f[0].count_ops())
t_qc_f[0].draw("mpl", fold=-1)
```

```text
OrderedDict([('rz', 35), ('rzz', 18), ('x', 13), ('rx', 9), ('measure', 4), ('barrier', 2)])
```

![Output of the previous code cell](/docs/images/tutorials/fractional-gates/extracted-outputs/a18e5c70-1.avif)

لتقييم تأثير البوابات الكسرية، نقيس عدد البوابات غير المحلية (CZ و RZZ لهذا الـ backend)،
إلى جانب عمق الدوائر ومدتها، ثم نقارن هذه المقاييس بتلك الخاصة بسير العمل المعياري لاحقاً.

```python
nnl_f = [qc.num_nonlocal_gates() for qc in t_qc_f]
depth_f = [qc.depth() for qc in t_qc_f]
duration_f = [
    qc.estimate_duration(backend_f.target, unit="u") for qc in t_qc_f
]
```

### الخطوة 3: التنفيذ باستخدام Qiskit primitives {#step-3-execute-using-qiskit-primitives}
نُشغّل الدائرة المحوَّلة مع الـ backend الذي يدعم البوابات الكسرية.

```python
sampler_f = SamplerV2(mode=backend_f)
sampler_f.options.dynamical_decoupling.enable = True
sampler_f.options.dynamical_decoupling.sequence_type = "XY4"
sampler_f.options.dynamical_decoupling.skip_reset_qubits = True
```

```python
job = sampler_f.run(t_qc_f, shots=shots)
print(job.job_id())
```

```text
d4bninsi51bc738j97eg
```

### الخطوة 4: المعالجة اللاحقة وإعادة النتيجة بالصيغة الكلاسيكية المطلوبة {#step-4-post-process-and-return-result-in-desired-classical-format}
يمكنك الحصول على قيمة دالة النواة $K(x, x)$ بقياس احتمال سلسلة البتات الصفرية الكاملة `00...00` في المخرجات.

```python
# job = service.job("d1obougt0npc73flhiag")
result = job.result()
fidelity_f = [fidelity(result=res) for res in result]
print(fidelity_f)
usage_f = job.usage()
```

```text
[0.9005, 0.647, 0.3345, 0.355, 0.3315, 0.174, 0.1875, 0.149, 0.1175, 0.085]
```

## مقارنة سير العمل والدائرة بدون البوابات الكسرية {#comparison-of-workflow-and-circuit-without-fractional-gates}

في هذا القسم، نعرض سير عمل أنماط Qiskit المعياري باستخدام backend لا يدعم البوابات الكسرية.
بمقارنة الدوائر المحوَّلة، ستلاحظ أن النسخة التي تستخدم البوابات الكسرية (من القسم السابق) أكثر إيجازاً من النسخة التي لا تستخدمها.

```python
# step 1: map classical inputs to quantum problem
# `circuits` and `params` from the previous section are reused here
```

```python
# step 2: optimize circuits
backend_c = service.backend(backend_name)  # w/o fractional gates
pm_c = generate_preset_pass_manager(
    optimization_level=optimization_level, backend=backend_c
)
t_qc_c = pm_c.run(circuits)
print(t_qc_c[0].count_ops())
t_qc_c[0].draw("mpl", fold=-1)
```

```text
OrderedDict([('rz', 130), ('sx', 80), ('cz', 36), ('measure', 4), ('barrier', 2)])
```

![Output of the previous code cell](/docs/images/tutorials/fractional-gates/extracted-outputs/a10f2d95-1.avif)

```python
nnl_c = [qc.num_nonlocal_gates() for qc in t_qc_c]
depth_c = [qc.depth() for qc in t_qc_c]
duration_c = [
    qc.estimate_duration(backend_c.target, unit="u") for qc in t_qc_c
]
```

```python
# step 3: execute
sampler_c = SamplerV2(backend_c)
sampler_c.options.dynamical_decoupling.enable = True
sampler_c.options.dynamical_decoupling.sequence_type = "XY4"
sampler_c.options.dynamical_decoupling.skip_reset_qubits = True
```

```python
job = sampler_c.run(pubs=zip(t_qc_c, params), shots=shots)
print(job.job_id())
```

```text
d4bnirvnmdfs73ae3a2g
```

```python
# step 4: post-processing
# job = service.job("d1obp8j3rr0s73bg4810")
result = job.result()
fidelity_c = [fidelity(res) for res in result]
print(fidelity_c)
usage_c = job.usage()
```

```text
[0.6675, 0.5725, 0.098, 0.102, 0.065, 0.0235, 0.006, 0.0015, 0.0015, 0.002]
```

## مقارنة الأعماق والإخلاص {#comparison-of-depths-and-fidelities}

في هذا القسم، نقارن عدد البوابات غير المحلية والإخلاص بين الدوائر مع البوابات الكسرية ودونها.
يُبرز هذا الفوائد المحتملة لاستخدام البوابات الكسرية من حيث كفاءة التنفيذ وجودته.

```python
plt.plot(qubits, depth_c, "-o", label="no fractional gates")
plt.plot(qubits, depth_f, "-o", label="with fractional gates")
plt.xlabel("number of qubits")
plt.ylabel("depth")
plt.title("Comparison of depths")
plt.grid()
plt.legend()
```

```text
<matplotlib.legend.Legend at 0x12bcaac50>
```

![Output of the previous code cell](/docs/images/tutorials/fractional-gates/extracted-outputs/ef343a53-1.avif)

```python
plt.plot(qubits, duration_c, "-o", label="no fractional gates")
plt.plot(qubits, duration_f, "-o", label="with fractional gates")
plt.xlabel("number of qubits")
plt.ylabel("duration (µs)")
plt.title("Comparison of durations")
plt.grid()
plt.legend()
```

```text
<matplotlib.legend.Legend at 0x12bdef310>
```

![Output of the previous code cell](/docs/images/tutorials/fractional-gates/extracted-outputs/98bb2cd0-1.avif)

```python
plt.plot(qubits, nnl_c, "-o", label="no fractional gates")
plt.plot(qubits, nnl_f, "-o", label="with fractional gates")
plt.xlabel("number of qubits")
plt.ylabel("number of non-local gates")
plt.title("Comparison of numbers of non-local gates")
plt.grid()
plt.legend()
```

```text
<matplotlib.legend.Legend at 0x12be8ac90>
```

![Output of the previous code cell](/docs/images/tutorials/fractional-gates/extracted-outputs/1383b242-1.avif)

```python
plt.plot(qubits, fidelity_c, "-o", label="no fractional gates")
plt.plot(qubits, fidelity_f, "-o", label="with fractional gates")
plt.xlabel("number of qubits")
plt.ylabel("fidelity")
plt.title("Comparison of fidelities")
plt.grid()
plt.legend()
```

```text
<matplotlib.legend.Legend at 0x12bea8290>
```

![Output of the previous code cell](/docs/images/tutorials/fractional-gates/extracted-outputs/8b4594f5-1.avif)

نقارن وقت استخدام وحدة المعالجة الكمومية مع البوابات الكسرية ودونها. تُظهر نتائج الخلية التالية أن أوقات استخدام وحدة المعالجة الكمومية متقاربة تقريباً.

```python
print(f"no fractional gates: {usage_c} seconds")
print(f"fractional gates: {usage_f} seconds")
```

```text
no fractional gates: 7 seconds
fractional gates: 7 seconds
```

## موضوع متقدم: استخدام بوابات RX الكسرية فحسب {#advanced-topic-using-only-fractional-rx-gates}

تنبع الحاجة إلى سير العمل المعدَّل عند استخدام البوابات الكسرية أساساً من القيد المفروض على زوايا بوابة RZZ.
غير أنه إذا اقتصرت على استخدام بوابات RX الكسرية واستثنيت بوابات RZZ الكسرية، يمكنك الاستمرار في اتباع سير عمل أنماط Qiskit المعياري.
لا يزال هذا النهج يُقدّم فوائد ملموسة، لا سيما في الدوائر التي تحتوي على عدد كبير من بوابات RX وبوابات U، وذلك بتقليل عدد البوابات الإجمالي وتحسين الأداء المحتمل.
في هذا القسم، نوضح كيفية تحسين دوائرك باستخدام بوابات RX الكسرية فحسب، مع إغفال بوابات RZZ.

لدعم هذا الغرض، نوفر دالة مساعدة تُتيح لك تعطيل بوابة أساسية محددة في كائن Target.
نستخدمها هنا لتعطيل بوابات RZZ.

```python
from qiskit.circuit.library import n_local
from qiskit.transpiler import Target
```

```python
def remove_instruction_from_target(target: Target, gate_name: str) -> Target:
    new_target = Target(
        description=target.description,
        num_qubits=target.num_qubits,
        dt=target.dt,
        granularity=target.granularity,
        min_length=target.min_length,
        pulse_alignment=target.pulse_alignment,
        acquire_alignment=target.acquire_alignment,
        qubit_properties=target.qubit_properties,
        concurrent_measurements=target.concurrent_measurements,
    )

    for name, qarg_map in target.items():
        if name == gate_name:
            continue
        instruction = target.operation_from_name(name)
        if qarg_map == {None: None}:
            qarg_map = None
        new_target.add_instruction(instruction, qarg_map, name=name)
    return new_target
```

نستخدم دائرة تتكون من بوابات U و CZ و RZZ كمثال.

```python
qc = n_local(3, "u", "cz", "linear", reps=1)
qc.rzz(1.1, 0, 1)
qc.draw("mpl")
```

![Output of the previous code cell](/docs/images/tutorials/fractional-gates/extracted-outputs/6b812497-0.avif)

نُحوّل أولاً الدائرة لـ backend لا يدعم البوابات الكسرية.

```python
pm_c = generate_preset_pass_manager(
    optimization_level=optimization_level, backend=backend_c
)
t_qc = pm_c.run(qc)
print(t_qc.count_ops())
t_qc.draw("mpl")
```

```text
OrderedDict([('rz', 23), ('sx', 16), ('cz', 4)])
```

![Output of the previous code cell](/docs/images/tutorials/fractional-gates/extracted-outputs/9e8e0709-1.avif)

ثم نُحوّل الدائرة ذاتها باستخدام بوابات RX الكسرية، مع استثناء بوابات RZZ.
يُفضي ذلك إلى تخفيض طفيف في إجمالي عدد البوابات، بفضل التطبيق الأكثر كفاءة لبوابات RX.

```python
backend_f = service.backend(backend_name, use_fractional_gates=True)
target = remove_instruction_from_target(backend_f.target, "rzz")
pm_f = generate_preset_pass_manager(
    optimization_level=optimization_level,
    target=target,
)
t_qc = pm_f.run(qc)
print(t_qc.count_ops())
t_qc.draw("mpl")
```

```text
OrderedDict([('rz', 22), ('sx', 14), ('cz', 4), ('rx', 1)])
```

![Output of the previous code cell](/docs/images/tutorials/fractional-gates/extracted-outputs/db45feb0-1.avif)

### تحسين بوابات U باستخدام بوابات RX الكسرية {#optimize-u-gates-with-fractional-rx-gates}

في هذا القسم، نوضح كيفية تحسين بوابات U باستخدام بوابات RX الكسرية، بالاستناد إلى الدائرة ذاتها المُقدَّمة في القسم السابق.

ستحتاج إلى تثبيت حزمة `qiskit-basis-constructor` [package](https://github.com/Qiskit/qiskit-basis-constructor) لهذا القسم.
هذه نسخة تجريبية من مكوّن تحويل جديد لـ Qiskit، قد يُدمج في Qiskit مستقبلاً.

```python
# %pip install qiskit-basis-constructor
```

```python
from qiskit.circuit.library import UGate
from qiskit_basis_constructor import DEFAULT_EQUIVALENCE_LIBRARY
```

نُحوّل الدائرة باستخدام بوابات RX الكسرية فحسب، مع استثناء بوابات RZZ.
من خلال إدخال قاعدة تحليل مخصصة، كما هو موضح فيما يلي،
يمكن تقليل عدد البوابات أحادية البت الكمومي اللازمة لتطبيق بوابة U.

هذه الميزة قيد النقاش حالياً في هذه [مشكلة على GitHub.](https://github.com/Qiskit/qiskit/issues/13455)

```python
# special decomposition rule for UGate
x = ParameterVector("x", 3)
zxz = QuantumCircuit(1)
zxz.rz(x[2] - np.pi / 2, 0)
zxz.rx(x[0], 0)
zxz.rz(x[1] + np.pi / 2, 0)
DEFAULT_EQUIVALENCE_LIBRARY.add_equivalence(UGate(x[0], x[1], x[2]), zxz)
```

بعد ذلك، نطبق المُحوّل باستخدام ترجمة `constructor-beta` المُوفَّرة من حزمة `qiskit-basis-constructor`.
ونتيجةً لذلك، يتقلص إجمالي عدد البوابات مقارنةً بعملية التحويل السابقة.

```python
pm_f = generate_preset_pass_manager(
    optimization_level=optimization_level,
    target=target,
    translation_method="constructor-beta",
)
t_qc = pm_f.run(qc)
print(t_qc.count_ops())
t_qc.draw("mpl")
```

```text
OrderedDict([('rz', 16), ('rx', 9), ('cz', 4)])
```

![Output of the previous code cell](/docs/images/tutorials/fractional-gates/extracted-outputs/b19aae7c-1.avif)

## استكشاف الأخطاء وإصلاحها {#troubleshooting}
### المشكلة: قد تبقى زوايا RZZ غير صالحة بعد التحويل {#issue-invalid-rzz-angles-might-remain-after-transpilation}

اعتباراً من Qiskit v2.0.3، ثمة مشكلات معروفة قد تظل فيها بوابات RZZ ذات الزوايا غير الصالحة في الدوائر حتى بعد التحويل.
تنشأ المشكلة عادةً في الحالات التالية.
#### الفشل عند استخدام خيار `target` مع `generate_preset_pass_manager` أو `transpiler` {#failure-when-using-target-option-with-generate-preset-pass-manager-or-transpiler}

عند استخدام خيار `target` مع `generate_preset_pass_manager` أو `transpiler`، لا تُستدعى مرحلة التحويل المتخصصة `FoldRzzAngle`.
لضمان المعالجة الصحيحة لزوايا RZZ في البوابات الكسرية، نوصي دائماً باستخدام خيار `backend` عوضاً عن ذلك.
راجع [هذه المشكلة](https://github.com/Qiskit/qiskit/issues/14318) للمزيد من التفاصيل.
#### الفشل عندما تحتوي الدوائر على بوابات معينة {#failure-when-circuits-contain-certain-gates}

إذا احتوت دائرتك على بوابات معينة مثل `XXPlusYYGate`، فقد يُولّد مُحوّل Qiskit بوابات RZZ بزوايا غير صالحة.
إذا واجهت هذه المشكلة، راجع هذه [مشكلة GitHub](https://github.com/Qiskit/qiskit-ibm-runtime/issues/2256#issuecomment-2889487152) للاطلاع على حل بديل.
## استطلاع البرنامج التعليمي {#tutorial-survey}

يُرجى إجراء هذا الاستطلاع القصير لتقديم ملاحظاتك حول هذا البرنامج التعليمي. ستُساعدنا آراؤك في تحسين محتوانا وتجربة المستخدم.

[رابط الاستطلاع](https://your.feedback.ibm.com/jfe/form/SV_cCNiGkGX5xZMzoG)
