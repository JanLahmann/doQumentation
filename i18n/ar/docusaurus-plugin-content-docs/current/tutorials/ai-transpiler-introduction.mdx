---
title: "مقدمة إلى خدمة المُحوِّل البرمجي المدعومة بالذكاء الاصطناعي في Qiskit"
sidebar_label: "مقدمة إلى خدمة المُحوِّل البرمجي المدعومة بالذكاء الاصطناعي في Qiskit"
description: "في هذا الدفتر، سنستكشف الفوائد الرئيسية لخدمة المُحوِّل البرمجي المدعومة بالذكاء الاصطناعي في Qiskit وكيفية مقارنتها بالأساليب التقليدية."
notebook_path: "docs/tutorials/ai-transpiler-introduction.ipynb"
---
{/* doqumentation-source-hash: 3bc5a35e */}

<OpenInLabBanner notebookPath="docs/tutorials/ai-transpiler-introduction.ipynb" />



{/* cspell:ignore fontsize idxmin */}

*الاستخدام التقديري لوحدة المعالجة الكمومية (QPU): لا شيء (ملاحظة: لا يُنفِّذ هذا البرنامج التعليمي أي مهام لأنه يركز على التحويل البرمجي)*

## الخلفية {#background}

تُقدِّم **خدمة المُحوِّل البرمجي المدعومة بالذكاء الاصطناعي في Qiskit (QTS)** تحسينات قائمة على تعلم الآلة في كلٍّ من مسارات التوجيه والتوليف. صُمِّمت هذه الأوضاع المعتمدة على الذكاء الاصطناعي لمعالجة قيود التحويل البرمجي التقليدي، ولا سيما في الدوائر الكبيرة الحجم وطبولوجيات الأجهزة المعقدة.

اعتبارًا من **يوليو 2025**، تمت ترحيل **خدمة المُحوِّل البرمجي** إلى منصة IBM Quantum&reg; الجديدة ولم تعد متاحة. للاطلاع على آخر المستجدات حول حالة خدمة المُحوِّل البرمجي، يُرجى الرجوع إلى [توثيق خدمة المُحوِّل البرمجي](/guides/qiskit-transpiler-service). لا يزال بإمكانك استخدام مُحوِّل الذكاء الاصطناعي محليًا، على غرار التحويل البرمجي القياسي في Qiskit. ما عليك سوى استبدال `generate_preset_pass_manager()` بـ `generate_ai_pass_manager()`. تقوم هذه الدالة ببناء مدير مسارات يدمج مسارات التوجيه والتوليف المدعومة بالذكاء الاصطناعي مباشرةً في سير عمل التحويل البرمجي المحلي.

### الميزات الرئيسية لمسارات الذكاء الاصطناعي {#key-features-of-ai-passes}

- مسارات التوجيه: يستطيع التوجيه المدعوم بالذكاء الاصطناعي ضبط مسارات البتات الكمومية (qubits) ديناميكيًا استنادًا إلى الدائرة والواجهة الخلفية المحددة، مما يقلل الحاجة إلى بوابات SWAP الزائدة.
    - `AIRouting`: اختيار التخطيط وتوجيه الدائرة

- مسارات التوليف: تُحسِّن تقنيات الذكاء الاصطناعي تفكيك البوابات متعددة البتات الكمومية، مما يقلل من عدد بوابات البتتين الكموميتين التي تكون أكثر عرضةً للأخطاء عادةً.
    - `AICliffordSynthesis`: توليف بوابة Clifford
    - `AILinearFunctionSynthesis`: توليف دائرة الدالة الخطية
    - `AIPermutationSynthesis`: توليف دائرة التبديل
    - `AIPauliNetworkSynthesis`: توليف دائرة شبكة Pauli (متاح فقط في خدمة المُحوِّل البرمجي في Qiskit، وغير متاح في البيئة المحلية)

- المقارنة مع التحويل البرمجي التقليدي: يُعدّ مُحوِّل Qiskit القياسي أداةً متينة قادرة على التعامل مع طيف واسع من الدوائر الكمومية بفاعلية. غير أنه حين تتضخم الدوائر في حجمها أو تزداد تعقيدًا في تهيئات الأجهزة، يمكن لمسارات الذكاء الاصطناعي تحقيق مكاسب تحسين إضافية. من خلال استخدام نماذج مكتسبة للتوجيه والتوليف، تُنقِّح خدمة QTS تخطيطات الدوائر وتقلل الحمل الزائد للمهام الكمومية الصعبة أو كبيرة الحجم.

يُقيِّم هذا البرنامج التعليمي أوضاع الذكاء الاصطناعي باستخدام مسارات التوجيه والتوليف معًا، مع مقارنة النتائج بالتحويل البرمجي التقليدي لإبراز المجالات التي يُحقق فيها الذكاء الاصطناعي مكاسب في الأداء.

لمزيد من التفاصيل حول مسارات الذكاء الاصطناعي المتاحة، راجع [توثيق مسارات الذكاء الاصطناعي](/guides/ai-transpiler-passes).

### لماذا نستخدم الذكاء الاصطناعي في التحويل البرمجي للدوائر الكمومية؟ {#why-use-ai-for-quantum-circuit-transpilation}

مع تنامي حجم الدوائر الكمومية وتعقيدها، تجد أساليب التحويل البرمجي التقليدية صعوبةً متزايدة في تحسين التخطيطات وخفض أعداد البوابات بكفاءة. تفرض الدوائر الكبيرة، ولا سيما تلك التي تضم مئات البتات الكمومية، تحديات جسيمة على التوجيه والتوليف بسبب قيود الأجهزة والاتصالية المحدودة ومعدلات أخطاء البتات الكمومية.

هنا يبرز التحويل البرمجي المدعوم بالذكاء الاصطناعي بوصفه حلًا محتملًا. من خلال توظيف تقنيات تعلم الآلة، يستطيع المُحوِّل المدعوم بالذكاء الاصطناعي في Qiskit اتخاذ قرارات أكثر ذكاءً بشأن توجيه البتات الكمومية وتوليف البوابات، مما يُفضي إلى تحسين أفضل للدوائر الكمومية كبيرة الحجم.

### نتائج موجزة للمقياس المرجعي {#brief-benchmarking-results}
![رسم بياني يُظهر أداء مُحوِّل الذكاء الاصطناعي مقارنةً بـ Qiskit](/docs/images/tutorials/ai-transpiler-introduction/ai-transpiler-benchmarks.avif)

في اختبارات المقياس المرجعي، أنتج مُحوِّل الذكاء الاصطناعي باستمرار دوائر أقل عمقًا وأعلى جودةً مقارنةً بمُحوِّل Qiskit القياسي. في هذه الاختبارات، استخدمنا استراتيجية مدير المسارات الافتراضية في Qiskit، المهيَّأة باستخدام [`generate_preset_passmanager`]. وفي حين تكون هذه الاستراتيجية الافتراضية فعّالة في أغلب الأحيان، إلا أنها قد تُعاني مع الدوائر الأكبر حجمًا أو الأكثر تعقيدًا. في المقابل، حقّقت المسارات المدعومة بالذكاء الاصطناعي تخفيضًا بنسبة 24% في المتوسط في أعداد بوابات البتتين الكموميتين، وتخفيضًا بنسبة 36% في عمق الدائرة للدوائر الكبيرة (أكثر من 100 بت كمومي) عند التحويل البرمجي إلى طبولوجيا heavy-hex لأجهزة IBM Quantum. للمزيد من المعلومات حول هذه المقاييس المرجعية، راجع هذه [المدونة.](https://www.ibm.com/quantum/blog/qiskit-performance)

يستكشف هذا البرنامج التعليمي الفوائد الرئيسية لمسارات الذكاء الاصطناعي وكيفية مقارنتها بالأساليب التقليدية.

```python
# Added by doQumentation — installs packages not in the Binder environment
%pip install -q qiskit-ibm-transpiler
```

```python
# This cell is hidden from users;
# it just disables a linting rule.
# ruff: noqa: F811
```

## المتطلبات {#requirements}

قبل البدء في هذا البرنامج التعليمي، تأكد من تثبيت ما يلي:

* Qiskit SDK الإصدار 1.0 أو أحدث، مع دعم [التصوير البياني](https://docs.quantum.ibm.com/api/qiskit/visualization)
* Qiskit Runtime (`pip install qiskit-ibm-runtime`) الإصدار 0.22 أو أحدث
* Qiskit IBM&reg; Transpiler مع وضع الذكاء الاصطناعي المحلي (`pip install 'qiskit-ibm-transpiler[ai-local-mode]'`)
## الإعداد {#setup}

```python
from qiskit import QuantumCircuit
from qiskit.circuit.library import efficient_su2, PermutationGate
from qiskit.synthesis.qft import synth_qft_full
from qiskit.circuit.random import random_circuit, random_clifford_circuit
from qiskit.transpiler import generate_preset_pass_manager, CouplingMap
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_transpiler import generate_ai_pass_manager
from qiskit.synthesis.permutation import (
    synth_permutation_depth_lnn_kms,
    synth_permutation_basic,
)
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import time
import logging

seed = 42

# Used for generating permutation circuits in part two for comparison
def generate_permutation_circuit(width, pattern):
    circuit = QuantumCircuit(width)
    circuit.append(
        PermutationGate(pattern=pattern),
        qargs=range(width),
    )
    return circuit

# Creates a Bernstein-Vazirani circuit given the number of qubits
def create_bv_circuit(num_qubits):
    qc = QuantumCircuit(num_qubits, num_qubits - 1)
    qc.x(num_qubits - 1)
    qc.h(qc.qubits)
    for i in range(num_qubits - 1):
        qc.cx(i, num_qubits - 1)
    qc.h(qc.qubits[:-1])
    return qc

# Transpile a circuit with a given pass manager and return metrics
def transpile_with_metrics(pass_manager, circuit):
    start = time.time()
    qc_out = pass_manager.run(circuit)
    elapsed = time.time() - start

    depth_2q = qc_out.depth(lambda x: x.operation.num_qubits == 2)
    gate_count = qc_out.size()

    return qc_out, {
        "depth_2q": depth_2q,
        "gate_count": gate_count,
        "time_s": elapsed,
    }

# Used for collecting metrics for part 3 of synthesis methods
def synth_transpile_with_metrics(qc, pm, pattern_id, method):
    start = time.time()
    qc = pm.run(qc)
    elapsed = time.time() - start

    return {
        "Pattern": pattern_id,
        "Method": method,
        "Depth (2Q)": qc.depth(lambda x: x.operation.num_qubits == 2),
        "Gates": qc.size(),
        "Time (s)": elapsed,
    }

# Ignore logs like "INFO:qiskit_ibm_transpiler.wrappers.ai_local_synthesis:Running Linear Functions AI synthesis on local mode"

logging.getLogger(
    "qiskit_ibm_transpiler.wrappers.ai_local_synthesis"
).setLevel(logging.WARNING)
```

# الجزء الأول. أنماط Qiskit {#part-i-qiskit-patterns}

لنرى الآن كيفية استخدام خدمة المُحوِّل البرمجي بالذكاء الاصطناعي مع دائرة كمومية بسيطة، باستخدام أنماط Qiskit. المفتاح هو إنشاء `PassManager` باستخدام `generate_ai_pass_manager()` بدلًا من `generate_preset_pass_manager()` القياسي.
## الخطوة 1: تعيين المدخلات الكلاسيكية إلى مسألة كمومية {#step-1-map-classical-inputs-to-a-quantum-problem}

في هذا القسم، سنختبر مُحوِّل الذكاء الاصطناعي على دائرة `efficient_su2`، وهي نموذج كفء للأجهزة شائع الاستخدام. تكتسب هذه الدائرة أهمية خاصة للخوارزميات الكمومية التغايرية (كخوارزمية VQE على سبيل المثال) ومهام التعلم الآلي الكمومي، مما يجعلها حالة اختبار مثالية لتقييم أداء التحويل البرمجي.

تتألف دائرة `efficient_su2` من طبقات متناوبة من دورانات البتة الكمومية الأحادية وبوابات التشابك مثل CNOTs. تُتيح هذه الطبقات استكشافًا مرنًا لفضاء الحالة الكمومية مع إبقاء عمق البوابات في حدود مقبولة. من خلال تحسين هذه الدائرة، نسعى إلى تقليل عدد البوابات وتحسين الدقة والحدّ من الضوضاء. مما يجعلها مرشحًا قويًا لاختبار كفاءة مُحوِّل الذكاء الاصطناعي.

```python
# For our transpilation, we will use a large circuit of 101 qubits
qc = efficient_su2(90, entanglement="circular", reps=1).decompose()

# Draw a smaller version of the circuit to get a visual representation
qc_small = efficient_su2(5, entanglement="circular", reps=1).decompose()
qc_small.draw(output="mpl")
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/c6e9c2c0-e02c-4276-bae8-d5692e60b6b8-0.avif)

## الخطوة 2: تحسين المسألة لتنفيذها على أجهزة الحوسبة الكمومية {#step-2-optimize-problem-for-quantum-hardware-execution}

### اختيار واجهة خلفية {#choose-a-backend}

في هذا المثال، نختار الواجهة الخلفية التشغيلية الأقل ازدحامًا من IBM Quantum والتي ليست محاكيًا وتمتلك ما لا يقل عن 100 بت كمومي:

**ملاحظة:** نظرًا لأن الواجهة الخلفية الأقل ازدحامًا قد تتغير بمرور الوقت، فقد تُختار أجهزة مختلفة في عمليات تشغيل مختلفة. قد تؤدي خصائص الجهاز المحددة، كخرائط الاقتران، إلى اختلافات في الدوائر المُحوَّلة برمجيًا.

```python
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=100
)
cm = backend.coupling_map
print(f"Using backend: {backend.name}")
```

```text
Using backend: ibm_torino
```

### إنشاء مديري مسارات الذكاء الاصطناعي والتقليدي {#create-ai-and-traditional-pass-managers}
لتقييم فاعلية مُحوِّل الذكاء الاصطناعي، سننفِّذ عمليتَي تحويل برمجي. أولًا، سنُحوِّل الدائرة باستخدام مُحوِّل الذكاء الاصطناعي. ثم سنُجري مقارنةً بتحويل الدائرة ذاتها دون استخدام مُحوِّل الذكاء الاصطناعي، مستخدمين الأساليب التقليدية. ستستخدم كلتا عمليتَي التحويل البرمجي خريطة الاقتران ذاتها من الواجهة الخلفية المختارة ومستوى التحسين المضبوط على 3 لإجراء مقارنة عادلة.

كلا الأسلوبَين يعكسان النهج القياسي لإنشاء نسخ `PassManager` لتحويل الدوائر برمجيًا في Qiskit.

```python
pm_ai = generate_ai_pass_manager(
    optimization_level=3,
    ai_optimization_level=3,
    coupling_map=cm,
    include_ai_synthesis=True,  # used for part 3 when comparing synthesis methods
)

pm_no_ai = generate_preset_pass_manager(
    optimization_level=3,
    coupling_map=cm,
    seed_transpiler=seed,  # note that the AI pass manager does not currently support seeding
)
```

تحويل الدوائر برمجيًا وتسجيل الأوقات.

```python
# Transpile using standard (non-AI) pass manager
_, metrics_no_ai = transpile_with_metrics(pm_no_ai, qc)
print(
    f"Standard transpilation: Depth (2q) {metrics_no_ai['depth_2q']}, "
    f"Gate count {metrics_no_ai['gate_count']}, Time {metrics_no_ai['time_s']}"
)

# Transpile using AI pass manager
_, metrics_ai = transpile_with_metrics(pm_ai, qc)
print(
    f"AI transpilation      : Depth (2q) {metrics_ai['depth_2q']}, "
    f"Gate count {metrics_ai['gate_count']}, Time {metrics_ai['time_s']}"
)
```

```text
Standard transpilation: Depth (2q) 95, Gate count 458, Time 0.04650712013244629
AI transpilation      : Depth (2q) 90, Gate count 456, Time 0.9342479705810547
```

في هذا الاختبار، نقارن أداء مُحوِّل الذكاء الاصطناعي وأسلوب التحويل البرمجي القياسي على دائرة efficient_su2. يُحقق مُحوِّل الذكاء الاصطناعي عمقًا ملحوظًا أقل للدائرة مع الحفاظ على عدد مماثل من البوابات.

- **عمق الدائرة:** يُنتج مُحوِّل الذكاء الاصطناعي دائرةً بعمق أقل للبوابات ثنائية البتات الكمومية. وهذا متوقع، إذ تُدرَّب مسارات الذكاء الاصطناعي على تحسين العمق من خلال تعلُّم أنماط تفاعل البتات الكمومية واستغلال اتصالية الأجهزة بصورة أكثر فاعليةً من الاستدلالات القائمة على القواعد.

- **عدد البوابات:** يظل إجمالي عدد البوابات متماثلًا إلى حدٍّ بعيد بين الأسلوبَين. يتوافق هذا مع التوقعات، إذ يُصغِّر التحويل البرمجي القائم على SABRE صراحةً عدد عمليات المبادلة التي تهيمن على الحمل الزائد للبوابات. في المقابل، يُعطي مُحوِّل الذكاء الاصطناعي الأولوية لعمق الدائرة الكلي وقد يُقايض أحيانًا ببضع بوابات إضافية مقابل مسار تنفيذ أقصر.

- **وقت التحويل البرمجي:** يستغرق مُحوِّل الذكاء الاصطناعي وقتًا أطول من الأسلوب القياسي. ويعود ذلك إلى التكلفة الحسابية الإضافية لاستدعاء النماذج المكتسبة أثناء التوجيه والتوليف. في المقابل، أصبح المُحوِّل القائم على SABRE أسرع بكثير بعد إعادة كتابته وتحسينه بلغة Rust، مما يوفر توجيهًا استدلاليًا عالي الكفاءة على نطاق واسع.

تجدر الإشارة إلى أن هذه النتائج مبنية على دائرة واحدة فقط. للحصول على فهم شامل لكيفية مقارنة مُحوِّل الذكاء الاصطناعي بالأساليب التقليدية، يجب اختبار مجموعة متنوعة من الدوائر. يمكن أن يتباين أداء خدمة QTS بشكل كبير تبعًا لنوع الدائرة المُحسَّنة. للاطلاع على مقارنة أشمل، راجع المقاييس المرجعية أعلاه أو زر [المدونة.](https://www.ibm.com/quantum/blog/qiskit-performance)
## الخطوة 3: التنفيذ باستخدام أوليّات Qiskit {#step-3-execute-using-qiskit-primitives}
نظرًا لأن هذا البرنامج التعليمي يركز على التحويل البرمجي، لن تُنفَّذ أي تجارب على الجهاز الكمومي. الهدف هو الاستفادة من التحسينات في الخطوة 2 للحصول على دائرة مُحوَّلة برمجيًا ذات عمق أقل أو عدد بوابات أقل.
## الخطوة 4: المعالجة اللاحقة وإرجاع النتائج بالصيغة الكلاسيكية المطلوبة {#step-4-post-process-and-return-result-in-desired-classical-format}
نظرًا لعدم وجود تنفيذ في هذا الدفتر، لا توجد نتائج لمعالجتها لاحقًا.
# الجزء الثاني. تحليل الدوائر المُحوَّلة برمجيًا وقياسها المرجعي {#part-ii-analyze-and-benchmark-the-transpiled-circuits}

في هذا القسم، سنوضِّح كيفية تحليل الدائرة المُحوَّلة برمجيًا وقياسها المرجعي مقارنةً بالنسخة الأصلية بمزيد من التفصيل. سنركز على مقاييس من قبيل عمق الدائرة وعدد البوابات ووقت التحويل البرمجي لتقييم مدى فاعلية التحسين. فضلًا عن ذلك، سنناقش كيف قد تختلف النتائج عبر أنواع مختلفة من الدوائر، مما يوفر رؤى حول الأداء العام للمُحوِّل في سيناريوهات متنوعة.

```python
# Circuits to benchmark
seed = 42
circuits = [
    {
        "name": "Random",
        "qc": random_circuit(num_qubits=30, depth=10, seed=seed),
    },
    {
        "name": "Clifford",
        "qc": random_clifford_circuit(
            num_qubits=40, num_gates=200, seed=seed
        ),
    },
    {
        "name": "QFT",
        "qc": synth_qft_full(num_qubits=20, do_swaps=False).decompose(),
    },
    {
        "name": "BV",
        "qc": create_bv_circuit(40),
    },
]

results = []

# Run the transpilation for each circuit and store the results
for circuit in circuits:
    qc_no_ai, metrics_no_ai = transpile_with_metrics(pm_no_ai, circuit["qc"])
    qc_ai, metrics_ai = transpile_with_metrics(pm_ai, circuit["qc"])

    print("Completed transpilation for", circuit["name"])

    results.append(
        {
            "Circuit": circuit["name"],
            "Depth 2Q (No AI)": metrics_no_ai["depth_2q"],
            "Gate Count (No AI)": metrics_no_ai["gate_count"],
            "Time (No AI)": metrics_no_ai["time_s"],
            "Depth 2Q (AI)": metrics_ai["depth_2q"],
            "Gate Count (AI)": metrics_ai["gate_count"],
            "Time (AI)": metrics_ai["time_s"],
        }
    )

df = pd.DataFrame(results)
df
```

```text
Completed transpilation for Random
Completed transpilation for Clifford
Completed transpilation for QFT
Completed transpilation for BV
```

```text
Circuit  Depth 2Q (No AI)  Gate Count (No AI)  Time (No AI)  \
0    Random                37                 221      0.039347
1  Clifford                36                 232      0.036633
2       QFT               165                 924      0.077458
3        BV                65                 155      0.024993

   Depth 2Q (AI)  Gate Count (AI)  Time (AI)
0             24              181   0.773718
1             43              267   1.097431
2            130              913   3.660771
3             70              155   0.345522
```

متوسط نسبة التخفيض لكل مقياس. القيم الموجبة تُمثِّل تحسينات، والسالبة تُمثِّل تراجعات.

```python
# Average reduction from non-AI to AI transpilation as a percentage
avg_reduction_depth = (
    (df["Depth 2Q (No AI)"] - df["Depth 2Q (AI)"]).mean()
    / df["Depth 2Q (No AI)"].mean()
    * 100
)
avg_reduction_gates = (
    (df["Gate Count (No AI)"] - df["Gate Count (AI)"]).mean()
    / df["Gate Count (No AI)"].mean()
    * 100
)
avg_reduction_time = (
    (df["Time (No AI)"] - df["Time (AI)"]).mean()
    / df["Time (No AI)"].mean()
    * 100
)

print(f"Average reduction in depth: {avg_reduction_depth:.2f}%")
print(f"Average reduction in gate count: {avg_reduction_gates:.2f}%")
print(f"Average reduction in transpilation time: {avg_reduction_time:.2f}%")
```

```text
Average reduction in depth: 11.88%
Average reduction in gate count: 1.04%
Average reduction in transpilation time: -3193.95%
```

```python
fig, axs = plt.subplots(1, 3, figsize=(21, 6))
df.plot(
    x="Circuit",
    y=["Depth 2Q (No AI)", "Depth 2Q (AI)"],
    kind="bar",
    ax=axs[0],
)
axs[0].set_title("Circuit Depth Comparison")
axs[0].set_ylabel("Depth")
axs[0].set_xlabel("Circuit")
axs[0].tick_params(axis="x", rotation=45)
df.plot(
    x="Circuit",
    y=["Gate Count (No AI)", "Gate Count (AI)"],
    kind="bar",
    ax=axs[1],
)
axs[1].set_title("Gate Count Comparison")
axs[1].set_ylabel("Gate Count")
axs[1].set_xlabel("Circuit")
axs[1].tick_params(axis="x", rotation=45)
df.plot(x="Circuit", y=["Time (No AI)", "Time (AI)"], kind="bar", ax=axs[2])
axs[2].set_title("Time Comparison")
axs[2].set_ylabel("Time (seconds)")
axs[2].set_xlabel("Circuit")
axs[2].tick_params(axis="x", rotation=45)
fig.suptitle(
    "Benchmarking AI transpilation vs Non-AI transpilation for various circuits"
)

plt.tight_layout()
plt.show()
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/79b8d5d9-0f9d-42ca-9583-8bec17430014-0.avif)

يتباين أداء مُحوِّل الذكاء الاصطناعي بشكل ملحوظ تبعًا لنوع الدائرة المُحسَّنة. ففي بعض الحالات، يُحقق تخفيضات بارزة في عمق الدائرة وعدد البوابات مقارنةً بالمُحوِّل القياسي. غير أن هذه التحسينات كثيرًا ما تأتي مصحوبةً بزيادة جوهرية في وقت التشغيل.

بالنسبة لأنواع معينة من الدوائر، قد يُفضي مُحوِّل الذكاء الاصطناعي إلى نتائج أفضل قليلًا من حيث عمق الدائرة، لكنه قد يؤدي أيضًا إلى زيادة في عدد البوابات وعقوبة زمنية ملموسة. تُشير هذه الملاحظات إلى أن فوائد مُحوِّل الذكاء الاصطناعي ليست موحدةً عبر جميع أنواع الدوائر، بل تعتمد فاعليته على الخصائص المحددة للدائرة، مما يجعله أكثر ملاءمةً لبعض حالات الاستخدام دون غيرها.
## متى ينبغي للمستخدمين اختيار التحويل البرمجي المدعوم بالذكاء الاصطناعي؟ {#when-should-users-choose-ai-powered-transpilation}

يتميز المُحوِّل البرمجي المدعوم بالذكاء الاصطناعي في Qiskit في السيناريوهات التي تجد فيها أساليب التحويل البرمجي التقليدية صعوبات، ولا سيما مع الدوائر الكمومية الكبيرة الحجم والمعقدة. فللدوائر التي تضم مئات البتات الكمومية أو تلك التي تستهدف أجهزةً ذات خرائط اقتران بالغة التعقيد، يوفر مُحوِّل الذكاء الاصطناعي تحسينًا متفوقًا من حيث عمق الدائرة وعدد البوابات وكفاءة وقت التشغيل. وقد تجلى ذلك باستمرار في اختبارات المقياس المرجعي، حيث تفوق على الأساليب التقليدية بتحقيق دوائر أقل عمقًا بصورة ملحوظة وتخفيض أعداد البوابات، وهو أمر بالغ الأهمية لتعزيز الأداء والتخفيف من الضوضاء على الأجهزة الكمومية الحقيقية.

ينبغي للمستخدمين التفكير في التحويل البرمجي المدعوم بالذكاء الاصطناعي عند العمل مع:
- الدوائر الكبيرة حيث تعجز الأساليب التقليدية عن التعامل بكفاءة مع هذا الحجم.
- طبولوجيات الأجهزة المعقدة حيث تنشأ تحديات في اتصالية الجهاز والتوجيه.
- التطبيقات الحساسة للأداء حيث يكون تخفيض عمق الدائرة وتحسين الدقة أمرًا بالغ الأهمية.
# الجزء الثالث. استكشاف توليف شبكة التبديل المدعوم بالذكاء الاصطناعي {#part-iii-explore-ai-powered-permutation-network-synthesis}

تُعدّ شبكات التبديل أساسيةً في الحوسبة الكمومية، ولا سيما في الأنظمة المقيَّدة بطبولوجيات محدودة. تُيسِّر هذه الشبكات التفاعلات بعيدة المدى من خلال تبديل البتات الكمومية ديناميكيًا لمحاكاة الاتصالية الشاملة على الأجهزة ذات الاتصالية المحدودة. تُعدّ مثل هذه التحويلات ضرورية لتنفيذ خوارزميات كمومية معقدة على الأجهزة قريبة المدى، حيث كثيرًا ما تمتد التفاعلات لتتجاوز الجيران الأقربين.


في هذا القسم، نُبرز تركيب شبكات التبديل (permutation networks) باعتبارها حالة استخدام مقنعة للمحوِّل البرمجي المدعوم بالذكاء الاصطناعي في Qiskit. تحديدًا، تستغل تمريرة `AIPermutationSynthesis` التحسين المدفوع بالذكاء الاصطناعي لتوليد دوائر فعّالة لمهام تبديل البتات الكمومية (qubit permutation). في المقابل، كثيرًا ما تُعاني مناهج التركيب العامة من صعوبة الموازنة بين عدد البوابات وعمق الدائرة، لا سيما في السيناريوهات ذات التفاعلات الكثيفة بين البتات الكمومية، أو عند السعي لتحقيق اتصالية كاملة (full connectivity).

سنستعرض مثالًا على أنماط Qiskit يُوضح تركيب شبكة تبديل لتحقيق اتصالية شاملة (all-to-all connectivity) لمجموعة من البتات الكمومية. سنقارن أداء `AIPermutationSynthesis` بأساليب التركيب القياسية في Qiskit. سيُظهر هذا المثال كيف يُحسِّن المحوِّل البرمجي بالذكاء الاصطناعي من حيث تقليل عمق الدائرة وعدد البوابات، مُسلِّطًا الضوء على مزاياه في سير العمل الكمومي العملي. لتفعيل تمريرة التركيب بالذكاء الاصطناعي، سنستخدم الدالة `generate_ai_pass_manager()` مع تعيين المعامل `include_ai_synthesis` على `True`.

## Step 1: Map classical inputs to a quantum problem

لتمثيل مسألة التبديل الكلاسيكية على حاسوب كمومي، نبدأ بتحديد بنية الدوائر الكمومية. في هذا المثال:

1. تهيئة الدائرة الكمومية:
   نُخصِّص 27 بتًا كموميًا لتتوافق مع النهاية الخلفية (backend) التي سنستخدمها، والتي تحتوي على 27 بتًا كموميًا.

2. تطبيق التبديلات:
   نُولِّد عشرة أنماط تبديل عشوائية (`pattern_1` إلى `pattern_10`) باستخدام بذرة ثابتة لضمان قابلية إعادة الإنتاج. يُطبَّق كل نمط تبديل على دائرة كمومية منفصلة (`qc_1` إلى `qc_10`).

3. تحليل الدائرة:
   يُحلَّل كل عملية تبديل إلى مجموعات بوابات أصلية متوافقة مع الجهاز الكمومي المستهدف. نُحلِّل العمق وعدد بوابات ثنائية البتات الكمومية (البوابات غير المحلية) لكل دائرة محلَّلة.

تُقدِّم النتائج رؤية حول تعقيد تمثيل مسائل التبديل الكلاسيكية على جهاز كمومي، مما يُوضِّح متطلبات الموارد لأنماط التبديل المختلفة.

```python
# Parameters
width = 27
num_circuits = 10

# Set random seed
np.random.seed(seed)

# Generate random patterns and circuits
patterns = [
    np.random.permutation(width).tolist() for _ in range(num_circuits)
]
circuits = {
    f"qc_{i}": generate_permutation_circuit(width, pattern)
    for i, pattern in enumerate(patterns, start=1)
}

# Display one of the circuits
circuits["qc_1"].decompose(reps=3).draw(output="mpl", fold=-1)
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/76a3e847-0808-4413-bd0c-c760cd2df3f4-0.avif)

## Step 2: Optimize problem for quantum hardware execution

في هذه الخطوة، نمضي قدمًا في التحسين باستخدام تمريرات التركيب بالذكاء الاصطناعي.

بالنسبة لتمريرات التركيب بالذكاء الاصطناعي، يتطلب `PassManager` خريطة الاقتران (coupling map) الخاصة بالنهاية الخلفية فقط. غير أن من المهم الإشارة إلى أن ليس كل خرائط الاقتران متوافقة؛ إذ لن تعمل إلا تلك التي دُرِّبت عليها تمريرة `AIPermutationSynthesis`. تدعم تمريرة `AIPermutationSynthesis` حاليًا كتلًا بأحجام 65 و33 و27 بتًا كموميًا. في هذا المثال نستخدم وحدة معالجة كمومية (QPU) من 27 بتًا كموميًا.

للمقارنة، سنُقيِّم أداء التركيب بالذكاء الاصطناعي مقابل أساليب التركيب العام للتبديل في Qiskit، بما يشمل:

- `synth_permutation_depth_lnn_kms`: تُركِّب هذه الطريقة دائرة تبديل لبنية الجار الأقرب الخطي (LNN) باستخدام خوارزمية Kutin وMoulton وSmithline (KMS). تضمن دائرة بعمق أقصاه $ n $ وحجم أقصاه $ n(n-1)/2 $، حيث يُقاس كل من العمق والحجم بوحدة بوابات SWAP.

- `synth_permutation_basic`: هذا تطبيق مباشر يُركِّب دوائر تبديل دون فرض قيود على الاتصالية أو التحسين لبنى معينة. يُعدّ خطًا أساسيًا للمقارنة مع الأساليب الأكثر تقدمًا.

تمثِّل كل من هذه الطرق نهجًا مختلفًا في تركيب شبكات التبديل، مما يُوفِّر معيار قياس شامل بالمقارنة مع الأساليب المدعومة بالذكاء الاصطناعي.

لمزيد من التفاصيل حول أساليب التركيب في Qiskit، راجع [توثيق Qiskit API](https://docs.quantum.ibm.com/api/qiskit/synthesis).

حدِّد خريطة الاقتران التي تمثِّل وحدة المعالجة الكمومية ذات 27 بتًا كموميًا.

```python
coupling_map = [
    [1, 0],
    [2, 1],
    [3, 2],
    [3, 5],
    [4, 1],
    [6, 7],
    [7, 4],
    [7, 10],
    [8, 5],
    [8, 9],
    [8, 11],
    [11, 14],
    [12, 10],
    [12, 13],
    [12, 15],
    [13, 14],
    [16, 14],
    [17, 18],
    [18, 15],
    [18, 21],
    [19, 16],
    [19, 22],
    [20, 19],
    [21, 23],
    [23, 24],
    [25, 22],
    [25, 24],
    [26, 25],
]
CouplingMap(coupling_map).draw()
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/84dff2c2-a496-4828-bb8e-08d373816a36-0.avif)

حوِّل كل دائرة تبديل باستخدام تمريرات التركيب بالذكاء الاصطناعي وأساليب التركيب العامة.

```python
results = []
pm_no_ai_synth = generate_preset_pass_manager(
    coupling_map=cm,
    optimization_level=1,  # set to 1 since we are using the synthesis methods
)

# Transpile and analyze all circuits
for i, (qc_name, qc) in enumerate(circuits.items(), start=1):
    pattern = patterns[i - 1]  # Get the corresponding pattern

    qc_depth_lnn_kms = synth_permutation_depth_lnn_kms(pattern)
    qc_basic = synth_permutation_basic(pattern)

    # AI synthesis
    results.append(
        synth_transpile_with_metrics(
            qc.decompose(reps=3),
            pm_ai,
            qc_name,
            "AI",
        )
    )

    # Depth-LNN-KMS Method
    results.append(
        synth_transpile_with_metrics(
            qc_depth_lnn_kms.decompose(reps=3),
            pm_no_ai_synth,
            qc_name,
            "Depth-LNN-KMS",
        )
    )

    # Basic Method
    results.append(
        synth_transpile_with_metrics(
            qc_basic.decompose(reps=3),
            pm_no_ai_synth,
            qc_name,
            "Basic",
        )
    )

results_df = pd.DataFrame(results)
```

سجِّل المقاييس (العمق، وعدد البوابات، والوقت) لكل دائرة بعد التحويل.

```python
# Calculate averages for each metric
average_metrics = results_df.groupby("Method")[
    ["Depth (2Q)", "Gates", "Time (s)"]
].mean()
average_metrics = average_metrics.round(3)  # Round to two decimal places
print("\n=== Average Metrics ===")
print(average_metrics)

# Identify the best non-AI method based on least average depth
non_ai_methods = [
    method for method in results_df["Method"].unique() if method != "AI"
]
best_non_ai_method = average_metrics.loc[non_ai_methods][
    "Depth (2Q)"
].idxmin()
print(
    f"\nBest Non-AI Method (based on least average depth): {best_non_ai_method}"
)

# Compare AI to the best non-AI method
ai_metrics = average_metrics.loc["AI"]
best_non_ai_metrics = average_metrics.loc[best_non_ai_method]

comparison = {
    "Metric": ["Depth (2Q)", "Gates", "Time (s)"],
    "AI": [
        ai_metrics["Depth (2Q)"],
        ai_metrics["Gates"],
        ai_metrics["Time (s)"],
    ],
    best_non_ai_method: [
        best_non_ai_metrics["Depth (2Q)"],
        best_non_ai_metrics["Gates"],
        best_non_ai_metrics["Time (s)"],
    ],
    "Improvement (AI vs Best Non-AI)": [
        ai_metrics["Depth (2Q)"] - best_non_ai_metrics["Depth (2Q)"],
        ai_metrics["Gates"] - best_non_ai_metrics["Gates"],
        ai_metrics["Time (s)"] - best_non_ai_metrics["Time (s)"],
    ],
}

comparison_df = pd.DataFrame(comparison)
print("\n=== Comparison of AI vs Best Non-AI Method ===")
comparison_df
```

```text
=== Average Metrics ===
               Depth (2Q)  Gates  Time (s)
Method
AI                   23.9   82.8     0.248
Basic                29.8   91.0     0.012
Depth-LNN-KMS        70.8  531.6     0.017

Best Non-AI Method (based on least average depth): Basic

=== Comparison of AI vs Best Non-AI Method ===
```

```text
Metric      AI   Basic  Improvement (AI vs Best Non-AI)
0  Depth (2Q)  23.900  29.800                           -5.900
1       Gates  82.800  91.000                           -8.200
2    Time (s)   0.248   0.012                            0.236
```

تُثبت النتائج أن المحوِّل البرمجي بالذكاء الاصطناعي يتفوق على جميع أساليب التركيب الأخرى في Qiskit لهذه المجموعة من دوائر التبديل العشوائية. وتتضمن النتائج الرئيسية:

1. العمق: يُحقِّق المحوِّل البرمجي بالذكاء الاصطناعي أدنى متوسط عمق، مما يدل على تحسين متميز لتخطيطات الدوائر.
2. عدد البوابات: يُقلِّص بصورة ملحوظة عدد البوابات مقارنةً بالأساليب الأخرى، مما يُحسِّن دقة التنفيذ وكفاءته.
3. وقت التحويل: تعمل جميع الأساليب بسرعة كبيرة على هذا النطاق، مما يجعلها عملية للاستخدام. بيد أن المحوِّل البرمجي بالذكاء الاصطناعي يُظهر زيادة ملحوظة في وقت التشغيل مقارنةً بالأساليب التقليدية، نظرًا لتعقيد نماذج الذكاء الاصطناعي المستخدمة.

تُرسِّخ هذه النتائج المحوِّل البرمجي بالذكاء الاصطناعي باعتباره النهج الأكثر فعالية لهذا المعيار، لا سيما فيما يخص تحسين العمق وعدد البوابات.

ارسم النتائج لمقارنة أداء تمريرات التركيب بالذكاء الاصطناعي مقابل أساليب التركيب العامة.

```python
methods = results_df["Method"].unique()

fig, axs = plt.subplots(1, 3, figsize=(18, 5))

# Pivot the DataFrame and reorder columns to ensure AI is first
pivot_depth = results_df.pivot(
    index="Pattern", columns="Method", values="Depth (2Q)"
)[["AI", "Depth-LNN-KMS", "Basic"]]
pivot_gates = results_df.pivot(
    index="Pattern", columns="Method", values="Gates"
)[["AI", "Depth-LNN-KMS", "Basic"]]
pivot_time = results_df.pivot(
    index="Pattern", columns="Method", values="Time (s)"
)[["AI", "Depth-LNN-KMS", "Basic"]]

pivot_depth.plot(kind="bar", ax=axs[0], legend=False)
axs[0].set_title("Circuit Depth Comparison")
axs[0].set_ylabel("Depth")
axs[0].set_xlabel("Pattern")
axs[0].tick_params(axis="x", rotation=45)
pivot_gates.plot(kind="bar", ax=axs[1], legend=False)
axs[1].set_title("2Q Gate Count Comparison")
axs[1].set_ylabel("Number of 2Q Gates")
axs[1].set_xlabel("Pattern")
axs[1].tick_params(axis="x", rotation=45)
pivot_time.plot(
    kind="bar", ax=axs[2], legend=True, title="Legend"
)  # Show legend on the last plot
axs[2].set_title("Time Comparison")
axs[2].set_ylabel("Time (seconds)")
axs[2].set_xlabel("Pattern")
axs[2].tick_params(axis="x", rotation=45)
fig.suptitle(
    "Benchmarking AI Synthesis Methods vs Non-AI Synthesis Methods For Random Permutations Circuits",
    fontsize=16,
    y=1,
)

plt.tight_layout()
plt.show()
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/a326f268-0115-442c-8563-968676b66670-0.avif)

يُبرز هذا الرسم البياني النتائج الفردية لكل دائرة (`qc_1` إلى `qc_10`) عبر أساليب التركيب المختلفة:

في حين تُؤكِّد هذه النتائج فعالية المحوِّل البرمجي بالذكاء الاصطناعي لدوائر التبديل، من المهم الإشارة إلى قيوده. لا يتوفر أسلوب التركيب بالذكاء الاصطناعي حاليًا إلا لخرائط اقتران معينة، مما قد يُقيِّد تطبيقه على نطاق أوسع. ينبغي مراعاة هذا القيد عند تقييم استخدامه في سيناريوهات مختلفة.

بشكل عام، يُظهر المحوِّل البرمجي بالذكاء الاصطناعي تحسينات واعدة في تحسين العمق وعدد البوابات لهذه الدوائر المحددة، مع الحفاظ على أوقات تحويل مماثلة.

## Step 3: Execute using Qiskit primitives

بما أن هذا البرنامج التعليمي يركز على التحويل البرمجي، لن تُنفَّذ أي تجارب على الجهاز الكمومي. الهدف هو الاستفادة من التحسينات في الخطوة 2 للحصول على دائرة محوَّلة ذات عمق أو عدد بوابات مُخفَّض.

## Step 4: Post-process and return result in desired classical format

نظرًا لعدم وجود تنفيذ في هذا الدفتر، لا توجد نتائج للمعالجة اللاحقة.

## Tutorial survey

يرجى إجراء هذا الاستبيان القصير لتقديم ملاحظاتك حول هذا البرنامج التعليمي. ستُساعدنا آراؤك في تحسين محتوانا وتجربة المستخدم.
