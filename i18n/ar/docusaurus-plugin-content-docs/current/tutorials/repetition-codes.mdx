---
title: "رموز التكرار"
sidebar_label: "رموز التكرار"
description: "يوضح هذا البرنامج التعليمي كيفية بناء رموز تكرار أساسية باستخدام الدوائر الديناميكية من IBM، كمثال على تصحيح الأخطاء الكمومية الأساسية (QEC)."
notebook_path: "docs/tutorials/repetition-codes.ipynb"
---

<OpenInLabBanner notebookPath="docs/tutorials/repetition-codes.ipynb" />



*تقدير الاستخدام: أقل من دقيقة واحدة على معالج Heron (ملاحظة: هذا تقدير فقط. قد يختلف وقت التشغيل الفعلي.)*

## الخلفية {#background}

لتمكين تصحيح الأخطاء الكمومية (QEC) في الوقت الفعلي، تحتاج إلى القدرة على التحكم الديناميكي في تدفق البرنامج الكمومي أثناء التنفيذ، بحيث يمكن تشريط البوابات الكمومية على نتائج القياس. يُشغّل هذا البرنامج التعليمي كود انقلاب البت، وهو شكل بسيط جداً من أشكال QEC. يوضح دائرة كمومية ديناميكية قادرة على حماية كيوبت مُشفَّر من خطأ انقلاب بت واحد، ثم يُقيّم أداء كود انقلاب البت.

يمكنك استغلال كيوبتات أنسيلا إضافية والتشابك الكمومي لقياس *المثبّتات* التي لا تحوّل المعلومات الكمومية المشفرة، مع إبلاغك في الوقت ذاته ببعض فئات الأخطاء التي ربما حدثت. يُشفّر كود المثبّت الكمومي $k$ كيوبتاً منطقياً في $n$ كيوبتاً فيزيائياً. تركّز رموز المثبّت بشكل حاسم على تصحيح مجموعة أخطاء منفصلة بدعم من مجموعة Pauli $\Pi^n$.

لمزيد من المعلومات حول QEC، راجع [Quantum Error Correction for Beginners.](https://arxiv.org/abs/0905.2794)
## المتطلبات {#requirements}

قبل البدء في هذا البرنامج التعليمي، تأكد من تثبيت ما يلي:

- Qiskit SDK الإصدار v2.0 أو أحدث، مع دعم [التصور](https://docs.quantum.ibm.com/api/qiskit/visualization)
- Qiskit Runtime الإصدار v0.40 أو أحدث (`pip install qiskit-ibm-runtime`)
## الإعداد {#setup}

```python
# Qiskit imports
from qiskit import (
    QuantumCircuit,
    QuantumRegister,
    ClassicalRegister,
)

# Qiskit Runtime
from qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler

from qiskit_ibm_runtime.circuit import MidCircuitMeasure

service = QiskitRuntimeService()
```

## الخطوة 1. تعيين المدخلات الكلاسيكية إلى مسألة كمومية {#step-1-map-classical-inputs-to-a-quantum-problem}
### بناء دائرة مثبّت انقلاب البت {#build-a-bit-flip-stabilizer-circuit}

يُعدّ كود انقلاب البت من أبسط أمثلة كود المثبّت. يحمي الحالة من خطأ انقلاب بت واحد (X) على أي من كيوبتات الترميز. بالنظر إلى تأثير خطأ انقلاب البت $X$، الذي يُحوّل $|0\rangle \rightarrow |1\rangle$ و $|1\rangle \rightarrow |0\rangle$ على أي من كيوبتاتنا، يكون $\epsilon = \{E_0, E_1, E_2 \} = \{IIX, IXI, XII\}$. يتطلب الكود خمسة كيوبتات: ثلاثة منها تُستخدم لترميز الحالة المحمية، والاثنان المتبقيان يُستخدمان كأنسيلا لقياس المثبّتات.

```python
# Choose the least busy backend that supports `measure_2`.

backend = service.least_busy(
    filters=lambda b: "measure_2" in b.supported_instructions,
    operational=True,
    simulator=False,
    dynamic_circuits=True,
)
```

```python
qreg_data = QuantumRegister(3)
qreg_measure = QuantumRegister(2)
creg_data = ClassicalRegister(3, name="data")
creg_syndrome = ClassicalRegister(2, name="syndrome")
state_data = qreg_data[0]
ancillas_data = qreg_data[1:]

def build_qc():
    """Build a typical error correction circuit"""
    return QuantumCircuit(qreg_data, qreg_measure, creg_data, creg_syndrome)

def initialize_qubits(circuit: QuantumCircuit):
    """Initialize qubit to |1>"""
    circuit.x(qreg_data[0])
    circuit.barrier(qreg_data)
    return circuit

def encode_bit_flip(circuit, state, ancillas) -> QuantumCircuit:
    """Encode bit-flip. This is done by simply adding a cx"""
    for ancilla in ancillas:
        circuit.cx(state, ancilla)
    circuit.barrier(state, *ancillas)
    return circuit

def measure_syndrome_bit(circuit, qreg_data, qreg_measure, creg_measure):
    """
    Measure the syndrome by measuring the parity.
    We reset our ancilla qubits after measuring the stabilizer
    so we can reuse them for repeated stabilizer measurements.
    Because we have already observed the state of the qubit,
    we can write the conditional reset protocol directly to
    avoid another round of qubit measurement if we used
    the `reset` instruction.
    """
    circuit.cx(qreg_data[0], qreg_measure[0])
    circuit.cx(qreg_data[1], qreg_measure[0])
    circuit.cx(qreg_data[0], qreg_measure[1])
    circuit.cx(qreg_data[2], qreg_measure[1])
    circuit.barrier(*qreg_data, *qreg_measure)
    circuit.append(MidCircuitMeasure(), [qreg_measure[0]], [creg_measure[0]])
    circuit.append(MidCircuitMeasure(), [qreg_measure[1]], [creg_measure[1]])

    with circuit.if_test((creg_measure[0], 1)):
        circuit.x(qreg_measure[0])
    with circuit.if_test((creg_measure[1], 1)):
        circuit.x(qreg_measure[1])
    circuit.barrier(*qreg_data, *qreg_measure)
    return circuit

def apply_correction_bit(circuit, qreg_data, creg_syndrome):
    """We can detect where an error occurred and correct our state"""
    with circuit.if_test((creg_syndrome, 3)):
        circuit.x(qreg_data[0])
    with circuit.if_test((creg_syndrome, 1)):
        circuit.x(qreg_data[1])
    with circuit.if_test((creg_syndrome, 2)):
        circuit.x(qreg_data[2])
    circuit.barrier(qreg_data)
    return circuit

def apply_final_readout(circuit, qreg_data, creg_data):
    """Read out the final measurements"""
    circuit.barrier(qreg_data)
    circuit.measure(qreg_data, creg_data)
    return circuit
```

```python
def build_error_correction_sequence(apply_correction: bool) -> QuantumCircuit:
    circuit = build_qc()
    circuit = initialize_qubits(circuit)
    circuit = encode_bit_flip(circuit, state_data, ancillas_data)
    circuit = measure_syndrome_bit(
        circuit, qreg_data, qreg_measure, creg_syndrome
    )

    if apply_correction:
        circuit = apply_correction_bit(circuit, qreg_data, creg_syndrome)

    circuit = apply_final_readout(circuit, qreg_data, creg_data)
    return circuit

circuit = build_error_correction_sequence(apply_correction=True)
circuit.draw(output="mpl", style="iqp", cregbundle=False)
```

![Output of the previous code cell](/docs/images/tutorials/repetition-codes/extracted-outputs/dbe02949-0.avif)

![Output of the previous code cell](/docs/images/tutorials/repetition-codes/extracted-outputs/dbe02949-1.avif)

## الخطوة 2. تحسين المسألة للتنفيذ الكمومي {#step-2-optimize-the-problem-for-quantum-execution}

لتقليل إجمالي وقت تنفيذ المهمة، تقبل عناصر Qiskit الأولية فقط الدوائر والمراقبات المطابقة للتعليمات والترابط الذي يدعمه النظام المستهدف (يُشار إليه بدوائر ومراقبات معمارية مجموعة التعليمات (ISA)).  [تعرّف على المزيد حول النقل.](/guides/transpile)
### توليد دوائر ISA {#generate-isa-circuits}

```python
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

pm = generate_preset_pass_manager(backend=backend, optimization_level=1)
 isa_circuit = pm.run(circuit)

isa_circuit.draw("mpl", style="iqp", idle_wires=False)
```

![Output of the previous code cell](/docs/images/tutorials/repetition-codes/extracted-outputs/67b55eef-0.avif)

![Output of the previous code cell](/docs/images/tutorials/repetition-codes/extracted-outputs/67b55eef-1.avif)

```python
no_correction_circuit = build_error_correction_sequence(
    apply_correction=False
)

isa_no_correction_circuit = pm.run(no_correction_circuit)
```

## الخطوة 3. التنفيذ باستخدام عناصر Qiskit الأولية {#step-3-execute-using-qiskit-primitives}
شغّل النسخة التي يُطبَّق فيها التصحيح والنسخة الأخرى بدون تصحيح.

```python
sampler_no_correction = Sampler(backend)
job_no_correction = sampler_no_correction.run(
    [isa_no_correction_circuit], shots=1000
)
result_no_correction = job_no_correction.result()[0]
```

```python
sampler_with_correction = Sampler(backend)

job_with_correction = sampler_with_correction.run([isa_circuit], shots=1000)
result_with_correction = job_with_correction.result()[0]
```

```python
print(f"Data (no correction):\n{result_no_correction.data.data.get_counts()}")
print(
    f"Syndrome (no correction):\n{result_no_correction.data.syndrome.get_counts()}"
)
```

```text
Data (no correction):
{'111': 878, '011': 42, '110': 35, '101': 40, '100': 1, '001': 2, '000': 2}
Syndrome (no correction):
{'00': 942, '10': 33, '01': 22, '11': 3}
```

```python
print(f"Data (corrected):\n{result_with_correction.data.data.get_counts()}")
print(
    f"Syndrome (corrected):\n{result_with_correction.data.syndrome.get_counts()}"
)
```

```text
Data (corrected):
{'111': 889, '110': 25, '000': 11, '011': 45, '101': 17, '010': 10, '001': 2, '100': 1}
Syndrome (corrected):
{'00': 929, '01': 39, '10': 20, '11': 12}
```

## الخطوة 4. المعالجة اللاحقة وإعادة النتيجة بالصيغة الكلاسيكية {#step-4-post-process-return-result-in-classical-format}

يمكنك أن ترى أن كود انقلاب البت اكتشف العديد من الأخطاء وصحّحها، مما أدى إلى تقليل الأخطاء الإجمالية.

```python
def decode_result(data_counts, syndrome_counts):
    shots = sum(data_counts.values())
    success_trials = data_counts.get("000", 0) + data_counts.get("111", 0)
    failed_trials = shots - success_trials
    error_correction_events = shots - syndrome_counts.get("00", 0)
    print(
        f"Bit flip errors were detected/corrected on {error_correction_events}/{shots} trials."
    )
    print(
        f"A final parity error was detected on {failed_trials}/{shots} trials."
    )
```

```python
# non-corrected marginalized results
data_result = result_no_correction.data.data.get_counts()
marginalized_syndrome_result = result_no_correction.data.syndrome.get_counts()

print(
    f"Completed bit code experiment data measurement counts (no correction): {data_result}"
)
print(
    f"Completed bit code experiment syndrome measurement counts (no correction): {marginalized_syndrome_result}"
)
decode_result(data_result, marginalized_syndrome_result)
```

```text
Completed bit code experiment data measurement counts (no correction): {'111': 878, '011': 42, '110': 35, '101': 40, '100': 1, '001': 2, '000': 2}
Completed bit code experiment syndrome measurement counts (no correction): {'00': 942, '10': 33, '01': 22, '11': 3}
Bit flip errors were detected/corrected on 58/1000 trials.
A final parity error was detected on 120/1000 trials.
```

```python
# corrected marginalized results
corrected_data_result = result_with_correction.data.data.get_counts()
corrected_syndrome_result = result_with_correction.data.syndrome.get_counts()

print(
    f"Completed bit code experiment data measurement counts (corrected): {corrected_data_result}"
)
print(
    f"Completed bit code experiment syndrome measurement counts (corrected): {corrected_syndrome_result}"
)
decode_result(corrected_data_result, corrected_syndrome_result)
```

```text
Completed bit code experiment data measurement counts (corrected): {'111': 889, '110': 25, '000': 11, '011': 45, '101': 17, '010': 10, '001': 2, '100': 1}
Completed bit code experiment syndrome measurement counts (corrected): {'00': 929, '01': 39, '10': 20, '11': 12}
Bit flip errors were detected/corrected on 71/1000 trials.
A final parity error was detected on 100/1000 trials.
```

## استطلاع البرنامج التعليمي {#tutorial-survey}

يُرجى إجراء هذا الاستطلاع القصير لتقديم ملاحظاتك حول هذا البرنامج التعليمي. ستساعدنا آراؤك في تحسين محتوانا وتجربة المستخدم.

[رابط الاستطلاع](https://your.feedback.ibm.com/jfe/form/SV_5onAlfA2Y7ac1FA)
