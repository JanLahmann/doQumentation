---
title: "Iiführig in de Qiskit KI-gstützte Transpiler-Service"
sidebar_label: "Iiführig in de Qiskit KI-gstützte Transpiler-Service"
description: "In dem Notebook schaue mir uns d' wichtigschte Vorteile vom Qiskit KI-gstützte Transpiler-Service aa un wie er sich mit traditionelle Methode vergleicht."
notebook_path: "docs/tutorials/ai-transpiler-introduction.ipynb"
---

<OpenInLabBanner notebookPath="docs/tutorials/ai-transpiler-introduction.ipynb" />



{/* cspell:ignore fontsize idxmin */}

*Gschätzte QPU-Nutzung: Kei (HINWEIS: Des Tutorial führt kei Jobs us, wil's sich uf Transpilation fokussiert)*

## Hintergrund {#hintergrund}

Dr **Qiskit KI-gstützte Transpiler-Service (QTS)** führt maschinelles-Lernen-basierti Optimierunge sowohl in Routing- als au in Synthesis-Passes ii. Die KI-Modi sin entwickelt worre, um d' Beschränkunge von dr traditionelle Transpilation azgehe, insbesondere für grossi Schaltunge un komplexe Hardware-Topologie.

Ab **Juli 2025** isch dr **Transpiler-Service** zur neue IBM Quantum&reg; Platform migriert worre un isch nit mehr verfügbar. Für d' neuschte Updates zum Status vom Transpiler-Service verwise mir uf d' [Transpiler-Service-Dokumentation](/guides/qiskit-transpiler-service). Ir chöit de KI-Transpiler witerhin lokal verwende, ähnlich wie bi dr Standard-Qiskit-Transpilation. Ersetzt eifach `generate_preset_pass_manager()` durch `generate_ai_pass_manager()`. Die Funktion konstruiert e Pass-Manager, wo d' KI-gstützte Routing- un Synthesis-Passes direkt in eire lokale Transpilations-Workflow integriert.

### Hauptmerkmal von de KI-Passes {#hauptmerkmale-der-ai-passes}

- Routing-Passes: KI-gstützts Routing ka Qubit-Pfad dynamisch basierend uf d' spezifischi Schaltung un s' Backend aapasst un de Bedarf aa übermässige SWAP-Gates reduziert.
    - `AIRouting`: Layout-Auswahl un Schaltungs-Routing

- Synthesis-Passes: KI-Technike optimiere d' Zerlegung von Multi-Qubit-Gates un minimiere d' Anzahl von de Zwei-Qubit-Gates, wo typischerwyse anfälliger für Fehler sin.
    - `AICliffordSynthesis`: Clifford-Gate-Synthese
    - `AILinearFunctionSynthesis`: Synthese von Linear-Funktionsschaltunge
    - `AIPermutationSynthesis`: Synthese von Permutationsschaltunge
    - `AIPauliNetworkSynthesis`: Synthese von Pauli-Netzwerkschaltunge (nur im Qiskit Transpiler Service verfügbar, nit in dr lokale Umgebung)

- Vergleich mit traditioneller Transpilation: Dr Standard-Qiskit-Transpiler isch e robustes Werkzeug, wo e breits Spektrum von Quanteschaltunge effektiv handhabe ka. Wenn Schaltunge aber grösser werre oder Hardware-Konfiguratione komplexer werre, chöi KI-Passes zusätzliche Optimierungsgewinn liefere. Durch d' Verwendung von glernde Modelle für Routing un Synthese verfeinert QTS Schaltungslayouts witer un reduziert de Overhead für herausfordernderi oder gross aagelegte Quanteaufgabe.

Des Tutorial evaluiert d' KI-Modi unter Verwendung sowohl von Routing- als au von Synthesis-Passes un vergleicht d' Ergebnis mit traditioneller Transpilation, um hervorzuhebe, wo KI Leistungsvorteile bietet.

Witteri Details zu de verfügbare KI-Passes findet ir in dr [KI-Passes-Dokumentation](/guides/ai-transpiler-passes).

### Warum KI für Quanteschaltungs-Transpilation verwende? {#warum-ai-für-quantenschaltungs-transpilation-verwenden}

Wil Quanteschaltunge in Gröss un Komplexität zunehmend wachse, hän traditionelle Transpilationsmethode Schwierigkeite, Layouts zu optimiere un Gate-Anzahle effizient zu reduziere. Grösseri Schaltunge, insbesondere solchi mit Hunderte von Qubits, stelle erhebliche Herausforderunge aa s' Routing un d' Synthese, wege Gerätebeschränkunge, begrenzter Konnektivität un Qubit-Fehlerraten.

Do bietet d' KI-gstützte Transpilation e potenzielli Lösung. Durch d' Nutzung von maschinelle Lerntechnike ka dr KI-gstützte Transpiler in Qiskit gscheiteri Entscheidunge über Qubit-Routing un Gate-Synthese treffe, was zu besserer Optimierung von gross aagelegte Quanteschaltunge führt.

### Kurzi Benchmarking-Ergebnis {#kurze-benchmarking-ergebnisse}
![Graph showing AI transpiler performance against Qiskit](/docs/images/tutorials/ai-transpiler-introduction/ai-transpiler-benchmarks.avif)

In Benchmarking-Tests hän dr KI-Transpiler konsistent flacheri Schaltunge höherer Qualität im Vergleich zum Standard-Qiskit-Transpiler produziert. Für die Tests hän mir d' Standard-Pass-Manager-Strategie von Qiskit verwendet, konfiguriert mit [`generate_preset_passmanager`]. Während die Standardstrategie oft effektiv isch, ka sie bi grössere oder komplexere Schaltunge Schwierigkeite hän. Im Gegensatz dazu hän KI-gstützte Passes e durchschnittlichi Reduzierig von dr Zwei-Qubit-Gate-Anzahl um 24% un e Reduzierig von dr Schaltungstiefe um 36% für grossi Schaltunge (100+ Qubits) bi dr Transpilation uf d' Heavy-Hex-Topologie von IBM Quantum Hardware erreicht. Witteri Informatione zu die Benchmarks findet ir in dem [Blog.](https://www.ibm.com/quantum/blog/qiskit-performance)

Des Tutorial untersucht d' wichtigschte Vorteile von de KI-Passes un wie se sich mit traditionelle Methode vergleiche.

```python
# Added by doQumentation — installs packages not in the Binder environment
%pip install -q qiskit-ibm-transpiler
```

```python
# This cell is hidden from users;
# it just disables a linting rule.
# ruff: noqa: F811
```

## Aforderunge {#anforderungen}

Stellt vor em Beginn von dem Tutorial sicher, dass ir Folgendes installiert hän:

* Qiskit SDK v1.0 oder höher, mit Unterstützig für [Visualisierig](https://docs.quantum.ibm.com/api/qiskit/visualization)
* Qiskit Runtime (`pip install qiskit-ibm-runtime`) v0.22 oder höher
* Qiskit IBM&reg; Transpiler mit KI-Lokalmodus(`pip install 'qiskit-ibm-transpiler[ai-local-mode]'`)

## Setup {#setup}

```python
from qiskit import QuantumCircuit
from qiskit.circuit.library import efficient_su2, PermutationGate
from qiskit.synthesis.qft import synth_qft_full
from qiskit.circuit.random import random_circuit, random_clifford_circuit
from qiskit.transpiler import generate_preset_pass_manager, CouplingMap
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_transpiler import generate_ai_pass_manager
from qiskit.synthesis.permutation import (
    synth_permutation_depth_lnn_kms,
    synth_permutation_basic,
)
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import time
import logging

seed = 42

# Used for generating permutation circuits in part two for comparison
def generate_permutation_circuit(width, pattern):
    circuit = QuantumCircuit(width)
    circuit.append(
        PermutationGate(pattern=pattern),
        qargs=range(width),
    )
    return circuit

# Creates a Bernstein-Vazirani circuit given the number of qubits
def create_bv_circuit(num_qubits):
    qc = QuantumCircuit(num_qubits, num_qubits - 1)
    qc.x(num_qubits - 1)
    qc.h(qc.qubits)
    for i in range(num_qubits - 1):
        qc.cx(i, num_qubits - 1)
    qc.h(qc.qubits[:-1])
    return qc

# Transpile a circuit with a given pass manager and return metrics
def transpile_with_metrics(pass_manager, circuit):
    start = time.time()
    qc_out = pass_manager.run(circuit)
    elapsed = time.time() - start

    depth_2q = qc_out.depth(lambda x: x.operation.num_qubits == 2)
    gate_count = qc_out.size()

    return qc_out, {
        "depth_2q": depth_2q,
        "gate_count": gate_count,
        "time_s": elapsed,
    }

# Used for collecting metrics for part 3 of synthesis methods
def synth_transpile_with_metrics(qc, pm, pattern_id, method):
    start = time.time()
    qc = pm.run(qc)
    elapsed = time.time() - start

    return {
        "Pattern": pattern_id,
        "Method": method,
        "Depth (2Q)": qc.depth(lambda x: x.operation.num_qubits == 2),
        "Gates": qc.size(),
        "Time (s)": elapsed,
    }

# Ignore logs like "INFO:qiskit_ibm_transpiler.wrappers.ai_local_synthesis:Running Linear Functions AI synthesis on local mode"

logging.getLogger(
    "qiskit_ibm_transpiler.wrappers.ai_local_synthesis"
).setLevel(logging.WARNING)
```

# Teil I. Qiskit-Muster {#teil-i-qiskit-muster}

Jetzt luege mir uns aa, wie mr de KI-Transpiler-Service mit ere einfache Quanteschaltung unter Verwendung von Qiskit-Mustere verwendet. Dr Schlüssel isch d' Erstellig von emm `PassManager` mit `generate_ai_pass_manager()` anstelle vom Standard `generate_preset_pass_manager()`.

## Schritt 1: Klassischi Iigage uf e Quanteproblem abbilden {#schritt-1-klassische-eingaben-auf-ein-quantenproblem-abbilden}

In dem Abschnitt teste mir de KI-Transpiler aa dr `efficient_su2`-Schaltung, emm wyt verbreitet hardwareeffizienten Aasatz. Die Schaltung isch besonders relevant für variationelli Quantealgorithme (zum Byschpiel VQE) un Quantum-Machine-Learning-Aufgabe, was sie zu emm ideale Testfall für d' Bewertig von dr Transpilationsleischtig macht.

D' `efficient_su2`-Schaltung besteht us abwechselnde Schichte von Ei-Qubit-Rotatione un verschränkende Gates wie CNOTs. Die Schichte ermögliche e flexible Erkundig vom Quantezustandsraum, während d' Gate-Tiefe überschaubar bliebt. Durch Optimierig von dere Schaltung welle mir d' Gate-Anzahl reduziere, d' Fidelität verbessere un Rausche minimiere. Des macht sie zu emm starke Kandidate zum Teste von dr Effizienz vom KI-Transpilers.

```python
# For our transpilation, we will use a large circuit of 101 qubits
qc = efficient_su2(90, entanglement="circular", reps=1).decompose()

# Draw a smaller version of the circuit to get a visual representation
qc_small = efficient_su2(5, entanglement="circular", reps=1).decompose()
qc_small.draw(output="mpl")
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/c6e9c2c0-e02c-4276-bae8-d5692e60b6b8-0.avif)

## Schritt 2: Problem für d' Usführig uf Quantehardware optimiere {#schritt-2-problem-für-die-ausführung-auf-quantenhardware-optimieren}

### E Backend uswähle {#ein-backend-auswählen}

Für des Byschpiel wähle mir s' am wenigschte usglaschtet betriebsberejte IBM Quantum Backend, wo kei Simulator isch un mindestens 100 Qubits hän:

**Hinweis:** Wil sich s' am wenigschte usglaschtet Backend im Laufe von dr Zyt ändere ka, chöi für verschiedeni Durchläuf unterschiedlichi Geräte usgwählt werre. Gerätespezifischi Eigenschafte, wie Coupling-Maps, chöi zu Unterschied in de transpilierte Schaltunge führe.

```python
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=100
)
cm = backend.coupling_map
print(f"Using backend: {backend.name}")
```

```text
Using backend: ibm_torino
```

### KI- un traditionelli Pass-Manager erstelle {#ai--und-traditionelle-pass-manager-erstellen}
Um d' Effektivität vom KI-Transpilers zu bewerte, führe mir zwoi Transpilationsläuf durch. Zerscht transpiliere mir d' Schaltung mit em KI-Transpiler. Derno führe mir e Vergleich durch, indem mir dieselb Schaltung ohni de KI-Transpiler mit traditionelle Methode transpiliere. Beidni Transpilationsprozesse verwende dieselb Coupling-Map vom gwählte Backend un s' Optimierungslevel wird uf 3 gsetzt, für e fairen Vergleich.

Beidni Methode spiegle de Standardaasatz zur Erstellig von `PassManager`-Instanze zur Transpilation von Schaltunge in Qiskit wider.

```python
pm_ai = generate_ai_pass_manager(
    optimization_level=3,
    ai_optimization_level=3,
    coupling_map=cm,
    include_ai_synthesis=True,  # used for part 3 when comparing synthesis methods
)

pm_no_ai = generate_preset_pass_manager(
    optimization_level=3,
    coupling_map=cm,
    seed_transpiler=seed,  # note that the AI pass manager does not currently support seeding
)
```

Transpiliert d' Schaltunge un zeichnet d' Zyte uf.

```python
# Transpile using standard (non-AI) pass manager
_, metrics_no_ai = transpile_with_metrics(pm_no_ai, qc)
print(
    f"Standard transpilation: Depth (2q) {metrics_no_ai['depth_2q']}, "
    f"Gate count {metrics_no_ai['gate_count']}, Time {metrics_no_ai['time_s']}"
)

# Transpile using AI pass manager
_, metrics_ai = transpile_with_metrics(pm_ai, qc)
print(
    f"AI transpilation      : Depth (2q) {metrics_ai['depth_2q']}, "
    f"Gate count {metrics_ai['gate_count']}, Time {metrics_ai['time_s']}"
)
```

```text
Standard transpilation: Depth (2q) 95, Gate count 458, Time 0.04650712013244629
AI transpilation      : Depth (2q) 90, Gate count 456, Time 0.9342479705810547
```

In dem Test vergleiche mir d' Leischtig vom KI-Transpiler un von dr Standard-Transpilationsmethode aa dr efficient_su2-Schaltung. Dr KI-Transpiler erreicht e merklich flacheri Schaltungstiefe bi ähnlicher Gate-Anzahl.

- **Schaltungstiefe:** Dr KI-Transpiler produziert e Schaltung mit geringerer Zwei-Qubit-Tiefe. Des isch zu erwarte, wil d' KI-Passes druf trainiert sin, d' Tiefe zu optimiere, indem sie Qubit-Interaktionsmuster lerne un Hardware-Konnektivität effektiver als regelbasierti Heuristike usnutze.

- **Gate-Anzahl:** D' Gesamt-Gate-Anzahl bliebt zwische de zwoi Methode ähnlich. Des entspricht de Erwartunge, wil d' Standard-SABRE-basierti Transpilation explizit d' Swap-Anzahl minimiert, wo de Gate-Overhead dominiert. Dr KI-Transpiler priorisiert stattdesse d' Gesamttiefe un ka gelegentlich e paar zusätzlichi Gates für e kürzere Usführungspfad iitusche.

- **Transpilationszyt:** Dr KI-Transpiler bruucht meh Zyt als d' Standardmethode. Des liegt aa de zusätzliche Rechekoscht für s' Ufrufe von glernde Modelle während vom Routing un dr Synthese. Im Gegensatz dazu isch dr SABRE-basierti Transpiler jetzt nach Neufassung un Optimierig in Rust deutlich schneller un bietet hocheffizients heuristisches Routing im grosse Maßstab.

's isch wichtig z'beachte, dass die Ergebnis nur uf ere Schaltung basiere. Um e umfassendes Verständnis davon z'chriege, wie sich dr KI-Transpiler im Vergleich zu traditionelle Methode verhält, isch es nötig, e Vielzahl von Schaltunge z'teste. D' Leischtig von QTS ka je nach Art von dr zu optimierende Schaltung stark variiere. Für e breiteren Vergleich verwise mir uf d' obige Benchmarks oder besueche de [Blog.](https://www.ibm.com/quantum/blog/qiskit-performance)

## Schritt 3: Usführig mit Qiskit Primitives {#schritt-3-ausführung-mit-qiskit-primitives}
Wil sich des Tutorial uf Transpilation konzentriert, werre kei Experimente uf em Quantegerät usgeführt. S' Ziel isch es, d' Optimierunge us Schritt 2 z'nutze, um e transpilierti Schaltung mit reduzierter Tiefe oder Gate-Anzahl z'chriege.

## Schritt 4: Nachbearbeitung un Rückgab vom Ergebnis im gwünscht klassische Format {#schritt-4-nachbearbeitung-und-rückgabe-des-ergebnisses-im-gewünschten-klassischen-format}
Wil's kei Usführig für des Notebook git, git's kei Ergebnis zur Nachbearbeitung.

# Teil II. Analyse un Benchmarking von de transpilierte Schaltunge {#teil-ii-analyse-und-benchmarking-der-transpilierten-schaltungen}

In dem Abschnitt zeige mir, wie mr d' transpilierti Schaltung analysiert un detaillierter mit dr Originalversion vergleicht. Mir konzentriere uns uf Metrike wie Schaltungstiefe, Gate-Anzahl un Transpilationszyt, um d' Effektivität von dr Optimierig z'bewerte. Zusätzlich diskutiere mir, wie d' Ergebnis über verschiedeni Schaltungstyp hii variiere chöi, un biete Einblick in d' breiteiri Leischtig vom Transpiler über verschiedeni Szenarios hii.

```python
# Circuits to benchmark
seed = 42
circuits = [
    {
        "name": "Random",
        "qc": random_circuit(num_qubits=30, depth=10, seed=seed),
    },
    {
        "name": "Clifford",
        "qc": random_clifford_circuit(
            num_qubits=40, num_gates=200, seed=seed
        ),
    },
    {
        "name": "QFT",
        "qc": synth_qft_full(num_qubits=20, do_swaps=False).decompose(),
    },
    {
        "name": "BV",
        "qc": create_bv_circuit(40),
    },
]

results = []

# Run the transpilation for each circuit and store the results
for circuit in circuits:
    qc_no_ai, metrics_no_ai = transpile_with_metrics(pm_no_ai, circuit["qc"])
    qc_ai, metrics_ai = transpile_with_metrics(pm_ai, circuit["qc"])

    print("Completed transpilation for", circuit["name"])

    results.append(
        {
            "Circuit": circuit["name"],
            "Depth 2Q (No AI)": metrics_no_ai["depth_2q"],
            "Gate Count (No AI)": metrics_no_ai["gate_count"],
            "Time (No AI)": metrics_no_ai["time_s"],
            "Depth 2Q (AI)": metrics_ai["depth_2q"],
            "Gate Count (AI)": metrics_ai["gate_count"],
            "Time (AI)": metrics_ai["time_s"],
        }
    )

df = pd.DataFrame(results)
df
```

```text
Completed transpilation for Random
Completed transpilation for Clifford
Completed transpilation for QFT
Completed transpilation for BV
```

```text
Circuit  Depth 2Q (No AI)  Gate Count (No AI)  Time (No AI)  \
0    Random                37                 221      0.039347
1  Clifford                36                 232      0.036633
2       QFT               165                 924      0.077458
3        BV                65                 155      0.024993

   Depth 2Q (AI)  Gate Count (AI)  Time (AI)
0             24              181   0.773718
1             43              267   1.097431
2            130              913   3.660771
3             70              155   0.345522
```

Durchschnittlichi prozentuale Reduzierig für jedi Metrik. Positivs sin Verbesserunge, Negativs sin Verschlechterunge.

```python
# Average reduction from non-AI to AI transpilation as a percentage
avg_reduction_depth = (
    (df["Depth 2Q (No AI)"] - df["Depth 2Q (AI)"]).mean()
    / df["Depth 2Q (No AI)"].mean()
    * 100
)
avg_reduction_gates = (
    (df["Gate Count (No AI)"] - df["Gate Count (AI)"]).mean()
    / df["Gate Count (No AI)"].mean()
    * 100
)
avg_reduction_time = (
    (df["Time (No AI)"] - df["Time (AI)"]).mean()
    / df["Time (No AI)"].mean()
    * 100
)

print(f"Average reduction in depth: {avg_reduction_depth:.2f}%")
print(f"Average reduction in gate count: {avg_reduction_gates:.2f}%")
print(f"Average reduction in transpilation time: {avg_reduction_time:.2f}%")
```

```text
Average reduction in depth: 11.88%
Average reduction in gate count: 1.04%
Average reduction in transpilation time: -3193.95%
```

```python
fig, axs = plt.subplots(1, 3, figsize=(21, 6))
df.plot(
    x="Circuit",
    y=["Depth 2Q (No AI)", "Depth 2Q (AI)"],
    kind="bar",
    ax=axs[0],
)
axs[0].set_title("Circuit Depth Comparison")
axs[0].set_ylabel("Depth")
axs[0].set_xlabel("Circuit")
axs[0].tick_params(axis="x", rotation=45)
df.plot(
    x="Circuit",
    y=["Gate Count (No AI)", "Gate Count (AI)"],
    kind="bar",
    ax=axs[1],
)
axs[1].set_title("Gate Count Comparison")
axs[1].set_ylabel("Gate Count")
axs[1].set_xlabel("Circuit")
axs[1].tick_params(axis="x", rotation=45)
df.plot(x="Circuit", y=["Time (No AI)", "Time (AI)"], kind="bar", ax=axs[2])
axs[2].set_title("Time Comparison")
axs[2].set_ylabel("Time (seconds)")
axs[2].set_xlabel("Circuit")
axs[2].tick_params(axis="x", rotation=45)
fig.suptitle(
    "Benchmarking AI transpilation vs Non-AI transpilation for various circuits"
)

plt.tight_layout()
plt.show()
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/79b8d5d9-0f9d-42ca-9583-8bec17430014-0.avif)

D' Leischtig vom KI-Transpilers variiert je nach Art von dr zu optimierende Schaltung erheblich. In manchi Fäll erreicht er bemerkenswerts Reduzierunge von dr Schaltungstiefe un Gate-Anzahl im Vergleich zum Standard-Transpiler. Die Verbesserunge gehen aber oft mit ere erhebliche Erhöhig von dr Laufzyt iher.

Für bestimmti Schaltungstyp ka dr KI-Transpiler e chli besseri Ergebnis bezüglich dr Schaltungstiefe erziige, aber au zu ere Erhöhig von dr Gate-Anzahl un ere erhebliche Laufzytstrof führe. Die Beobachtunge lege nahe, dass d' Vorteile vom KI-Transpilers nit bi alle Schaltungstyp einheitlich sin. Stattdesse hängt sini Effektivität von de spezifische Eigenschafte von dr Schaltung ab, was en für manchi Aawendungsfäll besser geignet macht als für anderi.

## Wenn sollete Benutzer KI-gstützte Transpilation wähle? {#wann-sollten-benutzer-ai-gestützte-transpilation-wählen}

Dr KI-gstützte Transpiler in Qiskit glänzt in Szenarios, wo traditionelle Transpilationsmethode Schwierigkeite hän, insbesondere bi gross aagelegte un komplexe Quanteschaltunge. Für Schaltunge mit Hunderte von Qubits oder solchi, wo uf Hardware mit komplizierte Coupling-Maps abzielet, bietet dr KI-Transpiler überlegeneri Optimierig bezüglich Schaltungstiefe, Gate-Anzahl un Laufzeiteffizienz. In Benchmarking-Tests hän er traditionelle Methode konsistent übertroff un deutlich flacheri Schaltunge geliefert un Gate-Anzahle reduziert, was für d' Verbesserig von dr Leischtig un d' Minderig von Rausche uf echter Quantehardware entscheidend isch.

Benutzer sollete KI-gstützte Transpilation in Betracht zie, wenn sie mit:
- Grosse Schaltunge arbeite, wo traditionelle Methode de Maßstab nit effizient handhabe chöi.
- Komplexe Hardware-Topologie, wo Gerätekonnektivität un Routing-Herausforderunge uftrete.
- Leistungssensitivi Aawendunge, wo d' Reduzierig von dr Schaltungstiefe un d' Verbesserig von dr Fidelität von grösster Bedeutig sin.

# Teil III. Erkundig von dr KI-gstützte Permutationsnetzwerk-Synthese {#teil-iii-erkundung-der-ai-gestützten-permutationsnetzwerk-synthese}

Permutationsnetzwerk sin grundlegend im Quantencomputing, insbesondere für Systeme, wo durch beschränkti Topologie ygschränkt sin. Die Netzwerk erleichtere Langstreckeninteraktione, indem sie Qubits dynamisch tausche, um All-to-All-Konnektivität uf Hardware mit begrenzter Konnektivität nachzuahme. Solchi Transformatione sin für d' Implementierig komplexer Quantealgorithme uf kurzfristigi Geräte unerlässlich, wo Interaktione oft über nächsti Nachbarn usgehen.

In dem Abschnitt hebe mir d' Synthese von Permutationsnetzwerk als überzeugendir Aawendungsfall für de KI-gstützte Transpiler in Qiskit hervor. Insbesondere nutzt dr `AIPermutationSynthesis`-Pass KI-gesteuerte Optimierig, um effizientisti Schaltunge für Qubit-Permutationsaufgabe z'generiere. Im Gegensatz dazu hän generischi Synthese-Aasätz oft Schwierigkeite, Gate-Anzahl un Schaltungstiefe azubalanciere, insbesondere in Szenarios mit dichti Qubit-Interaktione oder bim Versuch, volli Konnektivität z'erreiche.

Mir werre e Qiskit-Musterbyschpiel durchgeh, wo d' Synthese von emm Permutationsnetzwerk zeigt, um All-to-All-Konnektivität für e Satz von Qubits z'erreiche. Mir werre d' Leischtig von `AIPermutationSynthesis` mit de Standard-Synthesemethode in Qiskit vergleiche. Des Byschpiel wird zeige, wie dr KI-Transpiler für geringeri Schaltungstiefe un Gate-Anzahl optimiert un sini Vorteile in praktische Quanten-Workflows hervorhebt. Um de KI-Synthese-Pass z'aktiviere, verwende mir d' Funktion `generate_ai_pass_manager()` mit em Parameter `include_ai_synthesis` uf `True` gsetzt.

## Schritt 1: Klassischi Iigage uf e Quanteproblem abbilden {#schritt-1-klassische-eingaben-auf-ein-quantenproblem-abbilden-2}

Um e klassischs Permutationsproblem uf emm Quantencomputer darzustelle, fange mir mit dr Definiton von dr Struktur von de Quanteschaltunge aa. Für des Byschpiel:

1. Quanteschaltungs-Initialisierig:
   Mir wise 27 Qubits zu, um zum Backend z'passe, wo mir verwende werre, des 27 Qubits hän.

2. Permutationne aawendn:
   Mir generiere zehn zufälligi Permutationsmuster (`pattern_1` bis `pattern_10`) unter Verwendung von emm feste Seeds für Reproduzierbarkyt. Jedes Permutationsmuster wird uf e separati Quanteschaltung aagewende (`qc_1` bis `qc_10`).

3. Schaltungszerlegig:
   Jedi Permutationsoperation wird in nativs Gate-Sets zerlegt, wo mit dr Ziel-Quantehardware kompatibel sin. Mir analysiere d' Tiefe un d' Anzahl von de Zwei-Qubit-Gates (nichtlokali Gates) für jedi zerlegte Schaltung.

D' Ergebnis geben Einblick in d' Komplexität von dr Darstellig klassischer Permutationsprobleme uf emm Quantegerät un demonstriere d' Ressourceaaforderunge für verschiedeni Permutationsmuster.

```python
# Parameters
width = 27
num_circuits = 10

# Set random seed
np.random.seed(seed)

# Generate random patterns and circuits
patterns = [
    np.random.permutation(width).tolist() for _ in range(num_circuits)
]
circuits = {
    f"qc_{i}": generate_permutation_circuit(width, pattern)
    for i, pattern in enumerate(patterns, start=1)
}

# Display one of the circuits
circuits["qc_1"].decompose(reps=3).draw(output="mpl", fold=-1)
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/76a3e847-0808-4413-bd0c-c760cd2df3f4-0.avif)

## Schritt 2: Problem für d' Usführig uf Quantehardware optimiere {#schritt-2-problem-für-die-ausführung-auf-quantenhardware-optimieren-2}
In dem Schritt fahre mir mit dr Optimierig unter Verwendung von de KI-Synthese-Passes fort.

Für d' KI-Synthese-Passes bruucht dr `PassManager` nur d' Coupling-Map vom Backend. 's isch aber wichtig z'beachte, dass nit alli Coupling-Maps kompatibel sin; nur diejenige, uf dene dr `AIPermutationSynthesis`-Pass trainiert worre isch, werre funktioniere. Aktuell unterstützt dr `AIPermutationSynthesis`-Pass Blöck von de Grösse 65, 33 un 27 Qubits. Für des Byschpiel verwende mir e 27-Qubit-QPU.

Zum Vergleich werre mir d' Leischtig von dr KI-Synthese gegen generischi Permutations-Synthesemethode in Qiskit evaluiere, iibegreffe:

- `synth_permutation_depth_lnn_kms`: Die Methode synthetisiert e Permutationsschaltung für e lineare Nächste-Nachbar-(LNN)-Architektur unter Verwendung vom Kutin-, Moulton- un Smithline-(KMS)-Algorithmus. Sie garantiert e Schaltung mit ere Tiefe von höchstens $ n $ un ere Grösse von höchstens $ n(n-1)/2 $, wobei sowohl Tiefe als au Grösse in Bezug uf SWAP-Gates gmesse werre.

- `synth_permutation_basic`: Des isch e einfachi Implementierig, wo Permutationsschaltunge synthetisiert, ohni Beschränkunge für Konnektivität oder Optimierig für spezifischi Architekturen ufzuerlege. Sie dient als Basislinie für de Vergleich von dr Leischtig mit fortgschrittene Methode.

Jedi von de Methode repräsentiert e eigene Aasatz zur Synthese von Permutationsnetzwerk un bietet e umfassende Benchmark gegen d' KI-gstützte Methode.

Witteri Details zu Synthesemethode in Qiskit findet ir in dr [Qiskit-API-Dokumentation](https://docs.quantum.ibm.com/api/qiskit/synthesis).

Definiert d' Coupling-Map, wo d' 27-Qubit-QPU repräsentiert.

```python
coupling_map = [
    [1, 0],
    [2, 1],
    [3, 2],
    [3, 5],
    [4, 1],
    [6, 7],
    [7, 4],
    [7, 10],
    [8, 5],
    [8, 9],
    [8, 11],
    [11, 14],
    [12, 10],
    [12, 13],
    [12, 15],
    [13, 14],
    [16, 14],
    [17, 18],
    [18, 15],
    [18, 21],
    [19, 16],
    [19, 22],
    [20, 19],
    [21, 23],
    [23, 24],
    [25, 22],
    [25, 24],
    [26, 25],
]
CouplingMap(coupling_map).draw()
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/84dff2c2-a496-4828-bb8e-08d373816a36-0.avif)

Transpiliert jedi von de Permutationsschaltunge unter Verwendung von de KI-Synthese-Passes un generische Synthesemethode.

```python
results = []
pm_no_ai_synth = generate_preset_pass_manager(
    coupling_map=cm,
    optimization_level=1,  # set to 1 since we are using the synthesis methods
)

# Transpile and analyze all circuits
for i, (qc_name, qc) in enumerate(circuits.items(), start=1):
    pattern = patterns[i - 1]  # Get the corresponding pattern

    qc_depth_lnn_kms = synth_permutation_depth_lnn_kms(pattern)
    qc_basic = synth_permutation_basic(pattern)

    # AI synthesis
    results.append(
        synth_transpile_with_metrics(
            qc.decompose(reps=3),
            pm_ai,
            qc_name,
            "AI",
        )
    )

    # Depth-LNN-KMS Method
    results.append(
        synth_transpile_with_metrics(
            qc_depth_lnn_kms.decompose(reps=3),
            pm_no_ai_synth,
            qc_name,
            "Depth-LNN-KMS",
        )
    )

    # Basic Method
    results.append(
        synth_transpile_with_metrics(
            qc_basic.decompose(reps=3),
            pm_no_ai_synth,
            qc_name,
            "Basic",
        )
    )

results_df = pd.DataFrame(results)
```

Zeichnet d' Metrike (Tiefe, Gate-Anzahl, Zyt) für jedi Schaltung nach dr Transpilation uf.

```python
# Calculate averages for each metric
average_metrics = results_df.groupby("Method")[
    ["Depth (2Q)", "Gates", "Time (s)"]
].mean()
average_metrics = average_metrics.round(3)  # Round to two decimal places
print("\n=== Average Metrics ===")
print(average_metrics)

# Identify the best non-AI method based on least average depth
non_ai_methods = [
    method for method in results_df["Method"].unique() if method != "AI"
]
best_non_ai_method = average_metrics.loc[non_ai_methods][
    "Depth (2Q)"
].idxmin()
print(
    f"\nBest Non-AI Method (based on least average depth): {best_non_ai_method}"
)

# Compare AI to the best non-AI method
ai_metrics = average_metrics.loc["AI"]
best_non_ai_metrics = average_metrics.loc[best_non_ai_method]

comparison = {
    "Metric": ["Depth (2Q)", "Gates", "Time (s)"],
    "AI": [
        ai_metrics["Depth (2Q)"],
        ai_metrics["Gates"],
        ai_metrics["Time (s)"],
    ],
    best_non_ai_method: [
        best_non_ai_metrics["Depth (2Q)"],
        best_non_ai_metrics["Gates"],
        best_non_ai_metrics["Time (s)"],
    ],
    "Improvement (AI vs Best Non-AI)": [
        ai_metrics["Depth (2Q)"] - best_non_ai_metrics["Depth (2Q)"],
        ai_metrics["Gates"] - best_non_ai_metrics["Gates"],
        ai_metrics["Time (s)"] - best_non_ai_metrics["Time (s)"],
    ],
}

comparison_df = pd.DataFrame(comparison)
print("\n=== Comparison of AI vs Best Non-AI Method ===")
comparison_df
```

```text
=== Average Metrics ===
               Depth (2Q)  Gates  Time (s)
Method
AI                   23.9   82.8     0.248
Basic                29.8   91.0     0.012
Depth-LNN-KMS        70.8  531.6     0.017

Best Non-AI Method (based on least average depth): Basic

=== Comparison of AI vs Best Non-AI Method ===
```

```text
Metric      AI   Basic  Improvement (AI vs Best Non-AI)
0  Depth (2Q)  23.900  29.800                           -5.900
1       Gates  82.800  91.000                           -8.200
2    Time (s)   0.248   0.012                            0.236
```

D' Ergebnis zeige, dass dr KI-Transpiler alli anderi Qiskit-Synthesemethode für den Satz zufälliger Permutationsschaltunge übertrifft. Wichtigi Erkenntnisse umfasse:

1. Tiefe: Dr KI-Transpiler erreicht d' niedrigschte durchschnittlichi Tiefe, was uf überlegeneri Optimierig von Schaltungslayouts hinwyst.
2. Gate-Anzahl: Er reduziert d' Anzahl von de Gates im Vergleich zu anderi Methode erheblich un verbessert d' Usführungs-Fidelität un -Effizienz.
3. Transpilationszyt: Alli Methode laufe uf dere Skala sehr schnell, was sie praktisch insetzbar macht. Dr KI-Transpiler hän aber e bemerkenswerts Laufzyterhöhig im Vergleich zu traditionelle Methode wege dr Komplexität von de verwendete KI-Modelle.

Die Ergebnis etabliere de KI-Transpiler als de effektivschte Aasatz für den Benchmark, insbesondere für Tiefen- un Gate-Anzahl-Optimierig.

Stellt d' Ergebnis dar, um d' Leischtig von de KI-Synthese-Passes mit de generische Synthesemethode z'vergleiche.

```python
methods = results_df["Method"].unique()

fig, axs = plt.subplots(1, 3, figsize=(18, 5))

# Pivot the DataFrame and reorder columns to ensure AI is first
pivot_depth = results_df.pivot(
    index="Pattern", columns="Method", values="Depth (2Q)"
)[["AI", "Depth-LNN-KMS", "Basic"]]
pivot_gates = results_df.pivot(
    index="Pattern", columns="Method", values="Gates"
)[["AI", "Depth-LNN-KMS", "Basic"]]
pivot_time = results_df.pivot(
    index="Pattern", columns="Method", values="Time (s)"
)[["AI", "Depth-LNN-KMS", "Basic"]]

pivot_depth.plot(kind="bar", ax=axs[0], legend=False)
axs[0].set_title("Circuit Depth Comparison")
axs[0].set_ylabel("Depth")
axs[0].set_xlabel("Pattern")
axs[0].tick_params(axis="x", rotation=45)
pivot_gates.plot(kind="bar", ax=axs[1], legend=False)
axs[1].set_title("2Q Gate Count Comparison")
axs[1].set_ylabel("Number of 2Q Gates")
axs[1].set_xlabel("Pattern")
axs[1].tick_params(axis="x", rotation=45)
pivot_time.plot(
    kind="bar", ax=axs[2], legend=True, title="Legend"
)  # Show legend on the last plot
axs[2].set_title("Time Comparison")
axs[2].set_ylabel("Time (seconds)")
axs[2].set_xlabel("Pattern")
axs[2].tick_params(axis="x", rotation=45)
fig.suptitle(
    "Benchmarking AI Synthesis Methods vs Non-AI Synthesis Methods For Random Permutations Circuits",
    fontsize=16,
    y=1,
)

plt.tight_layout()
plt.show()
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/a326f268-0115-442c-8563-968676b66670-0.avif)

Des Diagramm hebt d' individuelli Ergebnis für jedi Schaltung (`qc_1` bis `qc_10`) über verschiedeni Synthesemethode hii hervor:

Während die Ergebnis d' Effektivität vom KI-Transpilers für Permutationsschaltunge unterstriche, isch es wichtig, sini Beschränkunge z'beachte. D' KI-Synthesemethode isch aktuell nur für bestimmti Coupling-Maps verfügbar, was ihri breiteiri Aawendbarkyt beschränke ka. Die Beschränkig sollet bi dr Bewertig von ihrer Verwendig in verschiedeni Szenarios berücksichtigt werre.

Insgesamt zeigt dr KI-Transpiler vielversprechendi Verbesserunge in dr Tiefen- un Gate-Anzahl-Optimierig für die spezifische Schaltunge bi vergleichbari Transpilationszyte.

## Schritt 3: Usführig mit Qiskit Primitives {#schritt-3-ausführung-mit-qiskit-primitives-2}
Wil sich des Tutorial uf Transpilation konzentriert, werre kei Experimente uf em Quantegerät usgeführt. S' Ziel isch es, d' Optimierunge us Schritt 2 z'nutze, um e transpilierti Schaltung mit reduzierter Tiefe oder Gate-Anzahl z'chriege.

## Schritt 4: Nachbearbeitung un Rückgab vom Ergebnis im gwünscht klassische Format {#schritt-4-nachbearbeitung-und-rückgabe-des-ergebnisses-im-gewünschten-klassischen-format-2}
Wil's kei Usführig für des Notebook git, git's kei Ergebnis zur Nachbearbeitung.

## Tutorial-Umfrag {#tutorial-umfrage}

Bitte machit bi dere kurze Umfrag mit, um Feedback zu dem Tutorial z'gebe. Eieri Erkenntnisse helfe uns, unser Ihaltsangebot un unseri Benutzererfahrig z'verbessere.

[Link zur Umfrag](https://your.feedback.ibm.com/jfe/form/SV_0igXMtMCQfApgDI)
