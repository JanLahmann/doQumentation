---
title: "Побудова схем"
sidebar_label: "Побудова схем"
description: "Як будувати та візуалізувати квантові схеми в Qiskit."
notebook_path: "docs/guides/construct-circuits.ipynb"
---
{/* doqumentation-source-hash: b204a29b */}

<OpenInLabBanner notebookPath="docs/guides/construct-circuits.ipynb" />



{/*
  DO NOT EDIT THIS CELL!!!
  This cell's content is generated automatically by a script. Anything you add
  here will be removed next time the notebook is run. To add new content, create
  a new cell before or after this one.
*/}

<details>
<summary><b>Версії пакетів</b></summary>

Код на цій сторінці був розроблений з використанням наступних вимог.
Ми рекомендуємо використовувати ці версії або новіші.

```
qiskit[all]~=2.3.0
```
</details>
Ця сторінка детальніше розглядає клас [`QuantumCircuit`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit) у Qiskit SDK, включаючи деякі більш просунуті методи, які ви можете використовувати для створення квантових схем.
## Що таке квантова схема? {#what-is-a-quantum-circuit}

Проста квантова схема — це колекція кубітів та список інструкцій, які діють на ці кубіти. Для демонстрації наступна комірка створює нову схему з двома новими кубітами, а потім відображає атрибут [`qubits`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#qubits) схеми, який є списком [`Qubits`](https://docs.quantum.ibm.com/api/qiskit/circuit#qiskit.circuit.Qubit) у порядку від найменш значущого біта $q_0$ до найбільш значущого біта $q_n$.

```python
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.qubits
```

```text
[<Qubit register=(2, "q"), index=0>, <Qubit register=(2, "q"), index=1>]
```

Кілька об'єктів `QuantumRegister` та `ClassicalRegister` можна об'єднати для створення схеми. Кожен [`QuantumRegister`](https://docs.quantum.ibm.com/api/qiskit/circuit#qiskit.circuit.QuantumRegister) та [`ClassicalRegister`](https://docs.quantum.ibm.com/api/qiskit/circuit#qiskit.circuit.ClassicalRegister) також може мати ім'я.

```python
from qiskit.circuit import QuantumRegister, ClassicalRegister

qr1 = QuantumRegister(2, "qreg1")  # Create a QuantumRegister with 2 qubits
qr2 = QuantumRegister(1, "qreg2")  # Create a QuantumRegister with 1 qubit
cr1 = ClassicalRegister(3, "creg1")  # Create a ClassicalRegister with 3 cbits

combined_circ = QuantumCircuit(
    qr1, qr2, cr1
)  # Create a quantum circuit with 2 QuantumRegisters and 1 ClassicalRegister
combined_circ.qubits
```

```text
[<Qubit register=(2, "qreg1"), index=0>,
 <Qubit register=(2, "qreg1"), index=1>,
 <Qubit register=(1, "qreg2"), index=0>]
```

Ви можете знайти індекс та регістр кубіта, використовуючи метод [`find_bit`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.find_bit) схеми та його атрибути.

```python
desired_qubit = qr2[0]  # Qubit 0 of register 'qreg2'

print("Index:", combined_circ.find_bit(desired_qubit).index)
print("Register:", combined_circ.find_bit(desired_qubit).registers)
```

```text
Index: 2
Register: [(QuantumRegister(1, 'qreg2'), 0)]
```

Додавання інструкції до схеми додає інструкцію до атрибуту [`data`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#data) схеми. Наступний вивід комірки показує, що `data` є списком об'єктів [`CircuitInstruction`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.CircuitInstruction), кожен з яких має атрибут `operation` та атрибут `qubits`.

```python
qc.x(0)  # Add X-gate to qubit 0
qc.data
```

```text
[CircuitInstruction(operation=Instruction(name='x', num_qubits=1, num_clbits=0, params=[]), qubits=(<Qubit register=(2, "q"), index=0>,), clbits=())]
```

Найлегший спосіб переглянути цю інформацію — через метод [`draw`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#draw), який повертає візуалізацію схеми. Дивіться [Візуалізація схем](./visualize-circuits) для різних способів відображення квантових схем.

```python
qc.draw("mpl")
```

![Output of the previous code cell](/docs/images/guides/construct-circuits/extracted-outputs/43a57258-3e33-4071-8a48-2bf127c8a5be-0.svg)

Об'єкти інструкцій схеми можуть містити схеми "визначення", які описують інструкцію в термінах більш фундаментальних інструкцій. Наприклад, [X-вентіль](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.XGate) визначається як конкретний випадок [U3-вентиля](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.U3Gate), більш загального однокубітного вентиля.

```python
# Draw definition circuit of 0th instruction in `qc`
qc.data[0].operation.definition.draw("mpl")
```

![Output of the previous code cell](/docs/images/guides/construct-circuits/extracted-outputs/653e2427-e301-4d2f-84de-1959185ace8e-0.svg)

Інструкції та схеми схожі тим, що обидва описують операції над бітами та кубітами, але вони мають різне призначення:

- Інструкції розглядаються як фіксовані, і їхні методи зазвичай повертатимуть нові інструкції (без зміни оригінального об'єкта).
- Схеми призначені для побудови впродовж багатьох рядків коду, і методи [`QuantumCircuit`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit) часто змінюють існуючий об'єкт.
### Що таке глибина схеми? {#what-is-circuit-depth}

[Глибина()](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.depth) квантової схеми є мірою кількості "шарів" квантових вентилів, виконаних паралельно, які потрібні для завершення обчислення, визначеного схемою. Оскільки квантові вентилі потребують часу для реалізації, глибина схеми приблизно відповідає кількості часу, який потрібен квантовому комп'ютеру для виконання схеми. Таким чином, глибина схеми є однією важливою величиною, яка використовується для вимірювання того, чи можна запустити квантову схему на пристрої.

Решта цієї сторінки ілюструє, як маніпулювати квантовими схемами.
## Побудова схем {#build-circuits}

Методи, такі як [`QuantumCircuit.h`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#h) та [`QuantumCircuit.cx`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#cx), додають конкретні інструкції до схем. Щоб додавати інструкції до схеми більш загально, використовуйте метод [`append`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#append). Це приймає інструкцію та список кубітів, до яких слід застосувати інструкцію. Дивіться [документацію API бібліотеки схем](https://docs.quantum.ibm.com/api/qiskit/circuit_library) для списку підтримуваних інструкцій.

```python
from qiskit.circuit.library import HGate

qc = QuantumCircuit(1)
qc.append(
    HGate(),  # New HGate instruction
    [0],  # Apply to qubit 0
)
qc.draw("mpl")
```

![Output of the previous code cell](/docs/images/guides/construct-circuits/extracted-outputs/66813cae-9841-47ea-96b7-8fd7b82e9759-0.svg)

Щоб об'єднати дві схеми, використовуйте метод [`compose`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#compose). Це приймає інший [`QuantumCircuit`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit) та необов'язковий список відображень кубітів.

<Admonition type="note">
    Метод [`compose`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#compose) повертає нову схему та **не** змінює жодну схему, на яку він діє. Щоб змінити схему, на якій ви викликаєте метод [`compose`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#compose), використовуйте аргумент `inplace=True`.
</Admonition>

```python
qc_a = QuantumCircuit(4)
qc_a.x(0)

qc_b = QuantumCircuit(2, name="qc_b")
qc_b.y(0)
qc_b.z(1)

# compose qubits (0, 1) of qc_a to qubits (1, 3) of qc_b respectively
combined = qc_a.compose(qc_b, qubits=[1, 3])
combined.draw("mpl")
```

![Output of the previous code cell](/docs/images/guides/construct-circuits/extracted-outputs/29152dfa-2275-4bc4-aadb-82185b9e0e86-0.svg)

Ви також можете захотіти скомпілювати схеми в інструкції, щоб тримати свої схеми організованими. Ви можете перетворити схему на інструкцію, використовуючи метод [`to_instruction`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#to_instruction), а потім додати це до іншої схеми, як і будь-яку іншу інструкцію. Схема, намальована в наступній комірці, функціонально еквівалентна схемі, намальованій у попередній комірці.

```python
inst = qc_b.to_instruction()
qc_a.append(inst, [1, 3])
qc_a.draw("mpl")
```

![Output of the previous code cell](/docs/images/guides/construct-circuits/extracted-outputs/81b682dd-45cb-4492-809e-d9e8ebbf5600-0.svg)

Якщо ваша схема є унітарною, ви можете перетворити її на [`Gate`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.Gate), використовуючи метод [`to_gate`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#to_gate). Об'єкти [`Gate`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.Gate) є конкретними типами інструкцій, які мають деякі додаткові функції, такі як метод [`control`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.Gate#control), який додає квантове керування.

```python
gate = qc_b.to_gate().control()
qc_a.append(gate, [0, 1, 3])
qc_a.draw("mpl")
```

![Output of the previous code cell](/docs/images/guides/construct-circuits/extracted-outputs/ed362e64-d6a4-4dfd-a5cf-5e6bdc7a81b5-0.svg)

Щоб побачити, що відбувається, ви можете використовувати метод [`decompose`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#decompose), щоб розгорнути кожну інструкцію в її визначення.

<Admonition type="note">
    Метод [`decompose`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#decompose) повертає нову схему та **не** змінює схему, на яку він діє.
</Admonition>

```python
qc_a.decompose().draw("mpl")
```

![Output of the previous code cell](/docs/images/guides/construct-circuits/extracted-outputs/3c0633db-929b-4428-a888-7a3d493bd6dd-0.svg)

<span id="measure-qubits"></span>
## Вимірювання кубітів {#measure-qubits}

Вимірювання використовуються для вибірки станів окремих кубітів та передачі результатів у класичний регістр. Зверніть увагу, що якщо ви подаєте схеми до примітиву [Sampler](./primitives#sampler), вимірювання є обов'язковими. Однак схеми, подані до примітиву [Estimator](./primitives#estimator), не повинні містити вимірювань.

Кубіти можна виміряти за допомогою трьох методів: [`measure`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#qiskit.circuit.QuantumCircuit.measure), [`measure_all`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#measure_all) та [`measure_active`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#measure_active). Щоб дізнатися, як візуалізувати виміряні результати, дивіться сторінку [Візуалізація результатів](./visualize-results).

1. `QuantumCircuit.measure` : вимірює кожен кубіт у першому аргументі на класичний біт, заданий другим аргументом. Цей метод дозволяє повний контроль над тим, де зберігається результат вимірювання.

2. `QuantumCircuit.measure_all` : не приймає аргументів і може використовуватися для квантових схем без попередньо визначених класичних бітів. Він створює класичні проводи та зберігає результати вимірювань у порядку. Наприклад, вимірювання кубіта $q_i$ зберігається в cbit $meas_i$). Він також додає бар'єр перед вимірюванням.

3. `QuantumCircuit.measure_active` : подібний до `measure_all`, але вимірює лише кубіти, які мають операції.

```python
qc1 = QuantumCircuit(2, 2)
qc1.measure(0, 1)
qc1.draw("mpl", cregbundle=False)
```

![Output of the previous code cell](/docs/images/guides/construct-circuits/extracted-outputs/0cdb2273-0.svg)

```python
qc2 = QuantumCircuit(2)
qc2.measure_all()
qc2.draw("mpl", cregbundle=False)
```

![Output of the previous code cell](/docs/images/guides/construct-circuits/extracted-outputs/6f33698c-0.svg)

```python
qc3 = QuantumCircuit(2)
qc3.x(1)
qc3.measure_active()
qc3.draw("mpl", cregbundle=False)
```

![Output of the previous code cell](/docs/images/guides/construct-circuits/extracted-outputs/ca3f225f-0.svg)

## Параметризовані схеми {#parameterized-circuits}

Багато близькочасових квантових алгоритмів включають виконання багатьох варіацій квантової схеми. Оскільки побудова та оптимізація великих схем може бути обчислювально дорогою, Qiskit підтримує **параметризовані** схеми. Ці схеми мають невизначені параметри, і їхні значення не потрібно визначати до моменту безпосередньо перед виконанням схеми. Це дозволяє вам винести побудову та оптимізацію схеми з основного циклу програми. Наступна комірка створює та відображає параметризовану схему.

```python
from qiskit.transpiler import generate_preset_pass_manager
from qiskit.circuit import Parameter

angle = Parameter("angle")  # undefined number

# Create and optimize circuit once
qc = QuantumCircuit(1)
qc.rx(angle, 0)
qc = generate_preset_pass_manager(
    optimization_level=3, basis_gates=["u", "cx"]
).run(qc)

qc.draw("mpl")
```

![Output of the previous code cell](/docs/images/guides/construct-circuits/extracted-outputs/a580552c-d585-4047-99f0-32aafd06e4f3-0.svg)

Наступна комірка створює багато варіацій цієї схеми та відображає одну з варіацій.

```python
circuits = []
for value in range(100):
    circuits.append(qc.assign_parameters({angle: value}))

circuits[0].draw("mpl")
```

![Output of the previous code cell](/docs/images/guides/construct-circuits/extracted-outputs/85af6231-921a-4130-99d3-f6998f761df8-0.svg)

Ви можете знайти список невизначених параметрів схеми в її атрибуті `parameters`.

```python
qc.parameters
```

```text
 ParameterView([Parameter(angle)])
```

### Зміна імені параметра {#change-a-parameters-name}

За замовчуванням імена параметрів для параметризованої схеми мають префікс `x` — наприклад, `x[0]`. Ви можете змінити імена після їх визначення, як показано в наступному прикладі.

```python
from qiskit.circuit.library import z_feature_map
from qiskit.circuit import ParameterVector

# Define a parameterized circuit with default names
# For example, x[0]
circuit = z_feature_map(2)

# Set new parameter names
# They will now be prefixed by `hi` instead
# For example, hi[0]
training_params = ParameterVector("hi", 2)

# Assign parameter names to the quantum circuit
circuit = circuit.assign_parameters(parameters=training_params)
```

<CodeAssistantAdmonition tagLine="Забули назву методу? Спробуйте запитати Qiskit Code Assistant." />
## Наступні кроки {#next-steps}

<Admonition type="tip" title="Рекомендації">
  -  Щоб дізнатися про близькочасові квантові алгоритми, пройдіть курс [Проектування варіаційних алгоритмів](/learning/courses/variational-algorithm-design).
  -  Подивіться приклад використання схем у підручнику [Алгоритм Гровера](/tutorials/grovers-algorithm).
  -  Працюйте з простими схемами, використовуючи [IBM Quantum Composer](/guides/composer).
</Admonition>
