---
title: "Візуалізація схем"
sidebar_label: "Візуалізація схем"
description: "Створення візуалізацій схем та побудова графіків даних завдань за допомогою модуля візуалізації Qiskit"
notebook_path: "docs/guides/visualize-circuits.ipynb"
---
{/* doqumentation-source-hash: 1353d06a */}

<OpenInLabBanner notebookPath="docs/guides/visualize-circuits.ipynb" />



{/* cspell:ignore qcircuit mactex, backgroundcolor, lightgreen */}
{/*
  DO NOT EDIT THIS CELL!!!
  This cell's content is generated automatically by a script. Anything you add
  here will be removed next time the notebook is run. To add new content, create
  a new cell before or after this one.
*/}

<details>
<summary><b>Версії пакетів</b></summary>

Код на цій сторінці був розроблений з використанням наступних вимог.
Ми рекомендуємо використовувати ці версії або новіші.

```
qiskit[all]~=2.3.0
```
</details>
Часто корисно бачити схеми, які ти створюєш. Використовуй наступні опції для відображення схем Qiskit.

```python
from qiskit import QuantumCircuit
```

## Малювання квантової схеми {#draw-a-quantum-circuit}

Клас `QuantumCircuit` підтримує малювання схем через метод `draw()` або шляхом друку об'єкта схеми. За замовчуванням обидва відтворюють версію діаграми схеми в ASCII-арті.

Зверніть увагу, що `print` повертає `None`, але має побічний ефект друку діаграми, тоді як `QuantumCircuit.draw` повертає діаграму без побічних ефектів. Оскільки Jupyter notebooks відображають вивід останнього рядка кожної комірки, вони мають однаковий ефект.

```python
# Build a quantum circuit
circuit = QuantumCircuit(3, 3)
circuit.x(1)
circuit.h(range(3))
circuit.cx(0, 1)
circuit.measure(range(3), range(3));
```

```python
print(circuit)
```

```text
┌───┐          ┌─┐
q_0: ┤ H ├───────■──┤M├───
     ├───┤┌───┐┌─┴─┐└╥┘┌─┐
q_1: ┤ X ├┤ H ├┤ X ├─╫─┤M├
     ├───┤└┬─┬┘└───┘ ║ └╥┘
q_2: ┤ H ├─┤M├───────╫──╫─
     └───┘ └╥┘       ║  ║
c: 3/═══════╩════════╩══╩═
            2        0  1
```

```python
circuit.draw()
```

```text
┌───┐          ┌─┐
q_0: ┤ H ├───────■──┤M├───
     ├───┤┌───┐┌─┴─┐└╥┘┌─┐
q_1: ┤ X ├┤ H ├┤ X ├─╫─┤M├
     ├───┤└┬─┬┘└───┘ ║ └╥┘
q_2: ┤ H ├─┤M├───────╫──╫─
     └───┘ └╥┘       ║  ║
c: 3/═══════╩════════╩══╩═
            2        0  1
```

### Альтернативні рендерери {#alternative-renderers}

Текстовий вивід корисний для швидкого перегляду виводу під час розробки схеми, але він не забезпечує найбільшої гнучкості. Є два альтернативні рендерери виводу для квантової схеми. Один використовує [Matplotlib](https://matplotlib.org/), а інший — [LaTeX](https://www.latex-project.org/). Рендерер LaTeX вимагає [пакет qcircuit](https://github.com/CQuIC/qcircuit). Виберіть ці рендерери, встановивши аргумент "output" на рядки `mpl` та `latex`.

<Admonition type="tip">
  Користувачі OSX можуть отримати необхідні пакети LaTeX через [пакет mactex](https://www.tug.org/mactex/).
</Admonition>

```python
# Matplotlib drawing
circuit.draw(output="mpl")
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/3f9c61c9-58f9-4315-a639-455fa2e58450-0.svg)

```python
# Latex drawing
circuit.draw(output="latex")
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/94948dab-57de-45f0-8dd7-5901ae69b70a-0.avif)

### Збереження виводу {#save-output}

Малювання великої схеми в Jupyter notebook може бути повільним або нечитабельним.
Ти можеш зберегти діаграму безпосередньо у файл, а потім відкрити її в програмі перегляду зображень та збільшити за потреби.

```python
# Save as an image using the Matplotlib drawer
circuit.draw(output="mpl", filename="circuit-mpl.jpeg")
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/17889caf-d953-4661-9188-00505c17064e-0.svg)

```python
# Or save a LaTeX rendering
circuit.draw(output="latex", filename="circuit-latex.pdf")
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/a36d1aa9-fa0d-4e27-ac83-5deee43a20dd-0.avif)

### Керування малюванням схем {#control-circuit-drawings}

За замовчуванням метод `draw()` повертає відтворене зображення як об'єкт і нічого не виводить. Точний клас, який повертається, залежить від вказаного виводу: `'text'` (за замовчуванням) повертає об'єкт `TextDrawer`, `'mpl'` повертає об'єкт `matplotlib.Figure`, а `latex` повертає об'єкт `PIL.Image`. Jupyter notebooks розуміють ці типи повернення та відтворюють їх належним чином, але під час роботи поза Jupyter зображення не відображатимуться автоматично.

Метод `draw()` має необов'язкові аргументи для відображення або збереження виводу. Коли вказано, kwarg `filename` приймає шлях, за яким він зберігає відтворений вивід. Альтернативно, якщо ти використовуєш виводи `mpl` або `latex`, ти можеш використовувати kwarg `interactive`, щоб відкрити зображення в новому вікні (це не завжди працюватиме з notebook).
### Налаштування виводу {#customize-the-output}

Залежно від виводу, є також опції для налаштування діаграми схеми.

#### Відключення бар'єрів побудови та зворотний порядок бітів {#disable-plot-barriers-and-reverse-bit-order}
Перші дві опції є спільними для всіх трьох backend. Вони дозволяють налаштувати як порядок бітів, так і те, чи малюєш ти бар'єри. Вони можуть бути встановлені за допомогою kwarg `reverse_bits` та kwarg `plot_barriers` відповідно. Наступні приклади працюють з будь-яким рендерером виводу; `mpl` використовується тут для стислості.

```python
from qiskit import QuantumRegister, ClassicalRegister

# Draw a new circuit with barriers and more registers
q_a = QuantumRegister(3, name="a")
q_b = QuantumRegister(5, name="b")
c_a = ClassicalRegister(3)
c_b = ClassicalRegister(5)

circuit = QuantumCircuit(q_a, q_b, c_a, c_b)
circuit.x(q_a[1])
circuit.x(q_b[1])
circuit.x(q_b[2])
circuit.x(q_b[4])
circuit.barrier()
circuit.h(q_a)
circuit.barrier(q_a)
circuit.h(q_b)
circuit.cswap(q_b[0], q_b[1], q_b[2])
circuit.cswap(q_b[2], q_b[3], q_b[4])
circuit.cswap(q_b[3], q_b[4], q_b[0])
circuit.barrier(q_b)
circuit.measure(q_a, c_a)
circuit.measure(q_b, c_b);
```

```python
# Draw the circuit
circuit.draw(output="mpl")
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/8e57cd43-8a48-469d-8f69-8e7c936d4a1e-0.svg)

```python
# Draw the circuit with reversed bit order
circuit.draw(output="mpl", reverse_bits=True)
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/8e7a251a-0a4f-43e0-8cf5-48493df7bad9-0.svg)

```python
# Draw the circuit without barriers
circuit.draw(output="mpl", plot_barriers=False)
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/b4a601ad-1c04-4b16-afbd-ac5a0ad42653-0.svg)

### Налаштування специфічні для рендерера {#renderer-specific-customizations}

Деякі доступні опції налаштування є специфічними для рендерера.

Аргумент `fold` встановлює максимальну ширину для виводу. У рендерері `text` це встановлює довжину рядків діаграми перед тим, як вона переноситься на наступний рядок. При використанні рендерера 'mpl' це кількість (візуальних) шарів перед складанням на наступний рядок.

Рендерер `mpl` має kwarg `style`, який змінює кольори та обриси. Дивіться [документацію API](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#draw) для більш детальної інформації.

Опція `scale` масштабує вивід рендерерів `mpl` та `latex`.

```python
circuit = QuantumCircuit(1)
for _ in range(10):
    circuit.h(0)
# limit line length to 40 characters
circuit.draw(output="text", fold=40)
```

```text
┌───┐┌───┐┌───┐┌───┐┌───┐┌───┐┌───┐»
q: ┤ H ├┤ H ├┤ H ├┤ H ├┤ H ├┤ H ├┤ H ├»
   └───┘└───┘└───┘└───┘└───┘└───┘└───┘»
«   ┌───┐┌───┐┌───┐
«q: ┤ H ├┤ H ├┤ H ├
«   └───┘└───┘└───┘
```

```python
# Change the background color in mpl

style = {"backgroundcolor": "lightgreen"}
circuit.draw(output="mpl", style=style)
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/decadf88-4866-45a0-9e2f-836c51491f9e-0.svg)

```python
# Scale the mpl output to 1/2 the normal size
circuit.draw(output="mpl", scale=0.5)
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/ade9a653-3243-4ac9-bb0e-c8fb82f7a034-0.svg)

### Автономна функція малювання схем {#standalone-circuit-drawing-function}

Якщо у тебе є додаток, де ти віддаєш перевагу малюванню схеми за допомогою самостійної функції замість як методу об'єкта схеми, ти можеш безпосередньо використовувати функцію `circuit_drawer()`, яка є частиною публічного стабільного інтерфейсу з `qiskit.visualization`. Функція поводиться ідентично методу `circuit.draw()`, за винятком того, що вона приймає об'єкт схеми як обов'язковий аргумент.

```python
from qiskit.visualization import circuit_drawer

circuit_drawer(circuit, output="mpl", plot_barriers=False)
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/256dd092-b2eb-47af-a025-0ecdf85c2d5a-0.svg)

## Наступні кроки {#next-steps}

<Admonition type="tip" title="Рекомендації">
  -  Подивіться приклад візуалізації схеми в підручнику [Алгоритм Гровера](/tutorials/grovers-algorithm).
  -  Візуалізуйте прості схеми, використовуючи [IBM Quantum Composer.](/guides/composer)
  -  [Візуалізуйте часові характеристики схеми.](/guides/visualize-circuit-timing)
  -  Перегляньте [документацію API візуалізацій Qiskit.](https://docs.quantum.ibm.com/api/qiskit/visualization)
</Admonition>
