---
title: "Порядок бітів у Qiskit SDK"
sidebar_label: "Порядок бітів у Qiskit SDK"
description: "Дізнайтеся про конвенції впорядкування Qiskit SDK та чому ми їх обрали"
notebook_path: "docs/guides/bit-ordering.ipynb"
---
{/* doqumentation-source-hash: 054ae82b */}

<OpenInLabBanner notebookPath="docs/guides/bit-ordering.ipynb" />



{/* cspell:ignore leftrightarrow */}
{/*
  DO NOT EDIT THIS CELL!!!
  This cell's content is generated automatically by a script. Anything you add
  here will be removed next time the notebook is run. To add new content, create
  a new cell before or after this one.
*/}

<details>
<summary><b>Версії пакетів</b></summary>

Код на цій сторінці був розроблений з використанням наступних вимог.
Ми рекомендуємо використовувати ці версії або новіші.

```
qiskit[all]~=2.3.0
```
</details>
Якщо у вас є набір з $n$ бітів (або кубітів), ви зазвичай позначатимете кожен біт $0
\rightarrow n-1$. Різні програмні забезпечення та ресурси повинні вибрати, як вони впорядковують
ці біти як у пам'яті комп'ютера, так і при відображенні на екрані.

## Конвенції Qiskit {#qiskit-conventions}

Ось як Qiskit SDK впорядковує біти в різних сценаріях.

### Квантові схеми {#quantum-circuits}

Клас `QuantumCircuit` зберігає свої кубіти в списку
(`QuantumCircuit.qubits`). Індекс кубіта в цьому списку визначає
мітку кубіта.

```python
from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit import Qubit

qc = QuantumCircuit(2)
qc.qubits[0]  # qubit "0"

Qubit(QuantumRegister(2, "q"), 0)
```

```text
<Qubit register=(2, "q"), index=0>
```

### Діаграми схем {#circuit-diagrams}

На діаграмі схеми кубіт $0$ є найвищим кубітом, а кубіт $n-1$ —
найнижчим кубітом. Ти можеш змінити це за допомогою аргументу `reverse_bits` методу
`QuantumCircuit.draw` (дивіться [Зміна впорядкування в
Qiskit](#change-ordering-in-qiskit)).

```python
qc.x(1)
qc.draw()
```

```text
q_0: ─────
     ┌───┐
q_1: ┤ X ├
     └───┘
```

### Цілі числа {#integers}

При інтерпретації бітів як числа біт $0$ є найменш значущим бітом, а
біт $n-1$ — найбільш значущим. Це корисно при програмуванні, оскільки кожен біт має
значення $2^\text{label}$ (label — це індекс кубіта в
`QuantumCircuit.qubits`). Наприклад, наступне виконання схеми закінчується
тим, що біт $0$ є `0`, а біт $1$ є `1`. Це інтерпретується як
десяткове ціле число `2` (виміряно з ймовірністю `1.0`).

```python
from qiskit.primitives import StatevectorSampler as Sampler

qc.measure_all()

job = Sampler().run([qc])
result = job.result()
print(f" > Counts: {result[0].data.meas.get_counts()}")
```

```text
> Counts: {'10': 1024}
```

### Рядки {#strings}

При відображенні або інтерпретації списку бітів (або кубітів) як рядка біт
$n-1$ є крайнім лівим бітом, а біт $0$ — крайнім правим бітом. Це тому, що ми
зазвичай записуємо числа з найбільш значущою цифрою зліва, а в
Qiskit біт $n-1$ інтерпретується як найбільш значущий біт.

Наприклад, наступна комірка визначає `Statevector` з рядка
станів одного кубіта. У цьому випадку кубіт $0$ знаходиться в стані $|+\rangle$, а
кубіт $1$ — в стані $|0\rangle$.

```python
from qiskit.quantum_info import Statevector

sv = Statevector.from_label("0+")
sv.probabilities_dict()
```

```text
{np.str_('00'): np.float64(0.4999999999999999),
 np.str_('01'): np.float64(0.4999999999999999)}
```

Це іноді викликає плутанину при інтерпретації рядка бітів, оскільки ти
можеш очікувати, що крайній лівий біт буде бітом $0$, тоді як він зазвичай представляє біт
$n-1$.

### Матриці вектора стану {#statevector-matrices}

При представленні вектора стану як списку комплексних чисел (амплітуд),
Qiskit впорядковує ці амплітуди так, що амплітуда за індексом $x$ представляє
обчислювальний базисний стан $|x\rangle$.

```python
print(sv[1])  # amplitude of state |01>
print(sv[2])  # amplitude of state |10>
```

```text
(0.7071067811865475+0j)
0j
```

### Вентилі {#gates}

Кожен вентіль у Qiskit може інтерпретувати список кубітів по-своєму, але
контрольовані вентилі зазвичай дотримуються конвенції `(control, target)`.

Наприклад, наступна комірка додає контрольований X-вентіль, де кубіт $0$ є
керуючим, а кубіт $1$ — цільовим.

```python
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.cx(0, 1)
qc.draw()
```

```text
q_0: ──■──
     ┌─┴─┐
q_1: ┤ X ├
     └───┘
```

Дотримуючись усіх раніше згаданих конвенцій у Qiskit, цей CX-вентіль
виконує перетворення $|01\rangle \leftrightarrow |11\rangle$, тож має наступну
матрицю.

$$
\begin{pmatrix}
 1 & 0 & 0 & 0 \\
 0 & 0 & 0 & 1 \\
 0 & 0 & 1 & 0 \\
 0 & 1 & 0 & 0 \\
\end{pmatrix}
$$

## Зміна впорядкування в Qiskit {#change-ordering-in-qiskit}

Щоб намалювати схему з кубітами в зворотному порядку (тобто кубіт $0$ внизу), використовуйте аргумент `reverse_bits`. Це впливає лише на згенеровану
діаграму і не впливає на схему; X-вентіль все ще діє на кубіт $0$.

```python
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.x(0)
qc.draw(reverse_bits=True)
```

```text
q_1: ─────
     ┌───┐
q_0: ┤ X ├
     └───┘
```

Ти можеш використовувати метод `reverse_bits`, щоб повернути нову схему з
зворотними мітками кубітів (це не змінює оригінальну схему).

```python
qc.reverse_bits().draw()
```

```text
q_0: ─────
     ┌───┐
q_1: ┤ X ├
     └───┘
```

Зверніть увагу, що в цій новій схемі X-вентіль діє на кубіт $1$.

## Наступні кроки {#next-steps}

<Admonition type="tip" title="Рекомендації">
  -  Подивіться приклад використання схем у підручнику [Алгоритм Гровера](/tutorials/grovers-algorithm).
  -  Вивчіть [довідку API QuantumCircuit](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#quantumcircuit-class).
</Admonition>
