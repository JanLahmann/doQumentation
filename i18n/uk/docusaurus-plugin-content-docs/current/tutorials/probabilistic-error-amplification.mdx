---
title: "Пом'якшення помилок промислового масштабу з ймовірнісним підсиленням помилок"
sidebar_label: "Пом'якшення помилок промислового масштабу з ймовірнісним підсиленням помилок"
description: "Запустіть експеримент з пом'якшення помилок промислового масштабу з екстраполяцією нульового шуму та ймовірнісним підсиленням помилок."
notebook_path: "docs/tutorials/probabilistic-error-amplification.ipynb"
---
{/* doqumentation-source-hash: b88e39b7 */}

<OpenInLabBanner notebookPath="docs/tutorials/probabilistic-error-amplification.ipynb" />



{/* cspell:ignore mapsto multigraph inds extrap sharex sharey pidx */}

*Оцінка використання: 16 хвилин на процесорі Heron r2 (ПРИМІТКА: Це лише оцінка. Час виконання може відрізнятися.)*
## Передумови {#background}

Цей підручник демонструє, як запустити експеримент з пом'якшення помилок промислового масштабу з Qiskit Runtime, використовуючи експериментальну версію *екстраполяції нульового шуму* (Zero Noise Extrapolation, ZNE) з *ймовірнісним підсиленням помилок* (Probabilistic Error Amplification, PEA).

![kim_nature_fig.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/e1e67c34-9d4d-4a88-9340-f0b2f3676770.avif)
__Посилання__: Y. Kim et al. *Evidence for the utility of quantum computing before fault tolerance.* [Nature 618.7965 (2023)](https://www.nature.com/articles/s41586-023-06096-3)
### Екстраполяція нульового шуму (ZNE) {#zero-noise-extrapolation-zne}
Екстраполяція нульового шуму (ZNE) - це техніка пом'якшення помилок, яка усуває ефекти *невідомого* шуму під час виконання схеми, який може бути масштабований *відомим* способом.

Вона припускає, що очікувані значення масштабуються з шумом за відомою функцією

$$
\langle A(\lambda) \rangle = \langle A(0) \rangle + \sum_{k=0}^{m} a_k \lambda^k + R
$$
де $\lambda$ параметризує силу шуму і може бути підсилена.
Ми можемо реалізувати ZNE з наступними кроками:

1. Підсилити шум схеми для кількох факторів шуму $\lambda_1, \lambda_2, ... $
2. Запустити кожну схему з підсиленим шумом для вимірювання $\langle A(\lambda_1)\rangle, ...$
3. Екстраполювати назад до межі нульового шуму $\langle A(0)\rangle$

![zne_stages.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/5e63d706-82d8-4212-b802-c9191ce53341.avif)
#### Підсилення шуму для ZNE {#amplify-noise-for-zne}
Основним викликом при успішній реалізації ZNE є наявність точної моделі шуму в очікуваному значенні та підсилення шуму відомим способом.

Існує три поширені способи реалізації підсилення помилок для ZNE.

| **Розтягування імпульсів** | **Згортання вентилів** | **Ймовірнісне підсилення помилок** |
|-----------|-----------|-----------|
| Масштабування тривалості імпульсу через калібрування | Повторення вентилів у циклах тотожності $U\mapsto U(U^{-1}U)^{\lambda-1}/2$ | Додавання шуму через вибірку каналів Паулі |
| ![zne_pulse_stretching.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/83188b57-e88f-43a1-a7bd-29327f46ecf5.avif) | ![zne_gate_folding.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/e1358d08-2632-4fd2-bf0f-f9384a2d3340.avif) | ![zne_pea.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/3d69d5bd-70e5-4eeb-aa02-fc0a62043010.avif) |
| Kandala et al. Nature (2019) | Shultz et al. PRA (2022) | Li & Benjamin PRX (2017) |
Для експериментів промислового масштабу *ймовірнісне підсилення помилок* (PEA) є найбільш привабливим.
- Розтягування імпульсів припускає, що шум вентиля пропорційний тривалості, що зазвичай не відповідає дійсності. Калібрування також є витратним.
- Згортання вентилів вимагає великих коефіцієнтів розтягування, які значно обмежують глибину схем, які можна запустити.
- PEA може бути застосовано до будь-якої схеми, яку можна запустити з нативним фактором шуму ($\lambda=1$), але вимагає вивчення моделі шуму.
### Вивчення моделі шуму для PEA {#learn-the-noise-model-for-pea}
PEA припускає ту саму шарувату модель шуму, що й *ймовірнісне скасування помилок* (Probabilistic Error Cancellation, PEC); однак вона уникає накладних витрат на вибірку, які експоненційно масштабуються з шумом схеми.
| **Крок 1** | **Крок 2** | **Крок 3** |
|-----------|-----------|-----------|
| Обертання Паулі шарів двокубітних вентилів | Повторення пар тотожності шарів і вивчення шуму | Виведення достовірності (помилка для кожного каналу шуму) |
| ![pec_pauli_twirling.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/2eab5ff4-40fa-4a41-9f2c-74f5e22c4643.avif) | ![pec_learn_layer.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/8d0d64c3-65ad-4419-8ac9-4ec9633d39a0.avif) | ![pec_curve_fitting.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/c51bd42d-2463-4c78-807b-d284ca79296f.avif) |

__Посилання__: E. van den Berg, Z. Minev, A. Kandala, and K. Temme, _Probabilistic error cancellation with sparse Pauli-Lindblad models on noisy quantum processors_ [arXiv:2201.09866](https://arxiv.org/abs/2201.09866)
## Вимоги {#requirements}

Перед початком цього підручника переконайтеся, що у Вас встановлено наступне:

- Qiskit SDK v1.0 або пізніше, з підтримкою [візуалізації](https://docs.quantum.ibm.com/api/qiskit/visualization)
- Qiskit Runtime v0.22 або пізніше (`pip install qiskit-ibm-runtime`)
## Налаштування {#setup}

```python
from __future__ import annotations
from collections.abc import Sequence
from collections import defaultdict
import numpy as np
import rustworkx
import matplotlib.pyplot as plt

from qiskit.circuit import QuantumCircuit, Parameter
from qiskit.circuit.library import CXGate, CZGate, ECRGate
from qiskit.providers import Backend
from qiskit.visualization import plot_error_map
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit.quantum_info import SparsePauliOp
from qiskit.primitives import PubResult

from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_runtime import EstimatorV2 as Estimator
```

## Крок 1: Відображення класичних вхідних даних на квантову задачу {#step-1-map-classical-inputs-to-a-quantum-problem}
### Створення параметризованої схеми моделі Ізінга {#create-a-parameterized-ising-model-circuit}
Спочатку виберіть бекенд для запуску. Ця демонстрація виконується на 127-кубітному бекенді, але Ви можете змінити це на будь-який доступний Вам бекенд.

```python
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=127
)
backend
```

```text
<IBMBackend('ibm_kingston')>
```

#### Допоміжні функції для конструювання схеми {#helper-functions-for-circuit-construction}
Далі створіть деякі допоміжні функції для конструювання схем для троттерізованої часової еволюції двовимірної поперечно-польової моделі Ізінга, яка відповідає топології бекенду.

```python
"""Trotter circuit generation"""

def remove_qubit_couplings(
    couplings: Sequence[tuple[int, int]], qubits: Sequence[int] | None = None
) -> list[tuple[int, int]]:
    """Remove qubits from a coupling list.

    Args:
        couplings: A sequence of qubit couplings.
        qubits: Optional, the qubits to remove.

    Returns:
        The input couplings with the specified qubits removed.
    """
    if qubits is None:
        return couplings
    qubits = set(qubits)
    return [edge for edge in couplings if not qubits.intersection(edge)]

def coupling_qubits(
    *couplings: Sequence[tuple[int, int]],
    allowed_qubits: Sequence[int] | None = None,
) -> list[int]:
    """Return a sorted list of all qubits involved in one or more couplings lists.

    Args:
        couplings: one or more coupling lists.
        allowed_qubits: Optional, the allowed qubits to include. If None all
            qubits are allowed.

    Returns:
        The intersection of all qubits in the couplings and the allowed qubits.
    """
    qubits = set()
    for edges in couplings:
        for edge in edges:
            qubits.update(edge)
    if allowed_qubits is not None:
        qubits = qubits.intersection(allowed_qubits)
    return list(qubits)

def construct_layer_couplings(
    backend: Backend,
) -> list[list[tuple[int, int]]]:
    """Separate a coupling map into disjoint 2-qubit gate layers.

    Args:
        backend: A backend to construct layer couplings for.

    Returns:
        A list of disjoint layers of directed couplings for the input coupling map.
    """
    coupling_graph = backend.coupling_map.graph.to_undirected(
        multigraph=False
    )
    edge_coloring = rustworkx.graph_bipartite_edge_color(coupling_graph)

    layers = defaultdict(list)
    for edge_idx, color in edge_coloring.items():
        layers[color].append(
            coupling_graph.get_edge_endpoints_by_index(edge_idx)
        )
    layers = [sorted(layers[i]) for i in sorted(layers.keys())]

    return layers

def entangling_layer(
    gate_2q: str,
    couplings: Sequence[tuple[int, int]],
    qubits: Sequence[int] | None = None,
) -> QuantumCircuit:
    """Generating a entangling layer for the specified couplings.

    This corresponds to a Trotter layer for a ZZ Ising term with angle Pi/2.

    Args:
        gate_2q: The 2-qubit basis gate for the layer, should be "cx", "cz", or "ecr".
        couplings: A sequence of qubit couplings to add CX gates to.
        qubits: Optional, the physical qubits for the layer. Any couplings involving
            qubits not in this list will be removed. If None the range up to the largest
            qubit in the couplings will be used.

    Returns:
        The QuantumCircuit for the entangling layer.
    """
    # Get qubits and convert to set to order
    if qubits is None:
        qubits = range(1 + max(coupling_qubits(couplings)))
    qubits = set(qubits)

    # Mapping of physical qubit to virtual qubit
    qubit_mapping = {q: i for i, q in enumerate(qubits)}

    # Convert couplings to indices for virtual qubits
    indices = [
        [qubit_mapping[i] for i in edge]
        for edge in couplings
        if qubits.issuperset(edge)
    ]

    # Layer circuit on virtual qubits
    circuit = QuantumCircuit(len(qubits))

    # Get 2-qubit basis gate and pre and post rotation circuits
    gate2q = None
    pre = QuantumCircuit(2)
    post = QuantumCircuit(2)

    if gate_2q == "cx":
        gate2q = CXGate()
        # Pre-rotation
        pre.sdg(0)
        pre.z(1)
        pre.sx(1)
        pre.s(1)
        # Post-rotation
        post.sdg(1)
        post.sxdg(1)
        post.s(1)
    elif gate_2q == "ecr":
        gate2q = ECRGate()
        # Pre-rotation
        pre.z(0)
        pre.s(1)
        pre.sx(1)
        pre.s(1)
        # Post-rotation
        post.x(0)
        post.sdg(1)
        post.sxdg(1)
        post.s(1)
    elif gate_2q == "cz":
        gate2q = CZGate()
        # Identity pre-rotation
        # Post-rotation
        post.sdg([0, 1])
    else:
        raise ValueError(
            f"Invalid 2-qubit basis gate {gate_2q}, should be 'cx', 'cz', or 'ecr'"
        )

    # Add 1Q pre-rotations
    for inds in indices:
        circuit.compose(pre, qubits=inds, inplace=True)

    # Use barriers around 2-qubit basis gate to specify a layer for PEA noise learning
    circuit.barrier()
    for inds in indices:
        circuit.append(gate2q, (inds[0], inds[1]))
    circuit.barrier()

    # Add 1Q post-rotations after barrier
    for inds in indices:
        circuit.compose(post, qubits=inds, inplace=True)

    # Add physical qubits as metadata
    circuit.metadata["physical_qubits"] = tuple(qubits)

    return circuit

def trotter_circuit(
    theta: Parameter | float,
    layer_couplings: Sequence[Sequence[tuple[int, int]]],
    num_steps: int,
    gate_2q: str | None = "cx",
    backend: Backend | None = None,
    qubits: Sequence[int] | None = None,
) -> QuantumCircuit:
    """Generate a Trotter circuit for the 2D Ising

    Args:
        theta: The angle parameter for X.
        layer_couplings: A list of couplings for each entangling layer.
        num_steps: the number of Trotter steps.
        gate_2q: The 2-qubit basis gate to use in entangling layers.
            Can be "cx", "cz", "ecr", or None if a backend is provided.
        backend: A backend to get the 2-qubit basis gate from, if provided
            will override the basis_gate field.
        qubits: Optional, the allowed physical qubits to truncate the
            couplings to. If None the range up to the largest
            qubit in the couplings will be used.

    Returns:
        The Trotter circuit.
    """
    if backend is not None:
        try:
            basis_gates = backend.configuration().basis_gates
        except AttributeError:
            basis_gates = backend.basis_gates
        for gate in ["cx", "cz", "ecr"]:
            if gate in basis_gates:
                gate_2q = gate
                break

    # If no qubits, get the largest qubit from all layers and
    # specify the range so the same one is used for all layers.
    if qubits is None:
        qubits = range(1 + max(coupling_qubits(layer_couplings)))

    # Generate the entangling layers
    layers = [
        entangling_layer(gate_2q, couplings, qubits=qubits)
        for couplings in layer_couplings
    ]

    # Construct the circuit for a single Trotter step
    num_qubits = len(qubits)
    trotter_step = QuantumCircuit(num_qubits)
    trotter_step.rx(theta, range(num_qubits))
    for layer in layers:
        trotter_step.compose(layer, range(num_qubits), inplace=True)

    # Construct the circuit for the specified number of Trotter steps
    circuit = QuantumCircuit(num_qubits)
    for _ in range(num_steps):
        circuit.rx(theta, range(num_qubits))
        for layer in layers:
            circuit.compose(layer, range(num_qubits), inplace=True)

    circuit.metadata["physical_qubits"] = tuple(qubits)
    return circuit
```

#### Визначення зв'язків шару сплутування {#define-entangling-layer-couplings}
Для реалізації троттерізованої симуляції Ізінга визначте три шари зв'язків двокубітних вентилів для пристрою, які будуть повторюватися на кожному з кроків Троттера. Вони визначають три обернені шари, для яких Вам потрібно вивчити шум для реалізації пом'якшення.

```python
layer_couplings = construct_layer_couplings(backend)
for i, layer in enumerate(layer_couplings):
    print(f"Layer {i}:\n{layer}\n")
```

```text
Layer 0:
[(2, 3), (4, 5), (6, 7), (8, 9), (10, 11), (12, 13), (14, 15), (16, 23), (18, 31), (19, 35), (20, 21), (25, 37), (26, 27), (28, 29), (33, 39), (36, 41), (38, 49), (42, 43), (45, 46), (47, 57), (51, 52), (53, 54), (56, 63), (58, 71), (59, 75), (61, 62), (64, 65), (66, 67), (68, 69), (72, 73), (76, 81), (79, 93), (82, 83), (84, 85), (86, 87), (88, 89), (91, 98), (94, 95), (97, 107), (99, 115), (100, 101), (102, 103), (105, 117), (108, 109), (110, 111), (113, 114), (116, 121), (118, 129), (123, 136), (124, 125), (126, 127), (130, 131), (132, 133), (135, 139), (138, 151), (142, 143), (144, 145), (146, 147), (152, 153), (154, 155)]

Layer 1:
[(0, 1), (3, 16), (5, 6), (7, 8), (11, 18), (13, 14), (17, 27), (21, 22), (23, 24), (25, 26), (29, 38), (30, 31), (32, 33), (34, 35), (39, 53), (41, 42), (43, 56), (44, 45), (47, 48), (49, 50), (51, 58), (54, 55), (57, 67), (60, 61), (62, 63), (65, 66), (69, 78), (70, 71), (73, 79), (74, 75), (77, 85), (80, 81), (83, 84), (87, 97), (89, 90), (91, 92), (93, 94), (96, 103), (101, 116), (104, 105), (106, 107), (109, 118), (111, 112), (113, 119), (114, 115), (117, 125), (121, 122), (123, 124), (127, 137), (128, 129), (131, 138), (133, 134), (136, 143), (139, 155), (140, 141), (145, 146), (147, 148), (149, 150), (151, 152)]

Layer 2:
[(1, 2), (3, 4), (7, 17), (9, 10), (11, 12), (15, 19), (21, 36), (22, 23), (24, 25), (27, 28), (29, 30), (31, 32), (33, 34), (37, 45), (40, 41), (43, 44), (46, 47), (48, 49), (50, 51), (52, 53), (55, 59), (61, 76), (63, 64), (65, 77), (67, 68), (69, 70), (71, 72), (73, 74), (78, 89), (81, 82), (83, 96), (85, 86), (87, 88), (90, 91), (92, 93), (95, 99), (98, 111), (101, 102), (103, 104), (105, 106), (107, 108), (109, 110), (112, 113), (119, 133), (120, 121), (122, 123), (125, 126), (127, 128), (129, 130), (131, 132), (134, 135), (137, 147), (141, 142), (143, 144), (148, 149), (150, 151), (153, 154)]
```

#### Видалення поганих кубітів {#remove-bad-qubits}
Подивіться на карту зв'язків для бекенду і перевірте, чи якісь кубіти підключені до зв'язків з високою помилкою. Видаліть ці "погані" кубіти з Вашого експерименту.

```python
# Plot gate error map
# NOTE: These can change over time, so your results may look different
plot_error_map(backend)
```

![Output of the previous code cell](/docs/images/tutorials/probabilistic-error-amplification/extracted-outputs/401e2d48-1b39-40c8-bf32-7b439ae0980d-0.avif)

```python
bad_qubits = {
    56,
    63,
    67,
}  # qubits removed based on high coupling error (1.00)
good_qubits = list(set(range(backend.num_qubits)).difference(bad_qubits))
print("Physical qubits:\n", good_qubits)
```

```text
Physical qubits:
 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62, 64, 65, 66, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155]
```

#### Генерація основної схеми Троттера {#main-trotter-circuit-generation}

```python
num_steps = 6
theta = Parameter("theta")
circuit = trotter_circuit(
    theta, layer_couplings, num_steps, qubits=good_qubits, backend=backend
)
```

### Створення списку значень параметрів для призначення пізніше {#create-a-list-of-parameter-values-to-be-assigned-later}

```python
num_params = 12

# 12 parameter values for Rx between [0, pi/2].
# Reshape to outer product broadcast with observables
parameter_values = np.linspace(0, np.pi / 2, num_params).reshape(
    (num_params, 1)
)
num_params = parameter_values.size
```
## Крок 2: Оптимізація задачі для виконання на квантовому обладнанні {#step-2-optimize-problem-for-quantum-hardware-execution}
### ISA схема {#isa-circuit}
Перед запуском схеми на обладнанні оптимізуйте її для виконання на апаратному забезпеченні. Цей процес включає кілька кроків:

- Виберіть розміщення кубітів, яке відображає віртуальні кубіти Вашої схеми на фізичні кубіти обладнання.
- Вставте вентилі обміну (swap gates) за потреби для маршрутизації взаємодій між кубітами, які не з'єднані.
- Перекладіть вентилі у Вашій схемі на інструкції [Архітектури набору інструкцій (ISA)](/guides/transpile#instruction-set-architecture), які можуть безпосередньо виконуватися на обладнанні.
- Виконайте оптимізації схеми для мінімізації глибини схеми та кількості вентилів.

Хоча транспілятор, вбудований у Qiskit, може виконувати всі ці кроки, цей посібник демонструє побудову схеми Троттера корисного масштабу з нуля. Виберіть хороші фізичні кубіти та визначте шари заплутування на з'єднаних парах кубітів з цих обраних кубітів. Тим не менш, Вам все ще потрібно перекласти не-ISA вентилі в схемі та скористатися будь-якою оптимізацією схеми, яку пропонує транспілятор.

Транспілюйте Вашу схему для обраного бекенду, створивши менеджер проходів, а потім запустивши менеджер проходів на схемі. Також зафіксуйте початкове розміщення схеми на вже обраних `good_qubits`. Простий спосіб створити менеджер проходів — використати функцію [`generate_preset_pass_manager`](https://docs.quantum.ibm.com/api/qiskit/qiskit.transpiler.generate_preset_pass_manager). Дивіться [Транспіляція з менеджерами проходів](/guides/transpile-with-pass-managers) для більш детального пояснення транспіляції з менеджерами проходів.

```python
pm = generate_preset_pass_manager(
    backend=backend,
    initial_layout=good_qubits,
    layout_method="trivial",
    optimization_level=1,
)

isa_circuit = pm.run(circuit)
```

### ISA спостережувані {#isa-observables}
Далі створіть всі спостережувані $\langle Z \rangle$ ваги-1 для кожного віртуального кубіта, доповнивши необхідну кількість членів $\langle I \rangle$.

```python
observables = []
num_qubits = len(good_qubits)
for q in range(num_qubits):
    observables.append(
        SparsePauliOp("I" * (num_qubits - q - 1) + "Z" + "I" * q)
    )
```

Процес транспіляції відобразив віртуальні кубіти Вашої схеми на фізичні кубіти обладнання. Інформація про розміщення кубітів зберігається в атрибуті `layout` транспільованої схеми. Ваша спостережувана також визначена у термінах віртуальних кубітів, тому Вам потрібно застосувати це розміщення до спостережуваної. Це робиться за допомогою методу `apply_layout` класу `SparsePauliOp`.

Зверніть увагу, що кожна спостережувана обгорнута в список у наступному блоці коду. Це зроблено для _трансляції_ із значеннями параметрів, щоб кожна спостережувана кубіта вимірювалася для кожного значення theta. Правила трансляції для примітивів можна знайти [тут](/guides/primitives).

```python
isa_observables = [
    [obs.apply_layout(layout=isa_circuit.layout)] for obs in observables
]
```

## Крок 3: Виконання з використанням примітивів Qiskit {#step-3-execute-using-qiskit-primitives}

```python
pub = (isa_circuit, isa_observables, parameter_values)
```

### Налаштування опцій Estimator {#configure-estimator-options}
Далі налаштуйте опції `Estimator`, необхідні для запуску експерименту з пом'якшення. Це включає опції для навчання шуму шарів заплутування та для екстраполяції ZNE.

Ми використовуємо наступну конфігурацію:

```python
# Experiment options
num_randomizations = 700
num_randomizations_learning = 40
max_batch_circuits = 3 * num_params
shots_per_randomization = 64
learning_pair_depths = [0, 1, 2, 4, 6, 12, 24]
noise_factors = [1, 1.3, 1.6]
extrapolated_noise_factors = np.linspace(0, max(noise_factors), 20)

# Base option formatting
options = {
    # Builtin resilience settings for ZNE
    "resilience": {
        "measure_mitigation": True,
        "zne_mitigation": True,
        # TREX noise learning configuration
        "measure_noise_learning": {
            "num_randomizations": num_randomizations_learning,
            "shots_per_randomization": 1024,
        },
        # PEA noise model configuration
        "layer_noise_learning": {
            "max_layers_to_learn": 3,
            "layer_pair_depths": learning_pair_depths,
            "shots_per_randomization": shots_per_randomization,
            "num_randomizations": num_randomizations_learning,
        },
        "zne": {
            "amplifier": "pea",
            "noise_factors": noise_factors,
            "extrapolator": ("exponential", "linear"),
            "extrapolated_noise_factors": extrapolated_noise_factors.tolist(),
        },
    },
    # Randomization configuration
    "twirling": {
        "num_randomizations": num_randomizations,
        "shots_per_randomization": shots_per_randomization,
        "strategy": "active-circuit",
    },
    # Optional Dynamical Decoupling (DD)
    "dynamical_decoupling": {"enable": True, "sequence_type": "XY4"},
}
```

#### Пояснення опцій ZNE {#explanation-of-zne-options}
Наступне надає деталі щодо додаткових опцій в експериментальній гілці. Зверніть увагу, що ці опції та назви не є остаточними, і все тут може змінитися до офіційного випуску.

* __amplifier__: Метод для використання при підсиленні шуму до бажаних факторів шуму.
    Дозволені значення: `"gate_folding"`, який підсилює шляхом повторення двокубітних базових вентилів,
    та `"pea"`, який підсилює шляхом імовірнісної вибірки після навчання моделі шуму з Паулі-обертанням
    для шарів обертаних двокубітних базових вентилів. Також є опції `"gate_folding_front"` та `"gate_folding_back"`, які пояснюються в [документації API](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/options-zne-options#amplifier)
* __extrapolated_noise_factors__: Вкажіть одне або більше значень фактора шуму, за якими потрібно оцінити
    екстрапольовані моделі. Якщо це послідовність значень, повернуті результати будуть масивами значень із вказаним фактором шуму, оціненим для моделі екстраполяції. Значення
    0 відповідає екстраполяції до нульового шуму.
### Запуск експерименту {#run-the-experiment}

```python
estimator = Estimator(mode=backend, options=options)
job = estimator.run([pub])
```

```python
print(f"Job ID {job.job_id()}")
```

```text
Job ID d0mcsvik4jhc73afljrg
```
## Крок 4: Постобробка та повернення результатів у бажаному класичному форматі {#step-4-post-process-and-return-result-in-desired-classical-format}
Після завершення експерименту Ви можете переглянути свої результати. Ви отримуєте необроблені та пом'якшені очікувані значення та порівнюєте їх з точними результатами. Потім побудуйте графіки очікуваних значень, як пом'якшених (екстрапольованих), так і необроблених, усереднених по всіх кубітах для кожного параметра. Нарешті, побудуйте графіки очікуваних значень для обраних Вами окремих кубітів.

```python
primitive_result = job.result()
```

### Загальні форми результатів та метадані {#general-result-shapes-and-metadata}
Об'єкт `PrimitiveResult` містить списко-подібну структуру з назвою `PubResult`. Оскільки ми подаємо лише один PUB до estimator, `PrimitiveResult` містить один об'єкт `PubResult`.

Очікувані значення та стандартні похибки результатів PUB (primitive unified bloc) мають значення у вигляді масивів. Для завдань estimator із ZNE доступні кілька полів даних очікуваних значень та стандартних похибок у контейнері `DataBin` об'єкта `PubResult`. Тут ми коротко обговоримо поля даних для очікуваних значень (аналогічні поля даних доступні також для стандартних похибок (`stds`)).

1. `pub_result.data.evs`: Очікувані значення, що відповідають нульовому шуму (на основі евристично найкращої екстраполяції).
    - Перша вісь — це індекс віртуального кубіта для спостережуваної $\langle Z_i\rangle$ ($124$ віртуальних кубітів/спостережуваних)
    - Друга вісь індексує значення параметра для $\theta$ ($12$ значень параметра)
2. `pub_result.data.evs_extrapolated`: Очікувані значення для екстрапольованих факторів шуму для кожного екстраполятора. Цей масив має дві додаткові осі.
    - Третя вісь індексує методи екстраполяції ($2$ екстраполятори, `exponential` та `linear`)
    - Остання вісь індексує `extrapolated_noise_factors` ($20$ точок екстраполяції, вказаних в опції)
3. `pub_result.data.evs_noise_factors`: Необроблені очікувані значення для кожного фактора шуму.
   - Третя вісь індексує необроблені `noise_factors` ($3$ фактори)

```python
pub_result = primitive_result[0]

print(
    f"{pub_result.data.evs.shape=}\n"
    f"{pub_result.data.evs_extrapolated.shape=}\n"
    f"{pub_result.data.evs_noise_factors.shape=}\n"
)
```

```text
pub_result.data.evs.shape=(153, 12)
pub_result.data.evs_extrapolated.shape=(153, 12, 2, 20)
pub_result.data.evs_noise_factors.shape=(153, 12, 3)
```

Кілька полів метаданих також доступні в `PrimitiveResult`. Метадані включають
- `resilience/zne/noise_factors`: Необроблені фактори шуму
- `resilience/zne/extrapolator`: Екстраполятори, використані для кожного результату

```python
primitive_result.metadata
```

```text
{'dynamical_decoupling': {'enable': True,
  'sequence_type': 'XY4',
  'extra_slack_distribution': 'middle',
  'scheduling_method': 'alap'},
 'twirling': {'enable_gates': True,
  'enable_measure': True,
  'num_randomizations': 700,
  'shots_per_randomization': 64,
  'interleave_randomizations': True,
  'strategy': 'active-circuit'},
 'resilience': {'measure_mitigation': True,
  'zne_mitigation': True,
  'pec_mitigation': False,
  'zne': {'noise_factors': [1.0, 1.3, 1.6],
   'extrapolator': ['exponential', 'linear'],
   'extrapolated_noise_factors': [0.0,
    0.08421052631578947,
    0.16842105263157894,
    0.25263157894736843,
    0.3368421052631579,
    0.42105263157894735,
    0.5052631578947369,
    0.5894736842105263,
    0.6736842105263158,
    0.7578947368421053,
    0.8421052631578947,
    0.9263157894736842,
    1.0105263157894737,
    1.0947368421052632,
    1.1789473684210525,
    1.263157894736842,
    1.3473684210526315,
    1.431578947368421,
    1.5157894736842106,
    1.6]},
  'layer_noise_model': '<omitted for brevity>'},
 'version': 2}
```

Об'єкт `PubResult` має додаткові метадані стійкості щодо вивчених моделей шуму, використаних при пом'якшенні.

```python
# Print learned layer noise metadata
for field, value in pub_result.metadata["resilience"]["layer_noise"].items():
    print(f"{field}: {value}")
```

```text
noise_overhead: Infinity
total_mitigated_layers: 18
unique_mitigated_layers: 3
unique_mitigated_layers_noise_overhead: [1.4100369479435003e+44, 3.407263868699073e+112, 3.500660129782563e+37]
```

```python
# Exact data computed using the methods described in the original reference
# Y. Kim et al. "Evidence for the utility of quantum computing before fault tolerance" (Nature 618, 500–505 (2023))
# Directly used here for brevity
exact_data = np.array(
    [
        1,
        0.9899,
        0.9531,
        0.8809,
        0.7536,
        0.5677,
        0.3545,
        0.1607,
        0.0539,
        0.0103,
        0.0012,
        0.0,
    ]
)
```

### Побудова графіків результатів моделювання Троттера {#plot-trotter-simulation-results}

Наступний код створює графік для порівняння необроблених та пом'якшених результатів експерименту з точним розв'язком.

```python
"""Result visualization functions"""

def plot_trotter_results(
    pub_result: PubResult,
    angles: Sequence[float],
    plot_noise_factors: Sequence[float] | None = None,
    plot_extrapolator: Sequence[str] | None = None,
    exact: np.ndarray = None,
    close: bool = True,
):
    """Plot average magnetization from ZNE result data.
    Args:
        pub_result: The Estimator PubResult for the PEA experiment.
        angles: The Rx angle values for the experiment.
        plot_raw: If provided plot the unextrapolated data for the noise factors.
        plot_extrapolator: If provided plot all extrapolators, if False only plot
            the Automatic method.
        exact: Optional, the exact values to include in the plot. Should be a 1D
            array-like where the values represent exact magnetization.
        close: Close the Matplotlib figure before returning.
    Returns:
        The figure.
    """
    data = pub_result.data

    evs = data.evs
    num_qubits = evs.shape[0]
    num_params = evs.shape[1]
    angles = np.asarray(angles).ravel()
    if angles.shape != (num_params,):
        raise ValueError(
            f"Incorrect number of angles for input data {angles.size} != {num_params}"
        )

    # Take average magnetization of qubits and its standard error
    x_vals = angles / np.pi
    y_vals = np.mean(evs, axis=0)
    y_errs = np.std(evs, axis=0) / np.sqrt(num_qubits)

    fig, _ = plt.subplots(1, 1)

    # Plot auto method
    plt.errorbar(x_vals, y_vals, y_errs, fmt="o-", label="ZNE (automatic)")

    # Plot individual extrapolator results
    if plot_extrapolator:
        y_vals_extrap = np.mean(data.evs_extrapolated, axis=0)
        y_errs_extrap = np.std(data.evs_extrapolated, axis=0) / np.sqrt(
            num_qubits
        )
        for i, extrap in enumerate(plot_extrapolator):
            plt.errorbar(
                x_vals,
                y_vals_extrap[:, i, 0],
                y_errs_extrap[:, i, 0],
                fmt="s-.",
                alpha=0.5,
                label=f"ZNE ({extrap})",
            )

    # Plot raw results
    if plot_noise_factors:
        y_vals_raw = np.mean(data.evs_noise_factors, axis=0)
        y_errs_raw = np.std(data.evs_noise_factors, axis=0) / np.sqrt(
            num_qubits
        )
        for i, nf in enumerate(plot_noise_factors):
            plt.errorbar(
                x_vals,
                y_vals_raw[:, i],
                y_errs_raw[:, i],
                fmt="d:",
                alpha=0.5,
                label=f"Raw (nf={nf:.1f})",
            )

    # Plot exact data
    if exact is not None:
        plt.plot(x_vals, exact, "--", color="black", alpha=0.5, label="Exact")

    plt.ylim(-0.1, 1.2)
    plt.xlabel("θ/π")
    plt.ylabel(r"$\overline{\langle Z \rangle}$")
    plt.legend()
    plt.title(
        f"Error Mitigated Average Magnetization for Rx(θ) [{num_qubits}-qubit]"
    )
    if close:
        plt.close(fig)
    return fig
```

```python
zne_metadata = primitive_result.metadata["resilience"]["zne"]
# Plot Trotter simulation results
fig = plot_trotter_results(
    pub_result,
    parameter_values,
    plot_extrapolator=zne_metadata["extrapolator"],
    plot_noise_factors=zne_metadata["noise_factors"],
    exact=exact_data,
)
display(fig)
```

![Output of the previous code cell](/docs/images/tutorials/probabilistic-error-amplification/extracted-outputs/2e0f0e84-32ba-4655-91c1-8445016bbeb2-0.avif)

Хоча зашумлені (фактор шуму `nf=1.0`) значення показують високе відхилення від точних значень, пом'якшені значення є близькими до точних значень, демонструючи корисність методу пом'якшення на основі PEA.
### Побудова графіків результатів екстраполяції для окремих кубітів {#plot-extrapolation-results-for-individual-qubits}

Нарешті, наступний код створює графік для відображення кривих екстраполяції для різних значень тета на конкретному кубіті.

```python
def plot_qubit_zne_data(
    pub_result: PubResult,
    angles: Sequence[float],
    qubit: int,
    noise_factors: Sequence[float],
    extrapolator: Sequence[str] | None = None,
    extrapolated_noise_factors: Sequence[float] | None = None,
    num_cols: int | None = None,
    close: bool = True,
):
    """Plot ZNE extrapolation data for specific virtual qubit
    Args:
        pub_result: The Estimator PubResult for the PEA experiment.
        angles: The Rx theta angles used for the experiment.
        qubit: The virtual qubit index to plot.
        noise_factors: the raw noise factors.
        extrapolator: The extrapolator metadata for multiple extrapolators.
        extrapolated_noise_factors: The noise factors used for extrapolation.
        num_cols: The number of columns for the generated subplots.
        close: Close the Matplotlib figure before returning.
    Returns:
        The Matplotlib figure.
    """
    data = pub_result.data

    evs_auto = data.evs[qubit]
    stds_auto = data.stds[qubit]
    evs_extrap = data.evs_extrapolated[qubit]
    stds_extrap = data.stds_extrapolated[qubit]
    evs_raw = data.evs_noise_factors[qubit]
    stds_raw = data.stds_noise_factors[qubit]

    num_params = evs_auto.shape[0]
    angles = np.asarray(angles).ravel()
    if angles.shape != (num_params,):
        raise ValueError(
            f"Incorrect number of angles for input data {angles.size} != {num_params}"
        )

    # Make a square subplot
    num_cols = num_cols or int(np.ceil(np.sqrt(num_params)))
    num_rows = int(np.ceil(num_params / num_cols))
    fig, axes = plt.subplots(
        num_rows, num_cols, sharex=True, sharey=True, figsize=(12, 5)
    )
    fig.suptitle(f"ZNE data for virtual qubit {qubit}")

    for pidx, ax in zip(range(num_params), axes.flat):
        # Plot auto extrapolated
        ax.errorbar(
            0,
            evs_auto[pidx],
            stds_auto[pidx],
            fmt="o",
            label="PEA (automatic)",
        )

        # Plot extrapolators
        if (
            extrapolator is not None
            and extrapolated_noise_factors is not None
        ):
            for i, method in enumerate(extrapolator):
                ax.errorbar(
                    extrapolated_noise_factors,
                    evs_extrap[pidx, i],
                    stds_extrap[pidx, i],
                    fmt="-",
                    alpha=0.5,
                    label=f"PEA ({method})",
                )

        # Plot raw
        ax.errorbar(
            noise_factors, evs_raw[pidx], stds_raw[pidx], fmt="d", label="Raw"
        )

        ax.set_yticks([0, 0.5, 1, 1.5, 2])
        ax.set_ylim(0, max(1, 1.1 * max(evs_auto)))

        ax.set_xticks([0, *noise_factors])
        ax.set_title(f"θ/π = {angles[pidx]/np.pi:.2f}")
        if pidx == 0:
            ax.set_ylabel(r"$\langle Z_{" + str(qubit) + r"} \rangle$")
        if pidx == num_params - 1:
            ax.set_xlabel("Noise Factor")
            ax.legend()
    if close:
        plt.close(fig)
    return fig
```

```python
virtual_qubit = 1
plot_qubit_zne_data(
    pub_result=pub_result,
    angles=parameter_values,
    qubit=virtual_qubit,
    noise_factors=zne_metadata["noise_factors"],
    extrapolator=zne_metadata["extrapolator"],
    extrapolated_noise_factors=zne_metadata["extrapolated_noise_factors"],
)
```

![Output of the previous code cell](/docs/images/tutorials/probabilistic-error-amplification/extracted-outputs/6948475c-bc15-493f-8af9-f8e66d0e467c-0.avif)

## Опитування щодо посібника {#tutorial-survey}

Будь ласка, пройдіть це коротке опитування, щоб надати відгук про цей посібник. Ваші відповіді допоможуть нам покращити наші матеріали та досвід користувачів.
