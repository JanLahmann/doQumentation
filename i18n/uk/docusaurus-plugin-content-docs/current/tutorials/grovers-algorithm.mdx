---
title: "Алгоритм Гровера"
sidebar_label: "Алгоритм Гровера"
description: "Дізнайтеся основи квантових обчислень та як використовувати сервіси IBM Quantum і QPU для вирішення реальних задач."
notebook_path: "docs/tutorials/grovers-algorithm.ipynb"
---

<OpenInLabBanner notebookPath="docs/tutorials/grovers-algorithm.ipynb" />



*Оцінка використання: менше однієї хвилини на процесорі Eagle r3 (ПРИМІТКА: Це лише оцінка. Ваш час виконання може відрізнятися.)*
## Загальна інформація {#background}

Підсилення амплітуди — це квантовий алгоритм загального призначення або підпрограма, яку можна використовувати для отримання квадратичного прискорення порівняно з деякими класичними алгоритмами. [Алгоритм Гровера](https://arxiv.org/abs/quant-ph/9605043) був першим, хто продемонстрував це прискорення на неструктурованих задачах пошуку. Формулювання задачі пошуку Гровера вимагає функції-оракула, яка позначає один або більше станів обчислювального базису як стани, які нас цікавлять, і схеми підсилення, яка збільшує амплітуду позначених станів, отже, пригнічуючи решту станів.

Тут ми демонструємо, як побудувати оракули Гровера та використовувати [`grover_operator()`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.grover_operator) з бібліотеки схем Qiskit для легкого налаштування екземпляра пошуку Гровера. Примітив `Sampler` виконавчого середовища дозволяє безперебійне виконання схем Гровера.
## Вимоги {#requirements}

Перед початком цього посібника переконайтеся, що у вас встановлено наступне:

* Qiskit SDK v1.4 або новіший, з підтримкою [візуалізації](https://docs.quantum.ibm.com/api/qiskit/visualization)
* Qiskit Runtime (`pip install qiskit-ibm-runtime`) v0.36 або новіший
## Налаштування {#setup}

```python
# Built-in modules
import math

# Imports from Qiskit
from qiskit import QuantumCircuit
from qiskit.circuit.library import grover_operator, MCMTGate, ZGate
from qiskit.visualization import plot_distribution
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

# Imports from Qiskit Runtime
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_runtime import SamplerV2 as Sampler

def grover_oracle(marked_states):
    """Build a Grover oracle for multiple marked states

    Here we assume all input marked states have the same number of bits

    Parameters:
        marked_states (str or list): Marked states of oracle

    Returns:
        QuantumCircuit: Quantum circuit representing Grover oracle
    """
    if not isinstance(marked_states, list):
        marked_states = [marked_states]
    # Compute the number of qubits in circuit
    num_qubits = len(marked_states[0])

    qc = QuantumCircuit(num_qubits)
    # Mark each target state in the input list
    for target in marked_states:
        # Flip target bit-string to match Qiskit bit-ordering
        rev_target = target[::-1]
        # Find the indices of all the '0' elements in bit-string
        zero_inds = [
            ind
            for ind in range(num_qubits)
            if rev_target.startswith("0", ind)
        ]
        # Add a multi-controlled Z-gate with pre- and post-applied X-gates (open-controls)
        # where the target bit-string has a '0' entry
        if zero_inds:
            qc.x(zero_inds)
        qc.compose(MCMTGate(ZGate(), num_qubits - 1, 1), inplace=True)
        if zero_inds:
            qc.x(zero_inds)
    return qc
```

## Крок 1: Відображення класичних входів на квантову задачу {#step-1-map-classical-inputs-to-a-quantum-problem}

Алгоритм Гровера вимагає [оракула](/learning/courses/fundamentals-of-quantum-algorithms/grover-algorithm/introduction), який визначає один або більше позначених станів обчислювального базису, де "позначений" означає стан з фазою -1. Контрольований Z-вентиль або його багатоконтрольована узагальнення для $N$ кубітів позначає стан $2^{N}-1$ (бітовий рядок `'1'`*$N$). Позначення базисних станів з одним або більше `'0'` у двійковому представленні вимагає застосування X-вентилів на відповідних кубітах до та після контрольованого Z-вентиля; еквівалентно наявності відкритого контролю на цьому кубіті. У наступному коді ми визначаємо оракул, який робить саме це, позначаючи один або більше вхідних базисних станів, визначених через їх бітово-рядкове представлення. Вентиль `MCMT` використовується для реалізації багатоконтрольованого Z-вентиля.

```python
# To run on hardware, select the backend with the fewest number of jobs in the queue
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=127
)
backend.name
```

```text
'ibm_brisbane'
```

### Конкретний екземпляр Гровера {#specific-grovers-instance}

Тепер, коли у нас є функція оракула, ми можемо визначити конкретний екземпляр пошуку Гровера. У цьому прикладі ми позначимо два обчислювальних стани з восьми доступних у тривимірному обчислювальному просторі:

```python
marked_states = ["011", "100"]

oracle = grover_oracle(marked_states)
oracle.draw(output="mpl", style="iqp")
```

![Output of the previous code cell](/docs/images/tutorials/grovers-algorithm/extracted-outputs/c150298f-0.avif)

```python
marked_states = ["011", "100"]

oracle = grover_oracle(marked_states)
oracle.draw(output="mpl", style="iqp")
```

![Output of the previous code cell](/docs/images/tutorials/grovers-algorithm/extracted-outputs/7baca7e2-99fc-4089-b5d8-30da56816a6a-0.avif)

```python
marked_states = ["011", "100"]

oracle = grover_oracle(marked_states)
oracle.draw(output="mpl", style="iqp")
```

![Output of the previous code cell](/docs/images/tutorials/grovers-algorithm/extracted-outputs/d3a26fc9-9090-4527-a749-a412661260b6-0.avif)

### Оператор Гровера {#grover-operator}

Вбудована функція Qiskit `grover_operator()` приймає схему оракула та повертає схему, яка складається зі самої схеми оракула та схеми, яка підсилює стани, позначені оракулом. Тут ми використовуємо метод `decompose()` схеми, щоб побачити вентилі всередині оператора:

```python
grover_op = grover_operator(oracle)
grover_op.decompose().draw(output="mpl", style="iqp")
```

![Output of the previous code cell](/docs/images/tutorials/grovers-algorithm/extracted-outputs/283d5265-0.avif)

Повторні застосування цієї схеми `grover_op` підсилюють позначені стани, роблячи їх найбільш ймовірними бітовими рядками у вихідному розподілі зі схеми. Існує оптимальна кількість таких застосувань, яка визначається відношенням позначених станів до загальної кількості можливих обчислювальних станів:

```python
optimal_num_iterations = math.floor(
    math.pi
    / (4 * math.asin(math.sqrt(len(marked_states) / 2**grover_op.num_qubits)))
)
```

### Повна схема Гровера {#full-grover-circuit}

Повний експеримент Гровера починається з вентиля Адамара на кожному кубіті; створюючи рівну суперпозицію всіх станів обчислювального базису, за яким слідує оператор Гровера (`grover_op`), повторений оптимальну кількість разів. Тут ми використовуємо метод `QuantumCircuit.power(INT)` для повторного застосування оператора Гровера.

```python
qc = QuantumCircuit(grover_op.num_qubits)
# Create even superposition of all basis states
qc.h(range(grover_op.num_qubits))
# Apply Grover operator the optimal number of times
qc.compose(grover_op.power(optimal_num_iterations), inplace=True)
# Measure all qubits
qc.measure_all()
qc.draw(output="mpl", style="iqp")
```

![Output of the previous code cell](/docs/images/tutorials/grovers-algorithm/extracted-outputs/4933ae44-0.avif)

## Крок 2: Оптимізація задачі для виконання на квантовому обладнанні {#step-2-optimize-problem-for-quantum-hardware-execution}

```python
target = backend.target
pm = generate_preset_pass_manager(target=target, optimization_level=3)

circuit_isa = pm.run(qc)
circuit_isa.draw(output="mpl", idle_wires=False, style="iqp")
```

![Output of the previous code cell](/docs/images/tutorials/grovers-algorithm/extracted-outputs/c9a3020e-0.avif)

## Крок 3: Виконання за допомогою примітивів Qiskit {#step-3-execute-using-qiskit-primitives}

Підсилення амплітуди — це задача вибірки, яка підходить для виконання з примітивом [`Sampler`](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/sampler-v2) виконавчого середовища.

Зверніть увагу, що метод `run()` [Qiskit Runtime `SamplerV2`](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/sampler-v2) приймає ітерований об'єкт `примітивних уніфікованих блоків (PUB)`. Для sampler кожен PUB — це ітерований об'єкт у форматі `(circuit, parameter_values)`. Однак, як мінімум, він приймає список квантових схем.

```python
# To run on local simulator:
#   1. Use the StatevectorSampler from qiskit.primitives instead
sampler = Sampler(mode=backend)
sampler.options.default_shots = 10_000
result = sampler.run([circuit_isa]).result()
dist = result[0].data.meas.get_counts()
```

## Крок 4: Постобробка та повернення результату в бажаному класичному форматі {#step-4-post-process-and-return-result-in-desired-classical-format}

```python
plot_distribution(dist)
```

![Output of the previous code cell](/docs/images/tutorials/grovers-algorithm/extracted-outputs/a5ef9913-0.avif)

## Опитування посібника {#tutorial-survey}

Будь ласка, пройдіть це коротке опитування, щоб надати відгук про цей посібник. Ваші ідеї допоможуть нам покращити наші пропозиції контенту та користувацький досвід.

[Посилання на опитування](https://your.feedback.ibm.com/jfe/form/SV_0j1SlLPkooyeFJY)
