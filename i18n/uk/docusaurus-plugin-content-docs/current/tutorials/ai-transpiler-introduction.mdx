---
title: "Вступ до сервісу AI-транспілятора Qiskit"
sidebar_label: "Вступ до сервісу AI-транспілятора Qiskit"
description: "У цьому блокноті ми дослідимо ключові переваги сервісу AI-транспілятора Qiskit та порівняємо його з традиційними методами."
notebook_path: "docs/tutorials/ai-transpiler-introduction.ipynb"
---
{/* doqumentation-source-hash: 3bc5a35e */}

<OpenInLabBanner notebookPath="docs/tutorials/ai-transpiler-introduction.ipynb" />



{/* cspell:ignore fontsize idxmin */}

*Оцінене використання QPU: Немає (ПРИМІТКА: Цей посібник не виконує завдання, оскільки він зосереджений на транспіляції)*

## Передумови {#background}

**Сервіс AI-транспілятора Qiskit (QTS)** впроваджує оптимізації на основі машинного навчання як у проходах маршрутизації, так і в проходах синтезу. Ці AI режими були розроблені для подолання обмежень традиційної транспіляції, особливо для великомасштабних схем та складних топологій апаратного забезпечення.

Станом на **липень 2025 року**, **Сервіс Транспілятора** був перенесений на нову платформу IBM Quantum&reg; і більше не доступний. Щоб отримати останні оновлення про статус Сервісу Транспілятора, зверніться до [документації сервісу транспілятора](/guides/qiskit-transpiler-service). Ви все ще можете використовувати AI транспілятор локально, подібно до стандартної транспіляції Qiskit. Просто замініть `generate_preset_pass_manager()` на `generate_ai_pass_manager()`. Ця функція створює менеджер проходів, який інтегрує AI-керовані проходи маршрутизації та синтезу безпосередньо у Ваш локальний робочий процес транспіляції.

### Ключові особливості AI проходів {#key-features-of-ai-passes}

- Проходи маршрутизації: AI-керована маршрутизація може динамічно налаштовувати шляхи кубітів на основі конкретної схеми та бекенду, зменшуючи потребу в надмірних вентилях SWAP.
    - `AIRouting`: Вибір розташування та маршрутизація схеми

- Проходи синтезу: AI техніки оптимізують декомпозицію багатокубітних вентилів, мінімізуючи кількість двокубітних вентилів, які зазвичай більш схильні до помилок.
    - `AICliffordSynthesis`: Синтез вентилів Кліффорда
    - `AILinearFunctionSynthesis`: Синтез схем лінійних функцій
    - `AIPermutationSynthesis`: Синтез схем перестановок
    - `AIPauliNetworkSynthesis`: Синтез схем мережі Паулі (доступний тільки в Сервісі Транспілятора Qiskit, не в локальному середовищі)

- Порівняння з традиційною транспіляцією: Стандартний транспілятор Qiskit є надійним інструментом, який може ефективно обробляти широкий спектр квантових схем. Однак, коли схеми стають більшими за масштабом або конфігурації апаратного забезпечення стають більш складними, AI проходи можуть забезпечити додаткові переваги оптимізації. Використовуючи навчені моделі для маршрутизації та синтезу, QTS додатково вдосконалює макети схем та зменшує накладні витрати для складних або великомасштабних квантових завдань.

Цей посібник оцінює AI режими, використовуючи як проходи маршрутизації, так і синтезу, порівнюючи результати з традиційною транспіляцією, щоб підкреслити, де AI пропонує переваги продуктивності.

Для більш детальної інформації про доступні AI проходи, дивіться [документацію AI проходів](/guides/ai-transpiler-passes).

### Чому використовувати AI для транспіляції квантових схем? {#why-use-ai-for-quantum-circuit-transpilation}

У міру того, як квантові схеми зростають за розміром та складністю, традиційні методи транспіляції стикаються з труднощами в оптимізації макетів та ефективному зменшенні кількості вентилів. Більші схеми, особливо ті, що включають сотні кубітів, створюють значні виклики для маршрутизації та синтезу через обмеження пристроїв, обмежену зв'язність та рівень помилок кубітів.

Саме тут AI-керована транспіляція пропонує потенційне рішення. Використовуючи техніки машинного навчання, AI-керований транспілятор у Qiskit може приймати розумніші рішення щодо маршрутизації кубітів та синтезу вентилів, що призводить до кращої оптимізації великомасштабних квантових схем.

### Короткі результати бенчмаркінгу {#brief-benchmarking-results}
![Graph showing AI transpiler performance against Qiskit](/docs/images/tutorials/ai-transpiler-introduction/ai-transpiler-benchmarks.avif)

У тестах бенчмаркінгу AI транспілятор постійно створював більш неглибокі схеми вищої якості порівняно зі стандартним транспілятором Qiskit. Для цих тестів ми використовували стандартну стратегію менеджера проходів Qiskit, налаштовану за допомогою [`generate_preset_passmanager`]. Хоча ця стандартна стратегія часто є ефективною, вона може мати труднощі з більшими або складнішими схемами. Навпаки, AI-керовані проходи досягли середнього зменшення кількості двокубітних вентилів на 24% та зменшення глибини схеми на 36% для великих схем (100+ кубітів) при транспіляції до топології heavy-hex апаратного забезпечення IBM Quantum. Для отримання додаткової інформації про ці бенчмарки зверніться до цього [блогу.](https://www.ibm.com/quantum/blog/qiskit-performance)

Цей посібник досліджує ключові переваги AI проходів та те, як вони порівнюються з традиційними методами.

```python
# Added by doQumentation — installs packages not in the Binder environment
%pip install -q qiskit-ibm-transpiler
```

```python
# This cell is hidden from users;
# it just disables a linting rule.
# ruff: noqa: F811
```

## Вимоги {#requirements}

Перед початком цього посібника переконайтеся, що у Вас встановлено наступне:

* Qiskit SDK v1.0 або пізніше, з підтримкою [візуалізації](https://docs.quantum.ibm.com/api/qiskit/visualization)
* Qiskit Runtime (`pip install qiskit-ibm-runtime`) v0.22 або пізніше
* Qiskit IBM&reg; Transpiler з AI локальним режимом(`pip install 'qiskit-ibm-transpiler[ai-local-mode]'`)
## Налаштування {#setup}

```python
from qiskit import QuantumCircuit
from qiskit.circuit.library import efficient_su2, PermutationGate
from qiskit.synthesis.qft import synth_qft_full
from qiskit.circuit.random import random_circuit, random_clifford_circuit
from qiskit.transpiler import generate_preset_pass_manager, CouplingMap
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_transpiler import generate_ai_pass_manager
from qiskit.synthesis.permutation import (
    synth_permutation_depth_lnn_kms,
    synth_permutation_basic,
)
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import time
import logging

seed = 42

# Used for generating permutation circuits in part two for comparison
def generate_permutation_circuit(width, pattern):
    circuit = QuantumCircuit(width)
    circuit.append(
        PermutationGate(pattern=pattern),
        qargs=range(width),
    )
    return circuit

# Creates a Bernstein-Vazirani circuit given the number of qubits
def create_bv_circuit(num_qubits):
    qc = QuantumCircuit(num_qubits, num_qubits - 1)
    qc.x(num_qubits - 1)
    qc.h(qc.qubits)
    for i in range(num_qubits - 1):
        qc.cx(i, num_qubits - 1)
    qc.h(qc.qubits[:-1])
    return qc

# Transpile a circuit with a given pass manager and return metrics
def transpile_with_metrics(pass_manager, circuit):
    start = time.time()
    qc_out = pass_manager.run(circuit)
    elapsed = time.time() - start

    depth_2q = qc_out.depth(lambda x: x.operation.num_qubits == 2)
    gate_count = qc_out.size()

    return qc_out, {
        "depth_2q": depth_2q,
        "gate_count": gate_count,
        "time_s": elapsed,
    }

# Used for collecting metrics for part 3 of synthesis methods
def synth_transpile_with_metrics(qc, pm, pattern_id, method):
    start = time.time()
    qc = pm.run(qc)
    elapsed = time.time() - start

    return {
        "Pattern": pattern_id,
        "Method": method,
        "Depth (2Q)": qc.depth(lambda x: x.operation.num_qubits == 2),
        "Gates": qc.size(),
        "Time (s)": elapsed,
    }

# Ignore logs like "INFO:qiskit_ibm_transpiler.wrappers.ai_local_synthesis:Running Linear Functions AI synthesis on local mode"

logging.getLogger(
    "qiskit_ibm_transpiler.wrappers.ai_local_synthesis"
).setLevel(logging.WARNING)
```

# Частина I. Патерни Qiskit {#part-i-qiskit-patterns}

Тепер давайте подивимося, як використовувати сервіс AI транспілятора з простою квантовою схемою, використовуючи патерни Qiskit. Ключовим моментом є створення `PassManager` за допомогою `generate_ai_pass_manager()` замість стандартного `generate_preset_pass_manager()`.
## Крок 1: Відобразити класичні входи на квантову задачу {#step-1-map-classical-inputs-to-a-quantum-problem}

У цьому розділі ми протестуємо AI транспілятор на схемі `efficient_su2`, широко використовуваному апаратно-ефективному анзаці. Ця схема є особливо актуальною для варіаційних квантових алгоритмів (наприклад, VQE) та завдань квантового машинного навчання, що робить її ідеальним тестовим випадком для оцінки продуктивності транспіляції.

Схема `efficient_su2` складається з чергування шарів однокубітних обертань та вентилів заплутування, таких як CNOT. Ці шари забезпечують гнучке дослідження простору квантових станів, зберігаючи глибину вентилів керованою. Оптимізуючи цю схему, ми прагнемо зменшити кількість вентилів, покращити точність та мінімізувати шум. Це робить її сильним кандидатом для тестування ефективності AI транспілятора.

```python
# For our transpilation, we will use a large circuit of 101 qubits
qc = efficient_su2(90, entanglement="circular", reps=1).decompose()

# Draw a smaller version of the circuit to get a visual representation
qc_small = efficient_su2(5, entanglement="circular", reps=1).decompose()
qc_small.draw(output="mpl")
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/c6e9c2c0-e02c-4276-bae8-d5692e60b6b8-0.avif)

## Крок 2: Оптимізувати задачу для виконання на квантовому апаратному забезпеченні {#step-2-optimize-problem-for-quantum-hardware-execution}

### Вибрати бекенд {#choose-a-backend}

Для цього прикладу ми вибираємо найменш завантажений працюючий бекенд IBM Quantum, який не є симулятором і має принаймні 100 кубітів:

**Примітка:** Оскільки найменш завантажений бекенд може змінюватися з часом, для різних запусків можуть бути вибрані різні пристрої. Властивості, специфічні для пристрою, такі як карти зв'язку, можуть призвести до відмінностей у транспільованих схемах.

```python
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=100
)
cm = backend.coupling_map
print(f"Using backend: {backend.name}")
```

```text
Using backend: ibm_torino
```

### Створити AI та традиційні менеджери проходів {#create-ai-and-traditional-pass-managers}
Щоб оцінити ефективність AI транспілятора, ми виконаємо два запуски транспіляції. Спочатку ми транспілюємо схему, використовуючи AI транспілятор. Потім ми проведемо порівняння, транспілюючи ту саму схему без AI транспілятора, використовуючи традиційні методи. Обидва процеси транспіляції використовуватимуть ту саму карту зв'язку з вибраного бекенду та рівень оптимізації, встановлений на 3 для справедливого порівняння.

Обидва ці методи відображають стандартний підхід до створення екземплярів `PassManager` для транспіляції схем у Qiskit.

```python
pm_ai = generate_ai_pass_manager(
    optimization_level=3,
    ai_optimization_level=3,
    coupling_map=cm,
    include_ai_synthesis=True,  # used for part 3 when comparing synthesis methods
)

pm_no_ai = generate_preset_pass_manager(
    optimization_level=3,
    coupling_map=cm,
    seed_transpiler=seed,  # note that the AI pass manager does not currently support seeding
)
```

Транспілюйте схеми та зареєструйте час.

```python
# Transpile using standard (non-AI) pass manager
_, metrics_no_ai = transpile_with_metrics(pm_no_ai, qc)
print(
    f"Standard transpilation: Depth (2q) {metrics_no_ai['depth_2q']}, "
    f"Gate count {metrics_no_ai['gate_count']}, Time {metrics_no_ai['time_s']}"
)

# Transpile using AI pass manager
_, metrics_ai = transpile_with_metrics(pm_ai, qc)
print(
    f"AI transpilation      : Depth (2q) {metrics_ai['depth_2q']}, "
    f"Gate count {metrics_ai['gate_count']}, Time {metrics_ai['time_s']}"
)
```

```text
Standard transpilation: Depth (2q) 95, Gate count 458, Time 0.04650712013244629
AI transpilation      : Depth (2q) 90, Gate count 456, Time 0.9342479705810547
```

У цьому тесті ми порівнюємо продуктивність AI транспілятора та стандартного методу транспіляції на схемі efficient_su2. AI транспілятор досягає помітно меншої глибини схеми, зберігаючи аналогічну кількість вентилів.

- **Глибина схеми:** AI транспілятор створює схему з меншою глибиною двокубітних вентилів. Це очікувано, оскільки AI проходи навчені оптимізувати глибину шляхом вивчення патернів взаємодії кубітів та більш ефективного використання зв'язності апаратного забезпечення, ніж евристики на основі правил.

- **Кількість вентилів:** Загальна кількість вентилів залишається аналогічною між двома методами. Це відповідає очікуванням, оскільки стандартна транспіляція на основі SABRE явно мінімізує кількість swap, що домінує в накладних витратах на вентилі. AI транспілятор натомість надає пріоритет загальній глибині та може іноді жертвувати кількома додатковими вентилями заради коротшого шляху виконання.

- **Час транспіляції:** AI транспілятор працює довше, ніж стандартний метод. Це пов'язано з додатковими обчислювальними витратами на виклик навчених моделей під час маршрутизації та синтезу. На відміну від цього, транспілятор на основі SABRE тепер значно швидший після переписування та оптимізації на Rust, забезпечуючи високоефективну евристичну маршрутизацію в масштабі.

Важливо відзначити, що ці результати базуються лише на одній схемі. Щоб отримати всебічне розуміння того, як AI транспілятор порівнюється з традиційними методами, необхідно протестувати різноманітні схеми. Продуктивність QTS може значно варіюватися залежно від типу оптимізованої схеми. Для ширшого порівняння зверніться до бенчмарків вище або відвідайте [блог.](https://www.ibm.com/quantum/blog/qiskit-performance)
## Крок 3: Виконати, використовуючи примітиви Qiskit {#step-3-execute-using-qiskit-primitives}
Оскільки цей посібник зосереджений на транспіляції, жодні експерименти не будуть виконані на квантовому пристрої. Мета полягає в тому, щоб використовувати оптимізації з Кроку 2 для отримання транспільованої схеми зі зменшеною глибиною або кількістю вентилів.
## Крок 4: Пост-обробити та повернути результат у бажаному класичному форматі {#step-4-post-process-and-return-result-in-desired-classical-format}
Оскільки для цього блокнота немає виконання, немає результатів для пост-обробки.
# Частина II. Аналіз та бенчмаркінг транспільованих схем {#part-ii-analyze-and-benchmark-the-transpiled-circuits}

У цьому розділі ми продемонструємо, як аналізувати транспільовану схему та порівнювати її з оригінальною версією більш детально. Ми зосередимося на метриках, таких як глибина схеми, кількість вентилів та час транспіляції, щоб оцінити ефективність оптимізації. Крім того, ми обговоримо, як результати можуть відрізнятися для різних типів схем, пропонуючи уявлення про ширшу продуктивність транспілятора в різних сценаріях.

```python
# Circuits to benchmark
seed = 42
circuits = [
    {
        "name": "Random",
        "qc": random_circuit(num_qubits=30, depth=10, seed=seed),
    },
    {
        "name": "Clifford",
        "qc": random_clifford_circuit(
            num_qubits=40, num_gates=200, seed=seed
        ),
    },
    {
        "name": "QFT",
        "qc": synth_qft_full(num_qubits=20, do_swaps=False).decompose(),
    },
    {
        "name": "BV",
        "qc": create_bv_circuit(40),
    },
]

results = []

# Run the transpilation for each circuit and store the results
for circuit in circuits:
    qc_no_ai, metrics_no_ai = transpile_with_metrics(pm_no_ai, circuit["qc"])
    qc_ai, metrics_ai = transpile_with_metrics(pm_ai, circuit["qc"])

    print("Completed transpilation for", circuit["name"])

    results.append(
        {
            "Circuit": circuit["name"],
            "Depth 2Q (No AI)": metrics_no_ai["depth_2q"],
            "Gate Count (No AI)": metrics_no_ai["gate_count"],
            "Time (No AI)": metrics_no_ai["time_s"],
            "Depth 2Q (AI)": metrics_ai["depth_2q"],
            "Gate Count (AI)": metrics_ai["gate_count"],
            "Time (AI)": metrics_ai["time_s"],
        }
    )

df = pd.DataFrame(results)
df
```

```text
Completed transpilation for Random
Completed transpilation for Clifford
Completed transpilation for QFT
Completed transpilation for BV
```

```text
Circuit  Depth 2Q (No AI)  Gate Count (No AI)  Time (No AI)  \
0    Random                37                 221      0.039347
1  Clifford                36                 232      0.036633
2       QFT               165                 924      0.077458
3        BV                65                 155      0.024993

   Depth 2Q (AI)  Gate Count (AI)  Time (AI)
0             24              181   0.773718
1             43              267   1.097431
2            130              913   3.660771
3             70              155   0.345522
```

Середнє процентне зменшення для кожної метрики. Позитивні значення є покращеннями, негативні є погіршеннями.

```python
# Average reduction from non-AI to AI transpilation as a percentage
avg_reduction_depth = (
    (df["Depth 2Q (No AI)"] - df["Depth 2Q (AI)"]).mean()
    / df["Depth 2Q (No AI)"].mean()
    * 100
)
avg_reduction_gates = (
    (df["Gate Count (No AI)"] - df["Gate Count (AI)"]).mean()
    / df["Gate Count (No AI)"].mean()
    * 100
)
avg_reduction_time = (
    (df["Time (No AI)"] - df["Time (AI)"]).mean()
    / df["Time (No AI)"].mean()
    * 100
)

print(f"Average reduction in depth: {avg_reduction_depth:.2f}%")
print(f"Average reduction in gate count: {avg_reduction_gates:.2f}%")
print(f"Average reduction in transpilation time: {avg_reduction_time:.2f}%")
```

```text
Average reduction in depth: 11.88%
Average reduction in gate count: 1.04%
Average reduction in transpilation time: -3193.95%
```

```python
fig, axs = plt.subplots(1, 3, figsize=(21, 6))
df.plot(
    x="Circuit",
    y=["Depth 2Q (No AI)", "Depth 2Q (AI)"],
    kind="bar",
    ax=axs[0],
)
axs[0].set_title("Circuit Depth Comparison")
axs[0].set_ylabel("Depth")
axs[0].set_xlabel("Circuit")
axs[0].tick_params(axis="x", rotation=45)
df.plot(
    x="Circuit",
    y=["Gate Count (No AI)", "Gate Count (AI)"],
    kind="bar",
    ax=axs[1],
)
axs[1].set_title("Gate Count Comparison")
axs[1].set_ylabel("Gate Count")
axs[1].set_xlabel("Circuit")
axs[1].tick_params(axis="x", rotation=45)
df.plot(x="Circuit", y=["Time (No AI)", "Time (AI)"], kind="bar", ax=axs[2])
axs[2].set_title("Time Comparison")
axs[2].set_ylabel("Time (seconds)")
axs[2].set_xlabel("Circuit")
axs[2].tick_params(axis="x", rotation=45)
fig.suptitle(
    "Benchmarking AI transpilation vs Non-AI transpilation for various circuits"
)

plt.tight_layout()
plt.show()
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/79b8d5d9-0f9d-42ca-9583-8bec17430014-0.avif)

Продуктивність AI транспілятора значно варіюється залежно від типу оптимізованої схеми. У деяких випадках він досягає помітних зменшень глибини схеми та кількості вентилів порівняно зі стандартним транспілятором. Однак ці покращення часто супроводжуються суттєвим збільшенням часу виконання.

Для певних типів схем AI транспілятор може давати дещо кращі результати з точки зору глибини схеми, але також може призвести до збільшення кількості вентилів та значного штрафу щодо часу виконання. Ці спостереження свідчать про те, що переваги AI транспілятора не є однаковими для всіх типів схем. Натомість його ефективність залежить від конкретних характеристик схеми, що робить його більш придатним для деяких випадків використання, ніж для інших.
## Коли користувачам слід обирати транспіляцію з використанням ШІ? {#when-should-users-choose-ai-powered-transpilation}

Транспілятор з використанням ШІ в Qiskit виділяється в сценаріях, де традиційні методи транспіляції зазнають труднощів, зокрема з великомасштабними та складними квантовими схемами. Для схем, що включають сотні кубітів, або тих, які орієнтовані на апаратне забезпечення зі складними картами зв'язування, ШІ-транспілятор пропонує вищу оптимізацію з точки зору глибини схеми, кількості вентилів та ефективності часу виконання. У тестах порівняльного аналізу він постійно перевершував традиційні методи, забезпечуючи значно менш глибокі схеми та зменшуючи кількість вентилів, що є критичним для покращення продуктивності та пом'якшення шуму на реальному квантовому обладнанні.

Користувачам слід розглянути транспіляцію з використанням ШІ під час роботи з:
- Великими схемами, де традиційні методи не можуть ефективно впоратися з масштабом.
- Складними топологіями апаратного забезпечення, де виникають проблеми з підключенням пристроїв та маршрутизацією.
- Додатками, чутливими до продуктивності, де зменшення глибини схеми та покращення точності є першочерговими.
# Частина III. Дослідження синтезу мереж перестановок з використанням ШІ {#part-iii-explore-ai-powered-permutation-network-synthesis}

Мережі перестановок є фундаментальними в квантових обчисленнях, особливо для систем, обмежених обмеженими топологіями. Ці мережі полегшують взаємодії на великі відстані шляхом динамічного обміну кубітів для імітації повного зв'язування на апаратному забезпеченні з обмеженим підключенням. Такі перетворення є важливими для реалізації складних квантових алгоритмів на пристроях ближньої перспективи, де взаємодії часто виходять за межі найближчих сусідів.

У цьому розділі ми виділяємо синтез мереж перестановок як переконливий випадок використання для транспілятора з використанням ШІ в Qiskit. Зокрема, прохід `AIPermutationSynthesis` використовує оптимізацію на основі ШІ для генерації ефективних схем для завдань перестановки кубітів. На відміну від цього, загальні підходи синтезу часто не можуть збалансувати кількість вентилів та глибину схеми, особливо в сценаріях з щільними взаємодіями кубітів або при спробі досягти повного зв'язування.

Ми розглянемо приклад патернів Qiskit, що демонструє синтез мережі перестановок для досягнення повного зв'язування для набору кубітів. Ми порівняємо продуктивність `AIPermutationSynthesis` зі стандартними методами синтезу в Qiskit. Цей приклад продемонструє, як ШІ-транспілятор оптимізує для меншої глибини схеми та кількості вентилів, підкреслюючи його переваги в практичних квантових робочих процесах. Щоб активувати прохід синтезу ШІ, ми використаємо функцію `generate_ai_pass_manager()` з параметром `include_ai_synthesis`, встановленим на `True`.
## Крок 1: Відображення класичних входів на квантову задачу {#step-1-map-classical-inputs-to-a-quantum-problem}

Щоб представити класичну задачу перестановки на квантовому комп'ютері, ми починаємо з визначення структури квантових схем. Для цього прикладу:

1. Ініціалізація квантової схеми:
   Ми виділяємо 27 кубітів, щоб відповідати бекенду, який ми будемо використовувати, який має 27 кубітів.

2. Застосування перестановок:
   Ми генеруємо десять випадкових патернів перестановок (`pattern_1` до `pattern_10`) з використанням фіксованого зерна для відтворюваності. Кожен патерн перестановки застосовується до окремої квантової схеми (`qc_1` до `qc_10`).

3. Декомпозиція схеми:
   Кожна операція перестановки розкладається на набори нативних вентилів, сумісних з цільовим квантовим обладнанням. Ми аналізуємо глибину та кількість двокубітних вентилів (нелокальних вентилів) для кожної розкладеної схеми.

Результати надають уявлення про складність представлення класичних задач перестановки на квантовому пристрої, демонструючи вимоги до ресурсів для різних патернів перестановок.

```python
# Parameters
width = 27
num_circuits = 10

# Set random seed
np.random.seed(seed)

# Generate random patterns and circuits
patterns = [
    np.random.permutation(width).tolist() for _ in range(num_circuits)
]
circuits = {
    f"qc_{i}": generate_permutation_circuit(width, pattern)
    for i, pattern in enumerate(patterns, start=1)
}

# Display one of the circuits
circuits["qc_1"].decompose(reps=3).draw(output="mpl", fold=-1)
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/76a3e847-0808-4413-bd0c-c760cd2df3f4-0.avif)

## Крок 2: Оптимізація задачі для виконання на квантовому обладнанні {#step-2-optimize-problem-for-quantum-hardware-execution}
На цьому кроці ми продовжуємо оптимізацію з використанням проходів синтезу ШІ.

Для проходів синтезу ШІ, `PassManager` потребує лише карти зв'язування бекенду. Однак важливо зазначити, що не всі карти зв'язування є сумісними; працюватимуть лише ті, на яких було навчено прохід `AIPermutationSynthesis`. Наразі прохід `AIPermutationSynthesis` підтримує блоки розмірів 65, 33 та 27 кубітів. Для цього прикладу ми використовуємо 27-кубітний QPU.

Для порівняння ми оцінимо продуктивність синтезу ШІ порівняно з загальними методами синтезу перестановок у Qiskit, включаючи:

- `synth_permutation_depth_lnn_kms`: Цей метод синтезує схему перестановки для архітектури лінійних найближчих сусідів (LNN) з використанням алгоритму Кутіна, Моултона та Смітлайна (KMS). Він гарантує схему з глибиною не більше $ n $ та розміром не більше $ n(n-1)/2 $, де і глибина, і розмір вимірюються в термінах вентилів SWAP.

- `synth_permutation_basic`: Це проста реалізація, яка синтезує схеми перестановок без накладання обмежень на підключення або оптимізацію для конкретних архітектур. Вона служить базовою лінією для порівняння продуктивності з більш просунутими методами.

Кожен з цих методів представляє окремий підхід до синтезу мереж перестановок, забезпечуючи всебічний еталон порівняно з методами на основі ШІ.

Для отримання додаткової інформації про методи синтезу в Qiskit зверніться до [документації API Qiskit](https://docs.quantum.ibm.com/api/qiskit/synthesis).
Визначте карту зв'язування, що представляє 27-кубітний QPU.

```python
coupling_map = [
    [1, 0],
    [2, 1],
    [3, 2],
    [3, 5],
    [4, 1],
    [6, 7],
    [7, 4],
    [7, 10],
    [8, 5],
    [8, 9],
    [8, 11],
    [11, 14],
    [12, 10],
    [12, 13],
    [12, 15],
    [13, 14],
    [16, 14],
    [17, 18],
    [18, 15],
    [18, 21],
    [19, 16],
    [19, 22],
    [20, 19],
    [21, 23],
    [23, 24],
    [25, 22],
    [25, 24],
    [26, 25],
]
CouplingMap(coupling_map).draw()
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/84dff2c2-a496-4828-bb8e-08d373816a36-0.avif)

Транспілюйте кожну зі схем перестановок з використанням проходів синтезу ШІ та загальних методів синтезу.

```python
results = []
pm_no_ai_synth = generate_preset_pass_manager(
    coupling_map=cm,
    optimization_level=1,  # set to 1 since we are using the synthesis methods
)

# Transpile and analyze all circuits
for i, (qc_name, qc) in enumerate(circuits.items(), start=1):
    pattern = patterns[i - 1]  # Get the corresponding pattern

    qc_depth_lnn_kms = synth_permutation_depth_lnn_kms(pattern)
    qc_basic = synth_permutation_basic(pattern)

    # AI synthesis
    results.append(
        synth_transpile_with_metrics(
            qc.decompose(reps=3),
            pm_ai,
            qc_name,
            "AI",
        )
    )

    # Depth-LNN-KMS Method
    results.append(
        synth_transpile_with_metrics(
            qc_depth_lnn_kms.decompose(reps=3),
            pm_no_ai_synth,
            qc_name,
            "Depth-LNN-KMS",
        )
    )

    # Basic Method
    results.append(
        synth_transpile_with_metrics(
            qc_basic.decompose(reps=3),
            pm_no_ai_synth,
            qc_name,
            "Basic",
        )
    )

results_df = pd.DataFrame(results)
```

Запишіть метрики (глибину, кількість вентилів, час) для кожної схеми після транспіляції.

```python
# Calculate averages for each metric
average_metrics = results_df.groupby("Method")[
    ["Depth (2Q)", "Gates", "Time (s)"]
].mean()
average_metrics = average_metrics.round(3)  # Round to two decimal places
print("\n=== Average Metrics ===")
print(average_metrics)

# Identify the best non-AI method based on least average depth
non_ai_methods = [
    method for method in results_df["Method"].unique() if method != "AI"
]
best_non_ai_method = average_metrics.loc[non_ai_methods][
    "Depth (2Q)"
].idxmin()
print(
    f"\nBest Non-AI Method (based on least average depth): {best_non_ai_method}"
)

# Compare AI to the best non-AI method
ai_metrics = average_metrics.loc["AI"]
best_non_ai_metrics = average_metrics.loc[best_non_ai_method]

comparison = {
    "Metric": ["Depth (2Q)", "Gates", "Time (s)"],
    "AI": [
        ai_metrics["Depth (2Q)"],
        ai_metrics["Gates"],
        ai_metrics["Time (s)"],
    ],
    best_non_ai_method: [
        best_non_ai_metrics["Depth (2Q)"],
        best_non_ai_metrics["Gates"],
        best_non_ai_metrics["Time (s)"],
    ],
    "Improvement (AI vs Best Non-AI)": [
        ai_metrics["Depth (2Q)"] - best_non_ai_metrics["Depth (2Q)"],
        ai_metrics["Gates"] - best_non_ai_metrics["Gates"],
        ai_metrics["Time (s)"] - best_non_ai_metrics["Time (s)"],
    ],
}

comparison_df = pd.DataFrame(comparison)
print("\n=== Comparison of AI vs Best Non-AI Method ===")
comparison_df
```

```text
=== Average Metrics ===
               Depth (2Q)  Gates  Time (s)
Method
AI                   23.9   82.8     0.248
Basic                29.8   91.0     0.012
Depth-LNN-KMS        70.8  531.6     0.017

Best Non-AI Method (based on least average depth): Basic

=== Comparison of AI vs Best Non-AI Method ===
```

```text
Metric      AI   Basic  Improvement (AI vs Best Non-AI)
0  Depth (2Q)  23.900  29.800                           -5.900
1       Gates  82.800  91.000                           -8.200
2    Time (s)   0.248   0.012                            0.236
```

Результати демонструють, що ШІ-транспілятор перевершує всі інші методи синтезу Qiskit для цього набору випадкових схем перестановок. Ключові висновки включають:

1. Глибина: ШІ-транспілятор досягає найменшої середньої глибини, що вказує на вищу оптимізацію макетів схем.
2. Кількість вентилів: Він значно зменшує кількість вентилів порівняно з іншими методами, покращуючи точність виконання та ефективність.
3. Час транспіляції: Усі методи працюють дуже швидко на цьому масштабі, що робить їх практичними для використання. Однак ШІ-транспілятор має помітне збільшення часу виконання порівняно з традиційними методами через складність використовуваних моделей ШІ.

Ці результати встановлюють ШІ-транспілятор як найбільш ефективний підхід для цього еталону, особливо для оптимізації глибини та кількості вентилів.
Побудуйте графіки результатів для порівняння продуктивності проходів синтезу ШІ з загальними методами синтезу.

```python
methods = results_df["Method"].unique()

fig, axs = plt.subplots(1, 3, figsize=(18, 5))

# Pivot the DataFrame and reorder columns to ensure AI is first
pivot_depth = results_df.pivot(
    index="Pattern", columns="Method", values="Depth (2Q)"
)[["AI", "Depth-LNN-KMS", "Basic"]]
pivot_gates = results_df.pivot(
    index="Pattern", columns="Method", values="Gates"
)[["AI", "Depth-LNN-KMS", "Basic"]]
pivot_time = results_df.pivot(
    index="Pattern", columns="Method", values="Time (s)"
)[["AI", "Depth-LNN-KMS", "Basic"]]

pivot_depth.plot(kind="bar", ax=axs[0], legend=False)
axs[0].set_title("Circuit Depth Comparison")
axs[0].set_ylabel("Depth")
axs[0].set_xlabel("Pattern")
axs[0].tick_params(axis="x", rotation=45)
pivot_gates.plot(kind="bar", ax=axs[1], legend=False)
axs[1].set_title("2Q Gate Count Comparison")
axs[1].set_ylabel("Number of 2Q Gates")
axs[1].set_xlabel("Pattern")
axs[1].tick_params(axis="x", rotation=45)
pivot_time.plot(
    kind="bar", ax=axs[2], legend=True, title="Legend"
)  # Show legend on the last plot
axs[2].set_title("Time Comparison")
axs[2].set_ylabel("Time (seconds)")
axs[2].set_xlabel("Pattern")
axs[2].tick_params(axis="x", rotation=45)
fig.suptitle(
    "Benchmarking AI Synthesis Methods vs Non-AI Synthesis Methods For Random Permutations Circuits",
    fontsize=16,
    y=1,
)

plt.tight_layout()
plt.show()
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/a326f268-0115-442c-8563-968676b66670-0.avif)

Цей графік виділяє індивідуальні результати для кожної схеми (від `qc_1` до `qc_10`) для різних методів синтезу:

Хоча ці результати підкреслюють ефективність ШІ-транспілятора для схем перестановок, важливо зазначити його обмеження. Метод синтезу ШІ наразі доступний лише для певних карт зв'язування, що може обмежити його ширшу застосовність. Це обмеження слід враховувати при оцінці його використання в різних сценаріях.

Загалом, ШІ-транспілятор демонструє багатообіцяючі покращення в оптимізації глибини та кількості вентилів для цих конкретних схем, зберігаючи при цьому порівнянний час транспіляції.
## Крок 3: Виконання з використанням примітивів Qiskit {#step-3-execute-using-qiskit-primitives}
Оскільки цей посібник зосереджується на транспіляції, жодні експерименти не будуть виконані на квантовому пристрої. Мета полягає в тому, щоб використати оптимізації з Кроку 2 для отримання транспільованої схеми зі зменшеною глибиною або кількістю вентилів.
## Крок 4: Постобробка та повернення результату в бажаному класичному форматі {#step-4-post-process-and-return-result-in-desired-classical-format}
Оскільки для цього блокнота не виконується жодне виконання, результати для постобробки відсутні.
## Опитування щодо посібника {#tutorial-survey}

Будь ласка, пройдіть це коротке опитування, щоб надати відгук про цей посібник. Ваші думки допоможуть нам покращити наші пропозиції контенту та досвід користувачів.
