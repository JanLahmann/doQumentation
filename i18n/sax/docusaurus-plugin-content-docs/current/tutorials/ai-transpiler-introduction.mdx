---
title: "Eiführung in'n Qiskit AI-geschtitzdn Transpiler-Service"
sidebar_label: "Eiführung in'n Qiskit AI-geschtitzdn Transpiler-Service"
description: "In däm Notebook gunschn mer uns de wichtischschn Voordeel vom Qiskit AI-geschtitzdn Transpiler-Service oo un vachlaaschdn, wie'r sich geechnüber traditionelln Metodn schläächt."
notebook_path: "docs/tutorials/ai-transpiler-introduction.ipynb"
---

<OpenInLabBanner notebookPath="docs/tutorials/ai-transpiler-introduction.ipynb" />



{/* cspell:ignore fontsize idxmin */}

*Gschätzde QPU-Nutzung: Geene (HIENWEIS: Däs Tutorial fierrd keene Jobs aus, weil's uff de Transpilatschn gundsentriert is)*

## Hintargrund {#background}

Dr **Qiskit AI-geschtitzte Transpiler-Service (QTS)** fierrd maschinenlärnbasierte Obtimierungen sowohl bei Routing- als ooch Synthese-Pässen ei. Die AI-Modi sinn dafier entwiggelt worn, de Grenzn von traditioneller Transpilatschn ze ieberwinden — besunders fier groß ooglächde Schaltgreese un gomblizierde Hardware-Topolochien.

Ab **Juli 2025** is dr **Transpiler-Service** uff de neue IBM Quantum&reg;-Plattform migrierd worn un steht nimmer zur Verfiegung. Fier de neeschn Infos iebern Susdand vom Transpiler-Service, gugg in de [Transpilaer-Service-Dokumentatschn](/guides/qiskit-transpiler-service). De gaannst dr AI-Transpiler noo immer loogal nutzen, ähnlich wie de schdandard Qiskit-Transpilatschn. Tausch eenfach `generate_preset_pass_manager()` geegn `generate_ai_pass_manager()` aus. Die Fundschen baut'n Pass-Manager, wo de AI-geschtitzdn Routing- un Synthese-Pässe direkd in dein loogaln Transpilatschens-Workflow integrierd.

### Hauptmärkmale von AI-Pässen {#key-features-of-ai-passes}

- Routing-Pässe: AI-geschtitztes Routing gann Qubit-Pfaade dynamisch oo de Schaltgrees- un Backend-Eigenschaften oopassn un do de Anzaal von iebermäßschn SWAP-Gates reducierdn.
    - `AIRouting`: Layout-Auswaal un Schaltgrees-Routing

- Synthese-Pässe: AI-Techniggen obtimieren de Zerläärung von Mehr-Qubit-Gates un minimiern de Anzaal von Zwaa-Qubit-Gates, wo typischerweis fähleroanfälliger sinn.
    - `AICliffordSynthesis`: Clifford-Gate-Synthese
    - `AILinearFunctionSynthesis`: Synthese von linäärn Fundschen-Schaltgreesn
    - `AIPermutationSynthesis`: Synthese von Permutatschen-Schaltgreesn
    - `AIPauliNetworkSynthesis`: Synthese von Pauli-Netzwerk-Schaltgreesn (nur im Qiskit-Transpiler-Service verfiegbar, nich in der loogaln Umgäbung)

- Vachlaasch mit traditioneller Transpilatschn: Dr schdandard Qiskit-Transpiler is'n robustes Wärgzeich, das'n breeschn Schbegtrum von Quanteschaltgreesn effegdiv handhabn gann. Wenn Schaltgreese aber größer werden oder Hardware-Konfiguratschen gomblizieerder wärn, gönnen AI-Pässe zusätzliche Obtimierungsgewinne liefern. Dursch den Einsatz von gelärndn Modälln fier Routing un Synthese verfeinerd QTS de Schaltgrees-Layouts weider un reducied dr Overhead fier anschbruchsvolle oder groß ooglächde Quanteufgoobn.

Däs Tutorial bewärtd de AI-Modi mit sowohl Routing- als ooch Synthese-Pässen un vachlaaschd de Argebnisse mit traditioneller Transpilatschn, um erauszufinden, wo AI Leistungsgewinne biedd.

Fier mähr Details ieber de verfiegbarn AI-Pässe, gugg in de [AI-Pässe-Dokumentatschn](/guides/ai-transpiler-passes).

### Warum AI fier die Transpilatschn von Quanteschaltgreesn nutzen? {#why-use-ai-for-quantum-circuit-transpilation}

Wenn Quanteschaltgreese in Größe un Gombläxität zunehmen, schdoßn traditionelle Transpilatschensmetodn bei der Obtimierung von Layouts un der Reduzierung von Gate-Anzaaln oo ihre Grenzn. Größere Schaltgreese, besunders die mit hunderte von Qubits, schdälln erhäbliche Herausforderungen fier Routing un Synthese dar — wegen Geräteeinschränkungen, begrenzder Gondektivitäd un Qubit-Fählerraatn.

Genau da biedd AI-geschtitzte Transpilatschn'ne mögliche Lösung. Dursch den Einsatz von Maschinenlärntekniggen gann dr AI-geschtitzte Transpiler in Qiskit glieger Endscheidungen ieber Qubit-Routing un Gate-Synthese träffn, was ze bässern Obtimierungen von groß ooglächdn Quanteschaltgreesn führd.

### Kurze Benchmarking-Ergebnisse {#brief-benchmarking-results}
![Groaff, der de AI-Transpiler-Leistung geechnüber Qiskit zeicht](/docs/images/tutorials/ai-transpiler-introduction/ai-transpiler-benchmarks.avif)

In Benchmarking-Tests hat dr AI-Transpiler gonseeschdent flachere, höherwärtige Schaltgreese lieferd als dr schdandard Qiskit-Transpiler. Fier die Tests ham mer Qiskit's schdandard Pass-Manager-Strategie verwend, konfiguriert mit [`generate_preset_passmanager`]. Während diese Schdandard-Strategie oft effegdiv is, gann se mit größern oder gomblizieerdn Schaltgreesn kämpfn. Im Gecheensatz doazu ham AI-geschtitzte Pässe durschnittlich 24 % weniger Zwaa-Qubit-Gates un 36 % weniger Schaltgrees-Diefe bei großn Schaltgreesn (100+ Qubits) arziild, wenn se uff die Heavy-Hex-Topolochie von IBM Quantum Hardware transpiiert worn sinn. Fier mehr Infos ieber die Benchmarks, gugg in däsn [Blog](https://www.ibm.com/quantum/blog/qiskit-performance).

Däs Tutorial ergundd de wichtischschn Voordeel von AI-Pässen un wie se sich geechnüber traditionelln Metodn schläächt.

```python
# Added by doQumentation — installs packages not in the Binder environment
%pip install -q qiskit-ibm-transpiler
```

```python
# This cell is hidden from users;
# it just disables a linting rule.
# ruff: noqa: F811
```

## Voraussetzungen {#requirements}

Bevor de mit däm Tutorial oonfängst, schdäll sicher, dass de Folgendes installiert hast:

* Qiskit SDK v1.0 oder neier, mit [Visualisieerungsunterschditzung](https://docs.quantum.ibm.com/api/qiskit/visualization)
* Qiskit Runtime (`pip install qiskit-ibm-runtime`) v0.22 oder neier
* Qiskit IBM&reg; Transpiler mit AI-loogaln Modus (`pip install 'qiskit-ibm-transpiler[ai-local-mode]'`)
## Setup {#setup}

```python
from qiskit import QuantumCircuit
from qiskit.circuit.library import efficient_su2, PermutationGate
from qiskit.synthesis.qft import synth_qft_full
from qiskit.circuit.random import random_circuit, random_clifford_circuit
from qiskit.transpiler import generate_preset_pass_manager, CouplingMap
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_transpiler import generate_ai_pass_manager
from qiskit.synthesis.permutation import (
    synth_permutation_depth_lnn_kms,
    synth_permutation_basic,
)
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import time
import logging

seed = 42

# Used for generating permutation circuits in part two for comparison
def generate_permutation_circuit(width, pattern):
    circuit = QuantumCircuit(width)
    circuit.append(
        PermutationGate(pattern=pattern),
        qargs=range(width),
    )
    return circuit

# Creates a Bernstein-Vazirani circuit given the number of qubits
def create_bv_circuit(num_qubits):
    qc = QuantumCircuit(num_qubits, num_qubits - 1)
    qc.x(num_qubits - 1)
    qc.h(qc.qubits)
    for i in range(num_qubits - 1):
        qc.cx(i, num_qubits - 1)
    qc.h(qc.qubits[:-1])
    return qc

# Transpile a circuit with a given pass manager and return metrics
def transpile_with_metrics(pass_manager, circuit):
    start = time.time()
    qc_out = pass_manager.run(circuit)
    elapsed = time.time() - start

    depth_2q = qc_out.depth(lambda x: x.operation.num_qubits == 2)
    gate_count = qc_out.size()

    return qc_out, {
        "depth_2q": depth_2q,
        "gate_count": gate_count,
        "time_s": elapsed,
    }

# Used for collecting metrics for part 3 of synthesis methods
def synth_transpile_with_metrics(qc, pm, pattern_id, method):
    start = time.time()
    qc = pm.run(qc)
    elapsed = time.time() - start

    return {
        "Pattern": pattern_id,
        "Method": method,
        "Depth (2Q)": qc.depth(lambda x: x.operation.num_qubits == 2),
        "Gates": qc.size(),
        "Time (s)": elapsed,
    }

# Ignore logs like "INFO:qiskit_ibm_transpiler.wrappers.ai_local_synthesis:Running Linear Functions AI synthesis on local mode"

logging.getLogger(
    "qiskit_ibm_transpiler.wrappers.ai_local_synthesis"
).setLevel(logging.WARNING)
```

# Deel I. Qiskit-Muster {#part-i-qiskit-patterns}

Loomer jetzd gunschn, wie mer dr AI-Transpiler-Service mit'ner eenfachn Quanteschaltgrees nutzt, mit Qiskit-Mustern. Dr Schlüssl is es,'n `PassManager` mit `generate_ai_pass_manager()` schdatt mit'm schdandard `generate_preset_pass_manager()` ze erzeugen.
## Schdritt 1: Glassische Eingoobn uff'n Quanteprobläm oobildn {#step-1-map-classical-inputs-to-a-quantum-problem}

In däm Abschnitt teschn mer dr AI-Transpiler uff dr `efficient_su2`-Schaltgrees,'n weid värbreedetn Hardware-effizienten Ansatz. Die Schaltgrees is besunders relevand fier variatschen-Quantealgorithmn (zum Beispiel VQE) un Quantemaschinenlärnaufgoabn, was se zu'm ideaaln Tesdfaall fier die Bewärtung von Transpilatschensleistung macht.

De `efficient_su2`-Schaltgrees besteht aus abwechselnd Schichtn von Einzel-Qubit-Rotatschen un Verschränkungsgates wie CNOTs. Die Schichtn ermöchln en flexibles Ergunden vom Quantesuschstandsraum, während de Gate-Diefe handhaabbar bleibd. Dursch de Obtimierung von dieser Schaltgrees wölln mer de Gate-Anzaal reduzieren, de Treue värbässern un Rausch minimieren. Das macht se ze'm schdarkn Kandidatn fier's Tesdn von dr Effizients vom AI-Transpiler.

```python
# For our transpilation, we will use a large circuit of 101 qubits
qc = efficient_su2(90, entanglement="circular", reps=1).decompose()

# Draw a smaller version of the circuit to get a visual representation
qc_small = efficient_su2(5, entanglement="circular", reps=1).decompose()
qc_small.draw(output="mpl")
```

![Ausgaab von der vorischn Code-Zälle](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/c6e9c2c0-e02c-4276-bae8-d5692e60b6b8-0.avif)

## Schdritt 2: Probläm fier die Ausfiehrung uff Quantehardware obtimieren {#step-2-optimize-problem-for-quantum-hardware-execution}

### Backend auswääln {#choose-a-backend}

Fier däs Beispiel wääln mer dr am wenigschn ausgelaschdete operatschen-älle IBM Quantum-Backend, der kee Simulator is un mindeschdens 100 Qubits hat:

**Hienweis:** Da dr am wenigschn ausgelaschdete Backend sich im Laufe dr Zeit änderd, gönnen fier verschiedene Ausfiehrungen verschiedene Geräte ausgewääld wärn. Gerätespezifische Eigenschaften, wie Koppplungsgarten, gönnen ze Unterschieden bei de transpilierdn Schaltgreesn führn.

```python
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=100
)
cm = backend.coupling_map
print(f"Using backend: {backend.name}")
```

```text
Using backend: ibm_torino
```

### AI- un traditionelle Pass-Manager erställn {#create-ai-and-traditional-pass-managers}
Um de Effegdivitäd vom AI-Transpiler ze bewärtn, fäährn mer zwei Transpilatschensläufe dursch. Zuersd transpiern mer de Schaltgrees mit'm AI-Transpiler. Donooch machn mer'n Vachlaasch, indääm mer diesälbe Schaltgrees ohni'n AI-Transpiler transpiern, mit traditionelln Metodn. Beede Transpilatschensprozässe nutzn densälbn Kopplungskaartn vom gewääldtn Backend un'n Obtimierungslevel 3 fier'n fairen Vachlaasch.

Beede Metodn verschbeechlln dr schdandard-Ooatz zum Erställn von `PassManager`-Instanzn fier de Transpilatschn von Schaltgreesn in Qiskit.

```python
pm_ai = generate_ai_pass_manager(
    optimization_level=3,
    ai_optimization_level=3,
    coupling_map=cm,
    include_ai_synthesis=True,  # used for part 3 when comparing synthesis methods
)

pm_no_ai = generate_preset_pass_manager(
    optimization_level=3,
    coupling_map=cm,
    seed_transpiler=seed,  # note that the AI pass manager does not currently support seeding
)
```

De Schaltgreese transpiern un de Zeeschn erfassn.

```python
# Transpile using standard (non-AI) pass manager
_, metrics_no_ai = transpile_with_metrics(pm_no_ai, qc)
print(
    f"Standard transpilation: Depth (2q) {metrics_no_ai['depth_2q']}, "
    f"Gate count {metrics_no_ai['gate_count']}, Time {metrics_no_ai['time_s']}"
)

# Transpile using AI pass manager
_, metrics_ai = transpile_with_metrics(pm_ai, qc)
print(
    f"AI transpilation      : Depth (2q) {metrics_ai['depth_2q']}, "
    f"Gate count {metrics_ai['gate_count']}, Time {metrics_ai['time_s']}"
)
```

```text
Standard transpilation: Depth (2q) 95, Gate count 458, Time 0.04650712013244629
AI transpilation      : Depth (2q) 90, Gate count 456, Time 0.9342479705810547
```

In däm Tesd vachlaaschdn mer de Leistung vom AI-Transpiler un dr schdandard Transpilatschensmetode uff dr efficient_su2-Schaltgrees. Dr AI-Transpiler arziild'ne merklich fiachere Schaltgrees-Diefe, während de Gate-Anzaal ähnlich bleibd.

- **Schaltgrees-Diefe:** Dr AI-Transpiler erzeugt'ne Schaltgrees mit niedrigerer Zwaa-Qubit-Diefe. Das is erwartbar, da de AI-Pässe drauf trainiert wärn, de Diefe ze obtimieren, indääm se Qubit-Interaktschensmusder lärndn un de Hardware-Gondektivitäd effegtiver ausnutzn als räägelbasierte Heuristiggn.

- **Gate-Anzaal:** De Gesamtzaal von Gates bleibd zwischn beiden Metodn ähnlich. Das stimmd mit den Erwartungen überein, da de schdandard SABRE-basierte Transpilatschn explizit de Swap-Anzaal minimiert, die den Gate-Overhead dominiert. Dr AI-Transpiler priorisiert schdattdässn de Gesamtdiefe un gann gelegentlich'ne paar zusätzliche Gates fier'n kürzern Ausfiehrungspfaad in Gouf nehm.

- **Transpilatschenszeit:** Dr AI-Transpiler braucht länger als de schdandard Metode. Das liechd an den zusätzlichen Räcknaufwand beim Aufruufn von gelärndn Modälln während Routing un Synthese. Im Gecheensatz doazu is dr SABRE-basierte Transpiler jetzt deutlich schnäller, noochdääm'r in Rust neugeschrieben un obtimiert worn is, was'n höchst effizientes heuristisches Routing in großm Maßschdab lieferd.

Es is wichtsch zu bemierkn, dass die Argebnisse uff nur einer Schaltgrees basieren. Um'n umfassendes Verständnis doofür ze erlaangn, wie sich dr AI-Transpiler geechnüber traditionelln Metodn schlächt, is's notwendisch,'ne Vielzaal von Schaltgreesn ze testn. De Leistung von QTS gann je nooch Art von der optimierten Schaltgrees erhäblich variieren. Fier'n breitern Vachlaasch, sieh dr de Benchmarks weeder obm oo oder besuuch den [Blog](https://www.ibm.com/quantum/blog/qiskit-performance).
## Schdritt 3: Ausfiehrung mit Qiskit-Primitives {#step-3-execute-using-qiskit-primitives}
Da sich däs Tutorial uff de Transpilatschn gundsentrierd, wärn geene Exberiment uff'm Quantegerät ausgefiehrd. Dr Zwägg is's, de Obtimierungen aus Schdritt 2 ze nutzen, um'ne transpiierte Schaltgrees mit reduzierter Diefe oder reduzierter Gate-Anzaal ze erlaangn.
## Schdritt 4: Argebnisse voroarbeitn un im gewünschtn glassischn Format zurückgäbn {#step-4-post-process-and-return-result-in-desired-classical-format}
Da's fier däs Notebook geene Ausfiehrung gibd, sinn geene Argebnisse zu voroarbeitn.
# Deel II. Transpiierte Schaltgreese analysieren un benchmarken {#part-ii-analyze-and-benchmark-the-transpiled-circuits}

In däm Abschnitt zeeschn mer, wie mer de transpiierte Schaltgrees analysiert un se im Detaal mit der Originals-Version benchmarkt. Mer gundsentriern uns uff Metrign wie Schaltgrees-Diefe, Gate-Anzaal un Transpilatschenszeit, um de Effegdivitäd von der Obtimierung ze bewärtn. Außerdem disskutiern mer, wie de Argebnisse ieber verschiedene Schaltgrees-Typen hinweg variieren gönnen, un gäbm Einblicke in de breidere Leistung vom Transpiler ieber verschiedene Szenariern.

```python
# Circuits to benchmark
seed = 42
circuits = [
    {
        "name": "Random",
        "qc": random_circuit(num_qubits=30, depth=10, seed=seed),
    },
    {
        "name": "Clifford",
        "qc": random_clifford_circuit(
            num_qubits=40, num_gates=200, seed=seed
        ),
    },
    {
        "name": "QFT",
        "qc": synth_qft_full(num_qubits=20, do_swaps=False).decompose(),
    },
    {
        "name": "BV",
        "qc": create_bv_circuit(40),
    },
]

results = []

# Run the transpilation for each circuit and store the results
for circuit in circuits:
    qc_no_ai, metrics_no_ai = transpile_with_metrics(pm_no_ai, circuit["qc"])
    qc_ai, metrics_ai = transpile_with_metrics(pm_ai, circuit["qc"])

    print("Completed transpilation for", circuit["name"])

    results.append(
        {
            "Circuit": circuit["name"],
            "Depth 2Q (No AI)": metrics_no_ai["depth_2q"],
            "Gate Count (No AI)": metrics_no_ai["gate_count"],
            "Time (No AI)": metrics_no_ai["time_s"],
            "Depth 2Q (AI)": metrics_ai["depth_2q"],
            "Gate Count (AI)": metrics_ai["gate_count"],
            "Time (AI)": metrics_ai["time_s"],
        }
    )

df = pd.DataFrame(results)
df
```

```text
Completed transpilation for Random
Completed transpilation for Clifford
Completed transpilation for QFT
Completed transpilation for BV
```

```text
Circuit  Depth 2Q (No AI)  Gate Count (No AI)  Time (No AI)  \
0    Random                37                 221      0.039347
1  Clifford                36                 232      0.036633
2       QFT               165                 924      0.077458
3        BV                65                 155      0.024993

   Depth 2Q (AI)  Gate Count (AI)  Time (AI)
0             24              181   0.773718
1             43              267   1.097431
2            130              913   3.660771
3             70              155   0.345522
```

Durschnittliche prozentuale Reduzierung fier jede Metrigg. Positiv bedeutet Värbässerungen, negativ bedeutet Verschlechtnerungen.

```python
# Average reduction from non-AI to AI transpilation as a percentage
avg_reduction_depth = (
    (df["Depth 2Q (No AI)"] - df["Depth 2Q (AI)"]).mean()
    / df["Depth 2Q (No AI)"].mean()
    * 100
)
avg_reduction_gates = (
    (df["Gate Count (No AI)"] - df["Gate Count (AI)"]).mean()
    / df["Gate Count (No AI)"].mean()
    * 100
)
avg_reduction_time = (
    (df["Time (No AI)"] - df["Time (AI)"]).mean()
    / df["Time (No AI)"].mean()
    * 100
)

print(f"Average reduction in depth: {avg_reduction_depth:.2f}%")
print(f"Average reduction in gate count: {avg_reduction_gates:.2f}%")
print(f"Average reduction in transpilation time: {avg_reduction_time:.2f}%")
```

```text
Average reduction in depth: 11.88%
Average reduction in gate count: 1.04%
Average reduction in transpilation time: -3193.95%
```

```python
fig, axs = plt.subplots(1, 3, figsize=(21, 6))
df.plot(
    x="Circuit",
    y=["Depth 2Q (No AI)", "Depth 2Q (AI)"],
    kind="bar",
    ax=axs[0],
)
axs[0].set_title("Circuit Depth Comparison")
axs[0].set_ylabel("Depth")
axs[0].set_xlabel("Circuit")
axs[0].tick_params(axis="x", rotation=45)
df.plot(
    x="Circuit",
    y=["Gate Count (No AI)", "Gate Count (AI)"],
    kind="bar",
    ax=axs[1],
)
axs[1].set_title("Gate Count Comparison")
axs[1].set_ylabel("Gate Count")
axs[1].set_xlabel("Circuit")
axs[1].tick_params(axis="x", rotation=45)
df.plot(x="Circuit", y=["Time (No AI)", "Time (AI)"], kind="bar", ax=axs[2])
axs[2].set_title("Time Comparison")
axs[2].set_ylabel("Time (seconds)")
axs[2].set_xlabel("Circuit")
axs[2].tick_params(axis="x", rotation=45)
fig.suptitle(
    "Benchmarking AI transpilation vs Non-AI transpilation for various circuits"
)

plt.tight_layout()
plt.show()
```

![Ausgaab von der vorischn Code-Zälle](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/79b8d5d9-0f9d-42ca-9583-8bec17430014-0.avif)

De Leistung vom AI-Transpiler variiert erhäblich je nooch Typ von der optimierten Schaltgrees. In manchn Fälln arziild'r merkliche Reduzierungen in Schaltgrees-Diefe un Gate-Anzaal geechnüber'm schdandard Transpiler. Diese Värbässerungen gähn ober oft mit'nem erhäblichn Anschdieg der Laufzeit einher.

Bei bestimmdn Schaltgrees-Typen gann dr AI-Transpiler leecht bässere Argebnisse hin zu Schaltgrees-Diefe liefern, aber ooch zu'nem Anschdieg in der Gate-Anzaal un'ner erhäblichn Laufzeit-Strafe führn. Diese Beobachtungen lächn nahe, dass de Voordeel vom AI-Transpiler nich gleichmäßisch fier alle Schaltgrees-Typen sinn. Schdattdässn hänchd seine Effegdivitäd von den spezifischn Eigenschaften von der Schaltgrees ab, was'n fier manche Oowendungsfälle geeigneter macht als fier andere.
## Wann solldn Nutzer AI-geschtitzte Transpilatschn wääln? {#when-should-users-choose-ai-powered-transpilation}

Dr AI-geschtitzte Transpiler in Qiskit excel-ierd in Szenariern, wo traditionelle Transpilatschensmetodn kämpfn — besunders mit groß ooglächdn un gombläxn Quanteschaltgreesn. Fier Schaltgreese mit hunderte von Qubits oder für Hardware mit komplizierdn Kopplungsgarten biedd dr AI-Transpiler überlegene Obtimierung hinsichtlich Schaltgrees-Diefe, Gate-Anzaal un Laufzeit-Effizienz. In Benchmarking-Tests hat'r traditionelle Metodn konseeschdent iebertrofffen un lieferd deutlich flachere Schaltgreese mit weniger Gates — was kritisch fier die Steigerung von der Leistung un de Minderung von Rausch uff echter Quantehardware is.

Nutzer solldn AI-geschtitzte Transpilatschn in Bedrochd zieschn, wenn se mit Folgendem arbeeden:
- Großn Schaltgreesn, wo traditionelle Metodn die Skaala nich effizient handhabn gönnen.
- Gombläxn Hardware-Topolochien, wo Gerätegondektivitäd un Routing-Herausforderungen entsteschn.
- Leistungsempfindlichn Oowendungen, bei denn de Reduzierung von Schaltgrees-Diefe un de Värbässerung von Treue vorrangsich sinn.
# Deel III. AI-geschtitzte Permutatschen-Netzwerk-Synthese erkunden {#part-iii-explore-ai-powered-permutation-network-synthesis}

Permutatschen-Netzwerke sinn grundläächnd im Quantecomputing, besunders fier Siesteme mit eingeschränkdn Topolochien. Diese Netzwerke ermöchln weeidreichende Interaktschonen, indääm se Qubits dynamisch tauschen, um Alles-zu-Alles-Gondektivitäd uff Hardware mit begrenzder Gondektivitäd nachzuahmen. Solche Transformatschen sinn unerlässlich fier de Implementierung von gombläxn Quantealgorithmn uff Geräten der gegenwärtichn Generation, wo Interaktschonen oft ieber nächste Nachbarn hinausgeschn.

In däm Abschnitt heben mer de Synthese von Permutatschen-Netzwerken als'n überzeugenden Oowendungsfall fier'n AI-geschtitztdn Transpiler in Qiskit hervor. Spezifisch nutzt dr `AIPermutationSynthesis`-Pass AI-geschtitzte Obtimierung, um effiziente Schaltgreese fier Qubit-Permutatschen-Ufgoabn ze erzeugen. Im Gecheensatz doazu kämpfn generische Synthese-Ooätze oft doamit, Gate-Anzaal un Schaltgrees-Diefe in Wage ze halten — besunders in Szenariern mit dichtn Qubit-Interaktschonen oder beim Versuch, volle Gondektivitäd ze arzieln.

Mer durchläbfn'n Qiskit-Muster-Beispiel, das de Synthese von'nem Permutatschen-Netzwerk zeicht, um Alles-zu-Alles-Gondektivitäd fier'n Saatz von Qubits ze arzieln. Mer vachlaaschdn de Leistung von `AIPermutationSynthesis` geechnüber schdandard Synthese-Metodn in Qiskit. Däs Beispiel demonstriert, wie dr AI-Transpiler fier niedrigere Schaltgrees-Diefe un Gate-Anzaal obtimiert, un hebd seine Voordeel in praxisnaahn Quantum-Workflows hervor. Um den AI-Synthese-Pass ze aktivieren, nutzen mer de `generate_ai_pass_manager()`-Fundschen mit dem uff `True` gesetztn `include_ai_synthesis`-Parameter.
## Schdritt 1: Glassische Eingoobn uff'n Quanteprobläm oobildn {#step-1-map-classical-inputs-to-a-quantum-problem-1}

Um'n glassisches Permutatschen-Probläm uff'm Quantecomputer darzuschdelln, fangn mer mit dr Definition von der Struktur von den Quanteschaltgreesn oo. Fier däs Beispiel:

1. Quanteschaltgrees-Initialisierung:
   Mer allozieren 27 Qubits, um'n Backend ze entspreechn, den mer verwenden wärn, der 27 Qubits hat.

2. Permutatschen oowendn:
   Mer erzeugen zehn zufällige Permutatschen-Muster (`pattern_1` bis `pattern_10`) mit'm fixen Saamen fier Reproduzierbarkeit. Jedes Permutatschen-Muster wärd uff'ne separate Quanteschaltgrees oogewendd (`qc_1` bis `qc_10`).

3. Schaltgrees-Zerläärung:
   Jede Permutatschen-Oberatschn wärd in native Gate-Sätz zerläärt, die mit der Ziel-Quantehardware goombatibl sinn. Mer analysieren de Diefe un de Anzaal von Zwaa-Qubit-Gates (nichtlokale Gates) fier jede zerläägte Schaltgrees.

De Argebnisse gäbn Einblicke in de Gombläxitäd beim Darställn von glassischn Permutatschen-Problämen uff'm Quantegerät un demonstrieren de Ressource-Ooforderngen fier verschiedene Permutatschen-Muster.

```python
# Parameters
width = 27
num_circuits = 10

# Set random seed
np.random.seed(seed)

# Generate random patterns and circuits
patterns = [
    np.random.permutation(width).tolist() for _ in range(num_circuits)
]
circuits = {
    f"qc_{i}": generate_permutation_circuit(width, pattern)
    for i, pattern in enumerate(patterns, start=1)
}

# Display one of the circuits
circuits["qc_1"].decompose(reps=3).draw(output="mpl", fold=-1)
```

![Ausgaab von der vorischn Code-Zälle](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/76a3e847-0808-4413-bd0c-c760cd2df3f4-0.avif)

## Schdritt 2: Probläm fier die Ausfiehrung uff Quantehardware obtimieren {#step-2-optimize-problem-for-quantum-hardware-execution-1}
In däm Schdritt gescn mer mit der Obtimierung mit den AI-Synthese-Pässen weider.

Fier de AI-Synthese-Pässe braucht dr `PassManager` nur'n Kopplungskaartn vom Backend. Es is aber wichtsch zu bemierkn, dass nich alle Kopplungsgärtn goombatibl sinn — nur die, uff denn dr `AIPermutationSynthesis`-Pass trainiert worn is, funktscheeniern. Derzeit unterschdutzt dr `AIPermutationSynthesis`-Pass Blöcke von 65, 33 un 27 Qubits. Fier däs Beispiel nutzn mer'n 27-Qubit-QPU.

Zum Vachlaasch bewärtn mer de Leistung von AI-Synthese geechnüber generischn Permutatschen-Synthese-Metodn in Qiskit, einschließlich:

- `synth_permutation_depth_lnn_kms`: Diese Metode synthesisiert'ne Permutatschen-Schaltgrees fier'ne Linear-Nearest-Neighbor-Architektur (LNN) mit dem Kutin-Moulton-Smithline-Algorithmus (KMS). Es garantiert'ne Schaltgrees mit'ner Diefe von höchschdns $ n $ un'ner Größe von höchschdns $ n(n-1)/2 $, wo beede, Diefe un Größe, in SWAP-Gates gemessn wärn.

- `synth_permutation_basic`: Das is'ne eenfache Implementierung, die Permutatschen-Schaltgreese synthesisiert, ohni Gondektivitäts-Einschränkungen oder Obtimierung fier spezifische Architekkturen ze ooferlegen. Sie dient als Basislinie fier de Leistungsvergleich mit fortgeschrittnern Metodn.

Jede von diesen Metodn ställt'n unterschiedlichn Ooatz zur Synthese von Permutatschen-Netzwerken dar un biedd'n umfassenden Benchmark geechnüber den AI-geschtitzdn Metodn.

Fier mähr Details ieber Synthese-Metodn in Qiskit, gugg in de [Qiskit-API-Dokumentatschn](https://docs.quantum.ibm.com/api/qiskit/synthesis).
De Kopplungsgaartn vom 27-Qubit-QPU definieren.

```python
coupling_map = [
    [1, 0],
    [2, 1],
    [3, 2],
    [3, 5],
    [4, 1],
    [6, 7],
    [7, 4],
    [7, 10],
    [8, 5],
    [8, 9],
    [8, 11],
    [11, 14],
    [12, 10],
    [12, 13],
    [12, 15],
    [13, 14],
    [16, 14],
    [17, 18],
    [18, 15],
    [18, 21],
    [19, 16],
    [19, 22],
    [20, 19],
    [21, 23],
    [23, 24],
    [25, 22],
    [25, 24],
    [26, 25],
]
CouplingMap(coupling_map).draw()
```

![Ausgaab von der vorischn Code-Zälle](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/84dff2c2-a496-4828-bb8e-08d373816a36-0.avif)

Jede von de Permutatschen-Schaltgreese mit den AI-Synthese-Pässen un generischn Synthese-Metodn transpiern.

```python
results = []
pm_no_ai_synth = generate_preset_pass_manager(
    coupling_map=cm,
    optimization_level=1,  # set to 1 since we are using the synthesis methods
)

# Transpile and analyze all circuits
for i, (qc_name, qc) in enumerate(circuits.items(), start=1):
    pattern = patterns[i - 1]  # Get the corresponding pattern

    qc_depth_lnn_kms = synth_permutation_depth_lnn_kms(pattern)
    qc_basic = synth_permutation_basic(pattern)

    # AI synthesis
    results.append(
        synth_transpile_with_metrics(
            qc.decompose(reps=3),
            pm_ai,
            qc_name,
            "AI",
        )
    )

    # Depth-LNN-KMS Method
    results.append(
        synth_transpile_with_metrics(
            qc_depth_lnn_kms.decompose(reps=3),
            pm_no_ai_synth,
            qc_name,
            "Depth-LNN-KMS",
        )
    )

    # Basic Method
    results.append(
        synth_transpile_with_metrics(
            qc_basic.decompose(reps=3),
            pm_no_ai_synth,
            qc_name,
            "Basic",
        )
    )

results_df = pd.DataFrame(results)
```

De Metrign (Diefe, Gate-Anzaal, Zeit) fier jede Schaltgrees nooch der Transpilatschn erfassn.

```python
# Calculate averages for each metric
average_metrics = results_df.groupby("Method")[
    ["Depth (2Q)", "Gates", "Time (s)"]
].mean()
average_metrics = average_metrics.round(3)  # Round to two decimal places
print("\n=== Average Metrics ===")
print(average_metrics)

# Identify the best non-AI method based on least average depth
non_ai_methods = [
    method for method in results_df["Method"].unique() if method != "AI"
]
best_non_ai_method = average_metrics.loc[non_ai_methods][
    "Depth (2Q)"
].idxmin()
print(
    f"\nBest Non-AI Method (based on least average depth): {best_non_ai_method}"
)

# Compare AI to the best non-AI method
ai_metrics = average_metrics.loc["AI"]
best_non_ai_metrics = average_metrics.loc[best_non_ai_method]

comparison = {
    "Metric": ["Depth (2Q)", "Gates", "Time (s)"],
    "AI": [
        ai_metrics["Depth (2Q)"],
        ai_metrics["Gates"],
        ai_metrics["Time (s)"],
    ],
    best_non_ai_method: [
        best_non_ai_metrics["Depth (2Q)"],
        best_non_ai_metrics["Gates"],
        best_non_ai_metrics["Time (s)"],
    ],
    "Improvement (AI vs Best Non-AI)": [
        ai_metrics["Depth (2Q)"] - best_non_ai_metrics["Depth (2Q)"],
        ai_metrics["Gates"] - best_non_ai_metrics["Gates"],
        ai_metrics["Time (s)"] - best_non_ai_metrics["Time (s)"],
    ],
}

comparison_df = pd.DataFrame(comparison)
print("\n=== Comparison of AI vs Best Non-AI Method ===")
comparison_df
```

```text
=== Average Metrics ===
               Depth (2Q)  Gates  Time (s)
Method
AI                   23.9   82.8     0.248
Basic                29.8   91.0     0.012
Depth-LNN-KMS        70.8  531.6     0.017

Best Non-AI Method (based on least average depth): Basic

=== Comparison of AI vs Best Non-AI Method ===
```

```text
Metric      AI   Basic  Improvement (AI vs Best Non-AI)
0  Depth (2Q)  23.900  29.800                           -5.900
1       Gates  82.800  91.000                           -8.200
2    Time (s)   0.248   0.012                            0.236
```

De Argebnisse demonstrieren, dass dr AI-Transpiler alle anderen Qiskit-Synthese-Metodn fier diesen Saatz von zufällichen Permutatschen-Schaltgreesn iebertrifft. Wichtschste Erkenntnisse:

1. Diefe: Dr AI-Transpiler arziild de niedrigste durschnittliche Diefe, was uff ieberwleegene Obtimierung von Schaltgrees-Layouts hindeit.
2. Gate-Anzaal: Er reduciert de Anzaal von Gates im Vachlaasch zu anderen Metodn erhäblich, was de Ausfiehrungstreue un Effizienz värbässerd.
3. Transpilatschenszeit: Alle Metodn läfn bei dieser Skaala sehr schnäll, was se praktisch fier den Einsatz macht. Dr AI-Transpiler hat ober'n merklichen Laufzeit-Anschdieg geechnüber traditionelln Metodn, wegen der Gombläxitäd von den verwändn AI-Modälln.

Diese Argebnisse etablieren'n AI-Transpiler als'n effegdivschn Ooatz fier diesen Benchmark — besunders fier de Obtimierung von Diefe un Gate-Anzaal.
De Argebnisse blottn, um de Leistung von den AI-Synthese-Pässen geechnüber den generischn Synthese-Metodn ze vachlaaschdn.

```python
methods = results_df["Method"].unique()

fig, axs = plt.subplots(1, 3, figsize=(18, 5))

# Pivot the DataFrame and reorder columns to ensure AI is first
pivot_depth = results_df.pivot(
    index="Pattern", columns="Method", values="Depth (2Q)"
)[["AI", "Depth-LNN-KMS", "Basic"]]
pivot_gates = results_df.pivot(
    index="Pattern", columns="Method", values="Gates"
)[["AI", "Depth-LNN-KMS", "Basic"]]
pivot_time = results_df.pivot(
    index="Pattern", columns="Method", values="Time (s)"
)[["AI", "Depth-LNN-KMS", "Basic"]]

pivot_depth.plot(kind="bar", ax=axs[0], legend=False)
axs[0].set_title("Circuit Depth Comparison")
axs[0].set_ylabel("Depth")
axs[0].set_xlabel("Pattern")
axs[0].tick_params(axis="x", rotation=45)
pivot_gates.plot(kind="bar", ax=axs[1], legend=False)
axs[1].set_title("2Q Gate Count Comparison")
axs[1].set_ylabel("Number of 2Q Gates")
axs[1].set_xlabel("Pattern")
axs[1].tick_params(axis="x", rotation=45)
pivot_time.plot(
    kind="bar", ax=axs[2], legend=True, title="Legend"
)  # Show legend on the last plot
axs[2].set_title("Time Comparison")
axs[2].set_ylabel("Time (seconds)")
axs[2].set_xlabel("Pattern")
axs[2].tick_params(axis="x", rotation=45)
fig.suptitle(
    "Benchmarking AI Synthesis Methods vs Non-AI Synthesis Methods For Random Permutations Circuits",
    fontsize=16,
    y=1,
)

plt.tight_layout()
plt.show()
```

![Ausgaab von der vorischn Code-Zälle](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/a326f268-0115-442c-8563-968676b66670-0.avif)

Däser Groaff hebd de Einzelargebnisse fier jede Schaltgrees (`qc_1` bis `qc_10`) ieber verschiedene Synthese-Metodn hervor:

Während diese Argebnisse de Effegdivitäd vom AI-Transpiler fier Permutatschen-Schaltgreese unterstreechn, is's wichtsch, seine Grenzen zu bemierkn. De AI-Synthese-Metode is derzeit nur fier bestimmde Kopplungsgärtn verfiegbar, was ihre breitere Oowendbarkeit einschränkn gann. Diese Einschränkung solld bei der Bewärtung von ihrem Einsatz in verschiedenen Szenariern berücksichticht wärn.

Insgesamt demonstriert dr AI-Transpiler vielverschbrechende Värbässerungen in Diefe- un Gate-Anzaal-Obtimierung fier diese spezifischn Schaltgreese, während vachläächbare Transpilatschenszeeschn beibehalten wärn.
## Schdritt 3: Ausfiehrung mit Qiskit-Primitives {#step-3-execute-using-qiskit-primitives-1}
Da sich däs Tutorial uff de Transpilatschn gundsentrierd, wärn geene Exberiment uff'm Quantegerät ausgefiehrd. Dr Zwägg is's, de Obtimierungen aus Schdritt 2 ze nutzen, um'ne transpiierte Schaltgrees mit reduzierter Diefe oder reduzierter Gate-Anzaal ze erlaangn.
## Schdritt 4: Argebnisse voroarbeitn un im gewünschtn glassischn Format zurückgäbn {#step-4-post-process-and-return-result-in-desired-classical-format-1}
Da's fier däs Notebook geene Ausfiehrung gibd, sinn geene Argebnisse zu voroarbeitn.
## Tutorial-Umfraache {#tutorial-survey}

Bitte mach disse kurze Umfraache, um Rieckmellung zu däm Tutorial ze gäbn. Deine Einblicke helfn uns, unsere Inhalte un de Nutzerärfahrung ze värbässern.

[Link zur Umfraache](https://your.feedback.ibm.com/jfe/form/SV_0igXMtMCQfApgDI)
