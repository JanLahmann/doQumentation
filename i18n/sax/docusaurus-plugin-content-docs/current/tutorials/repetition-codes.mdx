---
title: "Wiederhoolungscodes"
sidebar_label: "Wiederhoolungscodes"
description: "Des Tutorial zeigt, wie mer eenfache Wiederhoolungscodes mit IBM Dynamic Circuits baut — en Beispiel fier grundlegende Quantenfehlergorrektur (QEC)."
notebook_path: "docs/tutorials/repetition-codes.ipynb"
---
{/* doqumentation-source-hash: fc3a692b */}

<OpenInLabBanner notebookPath="docs/tutorials/repetition-codes.ipynb" />



*Laufzeidschätzung: wenicher als 1 Minute uff nem Heron-Brozessor (HINWEIS: Des is nur e Schätzung. Eiern tatsächliche Laufzeit gann abweichen.)*

## Hintergrund {#background}

Damitt echtzeidliche Quantenfehlergorrektur (QEC) funggsjooniert, muss mer den Brogrammfluss während der Ausfierung dynamisch steiern gennen, sodass Quantum Gates von Messkresultaten abhängich gemacht werd'n gennen. Des Tutorial fiert den Bit-Flip-Code aus, ne sehr eenfache Form von QEC. Es zeigt nen dynamischen Quantenschaltkrees, der en godierten Qubit vor enem einzelnen Bit-Flip-Fehler schiedzt, un bewertet dann de Leistung von dem Bit-Flip-Code.

Mer gann zusätzliche Ancilla-Qubits un Verschränggung nutzen, um *Stabilisatoren* zu messen, die de godierten Quanteninformatschjoon nich verändern, uns aber trotzdem ieeber bestimmde Fehlerglassen informieren. En Quanten-Stabilisator-Code godiert $k$ logische Qubits in $n$ physikalische Qubits. Stabilisatorcodes konzentrier'n sich dabei uff de Gorrektur enes disgreden Fehlersatzes mit Unterstietzing von der Pauli-Gruppe $\Pi^n$.

Fier mehr Informatschjoon'n zu QEC guggt eich [Quantum Error Correction for Beginners](https://arxiv.org/abs/0905.2794) an.

## Voraussetzung'n {#requirements}

Befor ihr mit dem Tutorial anfangt, guckt, dass folgendes installjert is:

- Qiskit SDK v2.0 oder neier, mit Unterstietzing fier [Visualisierung](https://docs.quantum.ibm.com/api/qiskit/visualization)
- Qiskit Runtime v0.40 oder neier (`pip install qiskit-ibm-runtime`)

## Einrichttung {#setup}

```python
# Qiskit imports
from qiskit import (
    QuantumCircuit,
    QuantumRegister,
    ClassicalRegister,
)

# Qiskit Runtime
from qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler

from qiskit_ibm_runtime.circuit import MidCircuitMeasure

service = QiskitRuntimeService()
```

## Schritt 1. Glassische Eingaben uff s Quantenproblem abbilden {#step-1-map-classical-inputs-to-a-quantum-problem}

### Nen Bit-Flip-Stabilisator-Circuit bau'n {#build-a-bit-flip-stabilizer-circuit}

Der Bit-Flip-Code gehert zu de eenfachstn Beispiele eenes Stabilisatorcodes. Er schietzte den Zustand vor enem einzelnen Bit-Flip-(X)-Fehler uff eenm von de Godierungsqubits. Betrachten mer den Bit-Flip-Fehler $X$, der $|0\rangle \rightarrow |1\rangle$ un $|1\rangle \rightarrow |0\rangle$ uff eenm von unsre Qubits abbildet, dann gild $\epsilon = \{E_0, E_1, E_2 \} = \{IIX, IXI, XII\}$. Der Code braucht fienf Qubits: drei werd'n zum Godieren des geschitzdtn Zustands verwendet, die restlichen zwei als Ancillas fier de Stabilisatormessung.

```python
# Choose the least busy backend that supports `measure_2`.

backend = service.least_busy(
    filters=lambda b: "measure_2" in b.supported_instructions,
    operational=True,
    simulator=False,
    dynamic_circuits=True,
)
```

```python
qreg_data = QuantumRegister(3)
qreg_measure = QuantumRegister(2)
creg_data = ClassicalRegister(3, name="data")
creg_syndrome = ClassicalRegister(2, name="syndrome")
state_data = qreg_data[0]
ancillas_data = qreg_data[1:]

def build_qc():
    """Build a typical error correction circuit"""
    return QuantumCircuit(qreg_data, qreg_measure, creg_data, creg_syndrome)

def initialize_qubits(circuit: QuantumCircuit):
    """Initialize qubit to |1>"""
    circuit.x(qreg_data[0])
    circuit.barrier(qreg_data)
    return circuit

def encode_bit_flip(circuit, state, ancillas) -> QuantumCircuit:
    """Encode bit-flip. This is done by simply adding a cx"""
    for ancilla in ancillas:
        circuit.cx(state, ancilla)
    circuit.barrier(state, *ancillas)
    return circuit

def measure_syndrome_bit(circuit, qreg_data, qreg_measure, creg_measure):
    """
    Measure the syndrome by measuring the parity.
    We reset our ancilla qubits after measuring the stabilizer
    so we can reuse them for repeated stabilizer measurements.
    Because we have already observed the state of the qubit,
    we can write the conditional reset protocol directly to
    avoid another round of qubit measurement if we used
    the `reset` instruction.
    """
    circuit.cx(qreg_data[0], qreg_measure[0])
    circuit.cx(qreg_data[1], qreg_measure[0])
    circuit.cx(qreg_data[0], qreg_measure[1])
    circuit.cx(qreg_data[2], qreg_measure[1])
    circuit.barrier(*qreg_data, *qreg_measure)
    circuit.append(MidCircuitMeasure(), [qreg_measure[0]], [creg_measure[0]])
    circuit.append(MidCircuitMeasure(), [qreg_measure[1]], [creg_measure[1]])

    with circuit.if_test((creg_measure[0], 1)):
        circuit.x(qreg_measure[0])
    with circuit.if_test((creg_measure[1], 1)):
        circuit.x(qreg_measure[1])
    circuit.barrier(*qreg_data, *qreg_measure)
    return circuit

def apply_correction_bit(circuit, qreg_data, creg_syndrome):
    """We can detect where an error occurred and correct our state"""
    with circuit.if_test((creg_syndrome, 3)):
        circuit.x(qreg_data[0])
    with circuit.if_test((creg_syndrome, 1)):
        circuit.x(qreg_data[1])
    with circuit.if_test((creg_syndrome, 2)):
        circuit.x(qreg_data[2])
    circuit.barrier(qreg_data)
    return circuit

def apply_final_readout(circuit, qreg_data, creg_data):
    """Read out the final measurements"""
    circuit.barrier(qreg_data)
    circuit.measure(qreg_data, creg_data)
    return circuit
```

```python
def build_error_correction_sequence(apply_correction: bool) -> QuantumCircuit:
    circuit = build_qc()
    circuit = initialize_qubits(circuit)
    circuit = encode_bit_flip(circuit, state_data, ancillas_data)
    circuit = measure_syndrome_bit(
        circuit, qreg_data, qreg_measure, creg_syndrome
    )

    if apply_correction:
        circuit = apply_correction_bit(circuit, qreg_data, creg_syndrome)

    circuit = apply_final_readout(circuit, qreg_data, creg_data)
    return circuit

circuit = build_error_correction_sequence(apply_correction=True)
circuit.draw(output="mpl", style="iqp", cregbundle=False)
```

![Output of the previous code cell](/docs/images/tutorials/repetition-codes/extracted-outputs/dbe02949-0.avif)

![Output of the previous code cell](/docs/images/tutorials/repetition-codes/extracted-outputs/dbe02949-1.avif)

## Schritt 2. Des Problem fier de Quantenausfierung optimier'n {#step-2-optimize-the-problem-for-quantum-execution}

Damitt de gesämde Job-Ausfierungszeit gürzer werd, aggzeptier'n Qiskit-Primitiven nur Circuits un Observablen, die de Anweisungen un de Gonnektivität von'm Zielsystem entsprechen (auch als ISA-Circuits un -Observablen bekannt). [Mehr zur Transpilatschjoon erfahr'n.](/guides/transpile)

### ISA-Circuits erzeing'n {#generate-isa-circuits}

```python
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

pm = generate_preset_pass_manager(backend=backend, optimization_level=1)
 isa_circuit = pm.run(circuit)

isa_circuit.draw("mpl", style="iqp", idle_wires=False)
```

![Output of the previous code cell](/docs/images/tutorials/repetition-codes/extracted-outputs/67b55eef-0.avif)

![Output of the previous code cell](/docs/images/tutorials/repetition-codes/extracted-outputs/67b55eef-1.avif)

```python
no_correction_circuit = build_error_correction_sequence(
    apply_correction=False
)

isa_no_correction_circuit = pm.run(no_correction_circuit)
```

## Schritt 3. Mit Qiskit-Primitiven ausfier'n {#step-3-execute-using-qiskit-primitives}

Fiert de Version mit Gorrektur un de Version ohne Gorrektur aus.

```python
sampler_no_correction = Sampler(backend)
job_no_correction = sampler_no_correction.run(
    [isa_no_correction_circuit], shots=1000
)
result_no_correction = job_no_correction.result()[0]
```

```python
sampler_with_correction = Sampler(backend)

job_with_correction = sampler_with_correction.run([isa_circuit], shots=1000)
result_with_correction = job_with_correction.result()[0]
```

```python
print(f"Data (no correction):\n{result_no_correction.data.data.get_counts()}")
print(
    f"Syndrome (no correction):\n{result_no_correction.data.syndrome.get_counts()}"
)
```

```text
Data (no correction):
{'111': 878, '011': 42, '110': 35, '101': 40, '100': 1, '001': 2, '000': 2}
Syndrome (no correction):
{'00': 942, '10': 33, '01': 22, '11': 3}
```

```python
print(f"Data (corrected):\n{result_with_correction.data.data.get_counts()}")
print(
    f"Syndrome (corrected):\n{result_with_correction.data.syndrome.get_counts()}"
)
```

```text
Data (corrected):
{'111': 889, '110': 25, '000': 11, '011': 45, '101': 17, '010': 10, '001': 2, '100': 1}
Syndrome (corrected):
{'00': 929, '01': 39, '10': 20, '11': 12}
```

## Schritt 4. Nachbearbeitung, Erchebnis in glassischem Format zurieggeb'n {#step-4-post-process-return-result-in-classical-format}

Mer siehd, dass der Bit-Flip-Code viele Fehler erkannt un gorrericht hat, was insgesämd zu wenicher Fehler gefiehrd hat.

```python
def decode_result(data_counts, syndrome_counts):
    shots = sum(data_counts.values())
    success_trials = data_counts.get("000", 0) + data_counts.get("111", 0)
    failed_trials = shots - success_trials
    error_correction_events = shots - syndrome_counts.get("00", 0)
    print(
        f"Bit flip errors were detected/corrected on {error_correction_events}/{shots} trials."
    )
    print(
        f"A final parity error was detected on {failed_trials}/{shots} trials."
    )
```

```python
# non-corrected marginalized results
data_result = result_no_correction.data.data.get_counts()
marginalized_syndrome_result = result_no_correction.data.syndrome.get_counts()

print(
    f"Completed bit code experiment data measurement counts (no correction): {data_result}"
)
print(
    f"Completed bit code experiment syndrome measurement counts (no correction): {marginalized_syndrome_result}"
)
decode_result(data_result, marginalized_syndrome_result)
```

```text
Completed bit code experiment data measurement counts (no correction): {'111': 878, '011': 42, '110': 35, '101': 40, '100': 1, '001': 2, '000': 2}
Completed bit code experiment syndrome measurement counts (no correction): {'00': 942, '10': 33, '01': 22, '11': 3}
Bit flip errors were detected/corrected on 58/1000 trials.
A final parity error was detected on 120/1000 trials.
```

```python
# corrected marginalized results
corrected_data_result = result_with_correction.data.data.get_counts()
corrected_syndrome_result = result_with_correction.data.syndrome.get_counts()

print(
    f"Completed bit code experiment data measurement counts (corrected): {corrected_data_result}"
)
print(
    f"Completed bit code experiment syndrome measurement counts (corrected): {corrected_syndrome_result}"
)
decode_result(corrected_data_result, corrected_syndrome_result)
```

```text
Completed bit code experiment data measurement counts (corrected): {'111': 889, '110': 25, '000': 11, '011': 45, '101': 17, '010': 10, '001': 2, '100': 1}
Completed bit code experiment syndrome measurement counts (corrected): {'00': 929, '01': 39, '10': 20, '11': 12}
Bit flip errors were detected/corrected on 71/1000 trials.
A final parity error was detected on 100/1000 trials.
```

## Tutorial-Umfrage {#tutorial-survey}

Macht doch bitte de gurze Umfrage, damitt ihr Rieggemeldung zu dem Tutorial geb'n gennt. Eier Einschätzung'n helf'n uns, unsre Inhalte un de Benutzererfahrung zu verbessern.

[Link zur Umfrage](https://your.feedback.ibm.com/jfe/form/SV_5onAlfA2Y7ac1FA)
