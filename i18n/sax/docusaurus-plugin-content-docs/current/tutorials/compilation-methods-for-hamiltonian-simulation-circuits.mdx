---
title: "Gombilieerungsmethodn fier Hamiltonian-Simulatschens-Schaltgreese"
sidebar_label: "Gombilieerungsmethodn fier Hamiltonian-Simulatschens-Schaltgreese"
description: "Dieses Tutorial gibd'n vergleichendn Ieberbligg ieber drei Gombilieerungsmethodn in Qiskit fier Hamiltonian-Simulatschens-Workloads."
notebook_path: "docs/tutorials/compilation-methods-for-hamiltonian-simulation-circuits.ipynb"
---
{/* doqumentation-source-hash: ff66bde1 */}

<OpenInLabBanner notebookPath="docs/tutorials/compilation-methods-for-hamiltonian-simulation-circuits.ipynb" />



Geschätzde QPU-Nutzung: In däm Tutorial ward nischds ausgefiehrd, weil's sich uff'n Transpilatschensbrotzess gunzendreert.

{/* cspell:ignore Rustiq, nshuffles, edgecolors, edgecolor, Hamlib, Benchpress, Brugière, Goubault, Martiel, Dubal, Lishman, Ivrii, fontweight, fontsize, textprops, wedgeprops, startangle, autopct */}
## Hintergund {#background}

Die Gombilierung von Quanteschaltgreesn is'n wichtschdr Schritt im Quantecombuting-Workflow. Dabei wird'n hochgradischn Quantealgorithmus in'n physikalischn Quanteschaltgrees ümgewandeld, der de Bedingungn von der Ziel-Quantehardware erfüllt. Effektive Gombilierung gann de Leistung von Quantealgorithmn erheblich värbässern, indeem se die Schaltgreesdieffe, de Gateanzahl un de Ausfiehrungszeit verringerd. Dieses Tutorial erkundet drei verschedene Oonsätze zur Gombilierung von Quanteschaltgreesn in Qiskit un zeicht deren Stärgn un Oowendungen oo Hand von pragtischn Beispieln.

Das Ziel von däm Tutorial is'es, Nutzern beizubringen, wie se drei Gombilieerungsmethodn in Qiskit oowenden un bewärten:'n SABRE-Transbilder, 'n KI-gestitztn Transbilder un 's Rustiq-Plugin. De Nutzer lärnen, wie se jede Methode effektiv einzetzen un de Leistung ieber verschedne Quanteschaltgreese benchmarken. Am Ende von däm Tutorial gönnen Nutzer Gombilierungsstrategien oo Hand von Optimierungszieln aussuchen un oobassn, zum Beispiel zum Verringern von der Schaltgreesdieffe, Minimieren von der Gateanzahl oder Verbässern von der Laufzeit.

### Was de lärnen warscht {#what-you-will-learn}
- **Wie de 'n Qiskit-Transbilder mit SABRE fier Layout- un Routing-Optimierung nutzst.**
- **Wie de 'n KI-Transbilder fier fordgeschriddne, automatisierte Schaltgreesoptimierung einsetzsdn gannst.**
- **Wie de 's Rustiq-Plugin fier Schaltgreese nutzst, bei denen 's Synthetisieren von Obetatschenen besonders genoich sinn muss — besonders bei Hamiltonian-Simulatschensoofgoabn.**

Dieses Tutorial nutzd drei Beispielschaltgreese, die'n [Qiskit-Patterns](/guides/intro-to-patterns)-Workflow folgen, um de Leistung von jeder Gombilieerungsmethode ze veranschaulichn. Am Ende vom Tutorial bischde in der Lage, de passende Gombilierungsstrategie oo Hand von deine spezifischn Ooforderngen un Bedingungen auszesuchen.

### Ieberbligg ieber de Gombilieerungsmethodn {#compilation-methods-overview}

#### 1. **Qiskit-Transbilder mit SABRE** {#1-qiskit-transpiler-with-sabre}
Dr Qiskit-Transbilder nutzd 'n SABRE-Algorithmus (SWAP-based BidiREctional heuristic search), um Schaltgreeslayout un Routing ze optimieren. SABRE guggd doruff, SWAP-Gates un deren Einfluss uff de Schaltgreesdieffe ze minimieren, un hält dabei de Konnektivitätsbeschränkungen von der Hardware ein. Die Methode is sehr vielseidig un eicnet sich fier allgemeine Schaltgreesoptimierung — se biedd'n gudn Kompromiss zwischn Leistung un Rechenzeit. Um von de neueschdne Verbässerungen in SABRE ze profitieren, die in [\[1\]](https://arxiv.org/abs/2409.08368) beschrieben worn sinn, gannste die Anzahl von de Versuche erhöhn (zum Beispiel `layout_trials=400, swap_trials=400`). In däm Tutorial nutzen mer de Standardweärde fier de Versuchsanzahl, um'n Vergleich mit Qiskits Standard-Transbilder ze ermöchln. Die Vorteile un Parameterexploratschn von SABRE worn in 'm extra [Vertiefungs-Tutorial](/tutorials/transpilation-optimizations-with-sabre) behandeld.

#### 2. **KI-Transbilder** {#2-ai-transpiler}

Dr KI-gestitzte Transbilder in Qiskit nutzd maschinelles Lärnen, um optimale Transpilatschensstrategie vorherzesagen, indeem er Muster in der Schaltgreesstruktur un de Hardwarebeschränkungen analysiert, um de beschde Sequenz von Optimierungen fier'n gegebenen Eingoab auszesuchen. Die Methode is besonders effektiv fier großschkaliche Quanteschaltgreese un biedd'n hohen Grad von Automatisierung un Oonpassungsfähigkeit an verschedne Problähmtypen. Zusätzlich zur allgemeine Schaltgreesoptimierung gann dr KI-Transbilder mit'm `AIPauliNetworkSynthesis`-Pass eingesetzsdn wärdn, der Pauli-Netzwerk-Schaltgreese zieeld — Blöcke, die aus H-, S-, SX-, CX-, RX-, RY- un RZ-Gates bestähn — un'n verstärkungslärnbasiertn Syntheseoosotz owendd. Mähre Informatschonen ieber 'n KI-Transbilder un seine Synthesestrategie findeste in [\[2\]](https://arxiv.org/abs/2405.13196) un [\[3\]](https://arxiv.org/abs/2503.14448).

#### 3. **Rustiq-Plugin**
's Rustiq-Plugin führd fordgeschriddne Synthesetechniggen speziell fier `PauliEvolutionGate`-Obetatschenen ein, die Pauli-Rotationen darstellen, die häufsch in Trotterisierten Dynamiken verwendet wärdn. Dieses Plugin is wertvoll fier Schaltgreese, die Hamiltonian-Simulatschn implementieren, wie se zum Beispiel in der Quantenchemie un -fieesik vorkoomm, wo genoue Pauli-Rotationen fier die effektive Simulatschn von Problem-Hamiltonians essenziel sinn. Rustiq biedd präzise, tiefenoptimierte Schaltgrees-Synthese fier dieze spezialisierten Obetatschenen. Mähre Details ieber de Implementierung un Leistung von Rustiq findeste in [\[4\]](https://arxiv.org/abs/2404.03280).

Dursch 's vertiefte Erkunden von diesen Gombilieerungsmethodn stellt dieses Tutorial den Nutzern de Werkzeige bereit, um de Leistung ihrer Quanteschaltgreese ze verbässern, un ebnet'n Wäch fier effizientere un pragtischere Quanteberechnungen.
## Ooforderngen {#requirements}

Bevor de mit däm Tutorial anfängst, stell sischer, dass de Folgendes installiert hasd:
- Qiskit SDK v1.3 oder neier, mit [Visualisieerungsunterstützung](https://docs.quantum.ibm.com/api/qiskit/visualization)
- Qiskit Runtime v0.28 oder neier (`pip install qiskit-ibm-runtime`)
- Qiskit IBM Transpiler (`pip install qiskit-ibm-transpiler`)
- Qiskit AI Transpiler im lokalen Modus (`pip install qiskit_ibm_ai_local_transpiler`)
- Networkx-Grafikbibliothek (`pip install networkx`)
## Eirichtung {#setup}

```python
# Added by doQumentation — installs packages not in the Binder environment
%pip install -q qiskit-ibm-transpiler
```

```python
from qiskit.circuit import QuantumCircuit
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit.circuit.library import (
    efficient_su2,
    PauliEvolutionGate,
)
from qiskit_ibm_transpiler import generate_ai_pass_manager
from qiskit.quantum_info import SparsePauliOp
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit.transpiler.passes.synthesis.high_level_synthesis import HLSConfig
from collections import Counter
from IPython.display import display
import time
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import json
import requests
import logging

# Suppress noisy loggers
logging.getLogger(
    "qiskit_ibm_transpiler.wrappers.ai_local_synthesis"
).setLevel(logging.ERROR)

seed = 42  # Seed for reproducibility
```

## Deel 1: Efficient-SU2-Schaltgrees {#part-1-efficient-su2-circuit}

### Schritt 1: Glassische Eingoabn uff'n Quanteprobläm abbildn {#step-1-map-classical-inputs-to-a-quantum-problem}

In däm Abschnitt erkunden mer 'n `efficient_su2`-Schaltgrees, 'n hardwareeffizienten Ansatz, der häufsch in variatschen-älln Quantealgorithmn (wie VQE) un Quantum-Machine-Learning-Aufgoabn gebruikt wird. Dr Schaltgrees besteht aus wechselndn Schichtn von Einzelqubit-Rotationen un verschränkenden Gates in 'm kreisförmigen Muster, um 'n Quantezuschstandsruum effektiv ze erkunden un dabei 'ne handhabbare Dieffn ze halten.

Mer fangen an damit, 'n `efficient_su2`-Schaltgrees ze erbauen, um ze zeign, wie mer verschedene Gombilieerungsmethodn vergleichd. Nooch Deel 1 erweitern mer unsere Ooalise uff 'ne größere Menge von Schaltgreesn, um 'nen umfassenden Benchmark fier de Bewärtung der Leistung von verschednen Gombilieerungstechnikken ze ermöchln.

```python
qubit_size = list(range(10, 101, 10))
qc_su2_list = [
    efficient_su2(n, entanglement="circular", reps=1)
    .decompose()
    .copy(name=f"SU2_{n}")
    for n in qubit_size
]

# Draw the first circuit
qc_su2_list[0].draw(output="mpl")
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/f362cdac-94d8-4cc5-85f4-015c3d9eba3a-0.avif)

### Schritt 2: Probläm fier die Ausfiehrung uff Quantehardware optimieren {#step-2-optimize-problem-for-quantum-hardware-execution}

Dieses Schritt is 'n Hauptfokus vom Tutorial. Hier zieeln mer doruff ab, Quanteschaltgreese fier die effiziente Ausfiehrung uff echter Quantehardware ze optimieren. Unser primäres Ziel is, Schaltgreesdieffe un Gateanzahl ze verringern, was wichtsche Faktoren fier de Verbesserung von der Ausfiehrungstreue un de Dämpfung von Hardwarerauschen sinn.

- **SABRE-Transbilder**: Nutzd Qiskits Standard-Transbilder mit'm SABRE-Layout- un -Routing-Algorithmus.
- **KI-Transbilder (lokaler Modus)**: Dr Standard-KI-Transbilder mit lokaler Inferenz un Standardsynthesestrategie.
- **Rustiq-Plugin**: 'n Transbilder-Plugin, das fier tiefenoptimierte Gombilierung bei Hamiltonian-Simulatschensoofgoabn endwickeld wordn is.

Das Ziel von däm Schritt is, de Ergebnisse von diesen Methodn in Begriffn von der Tiefe un der Gateanzahl vom transpilierten Schaltgrees ze vergleichen. Als weiteres wichtiches Metrik betrachten mer ooch die Transpilatschens-Laufzeit. Dursch 's Ooalysieren von diesen Metriken gönnen mer de relative Stärgn von jeder Methode bewärten un bestimmen, welche den effizienteschdnen Schaltgrees fier die Ausfiehrung uff der ausgewähltn Hardware erzeucht.

Hinweis: Fier des erste SU2-Schaltgreesbeispiel vergleichen mer nur 'n SABRE-Transbilder mit'm Standard-KI-Transbilder. Im nachfolgenden Benchmark mit Hamlib-Schaltgreesn vergleichen mer dann alle drei Transpilatschensmethodn.

```python
# QiskitRuntimeService.save_account(channel="ibm_quantum_platform", token="<YOUR-API-KEY>", overwrite=True, set_as_default=True)
service = QiskitRuntimeService(channel="ibm_quantum_platform")
backend = service.backend("ibm_torino")
print(f"Using backend: {backend}")
```

```text
qiskit_runtime_service._get_crn_from_instance_name:WARNING:2025-07-30 21:46:30,843: Multiple instances found. Using all matching instances.
```

```text
Using backend: <IBMBackend('ibm_torino')>
```

Qiskit-Transbilder mit SABRE:

```python
pm_sabre = generate_preset_pass_manager(
    optimization_level=3, backend=backend, seed_transpiler=seed
)
```

KI-Transbilder:

```python
# Standard AI transpiler pass manager, using the local mode
pm_ai = generate_ai_pass_manager(
    backend=backend, optimization_level=3, ai_optimization_level=3
)
```

Rustiq-Plugin:

```python
hls_config = HLSConfig(
    PauliEvolution=[
        (
            "rustiq",
            {
                "nshuffles": 400,
                "upto_phase": True,
                "fix_clifford": True,
                "preserve_order": False,
                "metric": "depth",
            },
        )
    ]
)
pm_rustiq = generate_preset_pass_manager(
    optimization_level=3,
    backend=backend,
    hls_config=hls_config,
    seed_transpiler=seed,
)
```

#### Transbildn un Metriken erfassn {#transpile-and-capture-metrics}

Um de Leistung von den Gombilieerungsmethodn ze vergleichen, definieren mer 'ne Funktschen, die 'n Eingoabschaltgrees transbidd un de relevanten Metriken in 'ner konsistenten Weise erfassd. Dazu ghörn de gesamte Schaltgreesdieffe, de gesamte Gateanzahl un de Transpilatschenszeit.

Zusätzlich ze diesen Standardmetriken erfassen mer ooch die Zweiqubit-Gate-Tiefe, was'n besonders wichtisches Metrik fier de Bewärtung von der Ausfiehrung uff Quantehardware is. Im Unterschied zur Gesamttiefe, die alle Gates eibeziehd, spieeld die Zweiqubit-Gate-Tiefe de tatsächliche Ausfiehrungsdauer uff der Hardware genouer wider. Das liechd doran, dass Zweiqubit-Gates in den meeschdne Quantegerädn de Zeit un das Fehlerbudget dominieren. Das Minimieren von der Zweiqubit-Gate-Tiefe is doher entscheidend fier's Verbässern von der Treue un Verringern von Dekoheränzeffektn während der Ausfiehrung.

Mer nutzn dieze Funktschen, um de Leistung von den verschednen Gombilieerungsmethodn ieber mehrere Schaltgreese ze ooalysieren.

```python
def capture_transpilation_metrics(
    results, pass_manager, circuits, method_name
):
    """
    Capture transpilation metrics for a list of circuits and stores the results in a DataFrame.

    Args:
        results (pd.DataFrame): DataFrame to store the results.
        pass_manager: Pass manager used for transpilation.
        circuits (list): List of quantum circuits to transpile.
        method_name (str): Name of the transpilation method.

    Returns:
        list: List of transpiled circuits.
    """
    transpiled_circuits = []

    for i, qc in enumerate(circuits):
        # Transpile the circuit
        start_time = time.time()
        transpiled_qc = pass_manager.run(qc)
        end_time = time.time()

        # Needed for AI transpiler to be consistent with other methods
        transpiled_qc = transpiled_qc.decompose(gates_to_decompose=["swap"])

        # Collect metrics
        transpilation_time = end_time - start_time
        circuit_depth = transpiled_qc.depth(
            lambda x: x.operation.num_qubits == 2
        )
        circuit_size = transpiled_qc.size()

        # Append results to DataFrame
        results.loc[len(results)] = {
            "method": method_name,
            "qc_name": qc.name,
            "qc_index": i,
            "num_qubits": qc.num_qubits,
            "ops": transpiled_qc.count_ops(),
            "depth": circuit_depth,
            "size": circuit_size,
            "runtime": transpilation_time,
        }
        transpiled_circuits.append(transpiled_qc)
        print(
            f"Transpiled circuit index {i} ({qc.name}) in {transpilation_time:.2f} seconds with method {method_name}, "
            f"depth {circuit_depth}, and size {circuit_size}."
        )

    return transpiled_circuits
```

```python
results_su2 = pd.DataFrame(
    columns=[
        "method",
        "qc_name",
        "qc_index",
        "num_qubits",
        "ops",
        "depth",
        "size",
        "runtime",
    ]
)

tqc_sabre = capture_transpilation_metrics(
    results_su2, pm_sabre, qc_su2_list, "sabre"
)
tqc_ai = capture_transpilation_metrics(results_su2, pm_ai, qc_su2_list, "ai")
```

```text
Transpiled circuit index 0 (SU2_10) in 0.06 seconds with method sabre, depth 13, and size 167.
Transpiled circuit index 1 (SU2_20) in 0.24 seconds with method sabre, depth 20, and size 299.
Transpiled circuit index 2 (SU2_30) in 10.72 seconds with method sabre, depth 72, and size 627.
Transpiled circuit index 3 (SU2_40) in 16.16 seconds with method sabre, depth 40, and size 599.
Transpiled circuit index 4 (SU2_50) in 76.89 seconds with method sabre, depth 77, and size 855.
Transpiled circuit index 5 (SU2_60) in 86.12 seconds with method sabre, depth 60, and size 899.
Transpiled circuit index 6 (SU2_70) in 94.46 seconds with method sabre, depth 79, and size 1085.
Transpiled circuit index 7 (SU2_80) in 69.05 seconds with method sabre, depth 80, and size 1199.
Transpiled circuit index 8 (SU2_90) in 88.25 seconds with method sabre, depth 105, and size 1420.
Transpiled circuit index 9 (SU2_100) in 83.80 seconds with method sabre, depth 100, and size 1499.
Transpiled circuit index 0 (SU2_10) in 0.17 seconds with method ai, depth 10, and size 168.
Transpiled circuit index 1 (SU2_20) in 0.29 seconds with method ai, depth 20, and size 299.
Transpiled circuit index 2 (SU2_30) in 13.56 seconds with method ai, depth 36, and size 548.
Transpiled circuit index 3 (SU2_40) in 15.95 seconds with method ai, depth 40, and size 599.
Transpiled circuit index 4 (SU2_50) in 80.70 seconds with method ai, depth 54, and size 823.
Transpiled circuit index 5 (SU2_60) in 75.99 seconds with method ai, depth 60, and size 899.
Transpiled circuit index 6 (SU2_70) in 64.96 seconds with method ai, depth 74, and size 1087.
Transpiled circuit index 7 (SU2_80) in 68.25 seconds with method ai, depth 80, and size 1199.
Transpiled circuit index 8 (SU2_90) in 75.07 seconds with method ai, depth 90, and size 1404.
Transpiled circuit index 9 (SU2_100) in 63.97 seconds with method ai, depth 100, and size 1499.
```

Transpilierte Ergebnisse von einem der Schaltgreese anzeign:

```python
print("Sabre transpilation")
display(tqc_sabre[0].draw("mpl", fold=-1, idle_wires=False))
print("AI transpilation")
display(tqc_ai[0].draw("mpl", fold=-1, idle_wires=False))
```

```text
Sabre transpilation
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/37924fc2-8fb6-451a-b8f9-cd79573f2384-1.avif)

```text
AI transpilation
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/37924fc2-8fb6-451a-b8f9-cd79573f2384-3.avif)

Ergebnistabelle:

```python
summary_su2 = (
    results_su2.groupby("method")[["depth", "size", "runtime"]]
    .mean()
    .round(2)
)
print(summary_su2)

results_su2
```

```text
depth   size  runtime
method
ai       56.4  852.5    45.89
sabre    64.6  864.9    52.57
```

```text
method  qc_name  qc_index  num_qubits                                ops  \
0   sabre   SU2_10         0          10     {'rz': 81, 'sx': 70, 'cz': 16}
1   sabre   SU2_20         1          20   {'rz': 160, 'sx': 119, 'cz': 20}
2   sabre   SU2_30         2          30   {'sx': 295, 'rz': 242, 'cz': 90}
3   sabre   SU2_40         3          40   {'rz': 320, 'sx': 239, 'cz': 40}
4   sabre   SU2_50         4          50   {'rz': 402, 'sx': 367, 'cz': 86}
5   sabre   SU2_60         5          60   {'rz': 480, 'sx': 359, 'cz': 60}
6   sabre   SU2_70         6          70   {'rz': 562, 'sx': 441, 'cz': 82}
7   sabre   SU2_80         7          80   {'rz': 640, 'sx': 479, 'cz': 80}
8   sabre   SU2_90         8          90  {'rz': 721, 'sx': 585, 'cz': 114}
9   sabre  SU2_100         9         100  {'rz': 800, 'sx': 599, 'cz': 100}
10     ai   SU2_10         0          10     {'rz': 81, 'sx': 71, 'cz': 16}
11     ai   SU2_20         1          20   {'rz': 160, 'sx': 119, 'cz': 20}
12     ai   SU2_30         2          30   {'sx': 243, 'rz': 242, 'cz': 63}
13     ai   SU2_40         3          40   {'rz': 320, 'sx': 239, 'cz': 40}
14     ai   SU2_50         4          50   {'rz': 403, 'sx': 346, 'cz': 74}
15     ai   SU2_60         5          60   {'rz': 480, 'sx': 359, 'cz': 60}
16     ai   SU2_70         6          70   {'rz': 563, 'sx': 442, 'cz': 82}
17     ai   SU2_80         7          80   {'rz': 640, 'sx': 479, 'cz': 80}
18     ai   SU2_90         8          90  {'rz': 721, 'sx': 575, 'cz': 108}
19     ai  SU2_100         9         100  {'rz': 800, 'sx': 599, 'cz': 100}

    depth  size    runtime
0      13   167   0.058845
1      20   299   0.238217
2      72   627  10.723922
3      40   599  16.159262
4      77   855  76.886604
5      60   899  86.118255
6      79  1085  94.458287
7      80  1199  69.048184
8     105  1420  88.254809
9     100  1499  83.795482
10     10   168   0.171532
11     20   299   0.291691
12     36   548  13.555931
13     40   599  15.952733
14     54   823  80.702141
15     60   899  75.993404
16     74  1087  64.960162
17     80  1199  68.253280
18     90  1404  75.072412
19    100  1499  63.967446
```

#### Ergebnisdiagramm {#results-graph}

Do mer 'ne Funktschen definiert hamm, um Metriken konsistent ze erfassn, definieren mer ooch 'ne zum Darstellen von den Metriken. Hier plotten mer de Zweiqubit-Tiefe, de Gateanzahl un de Laufzeit fier jede Gombilieerungsmethode ieber de Schaltgreese.

```python
def plot_transpilation_metrics(results, overall_title, x_axis="qc_index"):
    """
    Plots transpilation metrics (depth, size, runtime) for different transpilation methods.

    Parameters:
        results (DataFrame): Data containing columns ['num_qubits', 'method', 'depth', 'size', 'runtime']
        overall_title (str): The title of the overall figure.
        x_axis (str): The x-axis label, either 'num_qubits' or 'qc_index'.
    """

    fig, axs = plt.subplots(1, 3, figsize=(24, 6))
    metrics = ["depth", "size", "runtime"]
    titles = ["Circuit Depth", "Circuit Size", "Transpilation Runtime"]
    y_labels = ["Depth", "Size (Gate Count)", "Runtime (s)"]

    methods = results["method"].unique()
    colors = plt.colormaps["tab10"]
    markers = ["o", "^", "s", "D", "P", "*", "X", "v"]
    color_list = [colors(i % colors.N) for i in range(len(methods))]
    color_map = {method: color_list[i] for i, method in enumerate(methods)}
    marker_map = {
        method: markers[i % len(markers)] for i, method in enumerate(methods)
    }
    jitter_factor = 0.1  # Small x-axis jitter for visibility
    handles, labels = [], []  # Unique handles for legend
    # Plot each metric
    for i, metric in enumerate(metrics):
        for method in methods:
            method_data = results[results["method"] == method]

            # Introduce slight jitter to avoid exact overlap
            jitter = np.random.uniform(
                -jitter_factor, jitter_factor, len(method_data)
            )

            scatter = axs[i].scatter(
                method_data[x_axis] + jitter,
                method_data[metric],
                color=color_map[method],
                label=method,
                marker=marker_map[method],
                alpha=0.7,
                edgecolors="black",
                s=80,
            )

            if method not in labels:
                handles.append(scatter)
                labels.append(method)

        axs[i].set_title(titles[i])
        axs[i].set_xlabel(x_axis)
        axs[i].set_ylabel(y_labels[i])
        axs[i].grid(axis="y", linestyle="--", alpha=0.7)
        axs[i].tick_params(axis="x", rotation=45)
        axs[i].set_xticks(sorted(results[x_axis].unique()))

    fig.suptitle(overall_title, fontsize=16)
    fig.legend(
        handles=handles,
        labels=labels,
        loc="upper right",
        bbox_to_anchor=(1.05, 1),
    )

    plt.tight_layout()
    plt.show()
```

```python
plot_transpilation_metrics(
    results_su2, "Transpilation Metrics for SU2 Circuits", x_axis="num_qubits"
)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/7f7b502a-8ed6-45fa-a698-02977149e283-0.avif)

#### Ooalyse von de SU2-Schaltgreese-Gombilieerungsergebnisse {#analysis-of-su2-circuit-compilation-results}

In däm Exberiment vergleichen mer zwei Transpilatschensmethodn — Qiskits SABRE-Transbilder un 'n KI-Transbilder — uff 'ner Menge von `efficient_su2`-Schaltgreesn. Do dieze Schaltgreese keine `PauliEvolutionGate`-Obetatschenen enthältn, wird 's Rustiq-Plugin bei däm Vergleich nich einbezogn.

Durchschnittlich erbringt dr KI-Transbilder bessere Ergebnisse in Begriffn von der Schaltgreesdieffe, mit 'ner Verbesserung von mehr als 10% ieber 'n gesamtn Bereich von SU2-Schaltgreesn. Fier de Gateanzahl (Schaltgreessgröße) un de Transpilatschens-Laufzeit liefern beide Methodn insgesamt ähnliche Ergebnisse.

's Betrachtn von den einzlnen Datenpunktn zeicht ober 'nen tiefern Einblick:
- Fier de meeschdne Qubit-Größen erzeugen sowohl SABRE als ooch KI nahezu identische Ergebnisse, was doruff hindeitd, dass in vielen Fälln beide Methodn ze ähnlich effizienten Lösungen gonvergieren.
- Fier bestimmde Schaltgreesgrößen, speziell bei 30, 50, 70 un 90 Qubits, findert dr KI-Transbilder erheblich flachere Schaltgreese als SABRE. Das deutd doruff hin, dass KIs lärnbasierter Oosotz in den Fälln optimale Layouts oder Routing-Pfade entdecken gann, wo SABRE's Heuristik versachd.

Diese Beobachtung oogebbeld 'n wichtischn Schluss:
> Obwohl SABRE un KI häufsch vergleichbare Ergebnisse liefern, gann dr KI-Transbilder geleechntlich viel bessere Lösungen entdecken — besonders in Begriffn von der Tiefe — was ze erheblich verbässerter Leistung uff der Hardware führn gann.
## Deel 2: Hamiltonian-Simulatschens-Schaltgrees {#part-2-hamiltonian-simulation-circuit}

### Schritt 1: Schaltgreese mit `PauliEvolutionGate` untersuchen {#step-1-investigate-circuits-with-paulievolutiongate}

In däm Abschnitt untersuchen mer Quanteschaltgreese, die mit `PauliEvolutionGate` erbaut wordn sinn, was de effiziente Simulatschn von Hamiltonians ermöchlicht. Mer ooalysieren, wie verschedene Gombilieerungsmethodn dieze Schaltgreese ieber verschedne Hamiltonians optimieren.

#### Im Benchmark verwendete Hamiltonians {#hamiltonians-used-in-the-benchmark}

Die im Benchmark verwendetn Hamiltonians beschreibn paarweise Wechselwirkungen zwischn Qubits, eischließlich von Terme wie $ZZ$, $XX$ un $YY$. Dieze Hamiltonians wärdn häufsch in der Quantenchemie, der Physik von kondensiertn Materie un der Materialwissenschaft verwendet, wo se Systeme von wechselwirkenden Teilchen modellieren.

Als Referenz gönnen Nutzer 'ne breider aufgestellde Menge von Hamiltonians in däm Papier erkunden: [Efficient Hamiltonian Simulation on Noisy Quantum Devices](https://arxiv.org/pdf/2306.13126).

#### Benchmark-Quelle: Hamlib un Benchpress {#benchmark-source-hamlib-and-benchpress}

Die im Benchmark verwendetn Schaltgreese stammn aus'm [Hamlib-Benchmark-Repository](https://github.com/SRI-International/QC-App-Oriented-Benchmarks/tree/master/hamlib), das realistischde Hamiltonian-Simulatschens-Workloads enthält.

Dieze Schaltgreese wordn vorher mit [Benchpress](https://github.com/Qiskit/benchpress) benchmarkd — 'nem open-source-Framework zur Bewärtung von Quantetrasnpilatschensleisung. Dursch 's Verwenden von däm standardisierten Schaltgreessatz gönnen mer die Wirksamkeit von verschednen Gombilierungsstrategien uff repräsentativen Simulatschensblöblähmn direkt vergleichen.

Hamiltonian-Simulatschn is 'ne grundläcgliche Aufgoab im Quantecombuting, mit Oowendungen in molekularen Simulatschenen, Optimierungsproblähmn un Quanten-Vielteilchen-Fieesik. 's Verstehn davon, wie verschedene Gombilieerungsmethodn dieze Schaltgreese optimieren, helfd Nutzern, de pragtische Ausfiehrung solcher Schaltgreese uff modernen Quantegerätn ze verbässern.

```python
# Obtain the Hamiltonian JSON from the benchpress repository
url = "https://raw.githubusercontent.com/Qiskit/benchpress/e7b29ef7be4cc0d70237b8fdc03edbd698908eff/benchpress/hamiltonian/hamlib/100_representative.json"
response = requests.get(url)
response.raise_for_status()  # Raise an error if download failed
ham_records = json.loads(response.text)
# Remove circuits that are too large for the backend
ham_records = [
    h for h in ham_records if h["ham_qubits"] <= backend.num_qubits
]
# Remove the circuits that are large to save transpilation time
ham_records = sorted(ham_records, key=lambda x: x["ham_terms"])[:35]

qc_ham_list = []
for h in ham_records:
    terms = h["ham_hamlib_hamiltonian_terms"]
    coeff = h["ham_hamlib_hamiltonian_coefficients"]
    num_qubits = h["ham_qubits"]
    name = h["ham_problem"]

    evo_gate = PauliEvolutionGate(SparsePauliOp(terms, coeff))

    qc_ham = QuantumCircuit(num_qubits)
    qc_ham.name = name

    qc_ham.append(evo_gate, range(num_qubits))
    qc_ham_list.append(qc_ham)
print(f"Number of Hamiltonian circuits: {len(qc_ham_list)}")

# Draw the first Hamiltonian circuit
qc_ham_list[0].draw("mpl", fold=-1)
```

```text
Number of Hamiltonian circuits: 35
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/66347c00-1607-4405-bb76-610690adf6b8-1.avif)

### Schritt 2: Probläm fier die Ausfiehrung uff Quantehardware optimieren {#step-2-optimize-problem-for-quantum-hardware-execution-2}

Wie im vorherigen Beispiel nutzn mer 's gleiche Backend, um Konsistenz bei unsrn Vergleichen ze gewährleischdne. Do die Pass-Manager (`pm_sabre`, `pm_ai` un `pm_rustiq`) schon initialisiert worn sinn, gönnen mer direkd mit'm Transbildn von den Hamiltonian-Schaltgreesn mit jeder Methode fortfahrn.

Dieses Schritt gunzendreert sich ausschließlich doruff, de Transpilatschn durchzeführn un de resultierenden Schaltgreesmetriken ze erfassn, eischließlich Tiefe, Gateanzahl un Transpilatschens-Laufzeit. Dursch 's Ooalysieren von diesen Ergebnissen wölln mer de Effizienz von jeder Transpilatschensmethode fier diesen Schaltgreestyp bestimmen.
Transbildn un Metriken erfassn:

```python
results_ham = pd.DataFrame(
    columns=[
        "method",
        "qc_name",
        "qc_index",
        "num_qubits",
        "ops",
        "depth",
        "size",
        "runtime",
    ]
)

tqc_sabre = capture_transpilation_metrics(
    results_ham, pm_sabre, qc_ham_list, "sabre"
)
tqc_ai = capture_transpilation_metrics(results_ham, pm_ai, qc_ham_list, "ai")
tqc_rustiq = capture_transpilation_metrics(
    results_ham, pm_rustiq, qc_ham_list, "rustiq"
)
```

```text
Transpiled circuit index 0 (all-vib-o3) in 0.02 seconds with method sabre, depth 6, and size 58.
Transpiled circuit index 1 (all-vib-c2h) in 1.10 seconds with method sabre, depth 2, and size 39.
Transpiled circuit index 2 (all-vib-bh) in 0.01 seconds with method sabre, depth 3, and size 30.
Transpiled circuit index 3 (all-vib-c2h) in 0.03 seconds with method sabre, depth 18, and size 115.
Transpiled circuit index 4 (graph-gnp_k-2) in 0.02 seconds with method sabre, depth 24, and size 129.
Transpiled circuit index 5 (all-vib-fccf) in 0.05 seconds with method sabre, depth 14, and size 134.
Transpiled circuit index 6 (all-vib-hno) in 8.39 seconds with method sabre, depth 6, and size 174.
Transpiled circuit index 7 (all-vib-bhf2) in 3.92 seconds with method sabre, depth 22, and size 220.
Transpiled circuit index 8 (LiH) in 0.03 seconds with method sabre, depth 67, and size 290.
Transpiled circuit index 9 (uf20-ham) in 0.04 seconds with method sabre, depth 50, and size 340.
Transpiled circuit index 10 (all-vib-fccf) in 0.62 seconds with method sabre, depth 30, and size 286.
Transpiled circuit index 11 (all-vib-fccf) in 0.04 seconds with method sabre, depth 67, and size 339.
Transpiled circuit index 12 (all-vib-ch2) in 0.04 seconds with method sabre, depth 87, and size 421.
Transpiled circuit index 13 (tfim) in 0.05 seconds with method sabre, depth 36, and size 222.
Transpiled circuit index 14 (all-vib-cyclo_propene) in 9.51 seconds with method sabre, depth 22, and size 345.
Transpiled circuit index 15 (graph-gnp_k-4) in 0.05 seconds with method sabre, depth 128, and size 704.
Transpiled circuit index 16 (all-vib-hc3h2cn) in 13.83 seconds with method sabre, depth 2, and size 242.
Transpiled circuit index 17 (TSP_Ncity-4) in 0.05 seconds with method sabre, depth 106, and size 609.
Transpiled circuit index 18 (tfim) in 0.29 seconds with method sabre, depth 73, and size 399.
Transpiled circuit index 19 (all-vib-h2co) in 21.97 seconds with method sabre, depth 30, and size 572.
Transpiled circuit index 20 (Be2) in 0.09 seconds with method sabre, depth 324, and size 1555.
Transpiled circuit index 21 (graph-complete_bipart) in 0.12 seconds with method sabre, depth 250, and size 1394.
Transpiled circuit index 22 (all-vib-f2) in 0.07 seconds with method sabre, depth 215, and size 1027.
Transpiled circuit index 23 (all-vib-cyclo_propene) in 41.22 seconds with method sabre, depth 30, and size 1144.
Transpiled circuit index 24 (TSP_Ncity-5) in 1.89 seconds with method sabre, depth 175, and size 1933.
Transpiled circuit index 25 (H2) in 0.32 seconds with method sabre, depth 1237, and size 5502.
Transpiled circuit index 26 (uuf100-ham) in 0.20 seconds with method sabre, depth 385, and size 4303.
Transpiled circuit index 27 (ham-graph-gnp_k-5) in 0.20 seconds with method sabre, depth 311, and size 3654.
Transpiled circuit index 28 (tfim) in 0.15 seconds with method sabre, depth 276, and size 3213.
Transpiled circuit index 29 (uuf100-ham) in 0.21 seconds with method sabre, depth 520, and size 5250.
Transpiled circuit index 30 (flat100-ham) in 0.15 seconds with method sabre, depth 131, and size 3157.
Transpiled circuit index 31 (uf100-ham) in 0.24 seconds with method sabre, depth 624, and size 7378.
Transpiled circuit index 32 (OH) in 0.88 seconds with method sabre, depth 2175, and size 9808.
Transpiled circuit index 33 (HF) in 0.66 seconds with method sabre, depth 2206, and size 9417.
Transpiled circuit index 34 (BH) in 0.89 seconds with method sabre, depth 2177, and size 9802.
Transpiled circuit index 0 (all-vib-o3) in 0.02 seconds with method ai, depth 6, and size 58.
Transpiled circuit index 1 (all-vib-c2h) in 1.11 seconds with method ai, depth 2, and size 39.
Transpiled circuit index 2 (all-vib-bh) in 0.01 seconds with method ai, depth 3, and size 30.
Transpiled circuit index 3 (all-vib-c2h) in 0.11 seconds with method ai, depth 18, and size 94.
Transpiled circuit index 4 (graph-gnp_k-2) in 0.11 seconds with method ai, depth 22, and size 129.
Transpiled circuit index 5 (all-vib-fccf) in 0.06 seconds with method ai, depth 22, and size 177.
Transpiled circuit index 6 (all-vib-hno) in 8.62 seconds with method ai, depth 10, and size 198.
Transpiled circuit index 7 (all-vib-bhf2) in 3.71 seconds with method ai, depth 18, and size 195.
Transpiled circuit index 8 (LiH) in 0.19 seconds with method ai, depth 62, and size 267.
Transpiled circuit index 9 (uf20-ham) in 0.22 seconds with method ai, depth 47, and size 321.
Transpiled circuit index 10 (all-vib-fccf) in 0.71 seconds with method ai, depth 38, and size 369.
Transpiled circuit index 11 (all-vib-fccf) in 0.24 seconds with method ai, depth 65, and size 315.
Transpiled circuit index 12 (all-vib-ch2) in 0.24 seconds with method ai, depth 91, and size 430.
Transpiled circuit index 13 (tfim) in 0.15 seconds with method ai, depth 12, and size 251.
Transpiled circuit index 14 (all-vib-cyclo_propene) in 8.50 seconds with method ai, depth 18, and size 311.
Transpiled circuit index 15 (graph-gnp_k-4) in 0.25 seconds with method ai, depth 117, and size 659.
Transpiled circuit index 16 (all-vib-hc3h2cn) in 16.11 seconds with method ai, depth 2, and size 242.
Transpiled circuit index 17 (TSP_Ncity-4) in 0.39 seconds with method ai, depth 98, and size 564.
Transpiled circuit index 18 (tfim) in 0.38 seconds with method ai, depth 23, and size 437.
Transpiled circuit index 19 (all-vib-h2co) in 24.97 seconds with method ai, depth 38, and size 707.
Transpiled circuit index 20 (Be2) in 1.07 seconds with method ai, depth 293, and size 1392.
Transpiled circuit index 21 (graph-complete_bipart) in 0.61 seconds with method ai, depth 229, and size 1437.
Transpiled circuit index 22 (all-vib-f2) in 0.57 seconds with method ai, depth 178, and size 964.
Transpiled circuit index 23 (all-vib-cyclo_propene) in 50.89 seconds with method ai, depth 34, and size 1425.
Transpiled circuit index 24 (TSP_Ncity-5) in 1.61 seconds with method ai, depth 171, and size 2020.
Transpiled circuit index 25 (H2) in 6.39 seconds with method ai, depth 1148, and size 5208.
Transpiled circuit index 26 (uuf100-ham) in 3.97 seconds with method ai, depth 376, and size 5048.
Transpiled circuit index 27 (ham-graph-gnp_k-5) in 3.54 seconds with method ai, depth 357, and size 4451.
Transpiled circuit index 28 (tfim) in 1.72 seconds with method ai, depth 216, and size 3026.
Transpiled circuit index 29 (uuf100-ham) in 4.45 seconds with method ai, depth 426, and size 5399.
Transpiled circuit index 30 (flat100-ham) in 7.02 seconds with method ai, depth 86, and size 3108.
Transpiled circuit index 31 (uf100-ham) in 12.85 seconds with method ai, depth 623, and size 8354.
Transpiled circuit index 32 (OH) in 15.19 seconds with method ai, depth 2084, and size 9543.
Transpiled circuit index 33 (HF) in 17.51 seconds with method ai, depth 2063, and size 9446.
Transpiled circuit index 34 (BH) in 15.33 seconds with method ai, depth 2094, and size 9730.
Transpiled circuit index 0 (all-vib-o3) in 0.02 seconds with method rustiq, depth 13, and size 83.
Transpiled circuit index 1 (all-vib-c2h) in 1.11 seconds with method rustiq, depth 2, and size 39.
Transpiled circuit index 2 (all-vib-bh) in 0.01 seconds with method rustiq, depth 3, and size 30.
Transpiled circuit index 3 (all-vib-c2h) in 0.01 seconds with method rustiq, depth 13, and size 79.
Transpiled circuit index 4 (graph-gnp_k-2) in 0.02 seconds with method rustiq, depth 31, and size 131.
Transpiled circuit index 5 (all-vib-fccf) in 0.04 seconds with method rustiq, depth 50, and size 306.
Transpiled circuit index 6 (all-vib-hno) in 14.03 seconds with method rustiq, depth 22, and size 276.
Transpiled circuit index 7 (all-vib-bhf2) in 3.15 seconds with method rustiq, depth 13, and size 155.
Transpiled circuit index 8 (LiH) in 0.03 seconds with method rustiq, depth 54, and size 270.
Transpiled circuit index 9 (uf20-ham) in 0.04 seconds with method rustiq, depth 65, and size 398.
Transpiled circuit index 10 (all-vib-fccf) in 0.16 seconds with method rustiq, depth 41, and size 516.
Transpiled circuit index 11 (all-vib-fccf) in 0.02 seconds with method rustiq, depth 34, and size 189.
Transpiled circuit index 12 (all-vib-ch2) in 0.03 seconds with method rustiq, depth 49, and size 240.
Transpiled circuit index 13 (tfim) in 0.05 seconds with method rustiq, depth 20, and size 366.
Transpiled circuit index 14 (all-vib-cyclo_propene) in 9.08 seconds with method rustiq, depth 16, and size 277.
Transpiled circuit index 15 (graph-gnp_k-4) in 0.04 seconds with method rustiq, depth 116, and size 612.
Transpiled circuit index 16 (all-vib-hc3h2cn) in 13.89 seconds with method rustiq, depth 2, and size 257.
Transpiled circuit index 17 (TSP_Ncity-4) in 0.05 seconds with method rustiq, depth 133, and size 737.
Transpiled circuit index 18 (tfim) in 0.11 seconds with method rustiq, depth 25, and size 680.
Transpiled circuit index 19 (all-vib-h2co) in 27.19 seconds with method rustiq, depth 66, and size 983.
Transpiled circuit index 20 (Be2) in 0.07 seconds with method rustiq, depth 215, and size 1030.
Transpiled circuit index 21 (graph-complete_bipart) in 0.14 seconds with method rustiq, depth 328, and size 1918.
Transpiled circuit index 22 (all-vib-f2) in 0.05 seconds with method rustiq, depth 114, and size 692.
Transpiled circuit index 23 (all-vib-cyclo_propene) in 62.25 seconds with method rustiq, depth 74, and size 2348.
Transpiled circuit index 24 (TSP_Ncity-5) in 0.20 seconds with method rustiq, depth 436, and size 3605.
Transpiled circuit index 25 (H2) in 0.21 seconds with method rustiq, depth 643, and size 3476.
Transpiled circuit index 26 (uuf100-ham) in 0.24 seconds with method rustiq, depth 678, and size 6120.
Transpiled circuit index 27 (ham-graph-gnp_k-5) in 0.22 seconds with method rustiq, depth 588, and size 5241.
Transpiled circuit index 28 (tfim) in 0.34 seconds with method rustiq, depth 340, and size 5901.
Transpiled circuit index 29 (uuf100-ham) in 0.33 seconds with method rustiq, depth 881, and size 7667.
Transpiled circuit index 30 (flat100-ham) in 0.31 seconds with method rustiq, depth 279, and size 4910.
Transpiled circuit index 31 (uf100-ham) in 0.38 seconds with method rustiq, depth 1138, and size 10607.
Transpiled circuit index 32 (OH) in 0.38 seconds with method rustiq, depth 1148, and size 6512.
Transpiled circuit index 33 (HF) in 0.37 seconds with method rustiq, depth 1090, and size 6256.
Transpiled circuit index 34 (BH) in 0.37 seconds with method rustiq, depth 1148, and size 6501.
```

Ergebnistabelle (ohne Visualisieerung, do de Ausgabeschaltgreese sehr groß sinn):

```python
summary_ham = (
    results_ham.groupby("method")[["depth", "size", "runtime"]]
    .mean()
    .round(2)
)
print(summary_ham)

results_ham
```

```text
depth     size  runtime
method
ai      316.86  2181.26     5.97
rustiq  281.94  2268.80     3.86
sabre   337.97  2120.14     3.07
```

```text
method        qc_name  qc_index  num_qubits  \
0     sabre     all-vib-o3         0           4
1     sabre    all-vib-c2h         1           4
2     sabre     all-vib-bh         2           2
3     sabre    all-vib-c2h         3           3
4     sabre  graph-gnp_k-2         4           4
..      ...            ...       ...         ...
100  rustiq    flat100-ham        30          90
101  rustiq      uf100-ham        31          46
102  rustiq             OH        32          10
103  rustiq             HF        33          10
104  rustiq             BH        34          10

                                               ops  depth   size   runtime
0                    {'rz': 28, 'sx': 24, 'cz': 6}      6     58  0.016597
1            {'rz': 17, 'sx': 16, 'cz': 4, 'x': 2}      2     39  1.102089
2                    {'sx': 14, 'rz': 13, 'cz': 3}      3     30  0.011042
3           {'sx': 46, 'rz': 45, 'cz': 18, 'x': 6}     18    115  0.025816
4           {'sx': 49, 'rz': 47, 'cz': 24, 'x': 9}     24    129  0.023077
..                                             ...    ...    ...       ...
100    {'sx': 2709, 'cz': 1379, 'rz': 817, 'x': 5}    279   4910  0.309448
101   {'sx': 6180, 'cz': 3120, 'rz': 1303, 'x': 4}   1138  10607  0.380977
102  {'sx': 3330, 'cz': 1704, 'rz': 1455, 'x': 23}   1148   6512  0.383564
103  {'sx': 3213, 'cz': 1620, 'rz': 1406, 'x': 17}   1090   6256  0.368578
104  {'sx': 3331, 'cz': 1704, 'rz': 1447, 'x': 19}   1148   6501  0.374822

[105 rows x 8 columns]
```

Leistung oo Hand vom Schaltgreesindex visualisiern:

```python
plot_transpilation_metrics(
    results_ham, "Transpilation Metrics for Hamiltonian Circuits"
)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/4c6b810d-a4cf-4de3-aae6-c6c1cdd83d8f-0.avif)

'n Prozentsatz von de Schaltgreese visualisiern, bei denen jede Methode am beschdne abgeschnittne hat.

```python
def analyze_and_plot_best_methods(results, metric):
    """
    Analyze the best-performing methods for a given metric and plot a pie chart.

    Parameters:
        results (DataFrame): The input DataFrame containing method performance data.
        metric (str): The metric to evaluate ("depth" or "size").
    """
    method_counts = Counter()
    for qc_idx, group in results.groupby("qc_index"):
        min_value = group[metric].min()

        # Find all methods that achieved this minimum value
        best_methods = group[group[metric] == min_value]["method"]
        # Update counts for all best methods (handling ties)
        method_counts.update(best_methods)
    best_method_counts = dict(
        sorted(method_counts.items(), key=lambda x: x[1], reverse=True)
    )

    # Print summary
    print(f"Best-performing methods based on {metric}:")
    for method, count in best_method_counts.items():
        print(f"    {method}: {count} circuit(s)")

    # Plot pie chart
    num_methods = len(best_method_counts)
    colors = plt.cm.viridis_r(range(0, 256, 256 // num_methods))
    plt.figure(figsize=(5, 5))
    plt.pie(
        best_method_counts.values(),
        labels=best_method_counts.keys(),
        autopct="%1.1f%%",
        startangle=140,
        wedgeprops={"edgecolor": "black"},
        textprops={"fontsize": 10},
        colors=colors,
    )
    plt.title(
        f"Percentage of Circuits Method Performed Best for {metric.capitalize()}",
        fontsize=12,
        fontweight="bold",
    )
    plt.show()

analyze_and_plot_best_methods(results_ham, "depth")
analyze_and_plot_best_methods(results_ham, "size")
```

```text
Best-performing methods based on depth:
    ai: 16 circuit(s)
    rustiq: 16 circuit(s)
    sabre: 10 circuit(s)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/01b4644e-ac91-483c-944b-924f8b41718d-1.avif)

```text
Best-performing methods based on size:
    sabre: 18 circuit(s)
    rustiq: 14 circuit(s)
    ai: 10 circuit(s)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/01b4644e-ac91-483c-944b-924f8b41718d-3.avif)

#### Ooalyse von de Hamiltonian-Schaltgreese-Gombilieerungsergebnisse {#analysis-of-hamiltonian-circuit-compilation-results}

In däm Abschnitt bewärten mer de Leistung von drei Transpilatschensmethodn — SABRE, 'n KI-Transbilder un Rustiq — uff Quanteschaltgreesn, die mit `PauliEvolutionGate` erbaut wordn sinn, was bei Hamiltonian-Simulatschensoofgoabn häufsch gebruikt wird.

Rustiq hat durchschnittlich am beschdne bei der Schaltgreesdieffe abgeschnittne un erreechd ungefähr 20% geringere Tiefe als SABRE. Das is erwarted, do Rustiq speziell dafier entworfen wordn is, `PauliEvolutionGate`-Obetatschenen mit optimierten, tiefenreduzierten Zerlegungsstrategien ze synthetisieren. Außerdem zeicht 'n Tiefenplot, dass Rustiq beim Skalieren der Schaltgreese in Größe un Komplexität am effektivschdne skaliert un bei größern Schaltgreesn erheblich geringere Tiefe als sowohl KI als ooch SABRE beibehält.

Dr KI-Transbilder hat starke un konsistente Leistung fier de Schaltgreesdieffe gezeichd un SABRE ieber de meeschdne Schaltgreese durchgängig iebertroffen. Er hot ober de höchste Laufzeit verursachd, besonders bei größern Schaltgreesn, was seine Pragtikabilität bei zeitkritischn Workloads einschränkn gann. Seine Skalierbarkeit bei der Laufzeit bleibt'ne wichtische Begrenzung, ouch wenn er solide Verbässerungen bei der Tiefe biedd.

SABRE, obwohl 's de höchste durchschnittliche Tiefe erzeugt hat, hat die geringste durchschnittliche Gateanzahl erreechd, dicht gefolcht von'n KI-Transbilder. Das stimmt mit dr Konzebtschen von SABREs Heuristik ieberei, die vorrangich doruff ausgriechd is, de Gateanzahl direkt ze minimieren. Rustiq hat trotz seiner Stärke bei der Tiefenreduzierung die höchste durchschnittliche Gateanzahl, was'n bemerkenswertn Kompromiss is, der in Oowendungen zu berücksichtigen is, wo die Schaltgreessgröße wichtischer is als die Schaltgreesdauer.

### Zusammenfasseng {#summary}

Obwohl dr KI-Transbilder im Allgemeinen bessere Ergebnisse als SABRE lieferd, besonders bei der Schaltgreesdieffe, sollte de Schlussfolgerung nicht einfach sinn "immer den KI-Transbilder nutzen". Es gibd wichtische Nuancen ze berücksichtigen:

- **KI-Transbilder** is in der Regel zuverlässig un lieferd tiefenoptimierte Schaltgreese, ober er hat Kompromisse bei der Laufzeit un ooch weitere Einschränkungen, eischließlich unterstützter Kopplungskarten un Synthesefähigkeiten. Diese worn im [Qiskit Transpiler Service-Dokumentation](/guides/qiskit-transpiler-service) beschrieben.

- In einschn Fälln, besonders bei sehr großn oder hardwarespezifischn Schaltgreesn, gann dr KI-Transbilder wenicher effektiv sinn. In diesen Fälln bleibt 'n Standard-SABRE-Transbilder extrem zuverlässig un gann dursch 's Oonbassn seiner Parameter weiter optimiert wärdn (siehde 's [SABRE-Optimierungs-Tutorial](/tutorials/transpilation-optimizations-with-sabre)).

- 's is ooch wichtisch, de Schaltgreesstruktur bei der Auswahl von 'ner Methode ze berücksichtigen. Zum Beispiel is `rustiq` speziell fier Schaltgreese mit `PauliEvolutionGate` entwickeld wordn un lieferd häufsch de beschde Leistung fier Hamiltonian-Simulatschensproblähmn.

**Empfehlung:**
> Es gibd keine universelle Transpilatschensstrategie. Nutzer wärdn ermuticht, de Struktur ihrer Schaltgreese ze verstehn un mehrere Transpilatschensmethodn ze teschdn — eischließlich KI, SABRE un spezialisierde Werkzeige wie Rustiq — um de effizienteschde Lösung fier ihr spezifisches Probläm un ihre Hardwarebeschränkungen ze findn.
### Schritt 3: Mit Qiskit-Primitives ausführn {#step-3-execute-using-qiskit-primitives}
Do sich dieses Tutorial uff die Transpilatschn gunzendreert, wärdn keine Exberimente uff 'm Quantegerät ausgeführt. Das Ziel is, de Optimierungen aus Schritt 2 ze nutzn, um'n transpilierten Schaltgrees mit verringerter Tiefe un Gateanzahl ze erhaaldn.
### Schritt 4: Ergebnis noochbarbeiten un im gewünschtn glassischn Format zurückgebn {#step-4-post-process-and-return-result-in-desired-classical-format}
Do fier dieses Notebook keine Ausfiehrung stattfindd, gibd's keine Ergebnisse ze noochbarbieten.
## Quelln {#references}

[1] "LightSABRE: A Lightweight and Enhanced SABRE Algorithm". H. Zou, M. Treinish, K. Hartman, A. Ivrii, J. Lishman et al. https://arxiv.org/abs/2409.08368

[2] "Practical and efficient quantum circuit synthesis and transpiling with Reinforcement Learning". D. Kremer, V. Villar, H. Paik, I. Duran, I. Faro, J. Cruz-Benito et al. https://arxiv.org/abs/2405.13196

[3] "Pauli Network Circuit Synthesis with Reinforcement Learning". A. Dubal,  D. Kremer, S. Martiel, V. Villar, D. Wang, J. Cruz-Benito et al. https://arxiv.org/abs/2503.14448

[4] "Faster and shorter synthesis of Hamiltonian simulation circuits". T. Goubault de Brugière, S. Martiel et al. https://arxiv.org/abs/2404.03280
