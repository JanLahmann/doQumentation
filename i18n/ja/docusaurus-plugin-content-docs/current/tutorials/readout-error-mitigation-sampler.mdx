---
title: "M3ã‚’ä½¿ç”¨ã—ãŸSamplerãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã®èª­ã¿å‡ºã—ã‚¨ãƒ©ãƒ¼è»½æ¸›"
sidebar_label: "M3ã‚’ä½¿ç”¨ã—ãŸSamplerãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã®èª­ã¿å‡ºã—ã‚¨ãƒ©ãƒ¼è»½æ¸›"
description: "M3èª­ã¿å‡ºã—è»½æ¸›ã‚¢ãƒ‰ã‚ªãƒ³ã‚’Samplerãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã¨ã¨ã‚‚ã«ä½¿ç”¨ã™ã‚‹"
notebook_path: "docs/tutorials/readout-error-mitigation-sampler.ipynb"
---

<OpenInLabBanner notebookPath="docs/tutorials/readout-error-mitigation-sampler.ipynb" />



{/* cspell:ignore braket, Zgrm, newcommand, probs, quasis, topten */}

*ä½¿ç”¨é‡ã®ç›®å®‰: Heron r2ãƒ—ãƒ­ã‚»ãƒƒã‚µã§1åˆ†æœªæº€ï¼ˆæ³¨æ„: ã“ã‚Œã¯ç›®å®‰ã§ã™ã€‚å®Ÿéš›ã®å®Ÿè¡Œæ™‚é–“ã¯ç•°ãªã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ï¼‰*

## èƒŒæ™¯ {#background}

Estimatorãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã¨ã¯ç•°ãªã‚Šã€Samplerãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã«ã¯ã‚¨ãƒ©ãƒ¼è»½æ¸›ã®çµ„ã¿è¾¼ã¿ã‚µãƒãƒ¼ãƒˆãŒã‚ã‚Šã¾ã›ã‚“ã€‚
EstimatorãŒã‚µãƒãƒ¼ãƒˆã™ã‚‹ã„ãã¤ã‹ã®æ‰‹æ³•ã¯æœŸå¾…å€¤ã®è¨ˆç®—ã«ç‰¹åŒ–ã—ã¦è¨­è¨ˆã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€Samplerãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã«ã¯é©ç”¨ã§ãã¾ã›ã‚“ã€‚ä¾‹å¤–ã¯èª­ã¿å‡ºã—ã‚¨ãƒ©ãƒ¼è»½æ¸›ã§ã‚ã‚Šã€ã“ã‚Œã¯éå¸¸ã«åŠ¹æœçš„ãªæ‰‹æ³•ã§ã€Samplerãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã«ã‚‚é©ç”¨å¯èƒ½ã§ã™ã€‚

[M3 Qiskitã‚¢ãƒ‰ã‚ªãƒ³](https://qiskit.github.io/qiskit-addon-mthree/)ã¯ã€èª­ã¿å‡ºã—ã‚¨ãƒ©ãƒ¼è»½æ¸›ã®ãŸã‚ã®åŠ¹ç‡çš„ãªæ‰‹æ³•ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚ã“ã®ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã§ã¯ã€M3 Qiskitã‚¢ãƒ‰ã‚ªãƒ³ã‚’ä½¿ç”¨ã—ã¦Samplerãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã®èª­ã¿å‡ºã—ã‚¨ãƒ©ãƒ¼ã‚’è»½æ¸›ã™ã‚‹æ–¹æ³•ã‚’èª¬æ˜ã—ã¾ã™ã€‚

### èª­ã¿å‡ºã—ã‚¨ãƒ©ãƒ¼ã¨ã¯ä½•ã‹ {#what-is-readout-error}

æ¸¬å®šã®ç›´å‰ã«ãŠã„ã¦ã€é‡å­ãƒ“ãƒƒãƒˆãƒ¬ã‚¸ã‚¹ã‚¿ã®çŠ¶æ…‹ã¯
è¨ˆç®—åŸºåº•çŠ¶æ…‹ã®é‡ã­åˆã‚ã›ã€
ã¾ãŸã¯å¯†åº¦è¡Œåˆ—ã«ã‚ˆã£ã¦è¨˜è¿°ã•ã‚Œã¾ã™ã€‚
é‡å­ãƒ“ãƒƒãƒˆãƒ¬ã‚¸ã‚¹ã‚¿ã‹ã‚‰å¤å…¸ãƒ“ãƒƒãƒˆãƒ¬ã‚¸ã‚¹ã‚¿ã¸ã®æ¸¬å®šã¯ã€2ã¤ã®ã‚¹ãƒ†ãƒƒãƒ—ã§è¡Œã‚ã‚Œã¾ã™ã€‚
æœ€åˆã«é‡å­æ¸¬å®šãã®ã‚‚ã®ãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚
ã“ã‚Œã¯ã€é‡å­ãƒ“ãƒƒãƒˆãƒ¬ã‚¸ã‚¹ã‚¿ã®çŠ¶æ…‹ãŒ
$1$ã¨$0$ã®æ–‡å­—åˆ—ã§ç‰¹å¾´ä»˜ã‘ã‚‰ã‚Œã‚‹
å˜ä¸€ã®åŸºåº•çŠ¶æ…‹ã«å°„å½±ã•ã‚Œã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚
2ç•ªç›®ã®ã‚¹ãƒ†ãƒƒãƒ—ã¯ã€ã“ã®åŸºåº•çŠ¶æ…‹ã‚’ç‰¹å¾´ä»˜ã‘ã‚‹ãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã‚’èª­ã¿å–ã‚Šã€
å¤å…¸ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã®ãƒ¡ãƒ¢ãƒªã«æ›¸ãè¾¼ã‚€ã“ã¨ã§ã™ã€‚
ã“ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’*èª­ã¿å‡ºã—*ã¨å‘¼ã³ã¾ã™ã€‚
2ç•ªç›®ã®ã‚¹ãƒ†ãƒƒãƒ—ï¼ˆèª­ã¿å‡ºã—ï¼‰ã¯ã€æœ€åˆã®ã‚¹ãƒ†ãƒƒãƒ—ï¼ˆåŸºåº•çŠ¶æ…‹ã¸ã®å°„å½±ï¼‰ã‚ˆã‚Šã‚‚å¤šãã®ã‚¨ãƒ©ãƒ¼ã‚’ç”Ÿã˜ã‚‹ã“ã¨ãŒåˆ†ã‹ã£ã¦ã„ã¾ã™ã€‚
ã“ã‚Œã¯ã€èª­ã¿å‡ºã—ãŒå¾®è¦–çš„ãªé‡å­çŠ¶æ…‹ã‚’æ¤œå‡ºã—ã€
ãã‚Œã‚’å·¨è¦–çš„ãªé ˜åŸŸã«å¢—å¹…ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã“ã¨ã‚’æ€ã„å‡ºã›ã°ç´å¾—ã§ãã¾ã™ã€‚èª­ã¿å‡ºã—å…±æŒ¯å™¨ãŒ
ï¼ˆãƒˆãƒ©ãƒ³ã‚ºãƒ¢ãƒ³ï¼‰é‡å­ãƒ“ãƒƒãƒˆã«çµåˆã•ã‚Œã¦ãŠã‚Šã€ãã‚Œã«ã‚ˆã£ã¦éå¸¸ã«å°ã•ãªå‘¨æ³¢æ•°ã‚·ãƒ•ãƒˆãŒç”Ÿã˜ã¾ã™ã€‚ãƒã‚¤ã‚¯ãƒ­æ³¢ãƒ‘ãƒ«ã‚¹ãŒ
å…±æŒ¯å™¨ã§åå°„ã•ã‚Œã€ãã®ç‰¹æ€§ã«ã‚ãšã‹ãªå¤‰åŒ–ãŒç”Ÿã˜ã¾ã™ã€‚åå°„ã•ã‚ŒãŸãƒ‘ãƒ«ã‚¹ã¯å¢—å¹…ã•ã‚Œã€åˆ†æã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ç¹Šç´°ãª
ãƒ—ãƒ­ã‚»ã‚¹ã§ã‚ã‚Šã€ã•ã¾ã–ã¾ãªã‚¨ãƒ©ãƒ¼ã®å½±éŸ¿ã‚’å—ã‘ã¾ã™ã€‚

é‡è¦ãªç‚¹ã¯ã€é‡å­æ¸¬å®šã¨èª­ã¿å‡ºã—ã®ä¸¡æ–¹ãŒã‚¨ãƒ©ãƒ¼ã®å½±éŸ¿ã‚’å—ã‘ã¾ã™ãŒã€
å¾Œè€…ãŒæ”¯é…çš„ãªã‚¨ãƒ©ãƒ¼ã€ã™ãªã‚ã¡èª­ã¿å‡ºã—ã‚¨ãƒ©ãƒ¼ã‚’ç”Ÿã˜ã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚ã“ã‚ŒãŒã“ã®ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã®ç„¦ç‚¹ã§ã™ã€‚
### ç†è«–çš„èƒŒæ™¯ {#theoretical-background}

ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã•ã‚ŒãŸãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ï¼ˆå¤å…¸ãƒ¡ãƒ¢ãƒªã«æ ¼ç´ã•ã‚ŒãŸã‚‚ã®ï¼‰ãŒã€
å°„å½±ã•ã‚ŒãŸé‡å­çŠ¶æ…‹ã‚’ç‰¹å¾´ä»˜ã‘ã‚‹ãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã¨ç•°ãªã‚‹å ´åˆã€èª­ã¿å‡ºã—ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸã¨è¨€ã„ã¾ã™ã€‚
ã“ã‚Œã‚‰ã®ã‚¨ãƒ©ãƒ¼ã¯ãƒ©ãƒ³ãƒ€ãƒ ã§ã‚ã‚Šã€ã‚µãƒ³ãƒ—ãƒ«ã”ã¨ã«ç„¡ç›¸é–¢ã§ã‚ã‚‹ã“ã¨ãŒè¦³æ¸¬ã•ã‚Œã¦ã„ã¾ã™ã€‚
èª­ã¿å‡ºã—ã‚¨ãƒ©ãƒ¼ã‚’_ãƒã‚¤ã‚ºã®ã‚ã‚‹å¤å…¸ãƒãƒ£ãƒãƒ«_ã¨ã—ã¦ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹ã“ã¨ãŒæœ‰ç”¨ã§ã‚ã‚‹ã“ã¨ãŒç¤ºã•ã‚Œã¦ã„ã¾ã™ã€‚
ã™ãªã‚ã¡ã€ã™ã¹ã¦ã®ãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã®çµ„
$i$ã¨$j$ã«å¯¾ã—ã¦ã€çœŸã®å€¤$j$ãŒ
$i$ã¨ã—ã¦èª¤ã£ã¦èª­ã¿å–ã‚‰ã‚Œã‚‹å›ºå®šã®ç¢ºç‡ãŒå­˜åœ¨ã—ã¾ã™ã€‚

ã‚ˆã‚Šæ­£ç¢ºã«ã¯ã€ã™ã¹ã¦ã®ãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã®çµ„$(i, j)$ã«å¯¾ã—ã¦ã€çœŸã®å€¤ãŒ$j$ã§ã‚ã‚‹ã¨ãã«
$i$ãŒèª­ã¿å–ã‚‰ã‚Œã‚‹ï¼ˆæ¡ä»¶ä»˜ãï¼‰ç¢ºç‡${M}_{i,j}$ãŒå­˜åœ¨ã—ã¾ã™ã€‚
ã™ãªã‚ã¡ã€
$$
    {M}_{i,j} =  \Pr(\text{readout value is } i | \text{true value is } j)
    \text{ for } i,j \in (0,...,2^n - 1), \tag{1}
$$
ã“ã“ã§$n$ã¯èª­ã¿å‡ºã—ãƒ¬ã‚¸ã‚¹ã‚¿ã®ãƒ“ãƒƒãƒˆæ•°ã§ã™ã€‚
å…·ä½“çš„ã«ã¯ã€$i$ã¯è¨ˆç®—åŸºåº•çŠ¶æ…‹ã‚’ãƒ©ãƒ™ãƒ«ä»˜ã‘ã™ã‚‹ãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã®
2é€²è¡¨ç¾ã«å¯¾å¿œã™ã‚‹10é€²æ•´æ•°ã§ã‚ã‚‹ã¨ä»®å®šã—ã¾ã™ã€‚
$2^n \times 2^n$è¡Œåˆ—${M}$ã‚’_å‰²ã‚Šå½“ã¦è¡Œåˆ—_ã¨å‘¼ã³ã¾ã™ã€‚
å›ºå®šã®çœŸã®å€¤$j$ã«å¯¾ã—ã¦ã€ã™ã¹ã¦ã®ãƒã‚¤ã‚ºã®ã‚ã‚‹çµæœ$i$ã«ã¤ã„ã¦ç¢ºç‡ã‚’åˆè¨ˆã™ã‚‹ã¨$1$ã«ãªã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã™ãªã‚ã¡ã€
$$
    \sum_{i=0}^{2^n - 1} {M}_{i,j} = 1 \text{ for all } j
$$
éè² ã®è¦ç´ ã‚’æŒã¡(1)ã‚’æº€ãŸã™è¡Œåˆ—ã‚’
_å·¦ç¢ºç‡çš„_ã¨å‘¼ã³ã¾ã™ã€‚
å·¦ç¢ºç‡çš„è¡Œåˆ—ã¯ã€å„åˆ—ã®åˆè¨ˆãŒ$1$ã«ãªã‚‹ãŸã‚ã€_åˆ—ç¢ºç‡çš„_ã¨ã‚‚å‘¼ã°ã‚Œã¾ã™ã€‚
å„è¦ç´ ${M}_{i,j}$ã®è¿‘ä¼¼å€¤ã¯ã€
å„åŸºåº•çŠ¶æ…‹$|j \rangle$ã‚’ç¹°ã‚Šè¿”ã—æº–å‚™ã—ã€ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã•ã‚ŒãŸãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã®
å‡ºç¾é »åº¦ã‚’è¨ˆç®—ã™ã‚‹ã“ã¨ã§å®Ÿé¨“çš„ã«æ±ºå®šã—ã¾ã™ã€‚

å®Ÿé¨“ãŒç¹°ã‚Šè¿”ã—ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã«ã‚ˆã‚‹å‡ºåŠ›ãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã®ç¢ºç‡åˆ†å¸ƒã®æ¨å®šã‚’å«ã‚€å ´åˆã€
${M}$ã‚’ä½¿ç”¨ã—ã¦åˆ†å¸ƒãƒ¬ãƒ™ãƒ«ã§èª­ã¿å‡ºã—ã‚¨ãƒ©ãƒ¼ã‚’è»½æ¸›ã§ãã¾ã™ã€‚
æœ€åˆã®ã‚¹ãƒ†ãƒƒãƒ—ã¯ã€é–¢å¿ƒã®ã‚ã‚‹å›ºå®šã®å›è·¯ã‚’ä½•åº¦ã‚‚ç¹°ã‚Šè¿”ã—å®Ÿè¡Œã—ã€
ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã•ã‚ŒãŸãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã®ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã‚’ä½œæˆã™ã‚‹ã“ã¨ã§ã™ã€‚
æ­£è¦åŒ–ã•ã‚ŒãŸãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã¯ã€
$2^n$å€‹ã®å¯èƒ½ãªãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã«å¯¾ã™ã‚‹æ¸¬å®šã•ã‚ŒãŸç¢ºç‡åˆ†å¸ƒã§ã‚ã‚Šã€${\tilde{p}} \in \mathbb{R}^{2^n}$ã¨è¡¨è¨˜ã—ã¾ã™ã€‚
ãƒ“ãƒƒãƒˆæ–‡å­—åˆ—$i$ãŒã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã•ã‚Œã‚‹ï¼ˆæ¨å®šï¼‰ç¢ºç‡${{\tilde{p}}}_i$ã¯ã€
ã™ã¹ã¦ã®çœŸã®ãƒ“ãƒƒãƒˆæ–‡å­—åˆ—$j$ã®åˆè¨ˆã«ç­‰ã—ãã€å„$j$ã¯
ãã‚ŒãŒ$i$ã¨èª¤èªã•ã‚Œã‚‹ç¢ºç‡ã§é‡ã¿ä»˜ã‘ã•ã‚Œã¦ã„ã¾ã™ã€‚
ã“ã®æ–‡ã‚’è¡Œåˆ—å½¢å¼ã§è¡¨ã™ã¨ã€
$$
    {\tilde{p}} = {M} {\vec{p}}, \tag{2},
$$
ã¨ãªã‚Šã¾ã™ã€‚ã“ã“ã§${\vec{p}}$ã¯çœŸã®åˆ†å¸ƒã§ã™ã€‚è¨€ã„æ›ãˆã‚‹ã¨ã€èª­ã¿å‡ºã—ã‚¨ãƒ©ãƒ¼ã¯
ãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã«å¯¾ã™ã‚‹ç†æƒ³çš„ãªåˆ†å¸ƒ${\vec{p}}$ã«å‰²ã‚Šå½“ã¦è¡Œåˆ—${M}$ã‚’æ›ã‘ã¦
è¦³æ¸¬ã•ã‚ŒãŸåˆ†å¸ƒ${\tilde{p}}$ã‚’ç”Ÿæˆã™ã‚‹åŠ¹æœã‚’æŒã¡ã¾ã™ã€‚
${\tilde{p}}$ã¨${M}$ã¯æ¸¬å®šã•ã‚Œã¦ã„ã¾ã™ãŒã€${\vec{p}}$ã«ç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚åŸç†çš„ã«ã¯ã€
æ–¹ç¨‹å¼(2)ã‚’${\vec{p}}$ã«ã¤ã„ã¦æ•°å€¤çš„ã«è§£ãã“ã¨ã§ã€
å›è·¯ã®ãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã®çœŸã®åˆ†å¸ƒã‚’å¾—ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

å…ˆã«é€²ã‚€å‰ã«ã€ã“ã®ç´ æœ´ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒã®ã„ãã¤ã‹ã®é‡è¦ãªç‰¹å¾´ã«ã¤ã„ã¦è¿°ã¹ã¦ãŠãä¾¡å€¤ãŒã‚ã‚Šã¾ã™ã€‚

- å®Ÿéš›ã«ã¯ã€æ–¹ç¨‹å¼(2)ã¯${M}$ã‚’é€†è¡Œåˆ—ã«ã™ã‚‹ã“ã¨ã§ã¯è§£ã‹ã‚Œã¾ã›ã‚“ã€‚ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ç·šå½¢ä»£æ•°
  ãƒ«ãƒ¼ãƒãƒ³ã¯ã€ã‚ˆã‚Šå®‰å®šã§ã€æ­£ç¢ºã§ã€åŠ¹ç‡çš„ãªæ‰‹æ³•ã‚’æ¡ç”¨ã—ã¦ã„ã¾ã™ã€‚
- ${M}$ã‚’æ¨å®šã™ã‚‹éš›ã€èª­ã¿å‡ºã—ã‚¨ãƒ©ãƒ¼ã®ã¿ãŒç™ºç”Ÿã—ãŸã¨ä»®å®šã—ã¾ã—ãŸã€‚ç‰¹ã«ã€
  çŠ¶æ…‹æº–å‚™ã‚¨ãƒ©ãƒ¼ã‚„é‡å­æ¸¬å®šã‚¨ãƒ©ãƒ¼ãŒãªã‹ã£ãŸã€
  ã‚ã‚‹ã„ã¯å°‘ãªãã¨ã‚‚åˆ¥ã®æ–¹æ³•ã§è»½æ¸›ã•ã‚Œã¦ã„ãŸã¨ä»®å®šã—ã¦ã„ã¾ã™ã€‚
  ã“ã®ä»®å®šãŒå¦¥å½“ã§ã‚ã‚‹é™ã‚Šã€${M}$ã¯å®Ÿéš›ã«
  èª­ã¿å‡ºã—ã‚¨ãƒ©ãƒ¼ã®ã¿ã‚’è¡¨ã—ã¾ã™ã€‚ã—ã‹ã—ã€æ¸¬å®šã•ã‚ŒãŸãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã®åˆ†å¸ƒã‚’è£œæ­£ã™ã‚‹ãŸã‚ã«${M}$ã‚’_ä½¿ç”¨ã™ã‚‹_å ´åˆã€
  ãã®ã‚ˆã†ãªä»®å®šã¯è¡Œã„ã¾ã›ã‚“ã€‚å®Ÿéš›ã€èˆˆå‘³æ·±ã„å›è·¯ã¯
  ãƒã‚¤ã‚ºã€ä¾‹ãˆã°ã‚²ãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼ã‚’å°å…¥ã™ã‚‹ã“ã¨ãŒäºˆæƒ³ã•ã‚Œã¾ã™ã€‚ã€ŒçœŸã®ã€åˆ†å¸ƒã¯ã€
  ä»–ã®æ–¹æ³•ã§è»½æ¸›ã•ã‚Œã¦ã„ãªã„ã™ã¹ã¦ã®ã‚¨ãƒ©ãƒ¼ã®å½±éŸ¿ã‚’å«ã‚“ã§ã„ã¾ã™ã€‚

ã“ã®æ‰‹æ³•ã¯ã€ã„ãã¤ã‹ã®çŠ¶æ³ã§ã¯æœ‰ç”¨ã§ã™ãŒã€ã„ãã¤ã‹ã®åˆ¶é™ãŒã‚ã‚Šã¾ã™ã€‚

${M}$ã‚’æ¨å®šã™ã‚‹ãŸã‚ã«å¿…è¦ãªç©ºé–“ã¨æ™‚é–“ã®ãƒªã‚½ãƒ¼ã‚¹ã¯$n$ã«å¯¾ã—ã¦æŒ‡æ•°çš„ã«å¢—å¤§ã—ã¾ã™ï¼š
- ${M}$ã¨${\tilde{p}}$ã®æ¨å®šã¯ã€æœ‰é™ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã«ã‚ˆã‚‹çµ±è¨ˆçš„èª¤å·®ã®å½±éŸ¿ã‚’å—ã‘ã¾ã™ã€‚
  ã“ã®ãƒã‚¤ã‚ºã¯ã€ã‚ˆã‚Šå¤šãã®ã‚·ãƒ§ãƒƒãƒˆã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§æ‰€æœ›ã®å¤§ãã•ã¾ã§å°ã•ãã™ã‚‹ã“ã¨ãŒã§ãã¾ã™
  ï¼ˆ${M}$ã«ç³»çµ±çš„èª¤å·®ã‚’ã‚‚ãŸã‚‰ã™ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ãƒ‰ãƒªãƒ•ãƒˆã®æ™‚é–“ã‚¹ã‚±ãƒ¼ãƒ«ã¾ã§ï¼‰ã€‚
  ã—ã‹ã—ã€è»½æ¸›ã‚’è¡Œã†éš›ã«è¦³æ¸¬ã•ã‚Œã‚‹ãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã«ã¤ã„ã¦ä»®å®šã‚’ç½®ã‹ãªã„å ´åˆã€
  ${M}$ã‚’æ¨å®šã™ã‚‹ãŸã‚ã«å¿…è¦ãªã‚·ãƒ§ãƒƒãƒˆæ•°ã¯
  $n$ã«å¯¾ã—ã¦å°‘ãªãã¨ã‚‚æŒ‡æ•°çš„ã«å¢—å¤§ã—ã¾ã™ã€‚
- ${M}$ã¯$2^n \times 2^n$è¡Œåˆ—ã§ã™ã€‚
  $n>10$ã®å ´åˆã€${M}$ã‚’æ ¼ç´ã™ã‚‹ãŸã‚ã«å¿…è¦ãªãƒ¡ãƒ¢ãƒªé‡ã¯ã€
  é«˜æ€§èƒ½ãªãƒ©ãƒƒãƒ—ãƒˆãƒƒãƒ—ã§åˆ©ç”¨å¯èƒ½ãªãƒ¡ãƒ¢ãƒªã‚’è¶…ãˆã¾ã™ã€‚

ã•ã‚‰ãªã‚‹åˆ¶é™ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ï¼š

- å›å¾©ã•ã‚ŒãŸåˆ†å¸ƒ${\vec{p}}$ã¯ã€1ã¤ä»¥ä¸Šã®
  è² ã®ç¢ºç‡ã‚’æŒã¤å ´åˆãŒã‚ã‚Šã¾ã™ï¼ˆåˆè¨ˆã¯1ã®ã¾ã¾ï¼‰ã€‚1ã¤ã®è§£æ±ºç­–ã¯ã€
  ${\vec{p}}$ã®å„è¦ç´ ãŒéè² ã§ã‚ã‚‹ã¨ã„ã†åˆ¶ç´„ã®ä¸‹ã§$||{M} {\vec{p}} - {\tilde{p}}||^2$ã‚’æœ€å°åŒ–ã™ã‚‹ã“ã¨ã§ã™ã€‚ã—ã‹ã—ã€ã“ã®ã‚ˆã†ãª
  æ‰‹æ³•ã®å®Ÿè¡Œæ™‚é–“ã¯ã€æ–¹ç¨‹å¼(2)ã‚’ç›´æ¥è§£ãã‚ˆã‚Šã‚‚æ¡é•ã„ã«é•·ããªã‚Šã¾ã™ã€‚
- ã“ã®è»½æ¸›æ‰‹é †ã¯ã€ãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã«å¯¾ã™ã‚‹ç¢ºç‡åˆ†å¸ƒã®ãƒ¬ãƒ™ãƒ«ã§æ©Ÿèƒ½ã—ã¾ã™ã€‚
  ç‰¹ã«ã€å€‹ã€…ã®è¦³æ¸¬ã•ã‚ŒãŸãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã®ã‚¨ãƒ©ãƒ¼ã‚’è£œæ­£ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚
### Qiskit M3ã‚¢ãƒ‰ã‚ªãƒ³ï¼šã‚ˆã‚Šé•·ã„ãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã¸ã®ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚° {#qiskit-m3-addon-scaling-to-longer-bitstrings}

æ¨™æº–çš„ãªæ•°å€¤ç·šå½¢ä»£æ•°ãƒ«ãƒ¼ãƒãƒ³ã‚’ä½¿ç”¨ã—ã¦æ–¹ç¨‹å¼(2)ã‚’è§£ãæ–¹æ³•ã¯ã€ç´„10ãƒ“ãƒƒãƒˆä»¥ä¸‹ã®ãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã«é™å®šã•ã‚Œã¾ã™ã€‚ã—ã‹ã—ã€M3ã¯ã¯ã‚‹ã‹ã«é•·ã„ãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã‚’å‡¦ç†ã§ãã¾ã™ã€‚ã“ã‚Œã‚’å¯èƒ½ã«ã™ã‚‹M3ã®2ã¤ã®é‡è¦ãªç‰¹æ€§ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ï¼š
- ãƒ“ãƒƒãƒˆã®é›†åˆé–“ã«ãŠã‘ã‚‹3æ¬¡ä»¥ä¸Šã®èª­ã¿å‡ºã—ã‚¨ãƒ©ãƒ¼ã®ç›¸é–¢ã¯
  ç„¡è¦–ã§ãã‚‹ã‚‚ã®ã¨ä»®å®šã•ã‚Œã€ç„¡è¦–ã•ã‚Œã¾ã™ã€‚åŸç†çš„ã«ã¯ã€ã‚ˆã‚Šå¤šãã®ã‚·ãƒ§ãƒƒãƒˆã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã€
  ã‚ˆã‚Šé«˜æ¬¡ã®ç›¸é–¢ã‚‚æ¨å®šã§ãã¾ã™ã€‚
- ${M}$ã‚’æ˜ç¤ºçš„ã«æ§‹ç¯‰ã™ã‚‹ä»£ã‚ã‚Šã«ã€${\tilde{p}}$ã‚’æ§‹ç¯‰ã™ã‚‹éš›ã«åé›†ã•ã‚ŒãŸãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã®ã¿ã®
  ç¢ºç‡ã‚’è¨˜éŒ²ã™ã‚‹ã€ã¯ã‚‹ã‹ã«å°ã•ãªæœ‰åŠ¹è¡Œåˆ—ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

å¤§ã¾ã‹ã«è¨€ãˆã°ã€æ‰‹é †ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«æ©Ÿèƒ½ã—ã¾ã™ã€‚

ã¾ãšã€${M}$ã®ç°¡ç•¥åŒ–ã•ã‚ŒãŸæœ‰åŠ¹ãªè¨˜è¿°ã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã®æ§‹æˆè¦ç´ ã‚’ä½œæˆã—ã¾ã™ã€‚
æ¬¡ã«ã€é–¢å¿ƒã®ã‚ã‚‹å›è·¯ã‚’ç¹°ã‚Šè¿”ã—å®Ÿè¡Œã—ã¦ãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã‚’åé›†ã—ã€
ãã‚Œã‚’ä½¿ç”¨ã—ã¦${\tilde{p}}$ã¨ã€æ§‹æˆè¦ç´ ã®åŠ©ã‘ã‚’å€Ÿã‚Šã¦æœ‰åŠ¹ãª${M}$ã®ä¸¡æ–¹ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚

ã‚ˆã‚Šæ­£ç¢ºã«ã¯ã€
- å„é‡å­ãƒ“ãƒƒãƒˆã«ã¤ã„ã¦å˜ä¸€é‡å­ãƒ“ãƒƒãƒˆã®å‰²ã‚Šå½“ã¦è¡Œåˆ—ãŒæ¨å®šã•ã‚Œã¾ã™ã€‚ã“ã‚Œã‚’è¡Œã†ãŸã‚ã«ã€é‡å­ãƒ“ãƒƒãƒˆãƒ¬ã‚¸ã‚¹ã‚¿ã‚’
  å…¨ã‚¼ãƒ­çŠ¶æ…‹$|0 ... 0 \rangle$ã«ç¹°ã‚Šè¿”ã—æº–å‚™ã—ã€æ¬¡ã«å…¨1çŠ¶æ…‹
  $|1 ... 1 \rangle$ã«æº–å‚™ã—ã¦ã€å„é‡å­ãƒ“ãƒƒãƒˆãŒèª¤ã£ã¦èª­ã¿å–ã‚‰ã‚Œã‚‹ç¢ºç‡ã‚’è¨˜éŒ²ã—ã¾ã™ã€‚
- 3æ¬¡ä»¥ä¸Šã®ç›¸é–¢ã¯ç„¡è¦–ã§ãã‚‹ã‚‚ã®ã¨ä»®å®šã•ã‚Œã€ç„¡è¦–ã•ã‚Œã¾ã™ã€‚

  ä»£ã‚ã‚Šã«ã€$n$å€‹ã®$2 \times 2$å˜ä¸€é‡å­ãƒ“ãƒƒãƒˆå‰²ã‚Šå½“ã¦è¡Œåˆ—ã¨ã€
  $n(n-1)/2$å€‹ã®$4 \times 4$äºŒé‡å­ãƒ“ãƒƒãƒˆå‰²ã‚Šå½“ã¦è¡Œåˆ—ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚
  ã“ã‚Œã‚‰ã®1é‡å­ãƒ“ãƒƒãƒˆãŠã‚ˆã³2é‡å­ãƒ“ãƒƒãƒˆã®å‰²ã‚Šå½“ã¦è¡Œåˆ—ã¯ã€å¾Œã§ä½¿ç”¨ã™ã‚‹ãŸã‚ã«ä¿å­˜ã•ã‚Œã¾ã™ã€‚
- ${\tilde{p}}$ã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã«å›è·¯ã‚’ç¹°ã‚Šè¿”ã—ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã—ãŸå¾Œã€
  ${\tilde{p}}$ã‚’æ§‹ç¯‰ã™ã‚‹éš›ã«ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã•ã‚ŒãŸãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã®ã¿ã‚’ä½¿ç”¨ã—ã¦ã€
  ${M}$ã®æœ‰åŠ¹ãªè¿‘ä¼¼ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚ã“ã®æœ‰åŠ¹è¡Œåˆ—ã¯ã€
  å‰ã®é …ç›®ã§èª¬æ˜ã—ãŸå˜ä¸€é‡å­ãƒ“ãƒƒãƒˆãŠã‚ˆã³äºŒé‡å­ãƒ“ãƒƒãƒˆè¡Œåˆ—ã‚’ä½¿ç”¨ã—ã¦æ§‹ç¯‰ã•ã‚Œã¾ã™ã€‚
  ã“ã®è¡Œåˆ—ã®ç·šå½¢æ¬¡å…ƒã¯ã€${\tilde{p}}$ã®æ§‹ç¯‰ã«ä½¿ç”¨ã•ã‚Œã‚‹ã‚·ãƒ§ãƒƒãƒˆæ•°ã®
  ã‚ªãƒ¼ãƒ€ãƒ¼ä»¥ä¸‹ã§ã‚ã‚Šã€ã“ã‚Œã¯å®Œå…¨ãªå‰²ã‚Šå½“ã¦è¡Œåˆ—${M}$ã®
  æ¬¡å…ƒ$2^n$ã‚ˆã‚Šã‚‚ã¯ã‚‹ã‹ã«å°ã•ã„ã§ã™ã€‚

M3ã®æŠ€è¡“çš„ãªè©³ç´°ã«ã¤ã„ã¦ã¯ã€[*Scalable Mitigation of Measurement Errors on Quantum Computers*](https://journals.aps.org/prxquantum/abstract/10.1103/PRXQuantum.2.040326)ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚
### é‡å­ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¸ã®M3ã®é©ç”¨ {#application-of-m3-to-a-quantum-algorithm}
M3ã®èª­ã¿å‡ºã—è»½æ¸›ã‚’éš ã‚Œã‚·ãƒ•ãƒˆå•é¡Œã«é©ç”¨ã—ã¾ã™ã€‚éš ã‚Œã‚·ãƒ•ãƒˆå•é¡Œã€ãŠã‚ˆã³[éš ã‚Œéƒ¨åˆ†ç¾¤å•é¡Œ](https://en.wikipedia.org/wiki/Hidden_subgroup_problem)ãªã©ã®å¯†æ¥ã«é–¢é€£ã™ã‚‹å•é¡Œã¯ã€ã‚‚ã¨ã‚‚ã¨ãƒ•ã‚©ãƒ¼ãƒ«ãƒˆãƒˆãƒ¬ãƒ©ãƒ³ãƒˆãªè¨­å®šã§è€ƒæ¡ˆã•ã‚Œã¾ã—ãŸï¼ˆã‚ˆã‚Šæ­£ç¢ºã«ã¯ã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒˆãƒˆãƒ¬ãƒ©ãƒ³ãƒˆãªQPUãŒå¯èƒ½ã§ã‚ã‚‹ã“ã¨ãŒè¨¼æ˜ã•ã‚Œã‚‹å‰ã«è€ƒæ¡ˆã•ã‚Œã¾ã—ãŸï¼ï¼‰ã€‚ã—ã‹ã—ã€åˆ©ç”¨å¯èƒ½ãªãƒ—ãƒ­ã‚»ãƒƒã‚µã§ã‚‚ç ”ç©¶ã•ã‚Œã¦ã„ã¾ã™ã€‚127é‡å­ãƒ“ãƒƒãƒˆã®IBM&reg; QPUã§éš ã‚Œã‚·ãƒ•ãƒˆå•é¡Œã®å¤‰ç¨®ã«å¯¾ã—ã¦å¾—ã‚‰ã‚ŒãŸã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ çš„ãªæŒ‡æ•°çš„é«˜é€ŸåŒ–ã®ä¾‹ã¯ã€[ã“ã®è«–æ–‡](https://journals.aps.org/prx/accepted/a9074K06A8e1590147da9c69f8c4b64c28247be5a)ï¼ˆ[arXivç‰ˆ](https://arxiv.org/abs/2401.07934)ï¼‰ã§è¦‹ã¤ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

ä»¥ä¸‹ã§ã¯ã€ã™ã¹ã¦ã®ç®—è¡“ã¯ãƒ–ãƒ¼ãƒ«æ¼”ç®—ã§ã™ã€‚
ã™ãªã‚ã¡ã€$a, b \in \mathbb{Z}_2 = \{0, 1\}$ã«å¯¾ã—ã¦ã€åŠ ç®—$a + b$ã¯è«–ç†XORé–¢æ•°ã§ã™ã€‚
ã•ã‚‰ã«ã€ä¹—ç®—$a \times b$ï¼ˆã¾ãŸã¯$a b$ï¼‰ã¯è«–ç†ANDé–¢æ•°ã§ã™ã€‚$x, y \in \{0, 1\}^n$ã«å¯¾ã—ã¦ã€
$x + y$ã¯XORã®ãƒ“ãƒƒãƒˆã”ã¨ã®é©ç”¨ã«ã‚ˆã£ã¦å®šç¾©ã•ã‚Œã¾ã™ã€‚
å†…ç©$\cdot: {\mathbb{Z}_2^n} \rightarrow \mathbb{Z}_2$ã¯
$x \cdot y = \sum_i x_i y_i$ã§å®šç¾©ã•ã‚Œã¾ã™ã€‚
#### ã‚¢ãƒ€ãƒãƒ¼ãƒ«æ¼”ç®—å­ã¨ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ› {#hadamard-operator-and-fourier-transform}

é‡å­ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®å®Ÿè£…ã«ãŠã„ã¦ã€ã‚¢ãƒ€ãƒãƒ¼ãƒ«æ¼”ç®—å­ã‚’ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã¨ã—ã¦ä½¿ç”¨ã™ã‚‹ã“ã¨ã¯éå¸¸ã«ä¸€èˆ¬çš„ã§ã™ã€‚
è¨ˆç®—åŸºåº•çŠ¶æ…‹ã¯_å¤å…¸çŠ¶æ…‹_ã¨å‘¼ã°ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã¯å¤å…¸çš„ãªãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã¨
1å¯¾1ã®å¯¾å¿œé–¢ä¿‚ã«ã‚ã‚Šã¾ã™ã€‚
$n$é‡å­ãƒ“ãƒƒãƒˆã®ã‚¢ãƒ€ãƒãƒ¼ãƒ«æ¼”ç®—å­ã‚’å¤å…¸çŠ¶æ…‹ã«é©ç”¨ã—ãŸã‚‚ã®ã¯ã€ãƒ–ãƒ¼ãƒ«è¶…ç«‹æ–¹ä½“ä¸Šã®ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã¨è¦‹ãªã™ã“ã¨ãŒã§ãã¾ã™ï¼š
$$
H^{\otimes n} =  \frac{1}{\sqrt{2^n}} \sum_{x,y \in {\mathbb{Z}_2^n}} (-1)^{x \cdot y} {|{y}\rangle}{\langle{x}|}.
$$
å›ºå®šã®ãƒ“ãƒƒãƒˆæ–‡å­—åˆ—$s$ã«å¯¾å¿œã™ã‚‹çŠ¶æ…‹${|{s}\rangle}$ã‚’è€ƒãˆã¾ã™ã€‚
$H^{\otimes n}$ã‚’é©ç”¨ã—ã€${\langle {x}|{s}\rangle} = \delta_{x,s}$ã‚’ç”¨ã„ã‚‹ã¨ã€
${|{s}\rangle}$ã®ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ã‘ã¾ã™ï¼š
$$
   H^{\otimes n} {|{s}\rangle} =  \frac{1}{\sqrt{2^n}} \sum_{y \in {\mathbb{Z}_2^n}} (-1)^{s \cdot y} {|{y}\rangle}.
$$

ã‚¢ãƒ€ãƒãƒ¼ãƒ«æ¼”ç®—å­ã¯ãã‚Œè‡ªèº«ã®é€†æ¼”ç®—å­ã§ã™ã€‚ã™ãªã‚ã¡ã€
 $H^{\otimes n} H^{\otimes n} = (H H)^{\otimes n} = I^{\otimes n}$ã§ã™ã€‚
ã—ãŸãŒã£ã¦ã€é€†ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã¯åŒã˜æ¼”ç®—å­$H^{\otimes n}$ã§ã™ã€‚
æ˜ç¤ºçš„ã«æ›¸ãã¨ã€
$$
  {|{s}\rangle} =  H^{\otimes n} H^{\otimes n} {|{s}\rangle}  =  H^{\otimes n} \frac{1}{\sqrt{2^n}} \sum_{y \in {\mathbb{Z}_2^n}} (-1)^{s \cdot y} {|{y}\rangle}.
$$
#### éš ã‚Œã‚·ãƒ•ãƒˆå•é¡Œ {#the-hidden-shift-problem}

_éš ã‚Œã‚·ãƒ•ãƒˆå•é¡Œ_ã®ç°¡å˜ãªä¾‹ã‚’è€ƒãˆã¾ã™ã€‚
ã“ã®å•é¡Œã¯ã€é–¢æ•°ã¸ã®å…¥åŠ›ã«ãŠã‘ã‚‹å®šæ•°ã‚·ãƒ•ãƒˆã‚’ç‰¹å®šã™ã‚‹ã“ã¨ã§ã™ã€‚
ã“ã“ã§è€ƒãˆã‚‹é–¢æ•°ã¯å†…ç©ã§ã™ã€‚ã“ã‚Œã¯ã€ä»¥ä¸‹ã«ç¤ºã™æ‰‹æ³•ã¨åŒæ§˜ã®æ‰‹æ³•ã§
éš ã‚Œã‚·ãƒ•ãƒˆå•é¡Œã«å¯¾ã—ã¦é‡å­é«˜é€ŸåŒ–ã‚’å¯èƒ½ã«ã™ã‚‹é–¢æ•°ã®å¤§ããªã‚¯ãƒ©ã‚¹ã®
æœ€ã‚‚å˜ç´”ãªãƒ¡ãƒ³ãƒãƒ¼ã§ã™ã€‚

$x,y \in {\mathbb{Z}_2^m}$ã‚’é•·ã•$m$ã®ãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã¨ã—ã¾ã™ã€‚
${f}: {\mathbb{Z}_2^m} \times {\mathbb{Z}_2^m} \rightarrow \{-1,1\}$ã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã—ã¾ã™ï¼š
$$
  {f}(x, y) = (-1)^{x \cdot y}.
$$
  $a,b \in {\mathbb{Z}_2^m}$ã‚’é•·ã•$m$ã®å›ºå®šã®ãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã¨ã—ã¾ã™ã€‚
  ã•ã‚‰ã«ã€$g: {\mathbb{Z}_2^m} \times {\mathbb{Z}_2^m} \rightarrow \{-1,1\}$ã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã—ã¾ã™ï¼š
$$
  g(x, y) = {f}(x+a, y+b) = (-1)^{(x+a) \cdot (y+b)},
  $$
  ã“ã“ã§$a$ã¨$b$ã¯ï¼ˆéš ã•ã‚ŒãŸï¼‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§ã™ã€‚
  2ã¤ã®ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ãŒä¸ãˆã‚‰ã‚Œã¾ã™ã€‚1ã¤ã¯$f$ã‚’å®Ÿè£…ã—ã€ã‚‚ã†1ã¤ã¯$g$ã‚’å®Ÿè£…ã—ã¾ã™ã€‚
  ã“ã‚Œã‚‰ãŒä¸Šè¨˜ã§å®šç¾©ã•ã‚ŒãŸé–¢æ•°ã‚’è¨ˆç®—ã™ã‚‹ã“ã¨ã¯åˆ†ã‹ã£ã¦ã„ã¾ã™ãŒã€
  $a$ã‚‚$b$ã‚‚çŸ¥ã‚‰ãªã„ã¨ä»®å®šã—ã¾ã™ã€‚ã“ã®ã‚²ãƒ¼ãƒ ã®ç›®çš„ã¯ã€$f$ã¨$g$ã¸ã®ã‚¯ã‚¨ãƒªã«ã‚ˆã£ã¦
  éš ã•ã‚ŒãŸãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ï¼ˆã‚·ãƒ•ãƒˆï¼‰$a$ã¨$b$ã‚’æ±ºå®šã™ã‚‹ã“ã¨ã§ã™ã€‚å¤å…¸çš„ã«ã“ã®ã‚²ãƒ¼ãƒ ã‚’ãƒ—ãƒ¬ã‚¤ã™ã‚‹å ´åˆã€
  $a$ã¨$b$ã‚’æ±ºå®šã™ã‚‹ã«ã¯$O(2m)$å›ã®ã‚¯ã‚¨ãƒªãŒå¿…è¦ã§ã‚ã‚‹ã“ã¨ã¯æ˜ã‚‰ã‹ã§ã™ã€‚ä¾‹ãˆã°ã€çµ„ã®ä¸€æ–¹ã®è¦ç´ ãŒå…¨ã‚¼ãƒ­ã§ã€ã‚‚ã†ä¸€æ–¹ã®è¦ç´ ãŒã¡ã‚‡ã†ã©1ã¤ã®è¦ç´ ãŒ$1$ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®æ–‡å­—åˆ—ã®çµ„ã§$g$ã«ã‚¯ã‚¨ãƒªã‚’è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚
  å„ã‚¯ã‚¨ãƒªã§ã€$a$ã¾ãŸã¯$b$ã®1ã¤ã®è¦ç´ ãŒåˆ†ã‹ã‚Šã¾ã™ã€‚
  ã—ã‹ã—ã€ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ãŒé‡å­å›è·¯ã¨ã—ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹å ´åˆã€
  $f$ã¨$g$ãã‚Œãã‚Œã«å¯¾ã—ã¦1å›ã®ã‚¯ã‚¨ãƒªã§$a$ã¨$b$ã‚’æ±ºå®šã§ãã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚

  ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®è¨ˆç®—é‡ã®æ–‡è„ˆã§ã¯ã€ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã¯_ã‚ªãƒ©ã‚¯ãƒ«_ã¨å‘¼ã°ã‚Œã¾ã™ã€‚
  ä¸é€æ˜ã§ã‚ã‚‹ã“ã¨ã«åŠ ãˆã¦ã€ã‚ªãƒ©ã‚¯ãƒ«ã¯å…¥åŠ›ã‚’æ¶ˆè²»ã—ã€
  å‡ºåŠ›ã‚’ç¬æ™‚ã«ç”Ÿæˆã™ã‚‹ã¨ã„ã†æ€§è³ªã‚’æŒã¡ã€ãã‚ŒãŒçµ„ã¿è¾¼ã¾ã‚ŒãŸã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®
  è¨ˆç®—é‡ãƒã‚¸ã‚§ãƒƒãƒˆã«ä½•ã‚‚åŠ ãˆã¾ã›ã‚“ã€‚å®Ÿéš›ã€ã“ã“ã§æ‰±ã†å ´åˆã§ã¯ã€$f$ã¨
  $g$ã‚’å®Ÿè£…ã™ã‚‹ã‚ªãƒ©ã‚¯ãƒ«ã¯åŠ¹ç‡çš„ã§ã‚ã‚‹ã“ã¨ãŒåˆ†ã‹ã‚Šã¾ã™ã€‚
#### $f$ã¨$g$ã®é‡å­å›è·¯ {#quantum-circuits-for-f-and-g}

$f$ã¨$g$ã‚’é‡å­å›è·¯ã¨ã—ã¦å®Ÿè£…ã™ã‚‹ãŸã‚ã«ã€ä»¥ä¸‹ã®è¦ç´ ãŒå¿…è¦ã§ã™ã€‚

å˜ä¸€é‡å­ãƒ“ãƒƒãƒˆã®å¤å…¸çŠ¶æ…‹${|{x_1}\rangle}, {|{y_1}\rangle}$ï¼ˆ$x_1,y_1 \in \mathbb{Z}_2$ï¼‰ã«å¯¾ã—ã¦ã€
åˆ¶å¾¡$Z$ã‚²ãƒ¼ãƒˆ${CZ}$ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ã‘ã¾ã™ï¼š
$$
{CZ} {|{x_1}\rangle}{|{y_1}\rangle}{x_1} = (-1)^{x_1 y_1} {|{x_1}\rangle}{x_1}{|{y_1}\rangle}.
$$
$m$å€‹ã®CZã‚²ãƒ¼ãƒˆã‚’ä½¿ç”¨ã—ã¾ã™ã€‚1ã¤ã¯$(x_1, y_1)$ã«ã€1ã¤ã¯$(x_2, y_2)$ã«ã€ãã—ã¦$(x_m, y_m)$ã¾ã§åŒæ§˜ã«é©ç”¨ã—ã¾ã™ã€‚
ã“ã®æ¼”ç®—å­ã‚’${CZ}_{x,y}$ã¨å‘¼ã³ã¾ã™ã€‚

$U_f = {CZ}_{x,y}$ã¯${f} = {f}(x,y)$ã®é‡å­ç‰ˆã§ã™ï¼š
$$
%\CZ_{x,y} {|#1\rangle}{z} =
U_f {|{x}\rangle}{|{y}\rangle} = {CZ}_{x,y} {|{x}\rangle}{|{y}\rangle} = (-1)^{x \cdot y}  {|{x}\rangle}{|{y}\rangle}.
$$

ã¾ãŸã€ãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã®ã‚·ãƒ•ãƒˆã‚‚å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
$x$ãƒ¬ã‚¸ã‚¹ã‚¿ä¸Šã®æ¼”ç®—å­$X^{a_1}\cdots X^{a_m}$ã‚’$X_a$ã¨è¡¨è¨˜ã—ã€
åŒæ§˜ã«$y$ãƒ¬ã‚¸ã‚¹ã‚¿ä¸Šã®$X_b =  X^{b_1}\cdots X^{b_m}$ã¨ã—ã¾ã™ã€‚
ã“ã‚Œã‚‰ã®æ¼”ç®—å­ã¯ã€å˜ä¸€ãƒ“ãƒƒãƒˆãŒ$1$ã®ç®‡æ‰€ã«$X$ã‚’é©ç”¨ã—ã€$0$ã®ç®‡æ‰€ã«ã¯æ’ç­‰æ¼”ç®—å­$I$ã‚’é©ç”¨ã—ã¾ã™ã€‚
ã™ã‚‹ã¨ã€
$$
 X_a X_b  {|{x}\rangle}{|{y}\rangle} = {|{x+a}\rangle}{|{y+b}\rangle}.
$$

2ç•ªç›®ã®ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹$g$ã¯ã€ä»¥ä¸‹ã®ãƒ¦ãƒ‹ã‚¿ãƒª$U_g$ã«ã‚ˆã£ã¦å®Ÿè£…ã•ã‚Œã¾ã™ï¼š
$$
%U_g {|{x}\rangle}{|{y}\rangle} = X_aX_b \CZ_{x,y} X_aX_b {|{x}\rangle}{|{y}\rangle}.
U_g = X_aX_b {CZ}_{x,y} X_aX_b.
$$
ã“ã‚Œã‚’ç¢ºèªã™ã‚‹ãŸã‚ã«ã€æ¼”ç®—å­ã‚’å³ã‹ã‚‰å·¦ã«çŠ¶æ…‹${|{x}\rangle}{|{y}\rangle}$ã«é©ç”¨ã—ã¾ã™ã€‚
ã¾ãšã€

$$
 X_a X_b  {|{x}\rangle}{|{y}\rangle} = {|{x+a}\rangle}{|{y+b}\rangle}.
$$

æ¬¡ã«ã€
$$
  {CZ}_{x,y}  {|{x+a}\rangle}{|{y+b}\rangle} = (-1)^{(x+a)\cdot (y+b)} {|{x+a}\rangle}{|{y+b}\rangle}.
$$

æœ€å¾Œã«ã€

$$
  X^a X^b (-1)^{(x+a)\cdot (y+b)} {|{x+a}\rangle}{|{y+b}\rangle} = (-1)^{(x+a)\cdot (y+b)} {|{x}\rangle}{|{y}\rangle},
$$

ã“ã‚Œã¯ç¢ºã‹ã«$f(x+a, y+b)$ã®é‡å­ç‰ˆã§ã™ã€‚
#### éš ã‚Œã‚·ãƒ•ãƒˆã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ  {#the-hidden-shift-algorithm}

ã“ã“ã§ã€éš ã‚Œã‚·ãƒ•ãƒˆå•é¡Œã‚’è§£ããŸã‚ã«ã™ã¹ã¦ã®è¦ç´ ã‚’çµ„ã¿åˆã‚ã›ã¾ã™ã€‚
ã¾ãšã€å…¨ã‚¼ãƒ­çŠ¶æ…‹ã«åˆæœŸåŒ–ã•ã‚ŒãŸãƒ¬ã‚¸ã‚¹ã‚¿ã«ã‚¢ãƒ€ãƒãƒ¼ãƒ«ã‚’é©ç”¨ã—ã¾ã™ã€‚
$$
H^{\otimes 2m} = H^{\otimes m} \otimes H^{\otimes m} {{|{0}\rangle}^{\otimes m}}{{|{0}\rangle}^{\otimes m}} = \frac{1}{\sqrt{2^{2m}}} \sum_{x, y \in {\mathbb{Z}_2^m}} (-1)^{x \cdot y} {|{x}\rangle}{|{y}\rangle}.
$$

æ¬¡ã«ã€ã‚ªãƒ©ã‚¯ãƒ«$g$ã«ã‚¯ã‚¨ãƒªã—ã¦ä»¥ä¸‹ã«åˆ°é”ã—ã¾ã™ï¼š
$$
U_g H^{\otimes 2m} {{|{0}\rangle}^{\otimes m}}{{|{0}\rangle}^{\otimes m}}
= \frac{1}{\sqrt{2^{2m}}} \sum_{x, y \in {\mathbb{Z}_2^m}} (-1)^{(x+a) \cdot (y+b)} {|{x}\rangle}{|{y}\rangle}
$$
$$
\approx \frac{1}{\sqrt{2^{2m}}} \sum_{x, y \in {\mathbb{Z}_2^m}} (-1)^{x \cdot y + x \cdot b + y \cdot a} {|{x}\rangle}{|{y}\rangle}.
$$
æœ€å¾Œã®è¡Œã§ã¯ã€å®šæ•°ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«ä½ç›¸å› å­$(-1)^{a \cdot b}$ã‚’çœç•¥ã—ã€
ä½ç›¸ã‚’é™¤ã„ãŸç­‰å·ã‚’$\approx$ã§è¡¨ã—ã¦ã„ã¾ã™ã€‚
æ¬¡ã«ã€ã‚ªãƒ©ã‚¯ãƒ«$f$ã‚’é©ç”¨ã™ã‚‹ã¨åˆ¥ã®$(-1)^{x \cdot y}$ã®å› å­ãŒå°å…¥ã•ã‚Œã€æ—¢ã«å­˜åœ¨ã™ã‚‹ã‚‚ã®ã¨æ‰“ã¡æ¶ˆã—åˆã„ã¾ã™ã€‚ã™ã‚‹ã¨ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ï¼š
$$
U_f U_g H^{\otimes 2m} {{|{0}\rangle}^{\otimes m}}{{|{0}\rangle}^{\otimes m}}
\approx \frac{1}{\sqrt{2^{2m}}} \sum_{x, y \in {\mathbb{Z}_2^m}} (-1)^{x \cdot b + y \cdot a} {|{x}\rangle}{|{y}\rangle}.
$$
æœ€å¾Œã®ã‚¹ãƒ†ãƒƒãƒ—ã¯ã€é€†ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›$H^{\otimes 2m} = H^{\otimes m} \otimes H^{\otimes m}$ã‚’é©ç”¨ã™ã‚‹ã“ã¨ã§ã‚ã‚Šã€
çµæœã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ï¼š
$$
H^{\otimes 2m} U_f U_g  H^{\otimes 2m} {{|{0}\rangle}^{\otimes m}}{{|{0}\rangle}^{\otimes m}}
\approx {|{b}\rangle}{|{a}\rangle}.
$$
å›è·¯ã¯ã“ã‚Œã§å®Œæˆã§ã™ã€‚ãƒã‚¤ã‚ºãŒãªã„å ´åˆã€é‡å­ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã™ã‚‹ã¨ã€
ç¢ºç‡$1$ã§ãƒ“ãƒƒãƒˆæ–‡å­—åˆ—$b, a$ãŒè¿”ã•ã‚Œã¾ã™ã€‚

ãƒ–ãƒ¼ãƒ«å†…ç©ã¯ã€ã„ã‚ã‚†ã‚‹ãƒ™ãƒ³ãƒˆé–¢æ•°ã®ä¸€ä¾‹ã§ã™ã€‚
ã“ã“ã§ã¯ãƒ™ãƒ³ãƒˆé–¢æ•°ã‚’å®šç¾©ã—ã¾ã›ã‚“ãŒã€
ãƒ™ãƒ³ãƒˆé–¢æ•°ã¯ã€Œå…¥åŠ›ã®ä½•ã‚‰ã‹ã®ç·šå½¢éƒ¨åˆ†ç©ºé–“ã¸ã®å‡ºåŠ›ã®ä¾å­˜æ€§ã‚’åˆ©ç”¨ã—ã‚ˆã†ã¨ã™ã‚‹æ”»æ’ƒã«å¯¾ã—ã¦
æœ€å¤§é™ã«è€æ€§ãŒã‚ã‚‹ã€ã“ã¨ã‚’è¨˜ã—ã¦ãŠãã¾ã™ã€‚
ã“ã®å¼•ç”¨ã¯è«–æ–‡[_Quantum algorithms for highly non-linear Boolean functions_](https://arxiv.org/abs/0811.3208)ã‹ã‚‰ã®ã‚‚ã®ã§ã€
ã“ã®è«–æ–‡ã¯ã„ãã¤ã‹ã®ã‚¯ãƒ©ã‚¹ã®ãƒ™ãƒ³ãƒˆé–¢æ•°ã«å¯¾ã™ã‚‹åŠ¹ç‡çš„ãªéš ã‚Œã‚·ãƒ•ãƒˆã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’ä¸ãˆã¦ã„ã¾ã™ã€‚
ã“ã®ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ã€ãã®è«–æ–‡ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³3.1ã«è¨˜è¼‰ã•ã‚Œã¦ã„ã¾ã™ã€‚

ã‚ˆã‚Šä¸€èˆ¬çš„ãªå ´åˆã€éš ã‚Œã‚·ãƒ•ãƒˆ$s \in \mathbb{Z}^n$ã‚’è¦‹ã¤ã‘ã‚‹ãŸã‚ã®å›è·¯ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ï¼š
$$
 H^{\otimes n} U_{\tilde{f}}  H^{\otimes n} U_g  H^{\otimes n} {|{0}\rangle}^{\otimes n} = {|{s}\rangle}.
$$
 ä¸€èˆ¬çš„ãªå ´åˆã€$f$ã¨$g$ã¯å˜ä¸€å¤‰æ•°ã®é–¢æ•°ã§ã™ã€‚
 å†…ç©ã®ä¾‹ã¯ã€$f(x, y) \to f(z)$ã¨ã—ã€
 $z$ã‚’$x$ã¨$y$ã®é€£çµã€$s$ã‚’$a$ã¨$b$ã®é€£çµã¨ç­‰ã—ãã™ã‚Œã°ã€ã“ã®å½¢å¼ã«ãªã‚Šã¾ã™ã€‚
 ä¸€èˆ¬çš„ãªå ´åˆã€æ­£ç¢ºã«2ã¤ã®ã‚ªãƒ©ã‚¯ãƒ«ãŒå¿…è¦ã§ã™ï¼š$g$ã®ãŸã‚ã®ã‚ªãƒ©ã‚¯ãƒ«1ã¤ã¨$\tilde{f}$ã®ãŸã‚ã®ã‚ªãƒ©ã‚¯ãƒ«1ã¤ã§ã€
 å¾Œè€…ã¯ãƒ™ãƒ³ãƒˆé–¢æ•°$f$ã®_åŒå¯¾_ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã‚‹é–¢æ•°ã§ã™ã€‚
 å†…ç©é–¢æ•°ã¯è‡ªå·±åŒå¯¾æ€§$\tilde{f}=f$ã‚’æŒã¡ã¾ã™ã€‚

 å†…ç©ã«å¯¾ã™ã‚‹éš ã‚Œã‚·ãƒ•ãƒˆã®å›è·¯ã§ã¯ã€ä¸€èˆ¬çš„ãªå ´åˆã®å›è·¯ã«ç¾ã‚Œã‚‹ä¸­é–“å±¤ã®
 ã‚¢ãƒ€ãƒãƒ¼ãƒ«ã‚’çœç•¥ã—ã¾ã—ãŸã€‚ä¸€èˆ¬çš„ãªå ´åˆã§ã¯ã“ã®å±¤ãŒå¿…è¦ã§ã™ãŒã€
 å‡ºåŠ›ãŒæ‰€æœ›ã®${|{a}\rangle}{|{b}\rangle}$ã§ã¯ãªã${|{b}\rangle}{|{a}\rangle}$ã¨ãªã‚‹ãŸã‚å°‘ã—ã®å¾Œå‡¦ç†ãŒå¿…è¦ã«ãªã‚‹ä»£ã‚ã‚Šã«ã€
 å›è·¯ã®æ·±ã•ã‚’å°‘ã—ç¯€ç´„ã—ã¾ã—ãŸã€‚
## è¦ä»¶ {#requirements}

ã“ã®ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã‚’é–‹å§‹ã™ã‚‹å‰ã«ã€ä»¥ä¸‹ãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ãã ã•ã„ï¼š

- Qiskit SDK v2.1ä»¥é™ã€[å¯è¦–åŒ–](https://docs.quantum.ibm.com/api/qiskit/visualization)ã‚µãƒãƒ¼ãƒˆä»˜ã
- Qiskit Runtime v0.41ä»¥é™ï¼ˆ`pip install qiskit-ibm-runtime`ï¼‰
- M3 Qiskitã‚¢ãƒ‰ã‚ªãƒ³ v3.0ï¼ˆ`pip install mthree`ï¼‰
## ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— {#setup}

```python
# Added by doQumentation â€” installs packages not in the Binder environment
%pip install -q mthree
```

```python
from collections.abc import Iterator, Sequence
from random import Random
from qiskit.circuit import (
    CircuitInstruction,
    QuantumCircuit,
    QuantumRegister,
    Qubit,
)
from qiskit.circuit.library import CZGate, HGate, XGate
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit_ibm_runtime import QiskitRuntimeService
import timeit
import matplotlib.pyplot as plt
from qiskit_ibm_runtime import SamplerV2 as Sampler
import mthree
```

## ã‚¹ãƒ†ãƒƒãƒ—1ï¼šå¤å…¸çš„ãªå…¥åŠ›ã‚’é‡å­å•é¡Œã«ãƒãƒƒãƒ”ãƒ³ã‚°ã™ã‚‹ {#step-1-map-classical-inputs-to-a-quantum-problem}
ã¾ãšã€éš ã‚Œã‚·ãƒ•ãƒˆå•é¡Œã‚’`QuantumCircuit`ã¨ã—ã¦å®Ÿè£…ã™ã‚‹é–¢æ•°ã‚’è¨˜è¿°ã—ã¾ã™ã€‚

```python
def apply_hadamards(qubits: Sequence[Qubit]) -> Iterator[CircuitInstruction]:
    """Apply a Hadamard gate to every qubit."""
    for q in qubits:
        yield CircuitInstruction(HGate(), [q], [])

def apply_shift(
    qubits: Sequence[Qubit], shift: int
) -> Iterator[CircuitInstruction]:
    """Apply X gates where the bits of the shift are equal to 1."""
    for i, q in zip(range(shift.bit_length()), qubits):
        if shift >> i & 1:
            yield CircuitInstruction(XGate(), [q], [])

def oracle_f(qubits: Sequence[Qubit]) -> Iterator[CircuitInstruction]:
    """Apply the f oracle."""
    for i in range(0, len(qubits) - 1, 2):
        yield CircuitInstruction(CZGate(), [qubits[i], qubits[i + 1]])

def oracle_g(
    qubits: Sequence[Qubit], shift: int
) -> Iterator[CircuitInstruction]:
    """Apply the g oracle."""
    yield from apply_shift(qubits, shift)
    yield from oracle_f(qubits)
    yield from apply_shift(qubits, shift)

def determine_hidden_shift(
    qubits: Sequence[Qubit], shift: int
) -> Iterator[CircuitInstruction]:
    """Determine the hidden shift."""
    yield from apply_hadamards(qubits)
    yield from oracle_g(qubits, shift)
    # We omit this layer in exchange for post processing
    # yield from apply_hadamards(qubits)
    yield from oracle_f(qubits)
    yield from apply_hadamards(qubits)

def run_hidden_shift_circuit(n_qubits, rng):
    hidden_shift = rng.getrandbits(n_qubits)

    qubits = QuantumRegister(n_qubits, name="q")
    circuit = QuantumCircuit.from_instructions(
        determine_hidden_shift(qubits, hidden_shift), qubits=qubits
    )
    circuit.measure_all()
    # Format the hidden shift as a string.
    hidden_shift_string = format(hidden_shift, f"0{n_qubits}b")
    return (circuit, hidden_shift, hidden_shift_string)

def display_circuit(circuit):
    return circuit.remove_final_measurements(inplace=False).draw(
        "mpl", idle_wires=False, scale=0.5, fold=-1
    )
```

å°ã•ãªä¾‹ã‹ã‚‰å§‹ã‚ã¾ã—ã‚‡ã†ï¼š

```python
n_qubits = 6
random_seed = 12345
rng = Random(random_seed)
circuit, hidden_shift, hidden_shift_string = run_hidden_shift_circuit(
    n_qubits, rng
)

print(f"Hidden shift string {hidden_shift_string}")

display_circuit(circuit)
```

```text
Hidden shift string 011010
```

![Output of the previous code cell](/docs/images/tutorials/readout-error-mitigation-sampler/extracted-outputs/8297843e-00c3-4bb5-9d33-a7e558d1698c-1.avif)
## ã‚¹ãƒ†ãƒƒãƒ— 2: é‡å­ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢å®Ÿè¡Œã®ãŸã‚ã®å›è·¯ã®æœ€é©åŒ– {#step-2-optimize-circuits-for-quantum-hardware-execution}

```python
job_tags = [
    f"shift {hidden_shift_string}",
    f"n_qubits {n_qubits}",
    f"seed = {random_seed}",
]
job_tags
```

```text
['shift 011010', 'n_qubits 6', 'seed = 12345']
```

```python
# Uncomment this to run the circuits on a quantum computer on IBMCloud.
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=100
)

# from qiskit_ibm_runtime.fake_provider import FakeMelbourneV2
# backend = FakeMelbourneV2()
# backend.refresh(service)

print(f"Using backend {backend.name}")

def get_isa_circuit(circuit, backend):
    pass_manager = generate_preset_pass_manager(
        optimization_level=3, backend=backend, seed_transpiler=1234
    )
    isa_circuit = pass_manager.run(circuit)
    return isa_circuit

isa_circuit = get_isa_circuit(circuit, backend)
display_circuit(isa_circuit)
```

```text
Using backend ibm_kingston
```

![Output of the previous code cell](/docs/images/tutorials/readout-error-mitigation-sampler/extracted-outputs/f2b77d93-c34a-43a4-b436-e7a25024a94a-1.avif)

## ã‚¹ãƒ†ãƒƒãƒ— 3: Qiskit ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚’ä½¿ç”¨ã—ãŸå›è·¯ã®å®Ÿè¡Œ {#step-3-execute-circuits-using-qiskit-primitives}

```python
# submit job for solving the hidden shift problem using the Sampler primitive
NUM_SHOTS = 50_000

def run_sampler(backend, isa_circuit, num_shots):
    sampler = Sampler(mode=backend)
    sampler.options.environment.job_tags
    pubs = [(isa_circuit, None, NUM_SHOTS)]
    job = sampler.run(pubs)
    return job

def setup_mthree_mitigation(isa_circuit, backend):
    # retrieve the final qubit mapping so mthree knows which qubits to calibrate
    qubit_mapping = mthree.utils.final_measurement_mapping(isa_circuit)

    # submit jobs for readout error calibration
    mit = mthree.M3Mitigation(backend)
    mit.cals_from_system(qubit_mapping, rep_delay=None)

    return mit, qubit_mapping
```

```python
job = run_sampler(backend, isa_circuit, NUM_SHOTS)
mit, qubit_mapping = setup_mthree_mitigation(isa_circuit, backend)
```

## ã‚¹ãƒ†ãƒƒãƒ— 4: å¾Œå‡¦ç†ã¨å¤å…¸å½¢å¼ã§ã®çµæœã®è¿”å´ {#step-4-post-process-and-return-results-in-classical-format}

ä¸Šè¨˜ã®ç†è«–çš„ãªè­°è«–ã«ãŠã„ã¦ã€å…¥åŠ› $ab$ ã«å¯¾ã—ã¦å‡ºåŠ› $ba$ ãŒæœŸå¾…ã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã—ãŸã€‚
ã•ã‚‰ã«è¤‡é›‘ãªç‚¹ã¨ã—ã¦ã€ï¼ˆãƒˆãƒ©ãƒ³ã‚¹ãƒ‘ã‚¤ãƒ«å‰ã®ï¼‰ã‚ˆã‚Šå˜ç´”ãªå›è·¯ã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã«ã€å¿…è¦ãª CZ ã‚²ãƒ¼ãƒˆã‚’éš£æ¥ã™ã‚‹é‡å­ãƒ“ãƒƒãƒˆã®ãƒšã‚¢é–“ã«æŒ¿å…¥ã—ã¾ã—ãŸã€‚ã“ã‚Œã¯ãƒ“ãƒƒãƒˆåˆ— $a$ ã¨ $b$ ã‚’ $a1 b1 a2 b2 \ldots$ ã®ã‚ˆã†ã«ã‚¤ãƒ³ã‚¿ãƒ¼ãƒªãƒ¼ãƒ–ã™ã‚‹ã“ã¨ã«ç›¸å½“ã—ã¾ã™ã€‚
å‡ºåŠ›æ–‡å­—åˆ— $ba$ ã‚‚åŒæ§˜ã«ã‚¤ãƒ³ã‚¿ãƒ¼ãƒªãƒ¼ãƒ–ã•ã‚Œã¾ã™ï¼š$b1 a1 b2 a2 \ldots$ã€‚ä»¥ä¸‹ã® `unscramble` é–¢æ•°ã¯ã€å‡ºåŠ›æ–‡å­—åˆ—ã‚’ $b1 a1 b2 a2 \ldots$ ã‹ã‚‰ $a1 b1 a2 b2 \ldots$ ã«å¤‰æ›ã—ã€å…¥åŠ›ã¨å‡ºåŠ›ã®æ–‡å­—åˆ—ã‚’ç›´æ¥æ¯”è¼ƒã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

```python
# retrieve bitstring counts
def get_bitstring_counts(job):
    result = job.result()
    pub_result = result[0]
    counts = pub_result.data.meas.get_counts()
    return counts, pub_result
```

```python
counts, pub_result = get_bitstring_counts(job)
```

2ã¤ã®ãƒ“ãƒƒãƒˆåˆ—é–“ã®ãƒãƒŸãƒ³ã‚°è·é›¢ã¨ã¯ã€ãƒ“ãƒƒãƒˆãŒç•°ãªã‚‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®æ•°ã§ã™ã€‚

```python
def hamming_distance(s1, s2):
    weight = 0
    for c1, c2 in zip(s1, s2):
        (c1, c2) = (int(c1), int(c2))
        if (c1 == 1 and c2 == 1) or (c1 == 0 and c2 == 0):
            weight += 1

    return weight
```

```python
# Replace string of form a1b1a2b2... with b1a1b2a1...
# That is, reverse order of successive pairs of bits.
def unscramble(bitstring):
    ps = [bitstring[i : i + 2][::-1] for i in range(0, len(bitstring), 2)]
    return "".join(ps)

def find_hidden_shift_bitstring(counts, hidden_shift_string):
    # convert counts to probabilities
    probs = {
        unscramble(bitstring): count / NUM_SHOTS
        for bitstring, count in counts.items()
    }

    # Retrieve the most probable bitstring.
    most_probable = max(probs, key=lambda x: probs[x])

    print(f"Expected hidden shift string: {hidden_shift_string}")
    if most_probable == hidden_shift_string:
        print("Most probable bitstring matches hidden shift ğŸ˜Š.")
    else:
        print("Most probable bitstring didn't match hidden shift â˜¹ï¸.")
    print("Top 10 bitstrings and their probabilities:")
    display(
        {
            k: (v, hamming_distance(hidden_shift_string, k))
            for k, v in sorted(
                probs.items(), key=lambda x: x[1], reverse=True
            )[:10]
        }
    )

    return probs, most_probable
```

```python
probs, most_probable = find_hidden_shift_bitstring(
    counts, hidden_shift_string
)
```

```text
Expected hidden shift string: 011010
Most probable bitstring matches hidden shift ğŸ˜Š.
Top 10 bitstrings and their probabilities:
```

```text
{'011010': (0.9743, 6),
 '001010': (0.00812, 5),
 '010010': (0.0063, 5),
 '011000': (0.00554, 5),
 '011011': (0.00492, 5),
 '011110': (0.00044, 5),
 '001000': (0.00012, 4),
 '010000': (8e-05, 4),
 '001011': (6e-05, 4),
 '000010': (6e-05, 4)}
```

M3 ã«ã‚ˆã‚‹èª­ã¿å‡ºã—ã‚¨ãƒ©ãƒ¼ç·©å’Œã‚’é©ç”¨ã™ã‚‹å‰ã®ã€æœ€ã‚‚ç¢ºç‡ã®é«˜ã„ãƒ“ãƒƒãƒˆåˆ—ã®ç¢ºç‡ã‚’è¨˜éŒ²ã—ã¾ã—ã‚‡ã†ã€‚

```python
max_probability_before_M3 = probs[most_probable]
max_probability_before_M3
```

```text
0.9743
```

æ¬¡ã«ã€M3 ãŒå­¦ç¿’ã—ãŸèª­ã¿å‡ºã—è£œæ­£ã‚’ã‚«ã‚¦ãƒ³ãƒˆã«é©ç”¨ã—ã¾ã™ã€‚
`apply_corrections` é–¢æ•°ã¯æ“¬ä¼¼ç¢ºç‡åˆ†å¸ƒã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯åˆè¨ˆãŒ $1$ ã«ãªã‚‹ `float` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒªã‚¹ãƒˆã§ã™ãŒã€ä¸€éƒ¨ã®å€¤ãŒè² ã«ãªã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚

```python
def perform_mitigation(mit, counts, qubit_mapping):
    # mitigate readout error
    quasis = mit.apply_correction(counts, qubit_mapping)

    # print results
    most_probable_after_m3 = unscramble(max(quasis, key=lambda x: quasis[x]))

    is_hidden_shift_identified = most_probable_after_m3 == hidden_shift_string
    if is_hidden_shift_identified:
        print("Most probable bitstring matches hidden shift ğŸ˜Š.")
    else:
        print("Most probable bitstring didn't match hidden shift â˜¹ï¸.")
    print("Top 10 bitstrings and their quasi-probabilities:")
    topten = {
        unscramble(k): f"{v:.2e}"
        for k, v in sorted(quasis.items(), key=lambda x: x[1], reverse=True)[
            :10
        ]
    }
    max_probability_after_M3 = float(topten[most_probable_after_m3])
    display(topten)

    return max_probability_after_M3, is_hidden_shift_identified
```

```python
print(f"Expected hidden shift string: {hidden_shift_string}")
max_probability_after_M3, is_hidden_shift_identified = perform_mitigation(
    mit, counts, qubit_mapping
)
```

```text
Expected hidden shift string: 011010
Most probable bitstring matches hidden shift ğŸ˜Š.
Top 10 bitstrings and their quasi-probabilities:
```

```text
{'011010': '1.01e+00',
 '001010': '8.75e-04',
 '001000': '7.38e-05',
 '010000': '4.51e-05',
 '111000': '2.18e-05',
 '001011': '1.74e-05',
 '000010': '6.42e-06',
 '011001': '-7.18e-06',
 '011000': '-4.53e-04',
 '010010': '-1.28e-03'}
```

#### M3 è£œæ­£é©ç”¨å‰å¾Œã«ãŠã‘ã‚‹éš ã‚Œã‚·ãƒ•ãƒˆæ–‡å­—åˆ—ã®è­˜åˆ¥çµæœã®æ¯”è¼ƒ {#compare-identifying-the-hidden-shift-string-before-and-after-applying-m3-correction}

```python
def compare_before_and_after_M3(
    max_probability_before_M3,
    max_probability_after_M3,
    is_hidden_shift_identified,
):
    is_probability_improved = (
        max_probability_after_M3 > max_probability_before_M3
    )
    print(f"Most probable probability before M3: {max_probability_before_M3}")
    print(f"Most probable probability after M3: {max_probability_after_M3}")
    if is_hidden_shift_identified and is_probability_improved:
        print("Readout error mitigation effective! ğŸ˜Š")
    else:
        print("Readout error mitigation not effective. â˜¹ï¸")
```

```python
compare_before_and_after_M3(
    max_probability_before_M3,
    max_probability_after_M3,
    is_hidden_shift_identified,
)
```

```text
Most probable probability before M3: 0.9743
Most probable probability after M3: 1.01
Readout error mitigation effective! ğŸ˜Š
```

### M3 ã«å¿…è¦ãª CPU æ™‚é–“ãŒã‚·ãƒ§ãƒƒãƒˆæ•°ã«å¯¾ã—ã¦ã©ã®ã‚ˆã†ã«ã‚¹ã‚±ãƒ¼ãƒ«ã™ã‚‹ã‹ã®ãƒ—ãƒ­ãƒƒãƒˆ {#plot-how-cpu-time-required-by-m3-scales-with-shots}

```python
# Collect samples for numbers of shots varying from 5000 to 25000.
shots_range = range(5000, NUM_SHOTS + 1, 2500)
times = []
for shots in shots_range:
    print(f"Applying M3 correction to {shots} shots...")
    t0 = timeit.default_timer()
    _ = mit.apply_correction(
        pub_result.data.meas.slice_shots(range(shots)).get_counts(),
        qubit_mapping,
    )
    t1 = timeit.default_timer()
    print(f"\tDone in {t1 - t0} seconds.")
    times.append(t1 - t0)

fig, ax = plt.subplots()
ax.plot(shots_range, times, "o--")
ax.set_xlabel("Shots")
ax.set_ylabel("Time (s)")
ax.set_title("Time to apply M3 correction")
```

```text
Applying M3 correction to 5000 shots...
	Done in 0.003321983851492405 seconds.
Applying M3 correction to 7500 shots...
	Done in 0.004425413906574249 seconds.
Applying M3 correction to 10000 shots...
	Done in 0.006366567220538855 seconds.
Applying M3 correction to 12500 shots...
	Done in 0.0071477219462394714 seconds.
Applying M3 correction to 15000 shots...
	Done in 0.00860048783943057 seconds.
Applying M3 correction to 17500 shots...
	Done in 0.010026784148067236 seconds.
Applying M3 correction to 20000 shots...
	Done in 0.011459112167358398 seconds.
Applying M3 correction to 22500 shots...
	Done in 0.012727141845971346 seconds.
Applying M3 correction to 25000 shots...
	Done in 0.01406092382967472 seconds.
Applying M3 correction to 27500 shots...
	Done in 0.01546052098274231 seconds.
Applying M3 correction to 30000 shots...
	Done in 0.016769016161561012 seconds.
Applying M3 correction to 32500 shots...
	Done in 0.019537431187927723 seconds.
Applying M3 correction to 35000 shots...
	Done in 0.019739801064133644 seconds.
Applying M3 correction to 37500 shots...
	Done in 0.021093040239065886 seconds.
Applying M3 correction to 40000 shots...
	Done in 0.022840639110654593 seconds.
Applying M3 correction to 42500 shots...
	Done in 0.023974396288394928 seconds.
Applying M3 correction to 45000 shots...
	Done in 0.026412792038172483 seconds.
Applying M3 correction to 47500 shots...
	Done in 0.026364430785179138 seconds.
Applying M3 correction to 50000 shots...
	Done in 0.02820305060595274 seconds.
```

```text
Text(0.5, 1.0, 'Time to apply M3 correction')
```

![Output of the previous code cell](/docs/images/tutorials/readout-error-mitigation-sampler/extracted-outputs/33addc38-f738-48ed-a29d-9790f446c036-2.avif)

#### ãƒ—ãƒ­ãƒƒãƒˆã®è§£é‡ˆ {#interpreting-the-plot}

ä¸Šè¨˜ã®ãƒ—ãƒ­ãƒƒãƒˆã¯ã€M3 è£œæ­£ã®é©ç”¨ã«å¿…è¦ãªæ™‚é–“ãŒã‚·ãƒ§ãƒƒãƒˆæ•°ã«å¯¾ã—ã¦ç·šå½¢ã«ã‚¹ã‚±ãƒ¼ãƒ«ã™ã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚## ã‚¹ã‚±ãƒ¼ãƒ«ã‚¢ãƒƒãƒ—

```python
n_qubits = 80
rng = Random(12345)
circuit, hidden_shift, hidden_shift_string = run_hidden_shift_circuit(
    n_qubits, rng
)

print(f"Hidden shift string {hidden_shift_string}")
```

```text
Hidden shift string 00000010100110101011101110010001010000110011101001101010101001111001100110000111
```

```python
isa_circuit = get_isa_circuit(circuit, backend)
```

```python
job = run_sampler(backend, isa_circuit, NUM_SHOTS)
mit, qubit_mapping = setup_mthree_mitigation(isa_circuit, backend)
```

```python
counts, pub_result = get_bitstring_counts(job)
```

```python
probs, most_probable = find_hidden_shift_bitstring(
    counts, hidden_shift_string
)
```

```text
Expected hidden shift string: 00000010100110101011101110010001010000110011101001101010101001111001100110000111
Most probable bitstring matches hidden shift ğŸ˜Š.
Top 10 bitstrings and their probabilities:
```

```text
{'00000010100110101011101110010001010000110011101001101010101001111001100110000111': (0.50402,
  80),
 '00000010100110101011101110010001010000110011100001101010101001111001100110000111': (0.0396,
  79),
 '00000010100110101011101110010001010000110011101001101010101001111001100100000111': (0.0323,
  79),
 '00000010100110101011101110010001010000110011101001101010101001101001100110000111': (0.01936,
  79),
 '00000010100110101011101110010011010000110011101001101010101001111001100110000111': (0.01432,
  79),
 '00000010100110101011101110010001010000110011101001101010101001011001100110000111': (0.0101,
  79),
 '00000010100110101011101110010001010000110011101001101010101001110001100110000111': (0.00924,
  79),
 '00000010100110101011101110010001010000010011101001101010101001111001100110000111': (0.00908,
  79),
 '00000010100110101011100110010001010000110011101001101010101001111001100110000111': (0.00888,
  79),
 '00000010100110101011101110010001010000110011101001100010101001111001100110000111': (0.0082,
  79)}
```

æ­£ã—ã„éš ã‚Œã‚·ãƒ•ãƒˆæ–‡å­—åˆ—ãŒè¦‹ã¤ã‹ã£ãŸã“ã¨ãŒç¢ºèªã§ãã¾ã™ã€‚ã•ã‚‰ã«ã€æ¬¡ã«ç¢ºç‡ã®é«˜ã„9ã¤ã®ãƒ“ãƒƒãƒˆæ–‡å­—åˆ—ã¯ã€1ã¤ã®ä½ç½®ã®ã¿ãŒç•°ãªã£ã¦ã„ã¾ã™ã€‚
æœ€ã‚‚ç¢ºç‡ã®é«˜ã„å€¤ã‚’è¨˜éŒ²ã—ã¾ã™ã€‚

```python
max_probability_before_M3 = probs[most_probable]
max_probability_before_M3
```

```text
0.50402
```

```python
print(f"Expected hidden shift string: {hidden_shift_string}")
max_probability_after_M3, is_hidden_shift_identified = perform_mitigation(
    mit, counts, qubit_mapping
)
```

```text
Expected hidden shift string: 00000010100110101011101110010001010000110011101001101010101001111001100110000111
Most probable bitstring matches hidden shift ğŸ˜Š.
Top 10 bitstrings and their quasi-probabilities:
```

```text
{'00000010100110101011101110010001010000110011101001101010101001111001100110000111': '9.85e-01',
 '00000010100110101011101110010001010000110011100001101010101001111001100110000111': '6.84e-03',
 '00000010100110101011100110010001010000110011101001101010101001111001100110000111': '3.87e-03',
 '00000010100110101011101110010011010000110011101001101010101001111001100110000111': '3.42e-03',
 '00000010100110101011101110010001010000110011101001101010101001111001100100000111': '3.30e-03',
 '00000010100110101011101110010001010000110011101001101010101001110001100110000111': '3.28e-03',
 '00000010100010101011101110010001010000110011101001101010101001111001100110000111': '2.62e-03',
 '00000010100110101011101110010001010000110011101001101010101001101001100110000111': '2.43e-03',
 '00000010100110101011101110010000010000110011101001101010101001111001100110000111': '1.73e-03',
 '00000010100110101011101110010001010000110011101001101010101001111001000110000111': '1.63e-03'}
```

```python
compare_before_and_after_M3(
    max_probability_before_M3,
    max_probability_after_M3,
    is_hidden_shift_identified,
)
```

```text
Most probable probability before M3: 0.54348
Most probable probability after M3: 0.99
Readout error mitigation effective! ğŸ˜Š
```
