---
title: "周期境界条件のための回路カッティング"
sidebar_label: "周期境界条件のための回路カッティング"
description: "回路カッティングを使用して、最初と最後の量子ビットが隣接していないユーティリティスケールの周期チェーン問題に対処します。"
notebook_path: "docs/tutorials/periodic-boundary-conditions-with-circuit-cutting.ipynb"
---

<OpenInLabBanner notebookPath="docs/tutorials/periodic-boundary-conditions-with-circuit-cutting.ipynb" />



{/* cspell:ignore fontsize edgecolor */}

*使用量の目安：Eagleプロセッサで約2分（注意：これはあくまで目安です。実際の実行時間は異なる場合があります。）*
## 背景

このノートブックでは、隣接する全ての量子ビット間（最初と最後の量子ビット間を含む）に2量子ビット演算がある周期的な量子ビットチェーンのシミュレーションを考えます。周期チェーンは、イジングモデルや分子シミュレーションなどの物理学や化学の問題でよく見られます。

現在のIBM Quantum&reg;デバイスはプレーナー型です。最初と最後の量子ビットが隣接するように、一部の周期チェーンをトポロジー上に直接埋め込むことが可能です。しかし、十分に大きな問題では、最初と最後の量子ビットが離れてしまうため、これらの2量子ビット間の2量子ビット演算に多くのSWAPゲートが必要になります。このような周期境界問題は<a href="https://arxiv.org/abs/2402.17833">こちらの論文</a>で研究されています。

このノートブックでは、最初と最後の量子ビットが隣接していないユーティリティスケールの周期チェーン問題に対処するための回路カッティングの使用方法を示します。この長距離接続をカッティングすることで、回路の複数インスタンスの実行と古典的な後処理のコストと引き換えに、余分なSWAPゲートを回避できます。要約すると、カッティングを組み込むことで、長距離の2量子ビット演算を論理的に計算できます。言い換えれば、このアプローチはカップリングマップの接続性を実効的に向上させ、結果としてSWAPゲートの数を削減します。

カッティングには2種類あることに注意してください。回路のワイヤをカッティングする方法（`ワイヤカッティング`と呼ばれます）と、2量子ビットゲートを複数の1量子ビット演算に置き換える方法（`ゲートカッティング`と呼ばれます）です。このノートブックでは、ゲートカッティングに焦点を当てます。ゲートカッティングの詳細については、`qiskit-addon-cutting`の<a href="https://qiskit.github.io/qiskit-addon-cutting/explanation/index.html">解説資料</a>および対応する参考文献をご参照ください。ワイヤカッティングの詳細については、[期待値推定のためのワイヤカッティング](/tutorials/wire-cutting)チュートリアル、または<a href='https://qiskit.github.io/qiskit-addon-cutting/tutorials/index.html'>qiskit-addon-cutting</a>のチュートリアルをご参照ください。
## 前提条件

このチュートリアルを開始する前に、以下がインストールされていることをご確認ください：

- Qiskit SDK v1.2以降（`pip install qiskit`）
- Qiskit Runtime v0.3以降（`pip install qiskit-ibm-runtime`）
- Circuit cutting Qiskit addon v.9.0以降（`pip install qiskit-addon-cutting`）
## セットアップ

```python
# Added by doQumentation — installs packages not in the Binder environment
%pip install -q qiskit-addon-cutting
```

```python
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl

from qiskit.transpiler import PassManager
from qiskit.transpiler.passes import (
    BasisTranslator,
    Optimize1qGatesDecomposition,
)
from qiskit.circuit.equivalence_library import (
    SessionEquivalenceLibrary as sel,
)
from qiskit.converters import circuit_to_dag, dag_to_circuit
from qiskit.result import sampled_expectation_value
from qiskit.quantum_info import SparsePauliOp
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit.circuit.library import TwoLocal

from qiskit_addon_cutting import (
    cut_gates,
    generate_cutting_experiments,
    reconstruct_expectation_values,
)

from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_runtime import SamplerV2, SamplerOptions, Batch
```

## ステップ1：古典的な入力を量子問題にマッピングする

ここでは、TwoLocal回路を生成し、いくつかのオブザーバブルを定義します。

<ul>
    <li>入力：回路を作成するためのパラメータ</li>
    <li>出力：抽象回路とオブザーバブル</li>
</ul>
TwoLocal回路に対して、`エンタングラーマップ`の最後と最初の量子ビット間に周期的接続を持つハードウェア効率の良い`エンタングラーマップ`を考えます。この長距離相互作用はトランスパイル時に余分なSWAPゲートを生じさせ、回路の深さを増加させる可能性があります。
#### バックエンドと初期レイアウトの選択

```python
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=127
)
```

このノートブックでは、127量子ビットIBM Quantumデバイスのトポロジーにおける最長の1Dチェーンである109量子ビットの周期的1Dチェーンを考えます。127量子ビットデバイス上で、余分なSWAPゲートを追加せずに、最初と最後の量子ビットが隣接するように109量子ビットの周期チェーンを配置することはできません。

```python
init_layout = [
    13,
    12,
    11,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1,
    0,
    14,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    36,
    51,
    50,
    49,
    48,
    47,
    46,
    45,
    44,
    43,
    42,
    41,
    40,
    39,
    38,
    37,
    52,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    74,
    89,
    88,
    87,
    86,
    85,
    84,
    83,
    82,
    81,
    80,
    79,
    78,
    77,
    76,
    75,
    90,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    112,
    126,
    125,
    124,
    123,
    122,
    121,
    120,
    119,
    118,
    117,
    116,
    115,
    114,
    113,
]

# the number of qubits in the circuit is governed by the length of the initial layout
num_qubits = len(init_layout)
num_qubits
```

```text
109
```

#### TwoLocal回路のエンタングラーマップの構築

```python
coupling_map = [(i, i + 1) for i in range(0, len(init_layout) - 1)]
coupling_map.append(
    (len(init_layout) - 1, 0)
)  # adding in the periodic connectivity
```

TwoLocal回路では、`rotation_blocks`と`エンタングラーマップ`を複数回繰り返すことができます。この場合、繰り返し回数がカッティングが必要な周期ゲートの数を決定します。サンプリングオーバーヘッドはカッティング回数に対して指数関数的に増加するため（詳細は[期待値推定のためのワイヤカッティング](/tutorials/wire-cutting)チュートリアルを参照してください）、このノートブックでは繰り返し回数を2に固定します。

```python
num_reps = 2
entangler_map = []

for even_edge in coupling_map[0 : len(coupling_map) : 2]:
    entangler_map.append(even_edge)

for odd_edge in coupling_map[1 : len(coupling_map) : 2]:
    entangler_map.append(odd_edge)
```

```python
ansatz = TwoLocal(
    num_qubits=num_qubits,
    rotation_blocks="rx",
    entanglement_blocks="cx",
    entanglement=entangler_map,
    reps=num_reps,
).decompose()
ansatz.draw("mpl", fold=-1)
```

![前のコードセルの出力](/docs/images/tutorials/periodic-boundary-conditions-with-circuit-cutting/extracted-outputs/79428537-66cf-40ce-87cf-0f75f591cb4b-0.avif)

回路カッティングを使用した結果の品質を検証するためには、理想的な結果を知る必要があります。現在選択している回路はブルートフォースの古典シミュレーションの能力を超えています。そのため、クリフォード回路になるようにパラメータを慎重に固定します。

最初の2層の`Rx`ゲートにはパラメータ値$0$を、最後の層には値$\pi$を割り当てます。これにより、この回路の理想的な結果は$|1\rangle^{\otimes n}$（$n$は量子ビット数）となります。したがって、$\langle Z_i \rangle$と$\langle Z_i Z_{i+1} \rangle$の期待値（$i$は量子ビットのインデックス）はそれぞれ$-1$と$+1$になります。

```python
params_last_layer = [np.pi] * ansatz.num_qubits
params = [0] * (ansatz.num_parameters - ansatz.num_qubits)
params.extend(params_last_layer)

ansatz.assign_parameters(params, inplace=True)
```

#### オブザーバブルの選択
ゲートカッティングの利点を定量化するために、オブザーバブル$\frac{1}{n}\sum_{i=1}^n \langle Z_i \rangle$と$\frac{1}{n-1}\sum_{i=1}^{n-1} \langle Z_i Z_{i+1} \rangle$の期待値を測定します。前述の通り、理想的な期待値はそれぞれ$-1$と$+1$です。

```python
observables = []

for i in range(num_qubits):
    obs = "I" * (i) + "Z" + "I" * (num_qubits - i - 1)
    observables.append(obs)

for i in range(num_qubits):
    if i == num_qubits - 1:
        obs = "Z" + "I" * (num_qubits - 2) + "Z"
    else:
        obs = "I" * i + "ZZ" + "I" * (num_qubits - i - 2)
    observables.append(obs)

observables = SparsePauliOp(observables)
paulis = observables.paulis
coeffs = observables.coeffs
```
## ステップ2：量子ハードウェア実行のための問題の最適化

<ul>
    <li>入力：抽象回路とオブザーバブル</li>
    <li>出力：長距離ゲートのカットにより生成されたターゲット回路とオブザーバブル</li>
</ul>
#### 回路のトランスパイル

回路のトランスパイルはこの段階で行うことも、カット後に行うこともできます。カット後にトランスパイルする場合、サンプリングオーバーヘッドによって生成された各サブ実験をそれぞれトランスパイルする必要があります。そのため、トランスパイルのオーバーヘッドを削減するためには、この段階でトランスパイルを行う方が賢明です。

ただし、この段階でネイティブハードウェアの接続性を使用してトランスパイルを行うと、トランスパイラは周期的な2量子ビット演算を配置するために複数のSWAPゲートを追加してしまい、回路カットの利点が損なわれます。この問題を回避するために、カットすべき正確なゲートが分かっているという知識を活用できます。具体的には、周期的な2量子ビットゲートに対応するために、遠距離の量子ビット間に仮想的な接続を追加した仮想カップリングマップを作成します。これにより、余分なSWAPゲートを含めることなく、この段階で回路をトランスパイルできるようになります。

```python
coupling_map = backend.configuration().coupling_map

# create a virtual coupling map with long range connectivity
virtual_coupling_map = coupling_map.copy()
virtual_coupling_map.append([init_layout[-1], init_layout[0]])
virtual_coupling_map.append([init_layout[0], init_layout[-1]])
```

```python
pm_virtual = generate_preset_pass_manager(
    optimization_level=1,
    coupling_map=virtual_coupling_map,
    initial_layout=init_layout,
    basis_gates=backend.configuration().basis_gates,
)

virtual_mapped_circuit = pm_virtual.run(ansatz)
virtual_mapped_circuit.draw("mpl", fold=-1, idle_wires=False)
```

![Output of the previous code cell](/docs/images/tutorials/periodic-boundary-conditions-with-circuit-cutting/extracted-outputs/ad38aa32-4613-46c5-bf62-da332a1b9dfb-0.avif)

#### 長距離周期的接続のカット
次に、トランスパイルされた回路のゲートをカットします。カットすべき2量子ビットゲートは、レイアウトの最後の量子ビットと最初の量子ビットを接続するゲートであることに注意してください。

```python
# Find the indices of the distant gates
cut_indices = [
    i
    for i, instruction in enumerate(virtual_mapped_circuit.data)
    if {virtual_mapped_circuit.find_bit(q)[0] for q in instruction.qubits}
    == {init_layout[-1], init_layout[0]}
]
```

トランスパイルされた回路のレイアウトをオブザーバブルに適用します。

```python
trans_observables = observables.apply_layout(virtual_mapped_circuit.layout)
```

最後に、異なる測定基底と準備基底にわたるサンプリングによってサブ実験が生成されます。

```python
qpd_circuit, bases = cut_gates(virtual_mapped_circuit, cut_indices)
subexperiments, coefficients = generate_cutting_experiments(
    circuits=qpd_circuit,
    observables=trans_observables.paulis,
    num_samples=np.inf,
)
```

長距離相互作用のカットにより、測定基底と準備基底が異なる回路の複数のサンプルが実行されることに注意してください。これについての詳細は、<a href='https://arxiv.org/abs/1909.07534'>Constructing a virtual two-qubit gate by sampling single-qubit operations</a>および<a href='https://arxiv.org/abs/2312.11638'>Cutting circuits with multiple two-qubit unitaries</a>を参照してください。

カットすべき周期的ゲートの数は、上記で`num_reps`として定義された`TwoLocal`レイヤーの繰り返し回数と等しくなります。ゲートカットのサンプリングオーバーヘッドは6です。したがって、サブ実験の総数は$6^{num\_reps}$となります。

```python
print(f"Number of subexperiments is {len(subexperiments)} = 6**{num_reps}")
```

```text
Number of subexperiments is 36 = 6**2
```

#### サブ実験のトランスパイル
この時点で、サブ実験には基底ゲートセットに含まれない1量子ビットゲートが含まれています。これは、カットされた量子ビットが異なる基底で測定されるためであり、そのために使用される回転ゲートが必ずしも基底ゲートセットに属さないからです。例えば、X基底での測定は、通常のZ基底での測定の前にアダマールゲートを適用することを意味しますが、アダマールゲートは基底ゲートセットの一部ではありません。

サブ実験の各回路にトランスパイルプロセス全体を適用する代わりに、特定のトランスパイルパスを使用できます。利用可能なすべてのトランスパイルパスの詳細な説明については、<a href="https://docs.quantum.ibm.com/api/qiskit/transpiler_passes">こちらのドキュメント</a>を参照してください。

```BasisTranslator```を適用し、次に```Optimize1qGatesDecomposition```パスを適用して、これらの回路内のすべてのゲートが基底ゲートセットに属するようにします。ルーティングや初期レイアウト選択などの他のステップが再度実行されないため、これら2つのパスを使用する方がトランスパイルプロセス全体よりも高速です。

```python
pass_ = PassManager(
    [Optimize1qGatesDecomposition(basis=backend.configuration().basis_gates)]
)

subexperiments = pass_.run(
    [
        dag_to_circuit(
            BasisTranslator(sel, target_basis=backend.basis_gates).run(
                circuit_to_dag(circ)
            )
        )
        for circ in subexperiments
    ]
)
```

## ステップ3：Qiskitプリミティブを使用した実行

<ul>
    <li>入力：ターゲット回路</li>
    <li>出力：準確率分布</li>
</ul>
カットされた回路の実行には`SamplerV2`プリミティブを使用します。結果の改善が回路カットの効果的な適用のみによるものとなるよう、`dynamical decoupling`と`twirling`を無効にします。

```python
options = SamplerOptions()
options.default_shots = 10000
options.dynamical_decoupling.enable = False
options.twirling.enable_gates = False
options.twirling.enable_measure = False
```

次に、バッチモードを使用してジョブを送信します。

```python
with Batch(backend=backend) as batch:
    sampler = SamplerV2(options=options)
    cut_job = sampler.run(subexperiments)

print(f"Job ID {cut_job.job_id()}")
```

```text
Job ID cwxf7wq60bqg008pvt8g
```

```python
result = cut_job.result()
```

## ステップ4：後処理と所望の古典形式での結果の返却
<ul>
    <li>入力：準確率分布</li>
    <li>出力：再構成された期待値</li>
</ul>

```python
reconstructed_expvals = reconstruct_expectation_values(
    result,
    coefficients,
    paulis,
)
```

ここで、重み1および重み2のZタイプオブザーバブルの平均を計算します。

```python
cut_weight_1 = np.mean(reconstructed_expvals[:num_qubits])
cut_weight_2 = np.mean(reconstructed_expvals[num_qubits:])

print(f"Average of weight-1 expectation values is {cut_weight_1}")
print(f"Average of weight-2 expectation values is {cut_weight_2}")
```

```text
Average of weight-1 expectation values is -0.741733944954063
Average of weight-2 expectation values is 0.6968862385320495
```

### クロス検証：カットなしの期待値の取得
回路カット技術の利点をカットなしの場合と比較して検証することは有用です。ここでは、回路をカットせずに期待値を計算します。このようなカットなしの回路では、最初と最後の量子ビット間の2量子ビット演算を実装するために多数のSWAPゲートが必要となることに注意してください。カットなし回路の期待値を得るために、`SamplerV2`で確率分布を取得した後、`sampled_expectation_value`関数を使用します。これにより、すべてのインスタンスにわたってプリミティブを統一的に使用できます。ただし、`EstimatorV2`を使用して期待値を直接計算することも可能であったことに留意してください。

```python
if ansatz.num_clbits == 0:
    ansatz.measure_all()

pm_uncut = generate_preset_pass_manager(
    optimization_level=1, backend=backend, initial_layout=init_layout
)

transpiled_circuit = pm_uncut.run(ansatz)
```

```python
sampler = SamplerV2(mode=backend, options=options)
uncut_job = sampler.run([transpiled_circuit])
```

```python
uncut_job_id = uncut_job.job_id()
print(f"The job id for the uncut clifford circuit is {uncut_job_id}")
```

```text
The job id for the uncut clifford circuit is cwxfads2ac5g008jhe7g
```

```python
uncut_result = uncut_job.result()[0]
uncut_counts = uncut_result.data.meas.get_counts()
```

次に、カットなしでのすべての重み1および重み2のZタイプオブザーバブルの平均期待値を計算します。

```python
uncut_expvals = [
    sampled_expectation_value(uncut_counts, obs) for obs in paulis
]

uncut_weight_1 = np.mean(uncut_expvals[:num_qubits])
uncut_weight_2 = np.mean(uncut_expvals[num_qubits:])

print(f"Average of weight-1 expectation values is {uncut_weight_1}")
print(f"Average of weight-2 expectation values is {uncut_weight_2}")
```

```text
Average of weight-1 expectation values is -0.32494128440366965
Average of weight-2 expectation values is 0.32340917431192656
```

### 可視化
周期チェーン回路に対してゲートカットを使用した場合の、重み1および重み2のオブザーバブルの改善を可視化してみましょう。

```python
mpl.rcParams.update(mpl.rcParamsDefault)

fig = plt.subplots(figsize=(12, 8), dpi=200)
width = 0.25
labels = ["Weight-1", "Weight-2"]
x = np.arange(len(labels))

ideal = [-1, 1]
cut = [cut_weight_1, cut_weight_2]
uncut = [uncut_weight_1, uncut_weight_2]

br1 = np.arange(len(ideal))
br2 = [x + width for x in br1]
br3 = [x + width for x in br2]

plt.bar(
    br1, ideal, width=width, edgecolor="k", label="Ideal", color="#4589ff"
)
plt.bar(br2, cut, width=width, edgecolor="k", label="Cut", color="#a56eff")
plt.bar(
    br3, uncut, width=width, edgecolor="k", label="Uncut", color="#009d9a"
)

plt.axhline(y=0, color="k", linestyle="-")

plt.xticks([r + width for r in range(len(ideal))], labels, fontsize=14)
plt.yticks(fontsize=14)

plt.legend(fontsize=14)
plt.show()
```

![Output of the previous code cell](/docs/images/tutorials/periodic-boundary-conditions-with-circuit-cutting/extracted-outputs/2ba8913f-ba35-409c-bc4c-5f28e3698f20-0.avif)

### まとめ

要約すると、109量子ビットの周期的1次元チェーンに対して、重み1および重み2のZタイプオブザーバブルの平均期待値を計算しました。そのために、以下のことを行いました。

- 1次元チェーンの最初と最後の量子ビット間に長距離接続を追加して仮想カップリングマップを作成し、回路をトランスパイルしました。
    - この段階でのトランスパイルにより、カット後に各サブ実験を個別にトランスパイルするオーバーヘッドを回避できました。
    - 仮想カップリングマップの使用により、最初と最後の量子ビット間の2量子ビット演算に対する余分なSWAPゲートを回避できました。
- ゲートカットにより、トランスパイルされた回路から長距離接続を除去しました。
- 適切なトランスパイルパスを適用して、カットされた回路を基底ゲートセットに変換しました。
- `SamplerV2`プリミティブを使用して、IBM Quantumデバイス上でカットされた回路を実行しました。
- カットされた回路の結果を再構成して期待値を得ました。
### 考察

結果から、重み1の$\langle Z \rangle$および重み2の$\langle ZZ \rangle$タイプオブザーバブルの平均が、周期的ゲートのカットにより大幅に改善されていることが分かります。この研究にはエラー抑制やエラー軽減技術は含まれていないことに注意してください。観測された改善は、この問題に対するゲートカットの適切な使用のみによるものです。軽減技術や抑制技術を使用することで、結果をさらに改善できた可能性があります。

この研究は、計算パフォーマンスを向上させるためにゲートカットを効果的に使用する例を示しています。
## チュートリアルアンケート

このチュートリアルに関するフィードバックをお寄せいただくため、この短いアンケートにご協力ください。皆様のご意見は、コンテンツの提供やユーザーエクスペリエンスの改善に役立てさせていただきます。
