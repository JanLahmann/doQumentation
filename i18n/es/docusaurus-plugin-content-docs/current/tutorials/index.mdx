---
title: Tutoriales
sidebar_label: Descripción general
sidebar_position: 1
description: Explore los tutoriales de IBM Quantum — ejecutables en RasQberry, a través de Binder o en su propio servidor Jupyter.
---

# Tutoriales {#tutorials}

Utilice estos tutoriales para aprender cómo aplicar Qiskit a casos de uso comunes de computación cuántica.

- Comience con el conjunto de tutoriales en la sección [Primeros pasos](#get-started) si es la primera vez que ejecuta código en una computadora cuántica.
- La sección sobre [flujos de trabajo hacia la ventaja cuántica](#explore-workflows-toward-advantage) contiene ejemplos de extremo a extremo del uso de una computadora cuántica para resolver problemas del mundo real. Estos tutoriales se centran en algoritmos que son candidatos prometedores para lograr una ventaja computacional de una computadora cuántica sobre una computadora clásica.
- La sección sobre [capacidades de Qiskit](#leverage-qiskit-capabilities) contiene ejemplos que utilizan las técnicas más recientes y avanzadas del ecosistema Qiskit para mejorar parte o la totalidad de un flujo de trabajo particular.

## Primeros pasos {#get-started}

Estos tutoriales son para principiantes que están listos para explorar la ejecución de algoritmos cuánticos en una computadora cuántica.

* [Desigualdad CHSH](/tutorials/chsh-inequality)

## Explore flujos de trabajo hacia la ventaja cuántica {#explore-workflows-toward-advantage}

Los tutoriales de esta sección cubren demostraciones a gran escala de algoritmos cuánticos.

<details>
  <summary>**Algoritmos de muestreo verificable**</summary>

Los algoritmos de esta categoría se centran en circuitos cuánticos cuyas distribuciones de salida codifican soluciones a problemas estructurados con salida verificable. La verificabilidad significa que puede comprobar la consistencia entre los datos medidos, ya sea evaluando la cadena de bits elegida o sabiendo que no se producen falsos positivos.

Los tutoriales destacan técnicas donde el muestreo repetido permite la estimación de cantidades específicas del problema (por ejemplo, valores de función de costo o pesos espectrales). Estos métodos son particularmente relevantes para tareas de optimización y simulación con simetrías.

* [Diagonalización cuántica basada en muestras de un Hamiltoniano químico](/tutorials/sample-based-quantum-diagonalization)

* [Diagonalización cuántica de Krylov basada en muestras de un modelo de red fermiónica](/tutorials/sample-based-krylov-quantum-diagonalization)

* [Algoritmo de optimización aproximada cuántica](/tutorials/quantum-approximate-optimization-algorithm)

* [Técnicas avanzadas para QAOA](/tutorials/advanced-techniques-for-qaoa)

* [Codificación de correlación de Pauli para reducir los requisitos de Maxcut](/tutorials/pauli-correlation-encoding-for-qaoa)

</details>

<details>
  <summary>**Estimación de observables**</summary>

Estos tutoriales se centran en la estimación de cantidades físicamente significativas, como valores de energía o correlación, mediante la preparación de estados cuánticos y la medición de observables. Las técnicas incluyen enfoques de circuitos variacionales y trotterizados que equilibran la expresividad del circuito con la eficiencia en profundidad. Se hace énfasis en flujos de trabajo que reducen las demandas de recursos cuánticos manteniendo la precisión, y que permiten la estimación práctica de observables en sistemas químicos y físicos.

* [Diagonalización cuántica de Krylov de Hamiltonianos de red](/tutorials/krylov-quantum-diagonalization)

* [Transición de fase de Nishimori](/tutorials/nishimori-phase-transition)

* [Estimación de energía del estado fundamental de la cadena de Heisenberg con VQE](/tutorials/spin-chain-vqe)

* [Entrenamiento de kernel cuántico](/tutorials/quantum-kernel-training)

* [Mejore la clasificación de características usando kernels cuánticos proyectados](/tutorials/projected-quantum-kernels)

* [Desigualdad CHSH](/tutorials/chsh-inequality)

</details>

<details>
  <summary>**Algoritmos tolerantes a fallos**</summary>

Esta sección presenta algoritmos con garantías teóricas bien definidas que están diseñados para ejecutarse en futuro hardware cuántico con corrección de errores. Los circuitos o la sobrecarga de muestreo de estos algoritmos escalan de una manera que no es eficiente en profundidad y, por lo tanto, es más probable que demuestren ventaja cuántica cuando existan computadoras cuánticas tolerantes a fallos. Estos tutoriales ilustran cómo operan los métodos en entornos idealizados y demuestran ejemplos a pequeña escala.

* [Algoritmo de Shor](/tutorials/shors-algorithm)
* [Algoritmo de Grover](/tutorials/grovers-algorithm)

</details>

## Aproveche las capacidades de Qiskit {#leverage-qiskit-capabilities}

Esta sección presenta capacidades avanzadas dentro del ecosistema Qiskit que mejoran el rendimiento, la fiabilidad y la velocidad al ejecutar algoritmos cuánticos.

<details>
  <summary>**Optimización de cargas de trabajo**</summary>

La optimización de cargas de trabajo se centra en la orquestación eficiente de recursos clásicos y cuánticos o en métodos adaptados para mejorar la manipulación de circuitos cuánticos.

* [Evaluación comparativa de circuitos dinámicos con pares de Bell cortados](/tutorials/edc-cut-bell-pair-benchmarking)

* [Introducción a las puertas fraccionarias](/tutorials/fractional-gates)

* [Introducción al servicio de transpilación con IA de Qiskit](/tutorials/ai-transpiler-introduction)

* [Optimizaciones de transpilación con SABRE](/tutorials/transpilation-optimizations-with-sabre)

* [Métodos de compilación para circuitos de simulación Hamiltoniana](/tutorials/compilation-methods-for-hamiltonian-simulation-circuits)

* [Entrelazamiento de largo alcance con circuitos dinámicos](/tutorials/long-range-entanglement)

* [Simulación del Hamiltoniano de Ising pulsado con circuitos dinámicos](/tutorials/dc-hex-ising)

</details>

<details>
<summary>**Funciones de Qiskit**</summary>

Las Funciones de Qiskit son una colección de herramientas preempaquetadas de gestión de errores y aplicaciones, que facilitan el diseño de experimentos a gran escala con circuitos, moléculas, QUBOs y más.

- Diseñe nuevos algoritmos con **Funciones de circuito** -- con pipelines preconstruidos de transpilación, supresión de errores y mitigación de errores.

  * [Mitigación de errores con la función de circuito de IBM](/tutorials/error-mitigation-with-qiskit-functions)

  * [Modelo de Ising de campo transversal con la gestión de rendimiento de Q-CTRL](/tutorials/transverse-field-ising-model)

  * [Estimación de fase cuántica con las funciones de Qiskit de Q-CTRL](/tutorials/quantum-phase-estimation-qctrl)

  * [Simule Ising 2D con campo inclinado con la función QESEM](/tutorials/qedma-2d-ising-with-qesem)

- Experimente con problemas específicos de dominio con **Funciones de aplicación** -- con entradas y salidas familiares para solucionadores clásicos.

  * [Optimizador de cartera cuántica - Una función de Qiskit por Global Data Quantum](/tutorials/global-data-quantum-optimizer)

  * [Optimización binaria de orden superior con el solucionador de optimización de Q-CTRL](/tutorials/solve-higher-order-binary-optimization-problems-with-q-ctrls-optimization-solver)

  * [Modele un fluido no viscoso en movimiento usando QUICK-PDE](/tutorials/colibritd-pde)

  * [Curvas PES de disociación con Qunova HiVQE](/tutorials/qunova-hivqe)

  * [Clasificación de ensamble mejorada con computación cuántica híbrida (flujo de trabajo de estabilidad de red)](/tutorials/sml-classification)

  * [Resuelva el problema de división de mercado con el optimizador cuántico Iskay de Kipu Quantum](/tutorials/solve-market-split-problem-with-iskay-quantum-optimizer)

</details>

<details>
  <summary>**Complementos de Qiskit**</summary>

Los complementos permiten la manipulación avanzada de circuitos, como corte, retropropagación de observables o aproximación de circuitos, que permiten a los usuarios eludir las limitaciones del hardware a costa de una mayor sobrecarga de cómputo clásico.

* [Fórmulas de múltiples productos para reducir el error de Trotter](/tutorials/multi-product-formula)

* [Compilación cuántica aproximada para circuitos de evolución temporal](/tutorials/approximate-quantum-compilation-for-time-evolution)

* [Retropropagación de operadores (OBP) para la estimación de valores esperados](/tutorials/operator-back-propagation)

* [Corte de cables para la estimación de valores esperados](/tutorials/wire-cutting)

* [Corte de circuitos para condiciones de contorno periódicas](/tutorials/periodic-boundary-conditions-with-circuit-cutting)

* [Corte de circuitos para la reducción de profundidad](/tutorials/depth-reduction-with-circuit-cutting)

* [Mitigación de errores de lectura para la primitiva Sampler usando M3](/tutorials/readout-error-mitigation-sampler)

</details>

<details>
  <summary>**Mitigación de errores**</summary>

La mitigación de errores aborda el desafío del ruido sin tolerancia total a fallos, recuperando valores esperados precisos mediante la manipulación controlada de circuitos y el posprocesamiento.

* [Mitigación de errores a escala de utilidad con amplificación probabilística de errores](/tutorials/probabilistic-error-amplification)

* [Combine opciones de mitigación de errores con la primitiva Estimator](/tutorials/combine-error-mitigation-techniques)

* [Evaluación comparativa en tiempo real para la selección de qubits](/tutorials/real-time-benchmarking-for-qubit-selection)

</details>

<details>
  <summary>**Detección de errores**</summary>

La detección de errores identifica operaciones defectuosas para devolver resultados libres de ruido disparo por disparo mediante posprocesamiento.

* [Códigos de repetición](/tutorials/repetition-codes)

* [Detección de errores de baja sobrecarga con códigos de espacio-tiempo](/tutorials/ghz-spacetime-codes)

</details>

