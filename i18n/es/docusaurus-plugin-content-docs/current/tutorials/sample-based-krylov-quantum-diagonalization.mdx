---
title: "Diagonalización cuántica de Krylov basada en muestras de un modelo de red fermiónica"
sidebar_label: "Diagonalización cuántica de Krylov basada en muestras de un modelo de red fermiónica"
description: "Utilice el algoritmo de diagonalización cuántica basada en muestras para simular el modelo de Anderson de impureza única usando hardware cuántico ruidoso."
notebook_path: "docs/tutorials/sample-based-krylov-quantum-diagonalization.ipynb"
---
{/* doqumentation-source-hash: 63a6f4c2 */}

<OpenInLabBanner notebookPath="docs/tutorials/sample-based-krylov-quantum-diagonalization.ipynb" />



{/* cspell:ignore fontdict fontsize nocc SQKD DMRG textrm varepsilon vecs pqrs ijkl */}

*Estimación de uso: Nueve segundos en un procesador Heron r2 (NOTA: Esto es solo una estimación. Su tiempo de ejecución puede variar.)*
## Contexto {#background}

Este tutorial muestra cómo utilizar la diagonalización cuántica basada en muestras (SQD) para estimar la energía del estado fundamental de un modelo de red fermiónica. Específicamente, estudiamos el modelo de Anderson de impureza única unidimensional (SIAM), que se utiliza para describir impurezas magnéticas embebidas en metales.

Este tutorial sigue un flujo de trabajo similar al del tutorial relacionado [Diagonalización cuántica basada en muestras de un hamiltoniano químico](/tutorials/sample-based-quantum-diagonalization). Sin embargo, una diferencia clave radica en cómo se construyen los circuitos cuánticos. El otro tutorial utiliza un ansatz variacional heurístico, que resulta atractivo para hamiltonianos químicos con potencialmente millones de términos de interacción. Por otro lado, este tutorial utiliza circuitos que aproximan la evolución temporal del hamiltoniano. Tales circuitos pueden ser profundos, lo que hace que este enfoque sea más adecuado para aplicaciones a modelos de red. Los vectores de estado preparados por estos circuitos forman la base de un [subespacio de Krylov](https://en.wikipedia.org/wiki/Krylov_subspace), y como resultado, el algoritmo converge de manera demostrable y eficiente al estado fundamental, bajo suposiciones adecuadas.

El enfoque utilizado en este tutorial puede verse como una combinación de las técnicas empleadas en SQD y la [diagonalización cuántica de Krylov (KQD)](https://arxiv.org/abs/2407.14431). El enfoque combinado a veces se denomina diagonalización cuántica de Krylov basada en muestras (SQKD). Consulte [Diagonalización cuántica de Krylov de hamiltonianos de red](/tutorials/krylov-quantum-diagonalization) para un tutorial sobre el método KQD.

Este tutorial se basa en el trabajo ["Quantum-Centric Algorithm for Sample-Based Krylov Diagonalization"](https://arxiv.org/abs/2501.09702), al cual se puede consultar para obtener más detalles.

### Modelo de Anderson de impureza única (SIAM) {#single-impurity-anderson-model-siam}

El hamiltoniano SIAM unidimensional es una suma de tres términos:

$$
H = H_{\textrm{imp}}+ H_\textrm{bath} + H_\textrm{hyb},
$$

donde

$$
\begin{align*}
  H_\textrm{imp} &= \varepsilon \left( \hat{n}_{d\uparrow} + \hat{n}_{d\downarrow} \right) + U \hat{n}_{d\uparrow}\hat{n}_{d\downarrow}, \\
  H_\textrm{bath} &= -t \sum_{\substack{\mathbf{j} = 0\\ \sigma\in \{\uparrow, \downarrow\}}}^{L-1} \left(\hat{c}^\dagger_{\mathbf{j}, \sigma}\hat{c}_{\mathbf{j}+1, \sigma} + \hat{c}^\dagger_{\mathbf{j}+1, \sigma}\hat{c}_{\mathbf{j}, \sigma} \right), \\
  H_\textrm{hyb} &= V\sum_{\sigma \in \{\uparrow, \downarrow \}} \left(\hat{d}^\dagger_\sigma \hat{c}_{0, \sigma} + \hat{c}^\dagger_{0, \sigma} \hat{d}_{\sigma} \right).
\end{align*}
$$

Aquí, $c^\dagger_{\mathbf{j},\sigma}/c_{\mathbf{j},\sigma}$ son los operadores fermiónicos de creación/aniquilación para el sitio $\mathbf{j}^{\textrm{th}}$ del baño con espín $\sigma$, $\hat{d}^\dagger_{\sigma}/\hat{d}_{\sigma}$ son operadores de creación/aniquilación para el modo de impureza, y $\hat{n}_{d\sigma} = \hat{d}^\dagger_{\sigma} \hat{d}_{\sigma}$. $t$, $U$ y $V$ son números reales que describen las interacciones de salto, en sitio e hibridación, y $\varepsilon$ es un número real que especifica el potencial químico.

Tenga en cuenta que el hamiltoniano es una instancia específica del hamiltoniano genérico de electrones interactuantes,

$$
\begin{align*}
  H &= \sum_{\substack{p, q \\ \sigma}} h_{pq} \hat{a}^\dagger_{p\sigma} \hat{a}_{q\sigma}  +  \sum_{\substack{p, q, r, s \\ \sigma \tau}} \frac{h_{pqrs}}{2} \hat{a}^\dagger_{p\sigma} \hat{a}^\dagger_{q\tau} \hat{a}_{s\tau} \hat{a}_{r\sigma} \\
  &= H_1 + H_2,
\end{align*}
$$

donde $H_1$ consta de términos de un cuerpo, que son cuadráticos en los operadores fermiónicos de creación y aniquilación, y $H_2$ consta de términos de dos cuerpos, que son cuárticos. Para el SIAM,
$$
H_2 = U \hat{n}_{d\uparrow}\hat{n}_{d\downarrow}
$$

y $H_1$ contiene el resto de los términos del hamiltoniano. Para representar el hamiltoniano programáticamente, almacenamos la matriz $h_{pq}$ y el tensor $h_{pqrs}$.

### Bases de posición y momento {#position-and-momentum-bases}

Debido a la simetría traslacional aproximada en $H_\textrm{bath}$, no esperamos que el estado fundamental sea disperso en la base de posición (la base orbital en la que se especifica el hamiltoniano arriba). El rendimiento de SQD está garantizado solo si el estado fundamental es disperso, es decir, tiene peso significativo en solo un número pequeño de estados de la base computacional. Para mejorar la dispersión del estado fundamental, realizamos la simulación en la base orbital en la que $H_\textrm{bath}$ es diagonal. Llamamos a esta base la *base de momento*. Dado que $H_\textrm{bath}$ es un hamiltoniano fermiónico cuadrático, puede diagonalizarse eficientemente mediante una rotación orbital.

### Evolución temporal aproximada por el hamiltoniano {#approximate-time-evolution-by-the-hamiltonian}

Para aproximar la evolución temporal por el hamiltoniano, utilizamos una descomposición de Trotter-Suzuki de segundo orden,

$$
  e^{-i \Delta t H} \approx e^{-i\frac{\Delta t}{2} H_2} e^{-i\Delta t H_1} e^{-i\frac{\Delta t}{2} H_2}.
$$

Bajo la [transformación de Jordan-Wigner](https://en.wikipedia.org/wiki/Jordan%E2%80%93Wigner_transformation), la evolución temporal por $H_2$ equivale a una sola compuerta [CPhase](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.CPhaseGate) entre los orbitales de espín hacia arriba y hacia abajo en el sitio de impureza. Dado que $H_1$ es un hamiltoniano fermiónico cuadrático, la evolución temporal por $H_1$ equivale a una rotación orbital.

Los estados base de Krylov $\{ |\psi_k\rangle \}_{k=0}^{D-1}$, donde $D$ es la dimensión del subespacio de Krylov, se forman mediante la aplicación repetida de un solo paso de Trotter, de modo que

$$
  |\psi_k\rangle \approx \left[e^{-i\frac{\Delta t}{2} H_2} e^{-i\Delta t H_1} e^{-i\frac{\Delta t}{2} H_2} \right]^k\ket{\psi_0}.
$$

En el siguiente flujo de trabajo basado en SQD, muestrearemos a partir de este conjunto de circuitos y procesaremos el conjunto combinado de cadenas de bits con SQD. Este enfoque contrasta con el utilizado en el tutorial relacionado [Diagonalización cuántica basada en muestras de un hamiltoniano químico](/tutorials/sample-based-quantum-diagonalization), donde las muestras se extrajeron de un único circuito variacional heurístico.
## Requisitos {#requirements}

Antes de comenzar este tutorial, asegúrese de tener instalado lo siguiente:

- Qiskit SDK v1.0 o posterior, con soporte de [visualización](https://docs.quantum.ibm.com/api/qiskit/visualization)
- Qiskit Runtime v0.22 o posterior (`pip install qiskit-ibm-runtime`)
- SQD Qiskit addon v0.11 o posterior (`pip install qiskit-addon-sqd`)
- ffsim (`pip install ffsim`)
## Paso 1: Mapear el problema a un circuito cuántico {#step-1-map-problem-to-a-quantum-circuit}
Primero, generamos el hamiltoniano SIAM en la base de posición. El hamiltoniano se representa mediante la matriz $h_{pq}$ y el tensor $h_{pqrs}$. Luego, lo rotamos a la base de momento. En la base de posición, colocamos la impureza en el primer sitio. Sin embargo, cuando rotamos a la base de momento, movemos la impureza a un sitio central para facilitar las interacciones con otros orbitales.

```python
# Added by doQumentation — installs packages not in the Binder environment
%pip install -q ffsim qiskit-addon-sqd
```

```python
import numpy as np

def siam_hamiltonian(
    norb: int,
    hopping: float,
    onsite: float,
    hybridization: float,
    chemical_potential: float,
) -> tuple[np.ndarray, np.ndarray]:
    """Hamiltonian for the single-impurity Anderson model."""
    # Place the impurity on the first site
    impurity_orb = 0

    # One body matrix elements in the "position" basis
    h1e = np.zeros((norb, norb))
    np.fill_diagonal(h1e[:, 1:], -hopping)
    np.fill_diagonal(h1e[1:, :], -hopping)
    h1e[impurity_orb, impurity_orb + 1] = -hybridization
    h1e[impurity_orb + 1, impurity_orb] = -hybridization
    h1e[impurity_orb, impurity_orb] = chemical_potential

    # Two body matrix elements in the "position" basis
    h2e = np.zeros((norb, norb, norb, norb))
    h2e[impurity_orb, impurity_orb, impurity_orb, impurity_orb] = onsite

    return h1e, h2e

def momentum_basis(norb: int) -> np.ndarray:
    """Get the orbital rotation to change from the position to the momentum basis."""
    n_bath = norb - 1

    # Orbital rotation that diagonalizes the bath (non-interacting system)
    hopping_matrix = np.zeros((n_bath, n_bath))
    np.fill_diagonal(hopping_matrix[:, 1:], -1)
    np.fill_diagonal(hopping_matrix[1:, :], -1)
    _, vecs = np.linalg.eigh(hopping_matrix)

    # Expand to include impurity
    orbital_rotation = np.zeros((norb, norb))
    # Impurity is on the first site
    orbital_rotation[0, 0] = 1
    orbital_rotation[1:, 1:] = vecs

    # Move the impurity to the center
    new_index = n_bath // 2
    perm = np.r_[1 : (new_index + 1), 0, (new_index + 1) : norb]
    orbital_rotation = orbital_rotation[:, perm]

    return orbital_rotation

def rotated(
    h1e: np.ndarray, h2e: np.ndarray, orbital_rotation: np.ndarray
) -> tuple[np.ndarray, np.ndarray]:
    """Rotate the orbital basis of a Hamiltonian."""
    h1e_rotated = np.einsum(
        "ab,Aa,Bb->AB",
        h1e,
        orbital_rotation,
        orbital_rotation.conj(),
        optimize="greedy",
    )
    h2e_rotated = np.einsum(
        "abcd,Aa,Bb,Cc,Dd->ABCD",
        h2e,
        orbital_rotation,
        orbital_rotation.conj(),
        orbital_rotation,
        orbital_rotation.conj(),
        optimize="greedy",
    )
    return h1e_rotated, h2e_rotated

# Total number of spatial orbitals, including the bath sites and the impurity
# This should be an even number
norb = 20

# System is half-filled
nelec = (norb // 2, norb // 2)
# One orbital is the impurity, the rest are bath sites
n_bath = norb - 1

# Hamiltonian parameters
hybridization = 1.0
hopping = 1.0
onsite = 10.0
chemical_potential = -0.5 * onsite

# Generate Hamiltonian in position basis
h1e, h2e = siam_hamiltonian(
    norb=norb,
    hopping=hopping,
    onsite=onsite,
    hybridization=hybridization,
    chemical_potential=chemical_potential,
)

# Rotate to momentum basis
orbital_rotation = momentum_basis(norb)
h1e_momentum, h2e_momentum = rotated(h1e, h2e, orbital_rotation.T.conj())
# In the momentum basis, the impurity is placed in the center
impurity_index = n_bath // 2
```

A continuación, generamos los circuitos para producir los estados base de Krylov.
Para cada especie de espín, el estado inicial $\ket{\psi_0}$ está dado por la superposición de todas las excitaciones posibles de los tres electrones más cercanos al nivel de Fermi en los 4 modos vacíos más cercanos partiendo del estado $|00\cdots 0011 \cdots 11\rangle$, y se realiza mediante la aplicación de siete [XXPlusYYGate](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.XXPlusYYGate)s.
Los estados evolucionados en el tiempo se producen mediante aplicaciones sucesivas de un paso de Trotter de segundo orden.

Para una descripción más detallada de este modelo y cómo se diseñan los circuitos, consulte ["Quantum-Centric Algorithm for Sample-Based Krylov Diagonalization"](https://arxiv.org/abs/2501.09702).

```python
from typing import Sequence

import ffsim
import scipy
from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit import CircuitInstruction, Qubit
from qiskit.circuit.library import CPhaseGate, XGate, XXPlusYYGate

def prepare_initial_state(qubits: Sequence[Qubit], norb: int, nocc: int):
    """Prepare initial state."""
    x_gate = XGate()
    rot = XXPlusYYGate(0.5 * np.pi, -0.5 * np.pi)
    for i in range(nocc):
        yield CircuitInstruction(x_gate, [qubits[i]])
        yield CircuitInstruction(x_gate, [qubits[norb + i]])
    for i in range(3):
        for j in range(nocc - i - 1, nocc + i, 2):
            yield CircuitInstruction(rot, [qubits[j], qubits[j + 1]])
            yield CircuitInstruction(
                rot, [qubits[norb + j], qubits[norb + j + 1]]
            )
    yield CircuitInstruction(rot, [qubits[j + 1], qubits[j + 2]])
    yield CircuitInstruction(
        rot, [qubits[norb + j + 1], qubits[norb + j + 2]]
    )

def trotter_step(
    qubits: Sequence[Qubit],
    time_step: float,
    one_body_evolution: np.ndarray,
    h2e: np.ndarray,
    impurity_index: int,
    norb: int,
):
    """A Trotter step."""
    # Assume the two-body interaction is just the on-site interaction of the impurity
    onsite = h2e[
        impurity_index, impurity_index, impurity_index, impurity_index
    ]
    # Two-body evolution for half the time
    yield CircuitInstruction(
        CPhaseGate(-0.5 * time_step * onsite),
        [qubits[impurity_index], qubits[norb + impurity_index]],
    )
    # One-body evolution for the full time
    yield CircuitInstruction(
        ffsim.qiskit.OrbitalRotationJW(norb, one_body_evolution), qubits
    )
    # Two-body evolution for half the time
    yield CircuitInstruction(
        CPhaseGate(-0.5 * time_step * onsite),
        [qubits[impurity_index], qubits[norb + impurity_index]],
    )

# Time step
time_step = 0.2
# Number of Krylov basis states
krylov_dim = 8

# Initialize circuit
qubits = QuantumRegister(2 * norb, name="q")
circuit = QuantumCircuit(qubits)

# Generate initial state
for instruction in prepare_initial_state(qubits, norb=norb, nocc=norb // 2):
    circuit.append(instruction)
circuit.measure_all()

# Create list of circuits, starting with the initial state circuit
circuits = [circuit.copy()]

# Add time evolution circuits to the list
one_body_evolution = scipy.linalg.expm(-1j * time_step * h1e_momentum)
for i in range(krylov_dim - 1):
    # Remove measurements
    circuit.remove_final_measurements()
    # Append another Trotter step
    for instruction in trotter_step(
        qubits,
        time_step,
        one_body_evolution,
        h2e_momentum,
        impurity_index,
        norb,
    ):
        circuit.append(instruction)
    # Measure qubits
    circuit.measure_all()
    # Add a copy of the circuit to the list
    circuits.append(circuit.copy())
```

```python
circuits[0].draw("mpl", scale=0.4, fold=-1)
```

![Output of the previous code cell](/docs/images/tutorials/sample-based-krylov-quantum-diagonalization/extracted-outputs/9f2cc4d4-ecac-457a-bcae-558319668e1f-0.avif)

```python
circuits[-1].draw("mpl", scale=0.4, fold=-1)
```

![Output of the previous code cell](/docs/images/tutorials/sample-based-krylov-quantum-diagonalization/extracted-outputs/827976ec-4815-4707-80b1-e13fb2fef309-0.avif)
## Paso 2: Optimizar el problema para la ejecución cuántica {#step-2-optimize-problem-for-quantum-execution}
Ahora que hemos creado los circuitos, podemos optimizarlos para un hardware objetivo. Seleccionamos la QPU menos ocupada con al menos 127 qubits. Consulte la [documentación de Qiskit IBM&reg; Runtime](/guides/get-started-with-primitives#get-started-with-sampler) para obtener más información.

```python
from qiskit_ibm_runtime import QiskitRuntimeService

service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=127
)
print(f"Using backend {backend.name}")
```

```text
Using backend ibm_fez
```

Ahora, utilizamos Qiskit para transpilar los circuitos al backend objetivo.

```python
from qiskit.transpiler import generate_preset_pass_manager

pass_manager = generate_preset_pass_manager(
    optimization_level=3, backend=backend
)
isa_circuits = pass_manager.run(circuits)
```

## Paso 3: Ejecutar utilizando las primitivas de Qiskit {#step-3-execute-by-using-qiskit-primitives}
Después de optimizar los circuitos para la ejecución en hardware, estamos listos para ejecutarlos en el hardware objetivo y recopilar muestras para la estimación de la energía del estado fundamental. Después de utilizar la primitiva Sampler para muestrear cadenas de bits de cada circuito, combinamos todos los resultados en un único diccionario de conteos y graficamos las 20 cadenas de bits muestreadas con mayor frecuencia.

```python
from qiskit.visualization import plot_histogram
from qiskit_ibm_runtime import SamplerV2 as Sampler

# Sample from the circuits
sampler = Sampler(backend)
job = sampler.run(isa_circuits, shots=500)
```

```python
from qiskit.primitives import BitArray

# Combine the counts from the individual Trotter circuits
bit_array = BitArray.concatenate_shots(
    [result.data.meas for result in job.result()]
)

plot_histogram(bit_array.get_counts(), number_to_keep=20)
```

![Salida de la celda de código anterior](/docs/images/tutorials/sample-based-krylov-quantum-diagonalization/extracted-outputs/10af4663-7375-4b50-bae6-9f3d5106457b-0.avif)

## Paso 4: Post-procesar y devolver el resultado en el formato clásico deseado {#step-4-post-process-and-return-result-to-desired-classical-format}
Ahora, ejecutamos el algoritmo SQD utilizando la función `diagonalize_fermionic_hamiltonian`. Consulte la [documentación de la API](https://qiskit.github.io/qiskit-addon-sqd/apidocs/qiskit_addon_sqd.fermion.html#qiskit_addon_sqd.fermion.diagonalize_fermionic_hamiltonian) para obtener explicaciones de los argumentos de esta función.

```python
from qiskit_addon_sqd.fermion import (
    SCIResult,
    diagonalize_fermionic_hamiltonian,
)

# List to capture intermediate results
result_history = []

def callback(results: list[SCIResult]):
    result_history.append(results)
    iteration = len(result_history)
    print(f"Iteration {iteration}")
    for i, result in enumerate(results):
        print(f"\tSubsample {i}")
        print(f"\t\tEnergy: {result.energy}")
        print(
            f"\t\tSubspace dimension: {np.prod(result.sci_state.amplitudes.shape)}"
        )

rng = np.random.default_rng(24)
result = diagonalize_fermionic_hamiltonian(
    h1e_momentum,
    h2e_momentum,
    bit_array,
    samples_per_batch=100,
    norb=norb,
    nelec=nelec,
    num_batches=3,
    max_iterations=5,
    symmetrize_spin=True,
    callback=callback,
    seed=rng,
)
```

```text
Iteration 1
	Subsample 0
		Energy: -28.61321893815165
		Subspace dimension: 10609
	Subsample 1
		Energy: -28.628985564542244
		Subspace dimension: 13924
	Subsample 2
		Energy: -28.620151775558114
		Subspace dimension: 10404
Iteration 2
	Subsample 0
		Energy: -28.656893066053115
		Subspace dimension: 34225
	Subsample 1
		Energy: -28.65277622004119
		Subspace dimension: 38416
	Subsample 2
		Energy: -28.670856034959165
		Subspace dimension: 39601
Iteration 3
	Subsample 0
		Energy: -28.684787675404362
		Subspace dimension: 42436
	Subsample 1
		Energy: -28.676984757118426
		Subspace dimension: 50176
	Subsample 2
		Energy: -28.671581704249885
		Subspace dimension: 40804
Iteration 4
	Subsample 0
		Energy: -28.6859683054753
		Subspace dimension: 47961
	Subsample 1
		Energy: -28.69418206537316
		Subspace dimension: 51529
	Subsample 2
		Energy: -28.686083516445752
		Subspace dimension: 51529
Iteration 5
	Subsample 0
		Energy: -28.694665630711178
		Subspace dimension: 50625
	Subsample 1
		Energy: -28.69505984237118
		Subspace dimension: 47524
	Subsample 2
		Energy: -28.6942873883992
		Subspace dimension: 48841
```

La siguiente celda de código grafica los resultados. El primer gráfico muestra la energía calculada como función del número de iteraciones de recuperación de configuración, y el segundo gráfico muestra la ocupación promedio de cada orbital espacial después de la iteración final. Para la energía de referencia, utilizamos los resultados de un cálculo [DMRG](https://en.wikipedia.org/wiki/Density_matrix_renormalization_group) que se realizó por separado.

```python
import matplotlib.pyplot as plt

dmrg_energy = -28.70659686

min_es = [
    min(result, key=lambda res: res.energy).energy
    for result in result_history
]
min_id, min_e = min(enumerate(min_es), key=lambda x: x[1])

# Data for energies plot
x1 = range(len(result_history))

# Data for avg spatial orbital occupancy
y2 = np.sum(result.orbital_occupancies, axis=0)
x2 = range(len(y2))

fig, axs = plt.subplots(1, 2, figsize=(12, 6))

# Plot energies
axs[0].plot(x1, min_es, label="energy", marker="o")
axs[0].set_xticks(x1)
axs[0].set_xticklabels(x1)
axs[0].axhline(
    y=dmrg_energy, color="#BF5700", linestyle="--", label="DMRG energy"
)
axs[0].set_title("Approximated Ground State Energy vs SQD Iterations")
axs[0].set_xlabel("Iteration Index", fontdict={"fontsize": 12})
axs[0].set_ylabel("Energy", fontdict={"fontsize": 12})
axs[0].legend()

# Plot orbital occupancy
axs[1].bar(x2, y2, width=0.8)
axs[1].set_xticks(x2)
axs[1].set_xticklabels(x2)
axs[1].set_title("Avg Occupancy per Spatial Orbital")
axs[1].set_xlabel("Orbital Index", fontdict={"fontsize": 12})
axs[1].set_ylabel("Avg Occupancy", fontdict={"fontsize": 12})

print(f"Reference (DMRG) energy: {dmrg_energy:.5f}")
print(f"SQD energy: {min_e:.5f}")
print(f"Absolute error: {abs(min_e - dmrg_energy):.5f}")
plt.tight_layout()
plt.show()
```

```text
Reference (DMRG) energy: -28.70660
SQD energy: -28.69506
Absolute error: 0.01154
```

![Salida de la celda de código anterior](/docs/images/tutorials/sample-based-krylov-quantum-diagonalization/extracted-outputs/b6879566-8bf5-4c28-bfb6-b2686692e3d3-1.avif)

### Verificación de la energía {#verifying-the-energy}

La energía devuelta por SQD está garantizada como una cota superior de la verdadera energía del estado fundamental. El valor de la energía puede verificarse porque SQD también devuelve los coeficientes del vector de estado que aproxima el estado fundamental. Usted puede calcular la energía a partir del vector de estado utilizando sus matrices de densidad reducida de 1 y 2 partículas, como se demuestra en la siguiente celda de código.

```python
rdm1 = result.sci_state.rdm(rank=1, spin_summed=True)
rdm2 = result.sci_state.rdm(rank=2, spin_summed=True)

energy = np.sum(h1e_momentum * rdm1) + 0.5 * np.sum(h2e_momentum * rdm2)

print(f"Recomputed energy: {energy:.5f}")
```

```text
Recomputed energy: -28.69506
```

## Referencias {#references}

- [Quantum-Centric Algorithm for Sample-Based Krylov Diagonalization (artículo SKQD)](https://arxiv.org/abs/2501.09702)
- [Chemistry Beyond Exact Solutions on a Quantum-Centric Supercomputer (artículo SQD)](https://arxiv.org/abs/2405.05068)
