---
title: "Introducción al servicio de transpilación con IA de Qiskit"
sidebar_label: "Introducción al servicio de transpilación con IA de Qiskit"
description: "En este cuaderno, exploraremos los beneficios clave del servicio de transpilación con IA de Qiskit y cómo se compara con los métodos tradicionales."
notebook_path: "docs/tutorials/ai-transpiler-introduction.ipynb"
---
{/* doqumentation-source-hash: 3bc5a35e */}

<OpenInLabBanner notebookPath="docs/tutorials/ai-transpiler-introduction.ipynb" />



{/* cspell:ignore fontsize idxmin */}

*Uso estimado de QPU: Ninguno (NOTA: Este tutorial no ejecuta trabajos porque se centra en la transpilación)*

## Antecedentes {#background}

El **servicio de transpilación con IA de Qiskit (QTS)** introduce optimizaciones basadas en aprendizaje automático tanto en los pases de enrutamiento como en los de síntesis. Estos modos de IA han sido diseñados para abordar las limitaciones de la transpilación tradicional, particularmente para circuitos a gran escala y topologías de hardware complejas.

A partir de **julio de 2025**, el **Servicio de Transpilación** ha sido migrado a la nueva plataforma IBM Quantum&reg; y ya no está disponible. Para las últimas actualizaciones sobre el estado del Servicio de Transpilación, consulte la [documentación del servicio de transpilación](/guides/qiskit-transpiler-service). Aún puede utilizar el transpilador con IA localmente, de manera similar a la transpilación estándar de Qiskit. Simplemente reemplace `generate_preset_pass_manager()` con `generate_ai_pass_manager()`. Esta función construye un gestor de pases que integra los pases de enrutamiento y síntesis con IA directamente en su flujo de trabajo de transpilación local.

### Características clave de los pases de IA {#key-features-of-ai-passes}

- Pases de enrutamiento: El enrutamiento con IA puede ajustar dinámicamente las rutas de los qubits según el circuito y el backend específicos, reduciendo la necesidad de compuertas SWAP excesivas.
    - `AIRouting`: Selección de diseño y enrutamiento de circuitos

- Pases de síntesis: Las técnicas de IA optimizan la descomposición de compuertas multi-qubit, minimizando el número de compuertas de dos qubits, que suelen ser más propensas a errores.
    - `AICliffordSynthesis`: Síntesis de compuertas Clifford
    - `AILinearFunctionSynthesis`: Síntesis de circuitos de funciones lineales
    - `AIPermutationSynthesis`: Síntesis de circuitos de permutación
    - `AIPauliNetworkSynthesis`: Síntesis de circuitos de redes de Pauli (solo disponible en el Servicio de Transpilación de Qiskit, no en el entorno local)

- Comparación con la transpilación tradicional: El transpilador estándar de Qiskit es una herramienta robusta que puede manejar un amplio espectro de circuitos cuánticos de manera efectiva. Sin embargo, cuando los circuitos crecen en escala o las configuraciones de hardware se vuelven más complejas, los pases de IA pueden ofrecer ganancias de optimización adicionales. Al utilizar modelos aprendidos para el enrutamiento y la síntesis, QTS refina aún más los diseños de circuitos y reduce la sobrecarga para tareas cuánticas desafiantes o a gran escala.

Este tutorial evalúa los modos de IA utilizando tanto pases de enrutamiento como de síntesis, comparando los resultados con la transpilación tradicional para resaltar dónde la IA ofrece ganancias de rendimiento.

Para más detalles sobre los pases de IA disponibles, consulte la [documentación de pases de IA](/guides/ai-transpiler-passes).

### ¿Por qué utilizar IA para la transpilación de circuitos cuánticos? {#why-use-ai-for-quantum-circuit-transpilation}

A medida que los circuitos cuánticos crecen en tamaño y complejidad, los métodos de transpilación tradicionales tienen dificultades para optimizar los diseños y reducir los conteos de compuertas de manera eficiente. Los circuitos más grandes, particularmente aquellos que involucran cientos de qubits, imponen desafíos significativos en el enrutamiento y la síntesis debido a las restricciones del dispositivo, la conectividad limitada y las tasas de error de los qubits.

Aquí es donde la transpilación con IA ofrece una solución potencial. Al aprovechar técnicas de aprendizaje automático, el transpilador con IA en Qiskit puede tomar decisiones más inteligentes sobre el enrutamiento de qubits y la síntesis de compuertas, lo que lleva a una mejor optimización de circuitos cuánticos a gran escala.

### Resultados breves de benchmarking {#brief-benchmarking-results}
![Graph showing AI transpiler performance against Qiskit](/docs/images/tutorials/ai-transpiler-introduction/ai-transpiler-benchmarks.avif)

En las pruebas de benchmarking, el transpilador con IA produjo consistentemente circuitos menos profundos y de mayor calidad en comparación con el transpilador estándar de Qiskit. Para estas pruebas, utilizamos la estrategia predeterminada del gestor de pases de Qiskit, configurada con [`generate_preset_passmanager`]. Si bien esta estrategia predeterminada es a menudo efectiva, puede tener dificultades con circuitos más grandes o más complejos. En contraste, los pases con IA lograron una reducción promedio del 24% en los conteos de compuertas de dos qubits y una reducción del 36% en la profundidad del circuito para circuitos grandes (más de 100 qubits) al transpilar a la topología heavy-hex del hardware de IBM Quantum. Para más información sobre estos benchmarks, consulte este [blog.](https://www.ibm.com/quantum/blog/qiskit-performance)

Este tutorial explora los beneficios clave de los pases de IA y cómo se comparan con los métodos tradicionales.

```python
# Added by doQumentation — installs packages not in the Binder environment
%pip install -q qiskit-ibm-transpiler
```

```python
# This cell is hidden from users;
# it just disables a linting rule.
# ruff: noqa: F811
```

## Requisitos {#requirements}

Antes de comenzar este tutorial, asegúrese de tener lo siguiente instalado:

* Qiskit SDK v1.0 o posterior, con soporte de [visualización](https://docs.quantum.ibm.com/api/qiskit/visualization)
* Qiskit Runtime (`pip install qiskit-ibm-runtime`) v0.22 o posterior
* Qiskit IBM&reg; Transpiler con modo local de IA (`pip install 'qiskit-ibm-transpiler[ai-local-mode]'`)
## Configuración {#setup}

```python
from qiskit import QuantumCircuit
from qiskit.circuit.library import efficient_su2, PermutationGate
from qiskit.synthesis.qft import synth_qft_full
from qiskit.circuit.random import random_circuit, random_clifford_circuit
from qiskit.transpiler import generate_preset_pass_manager, CouplingMap
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_transpiler import generate_ai_pass_manager
from qiskit.synthesis.permutation import (
    synth_permutation_depth_lnn_kms,
    synth_permutation_basic,
)
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import time
import logging

seed = 42

# Used for generating permutation circuits in part two for comparison
def generate_permutation_circuit(width, pattern):
    circuit = QuantumCircuit(width)
    circuit.append(
        PermutationGate(pattern=pattern),
        qargs=range(width),
    )
    return circuit

# Creates a Bernstein-Vazirani circuit given the number of qubits
def create_bv_circuit(num_qubits):
    qc = QuantumCircuit(num_qubits, num_qubits - 1)
    qc.x(num_qubits - 1)
    qc.h(qc.qubits)
    for i in range(num_qubits - 1):
        qc.cx(i, num_qubits - 1)
    qc.h(qc.qubits[:-1])
    return qc

# Transpile a circuit with a given pass manager and return metrics
def transpile_with_metrics(pass_manager, circuit):
    start = time.time()
    qc_out = pass_manager.run(circuit)
    elapsed = time.time() - start

    depth_2q = qc_out.depth(lambda x: x.operation.num_qubits == 2)
    gate_count = qc_out.size()

    return qc_out, {
        "depth_2q": depth_2q,
        "gate_count": gate_count,
        "time_s": elapsed,
    }

# Used for collecting metrics for part 3 of synthesis methods
def synth_transpile_with_metrics(qc, pm, pattern_id, method):
    start = time.time()
    qc = pm.run(qc)
    elapsed = time.time() - start

    return {
        "Pattern": pattern_id,
        "Method": method,
        "Depth (2Q)": qc.depth(lambda x: x.operation.num_qubits == 2),
        "Gates": qc.size(),
        "Time (s)": elapsed,
    }

# Ignore logs like "INFO:qiskit_ibm_transpiler.wrappers.ai_local_synthesis:Running Linear Functions AI synthesis on local mode"

logging.getLogger(
    "qiskit_ibm_transpiler.wrappers.ai_local_synthesis"
).setLevel(logging.WARNING)
```

# Parte I. Patrones de Qiskit {#part-i-qiskit-patterns}

Veamos ahora cómo utilizar el servicio de transpilación con IA con un circuito cuántico simple, usando patrones de Qiskit. La clave es crear un `PassManager` con `generate_ai_pass_manager()` en lugar del estándar `generate_preset_pass_manager()`.
## Paso 1: Mapear entradas clásicas a un problema cuántico {#step-1-map-classical-inputs-to-a-quantum-problem}

En esta sección, probaremos el transpilador con IA en el circuito `efficient_su2`, un ansatz eficiente en hardware ampliamente utilizado. Este circuito es particularmente relevante para algoritmos cuánticos variacionales (por ejemplo, VQE) y tareas de aprendizaje automático cuántico, lo que lo convierte en un caso de prueba ideal para evaluar el rendimiento de la transpilación.

El circuito `efficient_su2` consiste en capas alternadas de rotaciones de un solo qubit y compuertas de entrelazamiento como CNOTs. Estas capas permiten una exploración flexible del espacio de estados cuánticos mientras mantienen la profundidad de compuertas manejable. Al optimizar este circuito, buscamos reducir el conteo de compuertas, mejorar la fidelidad y minimizar el ruido. Esto lo convierte en un candidato sólido para probar la eficiencia del transpilador con IA.

```python
# For our transpilation, we will use a large circuit of 101 qubits
qc = efficient_su2(90, entanglement="circular", reps=1).decompose()

# Draw a smaller version of the circuit to get a visual representation
qc_small = efficient_su2(5, entanglement="circular", reps=1).decompose()
qc_small.draw(output="mpl")
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/c6e9c2c0-e02c-4276-bae8-d5692e60b6b8-0.avif)

## Paso 2: Optimizar el problema para la ejecución en hardware cuántico {#step-2-optimize-problem-for-quantum-hardware-execution}

### Elegir un backend {#choose-a-backend}

Para este ejemplo, seleccionamos el backend operativo de IBM Quantum menos ocupado que no sea un simulador y que tenga al menos 100 qubits:

**Nota:** Dado que el backend menos ocupado puede cambiar con el tiempo, se pueden seleccionar diferentes dispositivos en diferentes ejecuciones. Las propiedades específicas del dispositivo, como los mapas de acoplamiento, pueden generar diferencias en los circuitos transpilados.

```python
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=100
)
cm = backend.coupling_map
print(f"Using backend: {backend.name}")
```

```text
Using backend: ibm_torino
```

### Crear gestores de pases con IA y tradicionales {#create-ai-and-traditional-pass-managers}
Para evaluar la efectividad del transpilador con IA, realizaremos dos ejecuciones de transpilación. Primero, transpilaremos el circuito utilizando el transpilador con IA. Luego, ejecutaremos una comparación transpilando el mismo circuito sin el transpilador con IA, utilizando métodos tradicionales. Ambos procesos de transpilación utilizarán el mismo mapa de acoplamiento del backend elegido y el nivel de optimización establecido en 3 para una comparación justa.

Ambos métodos reflejan el enfoque estándar para crear instancias de `PassManager` para transpilar circuitos en Qiskit.

```python
pm_ai = generate_ai_pass_manager(
    optimization_level=3,
    ai_optimization_level=3,
    coupling_map=cm,
    include_ai_synthesis=True,  # used for part 3 when comparing synthesis methods
)

pm_no_ai = generate_preset_pass_manager(
    optimization_level=3,
    coupling_map=cm,
    seed_transpiler=seed,  # note that the AI pass manager does not currently support seeding
)
```

Transpile los circuitos y registre los tiempos.

```python
# Transpile using standard (non-AI) pass manager
_, metrics_no_ai = transpile_with_metrics(pm_no_ai, qc)
print(
    f"Standard transpilation: Depth (2q) {metrics_no_ai['depth_2q']}, "
    f"Gate count {metrics_no_ai['gate_count']}, Time {metrics_no_ai['time_s']}"
)

# Transpile using AI pass manager
_, metrics_ai = transpile_with_metrics(pm_ai, qc)
print(
    f"AI transpilation      : Depth (2q) {metrics_ai['depth_2q']}, "
    f"Gate count {metrics_ai['gate_count']}, Time {metrics_ai['time_s']}"
)
```

```text
Standard transpilation: Depth (2q) 95, Gate count 458, Time 0.04650712013244629
AI transpilation      : Depth (2q) 90, Gate count 456, Time 0.9342479705810547
```

En esta prueba, comparamos el rendimiento del transpilador con IA y el método de transpilación estándar en el circuito efficient_su2. El transpilador con IA logra una profundidad de circuito notablemente menor mientras mantiene un conteo de compuertas similar.

- **Profundidad del circuito:** El transpilador con IA produce un circuito con menor profundidad de dos qubits. Esto es esperado, ya que los pases de IA están entrenados para optimizar la profundidad aprendiendo patrones de interacción de qubits y explotando la conectividad del hardware de manera más efectiva que las heurísticas basadas en reglas.

- **Conteo de compuertas:** El conteo total de compuertas permanece similar entre los dos métodos. Esto se alinea con las expectativas ya que la transpilación estándar basada en SABRE minimiza explícitamente el conteo de swaps, que domina la sobrecarga de compuertas. El transpilador con IA, en cambio, prioriza la profundidad general y puede ocasionalmente intercambiar algunas compuertas adicionales por una ruta de ejecución más corta.

- **Tiempo de transpilación:** El transpilador con IA tarda más en ejecutarse que el método estándar. Esto se debe al costo computacional adicional de invocar modelos aprendidos durante el enrutamiento y la síntesis. En contraste, el transpilador basado en SABRE es ahora significativamente más rápido después de haber sido reescrito y optimizado en Rust, proporcionando un enrutamiento heurístico altamente eficiente a escala.

Es importante señalar que estos resultados se basan en un solo circuito. Para obtener una comprensión completa de cómo el transpilador con IA se compara con los métodos tradicionales, es necesario probar una variedad de circuitos. El rendimiento de QTS puede variar enormemente dependiendo del tipo de circuito que se está optimizando. Para una comparación más amplia, consulte los benchmarks anteriores o visite el [blog.](https://www.ibm.com/quantum/blog/qiskit-performance)
## Paso 3: Ejecutar utilizando primitivas de Qiskit {#step-3-execute-using-qiskit-primitives}
Como este tutorial se centra en la transpilación, no se ejecutarán experimentos en el dispositivo cuántico. El objetivo es aprovechar las optimizaciones del Paso 2 para obtener un circuito transpilado con profundidad o conteo de compuertas reducido.
## Paso 4: Post-procesar y devolver el resultado en el formato clásico deseado {#step-4-post-process-and-return-result-in-desired-classical-format}
Dado que no hay ejecución en este cuaderno, no hay resultados que post-procesar.
# Parte II. Analizar y evaluar los circuitos transpilados {#part-ii-analyze-and-benchmark-the-transpiled-circuits}

En esta sección, demostraremos cómo analizar el circuito transpilado y evaluarlo comparativamente con la versión original en mayor detalle. Nos centraremos en métricas como la profundidad del circuito, el conteo de compuertas y el tiempo de transpilación para evaluar la efectividad de la optimización. Además, discutiremos cómo los resultados pueden diferir entre varios tipos de circuitos, ofreciendo información sobre el rendimiento más amplio del transpilador en diferentes escenarios.

```python
# Circuits to benchmark
seed = 42
circuits = [
    {
        "name": "Random",
        "qc": random_circuit(num_qubits=30, depth=10, seed=seed),
    },
    {
        "name": "Clifford",
        "qc": random_clifford_circuit(
            num_qubits=40, num_gates=200, seed=seed
        ),
    },
    {
        "name": "QFT",
        "qc": synth_qft_full(num_qubits=20, do_swaps=False).decompose(),
    },
    {
        "name": "BV",
        "qc": create_bv_circuit(40),
    },
]

results = []

# Run the transpilation for each circuit and store the results
for circuit in circuits:
    qc_no_ai, metrics_no_ai = transpile_with_metrics(pm_no_ai, circuit["qc"])
    qc_ai, metrics_ai = transpile_with_metrics(pm_ai, circuit["qc"])

    print("Completed transpilation for", circuit["name"])

    results.append(
        {
            "Circuit": circuit["name"],
            "Depth 2Q (No AI)": metrics_no_ai["depth_2q"],
            "Gate Count (No AI)": metrics_no_ai["gate_count"],
            "Time (No AI)": metrics_no_ai["time_s"],
            "Depth 2Q (AI)": metrics_ai["depth_2q"],
            "Gate Count (AI)": metrics_ai["gate_count"],
            "Time (AI)": metrics_ai["time_s"],
        }
    )

df = pd.DataFrame(results)
df
```

```text
Completed transpilation for Random
Completed transpilation for Clifford
Completed transpilation for QFT
Completed transpilation for BV
```

```text
Circuit  Depth 2Q (No AI)  Gate Count (No AI)  Time (No AI)  \
0    Random                37                 221      0.039347
1  Clifford                36                 232      0.036633
2       QFT               165                 924      0.077458
3        BV                65                 155      0.024993

   Depth 2Q (AI)  Gate Count (AI)  Time (AI)
0             24              181   0.773718
1             43              267   1.097431
2            130              913   3.660771
3             70              155   0.345522
```

Reducción porcentual promedio para cada métrica. Los valores positivos son mejoras, los negativos son degradaciones.

```python
# Average reduction from non-AI to AI transpilation as a percentage
avg_reduction_depth = (
    (df["Depth 2Q (No AI)"] - df["Depth 2Q (AI)"]).mean()
    / df["Depth 2Q (No AI)"].mean()
    * 100
)
avg_reduction_gates = (
    (df["Gate Count (No AI)"] - df["Gate Count (AI)"]).mean()
    / df["Gate Count (No AI)"].mean()
    * 100
)
avg_reduction_time = (
    (df["Time (No AI)"] - df["Time (AI)"]).mean()
    / df["Time (No AI)"].mean()
    * 100
)

print(f"Average reduction in depth: {avg_reduction_depth:.2f}%")
print(f"Average reduction in gate count: {avg_reduction_gates:.2f}%")
print(f"Average reduction in transpilation time: {avg_reduction_time:.2f}%")
```

```text
Average reduction in depth: 11.88%
Average reduction in gate count: 1.04%
Average reduction in transpilation time: -3193.95%
```

```python
fig, axs = plt.subplots(1, 3, figsize=(21, 6))
df.plot(
    x="Circuit",
    y=["Depth 2Q (No AI)", "Depth 2Q (AI)"],
    kind="bar",
    ax=axs[0],
)
axs[0].set_title("Circuit Depth Comparison")
axs[0].set_ylabel("Depth")
axs[0].set_xlabel("Circuit")
axs[0].tick_params(axis="x", rotation=45)
df.plot(
    x="Circuit",
    y=["Gate Count (No AI)", "Gate Count (AI)"],
    kind="bar",
    ax=axs[1],
)
axs[1].set_title("Gate Count Comparison")
axs[1].set_ylabel("Gate Count")
axs[1].set_xlabel("Circuit")
axs[1].tick_params(axis="x", rotation=45)
df.plot(x="Circuit", y=["Time (No AI)", "Time (AI)"], kind="bar", ax=axs[2])
axs[2].set_title("Time Comparison")
axs[2].set_ylabel("Time (seconds)")
axs[2].set_xlabel("Circuit")
axs[2].tick_params(axis="x", rotation=45)
fig.suptitle(
    "Benchmarking AI transpilation vs Non-AI transpilation for various circuits"
)

plt.tight_layout()
plt.show()
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/79b8d5d9-0f9d-42ca-9583-8bec17430014-0.avif)

El rendimiento del transpilador con IA varía significativamente según el tipo de circuito que se está optimizando. En algunos casos, logra reducciones notables en la profundidad del circuito y el conteo de compuertas en comparación con el transpilador estándar. Sin embargo, estas mejoras a menudo vienen acompañadas de un aumento sustancial en el tiempo de ejecución.

Para ciertos tipos de circuitos, el transpilador con IA puede producir resultados ligeramente mejores en términos de profundidad del circuito, pero también puede generar un aumento en el conteo de compuertas y una penalización significativa en el tiempo de ejecución. Estas observaciones sugieren que los beneficios del transpilador con IA no son uniformes en todos los tipos de circuitos. En cambio, su efectividad depende de las características específicas del circuito, lo que lo hace más adecuado para algunos casos de uso que para otros.
## ¿Cuándo deberían los usuarios elegir la transpilación con IA? {#when-should-users-choose-ai-powered-transpilation}

El transpilador con IA en Qiskit sobresale en escenarios donde los métodos de transpilación tradicionales tienen dificultades, particularmente con circuitos cuánticos a gran escala y complejos. Para circuitos que involucran cientos de qubits o aquellos dirigidos a hardware con mapas de acoplamiento intrincados, el transpilador con IA ofrece una optimización superior en términos de profundidad del circuito, conteo de compuertas y eficiencia en el tiempo de ejecución. En las pruebas de benchmarking, ha superado consistentemente a los métodos tradicionales, produciendo circuitos significativamente menos profundos y reduciendo los conteos de compuertas, lo cual es crítico para mejorar el rendimiento y mitigar el ruido en hardware cuántico real.

Los usuarios deberían considerar la transpilación con IA cuando trabajen con:
- Circuitos grandes donde los métodos tradicionales no logran manejar la escala de manera eficiente.
- Topologías de hardware complejas donde surgen desafíos de conectividad del dispositivo y enrutamiento.
- Aplicaciones sensibles al rendimiento donde reducir la profundidad del circuito y mejorar la fidelidad son primordiales.
# Parte III. Explorar la síntesis de redes de permutación con IA {#part-iii-explore-ai-powered-permutation-network-synthesis}

Las redes de permutación son fundamentales en la computación cuántica, particularmente para sistemas restringidos por topologías limitadas. Estas redes facilitan las interacciones de largo alcance al intercambiar dinámicamente qubits para imitar la conectividad de todos con todos en hardware con conectividad limitada. Tales transformaciones son esenciales para implementar algoritmos cuánticos complejos en dispositivos de corto plazo, donde las interacciones a menudo se extienden más allá de los vecinos más cercanos.

En esta sección, destacamos la síntesis de redes de permutación como un caso de uso convincente para el transpilador con IA en Qiskit. Específicamente, el pase `AIPermutationSynthesis` aprovecha la optimización impulsada por IA para generar circuitos eficientes para tareas de permutación de qubits. En contraste, los enfoques de síntesis genéricos a menudo tienen dificultades para equilibrar el conteo de compuertas y la profundidad del circuito, especialmente en escenarios con interacciones densas de qubits o al intentar lograr conectividad completa.

Recorreremos un ejemplo de patrones de Qiskit que muestra la síntesis de una red de permutación para lograr conectividad de todos con todos para un conjunto de qubits. Compararemos el rendimiento de `AIPermutationSynthesis` contra los métodos de síntesis estándar en Qiskit. Este ejemplo demostrará cómo el transpilador con IA optimiza para una menor profundidad de circuito y conteo de compuertas, resaltando sus ventajas en flujos de trabajo cuánticos prácticos. Para activar el pase de síntesis con IA, utilizaremos la función `generate_ai_pass_manager()` con el parámetro `include_ai_synthesis` establecido en `True`.
## Paso 1: Mapear entradas clásicas a un problema cuántico {#step-1-map-classical-inputs-to-a-quantum-problem}

Para representar un problema clásico de permutación en una computadora cuántica, comenzamos definiendo la estructura de los circuitos cuánticos. Para este ejemplo:

1. Inicialización del circuito cuántico:
   Asignamos 27 qubits para coincidir con el backend que utilizaremos, el cual tiene 27 qubits.

2. Aplicar permutaciones:
   Generamos diez patrones de permutación aleatorios (`pattern_1` a `pattern_10`) usando una semilla fija para reproducibilidad. Cada patrón de permutación se aplica a un circuito cuántico separado (`qc_1` a `qc_10`).

3. Descomposición del circuito:
   Cada operación de permutación se descompone en conjuntos de compuertas nativas compatibles con el hardware cuántico objetivo. Analizamos la profundidad y el número de compuertas de dos qubits (compuertas no locales) para cada circuito descompuesto.

Los resultados proporcionan información sobre la complejidad de representar problemas clásicos de permutación en un dispositivo cuántico, demostrando los requisitos de recursos para diferentes patrones de permutación.

```python
# Parameters
width = 27
num_circuits = 10

# Set random seed
np.random.seed(seed)

# Generate random patterns and circuits
patterns = [
    np.random.permutation(width).tolist() for _ in range(num_circuits)
]
circuits = {
    f"qc_{i}": generate_permutation_circuit(width, pattern)
    for i, pattern in enumerate(patterns, start=1)
}

# Display one of the circuits
circuits["qc_1"].decompose(reps=3).draw(output="mpl", fold=-1)
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/76a3e847-0808-4413-bd0c-c760cd2df3f4-0.avif)

## Paso 2: Optimizar el problema para la ejecución en hardware cuántico {#step-2-optimize-problem-for-quantum-hardware-execution}
En este paso, procedemos con la optimización utilizando los pases de síntesis con IA.

Para los pases de síntesis con IA, el `PassManager` requiere solo el mapa de acoplamiento del backend. Sin embargo, es importante señalar que no todos los mapas de acoplamiento son compatibles; solo aquellos en los que el pase `AIPermutationSynthesis` ha sido entrenado funcionarán. Actualmente, el pase `AIPermutationSynthesis` soporta bloques de tamaños de 65, 33 y 27 qubits. Para este ejemplo utilizamos una QPU de 27 qubits.

Para comparación, evaluaremos el rendimiento de la síntesis con IA contra los métodos genéricos de síntesis de permutaciones en Qiskit, incluyendo:

- `synth_permutation_depth_lnn_kms`: Este método sintetiza un circuito de permutación para una arquitectura de vecinos más cercanos lineales (LNN) utilizando el algoritmo de Kutin, Moulton y Smithline (KMS). Garantiza un circuito con una profundidad de como máximo $ n $ y un tamaño de como máximo $ n(n-1)/2 $, donde tanto la profundidad como el tamaño se miden en términos de compuertas SWAP.

- `synth_permutation_basic`: Esta es una implementación directa que sintetiza circuitos de permutación sin imponer restricciones de conectividad ni optimización para arquitecturas específicas. Sirve como línea base para comparar el rendimiento con métodos más avanzados.

Cada uno de estos métodos representa un enfoque distinto para la síntesis de redes de permutación, proporcionando un benchmark completo contra los métodos con IA.

Para más detalles sobre los métodos de síntesis en Qiskit, consulte la [documentación de la API de Qiskit](https://docs.quantum.ibm.com/api/qiskit/synthesis).
Defina el mapa de acoplamiento que representa la QPU de 27 qubits.

```python
coupling_map = [
    [1, 0],
    [2, 1],
    [3, 2],
    [3, 5],
    [4, 1],
    [6, 7],
    [7, 4],
    [7, 10],
    [8, 5],
    [8, 9],
    [8, 11],
    [11, 14],
    [12, 10],
    [12, 13],
    [12, 15],
    [13, 14],
    [16, 14],
    [17, 18],
    [18, 15],
    [18, 21],
    [19, 16],
    [19, 22],
    [20, 19],
    [21, 23],
    [23, 24],
    [25, 22],
    [25, 24],
    [26, 25],
]
CouplingMap(coupling_map).draw()
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/84dff2c2-a496-4828-bb8e-08d373816a36-0.avif)

Transpile cada uno de los circuitos de permutación utilizando los pases de síntesis con IA y los métodos de síntesis genéricos.

```python
results = []
pm_no_ai_synth = generate_preset_pass_manager(
    coupling_map=cm,
    optimization_level=1,  # set to 1 since we are using the synthesis methods
)

# Transpile and analyze all circuits
for i, (qc_name, qc) in enumerate(circuits.items(), start=1):
    pattern = patterns[i - 1]  # Get the corresponding pattern

    qc_depth_lnn_kms = synth_permutation_depth_lnn_kms(pattern)
    qc_basic = synth_permutation_basic(pattern)

    # AI synthesis
    results.append(
        synth_transpile_with_metrics(
            qc.decompose(reps=3),
            pm_ai,
            qc_name,
            "AI",
        )
    )

    # Depth-LNN-KMS Method
    results.append(
        synth_transpile_with_metrics(
            qc_depth_lnn_kms.decompose(reps=3),
            pm_no_ai_synth,
            qc_name,
            "Depth-LNN-KMS",
        )
    )

    # Basic Method
    results.append(
        synth_transpile_with_metrics(
            qc_basic.decompose(reps=3),
            pm_no_ai_synth,
            qc_name,
            "Basic",
        )
    )

results_df = pd.DataFrame(results)
```

Registre las métricas (profundidad, conteo de compuertas, tiempo) para cada circuito después de la transpilación.

```python
# Calculate averages for each metric
average_metrics = results_df.groupby("Method")[
    ["Depth (2Q)", "Gates", "Time (s)"]
].mean()
average_metrics = average_metrics.round(3)  # Round to two decimal places
print("\n=== Average Metrics ===")
print(average_metrics)

# Identify the best non-AI method based on least average depth
non_ai_methods = [
    method for method in results_df["Method"].unique() if method != "AI"
]
best_non_ai_method = average_metrics.loc[non_ai_methods][
    "Depth (2Q)"
].idxmin()
print(
    f"\nBest Non-AI Method (based on least average depth): {best_non_ai_method}"
)

# Compare AI to the best non-AI method
ai_metrics = average_metrics.loc["AI"]
best_non_ai_metrics = average_metrics.loc[best_non_ai_method]

comparison = {
    "Metric": ["Depth (2Q)", "Gates", "Time (s)"],
    "AI": [
        ai_metrics["Depth (2Q)"],
        ai_metrics["Gates"],
        ai_metrics["Time (s)"],
    ],
    best_non_ai_method: [
        best_non_ai_metrics["Depth (2Q)"],
        best_non_ai_metrics["Gates"],
        best_non_ai_metrics["Time (s)"],
    ],
    "Improvement (AI vs Best Non-AI)": [
        ai_metrics["Depth (2Q)"] - best_non_ai_metrics["Depth (2Q)"],
        ai_metrics["Gates"] - best_non_ai_metrics["Gates"],
        ai_metrics["Time (s)"] - best_non_ai_metrics["Time (s)"],
    ],
}

comparison_df = pd.DataFrame(comparison)
print("\n=== Comparison of AI vs Best Non-AI Method ===")
comparison_df
```

```text
=== Average Metrics ===
               Depth (2Q)  Gates  Time (s)
Method
AI                   23.9   82.8     0.248
Basic                29.8   91.0     0.012
Depth-LNN-KMS        70.8  531.6     0.017

Best Non-AI Method (based on least average depth): Basic

=== Comparison of AI vs Best Non-AI Method ===
```

```text
Metric      AI   Basic  Improvement (AI vs Best Non-AI)
0  Depth (2Q)  23.900  29.800                           -5.900
1       Gates  82.800  91.000                           -8.200
2    Time (s)   0.248   0.012                            0.236
```

Los resultados demuestran que el transpilador con IA supera a todos los demás métodos de síntesis de Qiskit para este conjunto de circuitos de permutación aleatorios. Los hallazgos clave incluyen:

1. Profundidad: El transpilador con IA logra la menor profundidad promedio, lo que indica una optimización superior de los diseños de circuitos.
2. Conteo de compuertas: Reduce significativamente el número de compuertas en comparación con otros métodos, mejorando la fidelidad y la eficiencia de ejecución.
3. Tiempo de transpilación: Todos los métodos se ejecutan muy rápidamente a esta escala, lo que los hace prácticos para su uso. Sin embargo, el transpilador con IA tiene un aumento notable en el tiempo de ejecución en comparación con los métodos tradicionales debido a la complejidad de los modelos de IA utilizados.

Estos resultados establecen al transpilador con IA como el enfoque más efectivo para este benchmark, particularmente para la optimización de profundidad y conteo de compuertas.
Grafique los resultados para comparar el rendimiento de los pases de síntesis con IA contra los métodos de síntesis genéricos.

```python
methods = results_df["Method"].unique()

fig, axs = plt.subplots(1, 3, figsize=(18, 5))

# Pivot the DataFrame and reorder columns to ensure AI is first
pivot_depth = results_df.pivot(
    index="Pattern", columns="Method", values="Depth (2Q)"
)[["AI", "Depth-LNN-KMS", "Basic"]]
pivot_gates = results_df.pivot(
    index="Pattern", columns="Method", values="Gates"
)[["AI", "Depth-LNN-KMS", "Basic"]]
pivot_time = results_df.pivot(
    index="Pattern", columns="Method", values="Time (s)"
)[["AI", "Depth-LNN-KMS", "Basic"]]

pivot_depth.plot(kind="bar", ax=axs[0], legend=False)
axs[0].set_title("Circuit Depth Comparison")
axs[0].set_ylabel("Depth")
axs[0].set_xlabel("Pattern")
axs[0].tick_params(axis="x", rotation=45)
pivot_gates.plot(kind="bar", ax=axs[1], legend=False)
axs[1].set_title("2Q Gate Count Comparison")
axs[1].set_ylabel("Number of 2Q Gates")
axs[1].set_xlabel("Pattern")
axs[1].tick_params(axis="x", rotation=45)
pivot_time.plot(
    kind="bar", ax=axs[2], legend=True, title="Legend"
)  # Show legend on the last plot
axs[2].set_title("Time Comparison")
axs[2].set_ylabel("Time (seconds)")
axs[2].set_xlabel("Pattern")
axs[2].tick_params(axis="x", rotation=45)
fig.suptitle(
    "Benchmarking AI Synthesis Methods vs Non-AI Synthesis Methods For Random Permutations Circuits",
    fontsize=16,
    y=1,
)

plt.tight_layout()
plt.show()
```

![Output of the previous code cell](/docs/images/tutorials/ai-transpiler-introduction/extracted-outputs/a326f268-0115-442c-8563-968676b66670-0.avif)

Este gráfico destaca los resultados individuales para cada circuito (`qc_1` a `qc_10`) a través de los diferentes métodos de síntesis:

Si bien estos resultados subrayan la efectividad del transpilador con IA para circuitos de permutación, es importante señalar sus limitaciones. El método de síntesis con IA actualmente solo está disponible para ciertos mapas de acoplamiento, lo que puede restringir su aplicabilidad más amplia. Esta restricción debe considerarse al evaluar su uso en diferentes escenarios.

En general, el transpilador con IA demuestra mejoras prometedoras en la optimización de profundidad y conteo de compuertas para estos circuitos específicos, manteniendo tiempos de transpilación comparables.
## Paso 3: Ejecutar utilizando primitivas de Qiskit {#step-3-execute-using-qiskit-primitives}
Como este tutorial se centra en la transpilación, no se ejecutarán experimentos en el dispositivo cuántico. El objetivo es aprovechar las optimizaciones del Paso 2 para obtener un circuito transpilado con profundidad o conteo de compuertas reducido.
## Paso 4: Post-procesar y devolver el resultado en el formato clásico deseado {#step-4-post-process-and-return-result-in-desired-classical-format}
Dado que no hay ejecución en este cuaderno, no hay resultados que post-procesar.
## Encuesta del tutorial {#tutorial-survey}

Por favor, realice esta breve encuesta para proporcionar comentarios sobre este tutorial. Sus opiniones nos ayudarán a mejorar nuestras ofertas de contenido y la experiencia del usuario.

[Enlace a la encuesta](https://your.feedback.ibm.com/jfe/form/SV_0igXMtMCQfApgDI)
