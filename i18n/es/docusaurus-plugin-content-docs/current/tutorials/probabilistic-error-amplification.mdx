---
title: "Mitigación de errores a escala de utilidad con amplificación probabilística de errores"
sidebar_label: "Mitigación de errores a escala de utilidad con amplificación probabilística de errores"
description: "Ejecute un experimento de mitigación de errores a escala de utilidad con extrapolación a ruido cero y amplificación probabilística de errores."
notebook_path: "docs/tutorials/probabilistic-error-amplification.ipynb"
---

<OpenInLabBanner notebookPath="docs/tutorials/probabilistic-error-amplification.ipynb" />



{/* cspell:ignore mapsto multigraph inds extrap sharex sharey pidx */}

*Estimación de uso: 16 minutos en un procesador Heron r2 (NOTA: Esto es solo una estimación. Su tiempo de ejecución puede variar.)*
## Antecedentes

Este tutorial demuestra cómo ejecutar un experimento de mitigación de errores a escala de utilidad con Qiskit Runtime utilizando una versión experimental de *extrapolación a ruido cero* (ZNE) con *amplificación probabilística de errores* (PEA).

![kim_nature_fig.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/e1e67c34-9d4d-4a88-9340-f0b2f3676770.avif)
__Referencia__: Y. Kim et al. *Evidence for the utility of quantum computing before fault tolerance.* [Nature 618.7965 (2023)](https://www.nature.com/articles/s41586-023-06096-3)
### Extrapolación a ruido cero (ZNE)
La extrapolación a ruido cero (ZNE) es una técnica de mitigación de errores que elimina los efectos de un ruido *desconocido* durante la ejecución de circuitos que puede escalarse de manera *conocida*.

Se asume que los valores esperados escalan con el ruido mediante una función conocida

$$
\langle A(\lambda) \rangle = \langle A(0) \rangle + \sum_{k=0}^{m} a_k \lambda^k + R
$$
donde $\lambda$ parametriza la intensidad del ruido y puede amplificarse.
Podemos implementar ZNE con los siguientes pasos:

1. Amplificar el ruido del circuito para varios factores de ruido $\lambda_1, \lambda_2, ... $
2. Ejecutar cada circuito con ruido amplificado para medir $\langle A(\lambda_1)\rangle, ...$
3. Extrapolar de vuelta al límite de ruido cero $\langle A(0)\rangle$

![zne_stages.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/5e63d706-82d8-4212-b802-c9191ce53341.avif)
#### Amplificar ruido para ZNE
El principal desafío para implementar ZNE exitosamente es tener un modelo preciso del ruido en el valor esperado y amplificar el ruido de manera conocida.

Existen tres formas comunes en que se implementa la amplificación de errores para ZNE.

| **Estiramiento de pulsos** | **Plegado de compuertas** | **Amplificación probabilística de errores** |
|-----------|-----------|-----------|
| Escalar la duración del pulso mediante calibración | Repetir compuertas en ciclos de identidad $U\mapsto U(U^{-1}U)^{\lambda-1}/2$ | Agregar ruido mediante muestreo de canales de Pauli |
| ![zne_pulse_stretching.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/83188b57-e88f-43a1-a7bd-29327f46ecf5.avif) | ![zne_gate_folding.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/e1358d08-2632-4fd2-bf0f-f9384a2d3340.avif) | ![zne_pea.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/3d69d5bd-70e5-4eeb-aa02-fc0a62043010.avif) |
| Kandala et al. Nature (2019) | Shultz et al. PRA (2022) | Li & Benjamin PRX (2017) |
Para experimentos a escala de utilidad, la *amplificación probabilística de errores* (PEA) es la más atractiva.
- El estiramiento de pulsos asume que el ruido de las compuertas es proporcional a la duración, lo cual típicamente no es cierto. La calibración también es costosa.
- El plegado de compuertas requiere factores de estiramiento grandes que limitan considerablemente la profundidad de los circuitos que pueden ejecutarse.
- PEA puede aplicarse a cualquier circuito que pueda ejecutarse con factor de ruido nativo ($\lambda=1$), pero requiere aprender el modelo de ruido.
### Aprender el modelo de ruido para PEA
PEA asume el mismo modelo de ruido basado en capas que la *cancelación probabilística de errores* (PEC); sin embargo, evita la sobrecarga de muestreo que escala exponencialmente con el ruido del circuito.
| **Paso 1** | **Paso 2** | **Paso 3** |
|-----------|-----------|-----------|
| Aplicar twirl de Pauli a capas de compuertas de dos qubits | Repetir pares de identidad de capas y aprender el ruido | Derivar una fidelidad (error para cada canal de ruido) |
| ![pec_pauli_twirling.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/2eab5ff4-40fa-4a41-9f2c-74f5e22c4643.avif) | ![pec_learn_layer.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/8d0d64c3-65ad-4419-8ac9-4ec9633d39a0.avif) | ![pec_curve_fitting.png](/docs/images/tutorials/utility-scale-error-mitigation-with-probabilistic-error-amplification/c51bd42d-2463-4c78-807b-d284ca79296f.avif) |

__Referencia__: E. van den Berg, Z. Minev, A. Kandala, and K. Temme, _Probabilistic error cancellation with sparse Pauli-Lindblad models on noisy quantum processors_ [arXiv:2201.09866](https://arxiv.org/abs/2201.09866)
## Requisitos

Antes de comenzar este tutorial, asegúrese de tener instalado lo siguiente:

- Qiskit SDK v1.0 o posterior, con soporte de [visualización](https://docs.quantum.ibm.com/api/qiskit/visualization)
- Qiskit Runtime v0.22 o posterior (`pip install qiskit-ibm-runtime`)
## Configuración

```python
from __future__ import annotations
from collections.abc import Sequence
from collections import defaultdict
import numpy as np
import rustworkx
import matplotlib.pyplot as plt

from qiskit.circuit import QuantumCircuit, Parameter
from qiskit.circuit.library import CXGate, CZGate, ECRGate
from qiskit.providers import Backend
from qiskit.visualization import plot_error_map
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit.quantum_info import SparsePauliOp
from qiskit.primitives import PubResult

from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_runtime import EstimatorV2 as Estimator
```

## Paso 1: Mapear entradas clásicas a un problema cuántico
### Crear un circuito parametrizado del modelo de Ising
Primero, elija un backend en el cual ejecutar. Esta demostración se ejecuta en un backend de 127 qubits, pero usted puede modificar esto para cualquier backend disponible.

```python
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=127
)
backend
```

```text
<IBMBackend('ibm_kingston')>
```

#### Funciones auxiliares para la construcción de circuitos
A continuación, cree algunas funciones auxiliares para construir los circuitos para la evolución temporal trotterizada de un modelo de Ising de campo transverso bidimensional que se adhiere a la topología del backend.

```python
"""Trotter circuit generation"""

def remove_qubit_couplings(
    couplings: Sequence[tuple[int, int]], qubits: Sequence[int] | None = None
) -> list[tuple[int, int]]:
    """Remove qubits from a coupling list.

    Args:
        couplings: A sequence of qubit couplings.
        qubits: Optional, the qubits to remove.

    Returns:
        The input couplings with the specified qubits removed.
    """
    if qubits is None:
        return couplings
    qubits = set(qubits)
    return [edge for edge in couplings if not qubits.intersection(edge)]

def coupling_qubits(
    *couplings: Sequence[tuple[int, int]],
    allowed_qubits: Sequence[int] | None = None,
) -> list[int]:
    """Return a sorted list of all qubits involved in one or more couplings lists.

    Args:
        couplings: one or more coupling lists.
        allowed_qubits: Optional, the allowed qubits to include. If None all
            qubits are allowed.

    Returns:
        The intersection of all qubits in the couplings and the allowed qubits.
    """
    qubits = set()
    for edges in couplings:
        for edge in edges:
            qubits.update(edge)
    if allowed_qubits is not None:
        qubits = qubits.intersection(allowed_qubits)
    return list(qubits)

def construct_layer_couplings(
    backend: Backend,
) -> list[list[tuple[int, int]]]:
    """Separate a coupling map into disjoint 2-qubit gate layers.

    Args:
        backend: A backend to construct layer couplings for.

    Returns:
        A list of disjoint layers of directed couplings for the input coupling map.
    """
    coupling_graph = backend.coupling_map.graph.to_undirected(
        multigraph=False
    )
    edge_coloring = rustworkx.graph_bipartite_edge_color(coupling_graph)

    layers = defaultdict(list)
    for edge_idx, color in edge_coloring.items():
        layers[color].append(
            coupling_graph.get_edge_endpoints_by_index(edge_idx)
        )
    layers = [sorted(layers[i]) for i in sorted(layers.keys())]

    return layers

def entangling_layer(
    gate_2q: str,
    couplings: Sequence[tuple[int, int]],
    qubits: Sequence[int] | None = None,
) -> QuantumCircuit:
    """Generating a entangling layer for the specified couplings.

    This corresponds to a Trotter layer for a ZZ Ising term with angle Pi/2.

    Args:
        gate_2q: The 2-qubit basis gate for the layer, should be "cx", "cz", or "ecr".
        couplings: A sequence of qubit couplings to add CX gates to.
        qubits: Optional, the physical qubits for the layer. Any couplings involving
            qubits not in this list will be removed. If None the range up to the largest
            qubit in the couplings will be used.

    Returns:
        The QuantumCircuit for the entangling layer.
    """
    # Get qubits and convert to set to order
    if qubits is None:
        qubits = range(1 + max(coupling_qubits(couplings)))
    qubits = set(qubits)

    # Mapping of physical qubit to virtual qubit
    qubit_mapping = {q: i for i, q in enumerate(qubits)}

    # Convert couplings to indices for virtual qubits
    indices = [
        [qubit_mapping[i] for i in edge]
        for edge in couplings
        if qubits.issuperset(edge)
    ]

    # Layer circuit on virtual qubits
    circuit = QuantumCircuit(len(qubits))

    # Get 2-qubit basis gate and pre and post rotation circuits
    gate2q = None
    pre = QuantumCircuit(2)
    post = QuantumCircuit(2)

    if gate_2q == "cx":
        gate2q = CXGate()
        # Pre-rotation
        pre.sdg(0)
        pre.z(1)
        pre.sx(1)
        pre.s(1)
        # Post-rotation
        post.sdg(1)
        post.sxdg(1)
        post.s(1)
    elif gate_2q == "ecr":
        gate2q = ECRGate()
        # Pre-rotation
        pre.z(0)
        pre.s(1)
        pre.sx(1)
        pre.s(1)
        # Post-rotation
        post.x(0)
        post.sdg(1)
        post.sxdg(1)
        post.s(1)
    elif gate_2q == "cz":
        gate2q = CZGate()
        # Identity pre-rotation
        # Post-rotation
        post.sdg([0, 1])
    else:
        raise ValueError(
            f"Invalid 2-qubit basis gate {gate_2q}, should be 'cx', 'cz', or 'ecr'"
        )

    # Add 1Q pre-rotations
    for inds in indices:
        circuit.compose(pre, qubits=inds, inplace=True)

    # Use barriers around 2-qubit basis gate to specify a layer for PEA noise learning
    circuit.barrier()
    for inds in indices:
        circuit.append(gate2q, (inds[0], inds[1]))
    circuit.barrier()

    # Add 1Q post-rotations after barrier
    for inds in indices:
        circuit.compose(post, qubits=inds, inplace=True)

    # Add physical qubits as metadata
    circuit.metadata["physical_qubits"] = tuple(qubits)

    return circuit

def trotter_circuit(
    theta: Parameter | float,
    layer_couplings: Sequence[Sequence[tuple[int, int]]],
    num_steps: int,
    gate_2q: str | None = "cx",
    backend: Backend | None = None,
    qubits: Sequence[int] | None = None,
) -> QuantumCircuit:
    """Generate a Trotter circuit for the 2D Ising

    Args:
        theta: The angle parameter for X.
        layer_couplings: A list of couplings for each entangling layer.
        num_steps: the number of Trotter steps.
        gate_2q: The 2-qubit basis gate to use in entangling layers.
            Can be "cx", "cz", "ecr", or None if a backend is provided.
        backend: A backend to get the 2-qubit basis gate from, if provided
            will override the basis_gate field.
        qubits: Optional, the allowed physical qubits to truncate the
            couplings to. If None the range up to the largest
            qubit in the couplings will be used.

    Returns:
        The Trotter circuit.
    """
    if backend is not None:
        try:
            basis_gates = backend.configuration().basis_gates
        except AttributeError:
            basis_gates = backend.basis_gates
        for gate in ["cx", "cz", "ecr"]:
            if gate in basis_gates:
                gate_2q = gate
                break

    # If no qubits, get the largest qubit from all layers and
    # specify the range so the same one is used for all layers.
    if qubits is None:
        qubits = range(1 + max(coupling_qubits(layer_couplings)))

    # Generate the entangling layers
    layers = [
        entangling_layer(gate_2q, couplings, qubits=qubits)
        for couplings in layer_couplings
    ]

    # Construct the circuit for a single Trotter step
    num_qubits = len(qubits)
    trotter_step = QuantumCircuit(num_qubits)
    trotter_step.rx(theta, range(num_qubits))
    for layer in layers:
        trotter_step.compose(layer, range(num_qubits), inplace=True)

    # Construct the circuit for the specified number of Trotter steps
    circuit = QuantumCircuit(num_qubits)
    for _ in range(num_steps):
        circuit.rx(theta, range(num_qubits))
        for layer in layers:
            circuit.compose(layer, range(num_qubits), inplace=True)

    circuit.metadata["physical_qubits"] = tuple(qubits)
    return circuit
```

#### Definir los acoplamientos de las capas de entrelazamiento
Para implementar la simulación de Ising trotterizada, defina tres capas de acoplamientos de compuertas de dos qubits para el dispositivo, que se repetirán en cada uno de los pasos de Trotter. Estas definen las tres capas con twirl que necesita aprender para el ruido e implementar la mitigación.

```python
layer_couplings = construct_layer_couplings(backend)
for i, layer in enumerate(layer_couplings):
    print(f"Layer {i}:\n{layer}\n")
```

```text
Layer 0:
[(2, 3), (4, 5), (6, 7), (8, 9), (10, 11), (12, 13), (14, 15), (16, 23), (18, 31), (19, 35), (20, 21), (25, 37), (26, 27), (28, 29), (33, 39), (36, 41), (38, 49), (42, 43), (45, 46), (47, 57), (51, 52), (53, 54), (56, 63), (58, 71), (59, 75), (61, 62), (64, 65), (66, 67), (68, 69), (72, 73), (76, 81), (79, 93), (82, 83), (84, 85), (86, 87), (88, 89), (91, 98), (94, 95), (97, 107), (99, 115), (100, 101), (102, 103), (105, 117), (108, 109), (110, 111), (113, 114), (116, 121), (118, 129), (123, 136), (124, 125), (126, 127), (130, 131), (132, 133), (135, 139), (138, 151), (142, 143), (144, 145), (146, 147), (152, 153), (154, 155)]

Layer 1:
[(0, 1), (3, 16), (5, 6), (7, 8), (11, 18), (13, 14), (17, 27), (21, 22), (23, 24), (25, 26), (29, 38), (30, 31), (32, 33), (34, 35), (39, 53), (41, 42), (43, 56), (44, 45), (47, 48), (49, 50), (51, 58), (54, 55), (57, 67), (60, 61), (62, 63), (65, 66), (69, 78), (70, 71), (73, 79), (74, 75), (77, 85), (80, 81), (83, 84), (87, 97), (89, 90), (91, 92), (93, 94), (96, 103), (101, 116), (104, 105), (106, 107), (109, 118), (111, 112), (113, 119), (114, 115), (117, 125), (121, 122), (123, 124), (127, 137), (128, 129), (131, 138), (133, 134), (136, 143), (139, 155), (140, 141), (145, 146), (147, 148), (149, 150), (151, 152)]

Layer 2:
[(1, 2), (3, 4), (7, 17), (9, 10), (11, 12), (15, 19), (21, 36), (22, 23), (24, 25), (27, 28), (29, 30), (31, 32), (33, 34), (37, 45), (40, 41), (43, 44), (46, 47), (48, 49), (50, 51), (52, 53), (55, 59), (61, 76), (63, 64), (65, 77), (67, 68), (69, 70), (71, 72), (73, 74), (78, 89), (81, 82), (83, 96), (85, 86), (87, 88), (90, 91), (92, 93), (95, 99), (98, 111), (101, 102), (103, 104), (105, 106), (107, 108), (109, 110), (112, 113), (119, 133), (120, 121), (122, 123), (125, 126), (127, 128), (129, 130), (131, 132), (134, 135), (137, 147), (141, 142), (143, 144), (148, 149), (150, 151), (153, 154)]
```

#### Eliminar qubits defectuosos
Observe el mapa de acoplamiento del backend y verifique si algún qubit se conecta a acoplamientos con alto error. Elimine estos qubits "defectuosos" de su experimento.

```python
# Plot gate error map
# NOTE: These can change over time, so your results may look different
plot_error_map(backend)
```

![Output of the previous code cell](/docs/images/tutorials/probabilistic-error-amplification/extracted-outputs/401e2d48-1b39-40c8-bf32-7b439ae0980d-0.avif)

```python
bad_qubits = {
    56,
    63,
    67,
}  # qubits removed based on high coupling error (1.00)
good_qubits = list(set(range(backend.num_qubits)).difference(bad_qubits))
print("Physical qubits:\n", good_qubits)
```

```text
Physical qubits:
 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62, 64, 65, 66, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155]
```

#### Generación del circuito principal de Trotter

```python
num_steps = 6
theta = Parameter("theta")
circuit = trotter_circuit(
    theta, layer_couplings, num_steps, qubits=good_qubits, backend=backend
)
```

### Crear una lista de valores de parámetros para asignar posteriormente

```python
num_params = 12

# 12 parameter values for Rx between [0, pi/2].
# Reshape to outer product broadcast with observables
parameter_values = np.linspace(0, np.pi / 2, num_params).reshape(
    (num_params, 1)
)
num_params = parameter_values.size
```
## Paso 2: Optimizar el problema para la ejecución en hardware cuántico
### Circuito ISA
Antes de ejecutar el circuito en hardware, optimícelo para la ejecución en hardware. Este proceso involucra varios pasos:

- Elegir una disposición de qubits que mapee los qubits virtuales de su circuito a qubits físicos en el hardware.
- Insertar compuertas swap según sea necesario para enrutar interacciones entre qubits que no están conectados.
- Traducir las compuertas en nuestro circuito a instrucciones de la [Arquitectura del Conjunto de Instrucciones (ISA)](/guides/transpile#instruction-set-architecture) que pueden ejecutarse directamente en el hardware.
- Realizar optimizaciones del circuito para minimizar la profundidad del circuito y el conteo de compuertas.

Aunque el transpilador integrado en Qiskit puede realizar todos estos pasos, este tutorial demuestra la construcción del circuito de Trotter a escala de utilidad desde cero. Seleccione los qubits físicos adecuados y defina capas de entrelazamiento en pares de qubits conectados a partir de esos qubits seleccionados. No obstante, aún necesita traducir las compuertas que no son ISA en el circuito y aprovechar cualquier optimización de circuito ofrecida por el transpilador.

Transpile su circuito para el backend elegido creando un administrador de pases y luego ejecutando el administrador de pases en el circuito. Además, fije la disposición inicial del circuito a los `good_qubits` ya seleccionados. Una forma sencilla de crear un administrador de pases es usar la función [`generate_preset_pass_manager`](https://docs.quantum.ibm.com/api/qiskit/qiskit.transpiler.generate_preset_pass_manager). Consulte [Transpilar con administradores de pases](/guides/transpile-with-pass-managers) para una explicación más detallada sobre la transpilación con administradores de pases.

```python
pm = generate_preset_pass_manager(
    backend=backend,
    initial_layout=good_qubits,
    layout_method="trivial",
    optimization_level=1,
)

isa_circuit = pm.run(circuit)
```

### Observables ISA
A continuación, cree todos los observables $\langle Z \rangle$ de peso 1 para cada qubit virtual rellenando el número necesario de términos $\langle I \rangle$.

```python
observables = []
num_qubits = len(good_qubits)
for q in range(num_qubits):
    observables.append(
        SparsePauliOp("I" * (num_qubits - q - 1) + "Z" + "I" * q)
    )
```

El proceso de transpilación ha mapeado los qubits virtuales de su circuito a qubits físicos en el hardware. La información sobre la disposición de qubits se almacena en el atributo `layout` del circuito transpilado. Su observable también está definido en términos de los qubits virtuales, por lo que necesita aplicar esta disposición al observable. Esto se hace usando el método `apply_layout` de `SparsePauliOp`.

Observe que cada observable está envuelto en una lista en el siguiente bloque de código. Esto se hace para _transmitir_ (broadcast) con los valores de parámetros de modo que cada observable de qubit se mida para cada valor de theta. Las reglas de transmisión para primitivas se pueden encontrar [aquí](/guides/primitives).

```python
isa_observables = [
    [obs.apply_layout(layout=isa_circuit.layout)] for obs in observables
]
```

## Paso 3: Ejecutar usando primitivas de Qiskit

```python
pub = (isa_circuit, isa_observables, parameter_values)
```

### Configurar las opciones del Estimator
A continuación, configure las opciones del `Estimator` necesarias para ejecutar el experimento de mitigación. Esto incluye opciones para el aprendizaje de ruido de las capas de entrelazamiento y para la extrapolación ZNE.

Utilizamos la siguiente configuración:

```python
# Experiment options
num_randomizations = 700
num_randomizations_learning = 40
max_batch_circuits = 3 * num_params
shots_per_randomization = 64
learning_pair_depths = [0, 1, 2, 4, 6, 12, 24]
noise_factors = [1, 1.3, 1.6]
extrapolated_noise_factors = np.linspace(0, max(noise_factors), 20)

# Base option formatting
options = {
    # Builtin resilience settings for ZNE
    "resilience": {
        "measure_mitigation": True,
        "zne_mitigation": True,
        # TREX noise learning configuration
        "measure_noise_learning": {
            "num_randomizations": num_randomizations_learning,
            "shots_per_randomization": 1024,
        },
        # PEA noise model configuration
        "layer_noise_learning": {
            "max_layers_to_learn": 3,
            "layer_pair_depths": learning_pair_depths,
            "shots_per_randomization": shots_per_randomization,
            "num_randomizations": num_randomizations_learning,
        },
        "zne": {
            "amplifier": "pea",
            "noise_factors": noise_factors,
            "extrapolator": ("exponential", "linear"),
            "extrapolated_noise_factors": extrapolated_noise_factors.tolist(),
        },
    },
    # Randomization configuration
    "twirling": {
        "num_randomizations": num_randomizations,
        "shots_per_randomization": shots_per_randomization,
        "strategy": "active-circuit",
    },
    # Optional Dynamical Decoupling (DD)
    "dynamical_decoupling": {"enable": True, "sequence_type": "XY4"},
}
```

#### Explicación de las opciones de ZNE
A continuación se proporcionan detalles sobre las opciones adicionales en la rama experimental. Tenga en cuenta que estas opciones y nombres no están finalizados, y todo aquí está sujeto a cambios antes de un lanzamiento oficial.

* __amplifier__: El método a utilizar al amplificar el ruido a los factores de ruido deseados.
    Los valores permitidos son `"gate_folding"`, que amplifica repitiendo compuertas base de dos qubits,
    y `"pea"`, que amplifica mediante muestreo probabilístico después de aprender el modelo de ruido
    con twirl de Pauli para capas de compuertas base de dos qubits con twirl. También existen las opciones `"gate_folding_front"` y `"gate_folding_back"` que se explican en la [documentación de la API](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/options-zne-options#amplifier)
* __extrapolated_noise_factors__: Especifique uno o más valores de factor de ruido en los cuales evaluar los
    modelos extrapolados. Si es una secuencia de valores, los resultados devueltos serán un arreglo con el factor de ruido especificado evaluado para el modelo de extrapolación. Un valor
    de 0 corresponde a la extrapolación a ruido cero.
### Ejecutar el experimento

```python
estimator = Estimator(mode=backend, options=options)
job = estimator.run([pub])
```

```python
print(f"Job ID {job.job_id()}")
```

```text
Job ID d0mcsvik4jhc73afljrg
```
## Paso 4: Post-procesar y devolver el resultado en el formato clásico deseado
Una vez finalizado el experimento, puede ver sus resultados. Obtenga los valores esperados crudos y mitigados y compárelos con los resultados exactos. Luego, grafique los valores esperados, tanto mitigados (extrapolados) como crudos, promediados sobre todos los qubits para cada parámetro. Finalmente, grafique los valores esperados para los qubits individuales de su elección.

```python
primitive_result = job.result()
```

### Formas generales de los resultados y metadatos
El objeto `PrimitiveResult` contiene una estructura tipo lista denominada `PubResult`. Como enviamos solo un PUB al estimador, el `PrimitiveResult` contiene un único objeto `PubResult`.

Los valores esperados y errores estándar del resultado PUB (bloque unificado de primitiva) son valores de arreglo. Para trabajos del estimador con ZNE, hay varios campos de datos de valores esperados y errores estándar disponibles en el contenedor `DataBin` del `PubResult`. Discutiremos brevemente los campos de datos para valores esperados aquí (campos de datos similares están disponibles para errores estándar (`stds`) también).

1. `pub_result.data.evs`: Valores esperados correspondientes al ruido cero (basados en la mejor extrapolación heurística).
    - El primer eje es el índice de qubit virtual para el observable $\langle Z_i\rangle$ ($124$ qubits virtuales/observables)
    - El segundo eje indexa el valor del parámetro para $\theta$ ($12$ valores de parámetros)
2. `pub_result.data.evs_extrapolated`: Valores esperados para factores de ruido extrapolados para cada extrapolador. Este arreglo tiene dos ejes adicionales.
    - El tercer eje indexa los métodos de extrapolación ($2$ extrapoladores, `exponential` y `linear`)
    - El último eje indexa los `extrapolated_noise_factors` ($20$ puntos de extrapolación especificados en la opción)
3. `pub_result.data.evs_noise_factors`: Valores esperados crudos para cada factor de ruido.
   - El tercer eje indexa los `noise_factors` crudos ($3$ factores)

```python
pub_result = primitive_result[0]

print(
    f"{pub_result.data.evs.shape=}\n"
    f"{pub_result.data.evs_extrapolated.shape=}\n"
    f"{pub_result.data.evs_noise_factors.shape=}\n"
)
```

```text
pub_result.data.evs.shape=(153, 12)
pub_result.data.evs_extrapolated.shape=(153, 12, 2, 20)
pub_result.data.evs_noise_factors.shape=(153, 12, 3)
```

Varios campos de metadatos también están disponibles en el `PrimitiveResult`. Los metadatos incluyen
- `resilience/zne/noise_factors`: Los factores de ruido crudos
- `resilience/zne/extrapolator`: Los extrapoladores utilizados para cada resultado

```python
primitive_result.metadata
```

```text
{'dynamical_decoupling': {'enable': True,
  'sequence_type': 'XY4',
  'extra_slack_distribution': 'middle',
  'scheduling_method': 'alap'},
 'twirling': {'enable_gates': True,
  'enable_measure': True,
  'num_randomizations': 700,
  'shots_per_randomization': 64,
  'interleave_randomizations': True,
  'strategy': 'active-circuit'},
 'resilience': {'measure_mitigation': True,
  'zne_mitigation': True,
  'pec_mitigation': False,
  'zne': {'noise_factors': [1.0, 1.3, 1.6],
   'extrapolator': ['exponential', 'linear'],
   'extrapolated_noise_factors': [0.0,
    0.08421052631578947,
    0.16842105263157894,
    0.25263157894736843,
    0.3368421052631579,
    0.42105263157894735,
    0.5052631578947369,
    0.5894736842105263,
    0.6736842105263158,
    0.7578947368421053,
    0.8421052631578947,
    0.9263157894736842,
    1.0105263157894737,
    1.0947368421052632,
    1.1789473684210525,
    1.263157894736842,
    1.3473684210526315,
    1.431578947368421,
    1.5157894736842106,
    1.6]},
  'layer_noise_model': [LayerError(circuit=<qiskit.circuit.quantumcircuit.QuantumCircuit object at 0x168671910>, qubits=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62, 64, 65, 66, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155], error=PauliLindbladError(generators=['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...',
    'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...', ...], rates=[0.00023, 0.00022, 0.00011, 0.00042, 0.0, 0.0, 9e-05, 0.00019, 0.0, 0.0, 0.0, 0.0, 0.00018, 0.0, 0.0, 5e-05, 0.0, 0.0001, 6e-05, 0.00017, 5e-05, 0.0, 0.0, 0.00023, 1e-05, 5e-05, 0.0, 4e-05, 7e-05, 4e-05, 0.00032, 0.0001, 4e-05, 7e-05, 0.00021, 0.00029, 0.00021, 0.00023, 0.00015, 0.00011, 0.0, 7e-05, 1e-05, 4e-05, 0.00014, 0.0, 0.0, 0.00101, 3e-05, 0.0, 0.0, 7e-05, 2e-05, 7e-05, 0.0002, 0.00014, 7e-05, 2e-05, 0.00024, 0.00066, 0.00019, 0.00018, 7e-05, 0.0001, 2e-05, 2e-05, 0.0, 0.0, 7e-05, 0.0, 7e-05, 0.00057, 4e-05, 8e-05, 0.0, 7e-05, 5e-05, 3e-05, 0.00034, 7e-05, 3e-05, 5e-05, 0.00032, 0.00361, 0.00015, 0.00014, 1e-05, 0.00013, 0.0, 0.00012, 0.0, 0.0, 0.0, 0.0, 0.00021, 0.001, 0.0001, 0.0, 0.0, 0.00055, 0.0001, 0.0, 0.00123, 0.0009, 0.0, 0.0001, 0.00127, 0.00392, 0.00031, 2e-05, 0.00036, 0.0, 0.00018, 0.0, 0.0, 0.0, 0.0, 0.00014, 0.0001, 0.0, 0.0005, 0.00023, 0.0, 0.0008, 5e-05, 5e-05, 0.00093, 0.00067, 5e-05, 5e-05, 0.00085, 0.00051, 0.00011, 0.00025, 2e-05, 0.00034, 4e-05, 0.0, 0.0, 0.00019, 6e-05, 0.0, 0.0, 0.00019, 0.0, 8e-05, 0.0, 0.00022, 9e-05, 0.0, 0.00038, 0.00022, 0.0, 9e-05, 0.00037, 7e-05, 0.00038, 0.00025, 6e-05, 0.0, 0.00015, 0.0, 6e-05, 3e-05, 0.0, 0.00012, 0.0, 0.0001, 0.0, 1e-05, 4e-05, 0.00027, 0.00014, 0.0, 0.00029, 0.00016, 0.0, 0.00014, 0.00029, 0.00582, 0.00022, 0.00016, 0.0002, 2e-05, 2e-05, 4e-05, 0.0, 8e-05, 3e-05, 0.0, 0.0, 3e-05, 7e-05, 0.0, 0.00012, 0.00024, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00013, 0.00015, 0.00038, 0.00016, 0.0, 0.0, 0.00036, 0.0, 4e-05, 0.0, 0.00038, 0.0, 4e-05, 1e-05, 0.0006, 0.0, 0.0, 0.0, 0.00011, 2e-05, 0.0, 0.00012, 0.00022, 0.0, 1e-05, 0.0, 0.00029, 0.0, 0.00012, 0.0, 0.0001, 0.00016, 0.00046, 0.00019, 0.0002, 0.0, 0.00047, 0.00017, 0.0, 0.0002, 0.00051, 0.0014, 0.0001, 0.00016, 0.00016, 0.00029, 0.00015, 1e-05, 1e-05, 0.00029, 0.0, 0.00015, 0.0, 0.00032, 0.0, 0.0, 6e-05, 2e-05, 7e-05, 2e-05, 0.00026, 0.0, 2e-05, 0.00015, 6e-05, 2e-05, 7e-05, 0.00027, 1e-05, 3e-05, 5e-05, 0.0, 7e-05, 0.00011, 0.00015, 0.0, 1e-05, 4e-05, 0.00055, 2e-05, 5e-05, 0.0, 0.0002, 5e-05, 8e-05, 2e-05, 0.00109, 0.0, 0.0, 9e-05, 0.00189, 0.0, 0.00012, 1e-05, 0.00181, 0.00017, 0.0, 0.0, 0.00502, 0.0, 8e-05, 0.00019, 0.0, 0.0, 0.00035, 0.0, 0.0, 0.00013, 0.0, 0.00016, 0.00032, 0.0, 1e-05, 2e-05, 0.0, 2e-05, 0.0, 0.00018, 0.0001, 2e-05, 0.00023, 7e-05, 0.0, 9e-05, 0.00011, 2e-05, 0.0001, 0.00031, 0.00045, 4e-05, 2e-05, 0.0001, 0.00036, 0.00028, 0.0002, 0.00056, 6e-05, 0.0, 0.0, 0.00043, 0.0, 0.0, 6e-05, 0.00038, 0.0, 3e-05, 0.0001, 8e-05, 4e-05, 0.00016, 0.00032, 0.00011, 0.00016, 4e-05, 0.00034, 0.00103, 0.00063, 0.00049, 0.00018, 0.00094, 2e-05, 0.00011, 0.0, 0.00047, 0.0001, 0.0, 0.00016, 0.00136, 5e-05, 0.0, 0.0, 0.0, 0.0, 9e-05, 0.00051, 0.0, 0.00018, 9e-05, 0.0, 9e-05, 0.0, 0.0003, 0.00019, 0.0, 0.0, 0.00425, 0.0004, 0.00043, 0.00032, 0.0, 0.0, 0.00016, 0.00183, 0.0, 0.00012, 0.0, 0.00161, 0.00024, 0.0, 0.0, 0.00024, 0.0, 1e-05, 9e-05, 0.0, 0.0, 0.0002, 4e-05, 0.0, 5e-05, 8e-05, 8e-05, 9e-05, 2e-05, 7e-05, 4e-05, 0.00028, 0.0, 0.00011, 0.0, 0.00019, 0.00013, 4e-05, 0.0, 0.00015, 4e-05, 1e-05, 2e-05, 0.00015, 3e-05, 0.0, 0.00028, 0.0, 2e-05, 0.0001, 0.0, 0.0, 3e-05, 0.0001, 0.00011, 1e-05, 0.0, 0.00433, 0.00025, 0.00023, 0.00046, 0.0, 0.0, 6e-05, 9e-05, 0.00013, 0.0, 0.0, 7e-05, 0.0, 0.00018, 7e-05, 0.00026, 0.0, 0.0, 0.0, 5e-05, 7e-05, 0.0, 0.00029, 2e-05, 0.0, 7e-05, 0.00029, 0.00115, 0.00215, 0.00234, 0.00049, 0.00038, 0.0, 0.00012, 0.0, 0.00019, 5e-05, 0.0, 0.0001, 0.00048, 2e-05, 0.0, 0.0, 2e-05, 1e-05, 0.0001, 0.00022, 1e-05, 0.0001, 1e-05, 0.0002, 0.00033, 0.0004, 0.00036, 0.00022, 0.00068, 0.00095, 0.00373, 0.0003, 0.0, 0.0, 0.00056, 0.00014, 0.0, 1e-05, 0.00039, 0.0, 0.0, 0.0005, 0.0, 9e-05, 0.0, 0.0046, 0.00023, 0.00032, 0.00043, 0.0, 8e-05, 0.0, 0.00035, 9e-05, 0.0, 0.0, 0.00025, 0.0, 0.0, 7e-05, 0.00195, 3e-05, 2e-05, 0.0, 0.00043, 0.0, 0.00017, 0.00054, 0.00036, 0.00017, 0.0, 0.00054, 0.00424, 0.00044, 0.00032, 0.00014, 0.00021, 0.0, 4e-05, 0.0, 0.0002, 9e-05, 0.0, 0.0, 0.00019, 2e-05, 0.00014, 0.0, 0.0, 0.00024, 0.0, 0.0, 4e-05, 7e-05, 0.0, 0.0, 0.0, 0.0001, 0.0, 1e-05, 0.0, 0.00017, 0.01108, 0.0, 0.00016, 0.0, 6e-05, 8e-05, 0.0, 0.0003, 0.00016, 0.0, 0.0003, 1e-05, 0.0, 0.00016, 0.0002, 0.00042, 0.00026, 0.00031, 0.0003, 0.0, 0.0, 0.0, 0.00028, 0.00019, 0.0, 0.00018, 0.0, 0.00055, 0.0, 0.0, 0.0, 0.00061, 0.0, 0.0, 0.0, 0.00036, 1e-05, 6e-05, 0.0, 0.00047, 0.00029, 0.0, 6e-05, 0.00019, 5e-05, 6e-05, 0.00042, 5e-05, 4e-05, 3e-05, 0.0, 6e-05, 5e-05, 0.00036, 7e-05, 0.0, 0.00017, 0.0, 0.0005, 0.00035, 0.00031, 4e-05, 3e-05, 0.0, 0.0003, 0.0, 0.0, 2e-05, 0.0, 0.0001, 9e-05, 0.0, 0.00017, 0.0, 7e-05, 7e-05, 0.0001, 0.0, 0.0, 6e-05, 0.00015, 0.0, 0.0, 4e-05, 0.00353, 0.0, 9e-05, 0.0, 7e-05, 2e-05, 0.0, 0.00022, 0.00017, 0.0, 2e-05, 0.0003, 8e-05, 0.00039, 0.00025, 0.00059, 0.00028, 0.0, 0.00016, 0.00013, 0.00014, 0.0, 0.0, 0.00021, 0.00012, 0.0, 0.0, 0.0, 0.00013, 0.00021, 0.00327, 8e-05, 2e-05, 8e-05, 1e-05, 0.0, 0.00011, 3e-05, 0.00022, 0.0, 0.00023, 0.0, 0.0, 0.00022, 0.00017, 0.00053, 0.00072, 0.00068, 4e-05, 0.00028, 0.0, 1e-05, 0.00014, 0.00016, 1e-05, 0.00016, 4e-05, 0.00034, 0.00019, 0.0, 0.0, 0.00185, 0.00013, 0.0, 0.00186, 0.00218, 0.0, 0.00013, 0.00218, 0.00392, 0.00057, 0.00043, 0.00024, 0.00012, 8e-05, 0.0, 0.0, 0.0, 0.0, 3e-05, 8e-05, 0.00053, 0.00016, 3e-05, 0.0, 0.0, 0.0, 7e-05, 5e-05, 1e-05, 5e-05, 0.0001, 5e-05, 0.0, 0.0001, 0.0, 0.0, 0.00101, 0.00112, 0.00422, 1e-05, 0.0, 1e-05, 0.00013, 0.00045, 0.0, 0.0, 0.0, 0.00456, 0.0, 0.0, 0.0, 0.00057, 7e-05, 0.0, 0.00057, 0.00036, 0.0, 7e-05, 0.00036, 0.00175, 0.0005, 0.00055, 0.0004, 0.00032, 0.00016, 0.00094, 0.00041, 0.0, 0.00012, 0.00066, 0.00017, 0.00012, 0.0, 0.00063, 0.00595, 0.00032, 0.00016, 0.00077, 0.00057, 0.0001, 8e-05, 0.0, 0.00079, 0.0, 0.0, 0.00011, 0.00037, 1e-05, 0.00015, 7e-05, 0.00025, 0.00023, 0.00027, 0.00012, 9e-05, 0.0, 0.00046, 0.0, 0.0, 9e-05, 0.00035, 0.00168, 0.00025, 0.00023, 0.0004, 3e-05, 3e-05, 1e-05, 0.0001, 0.00012, 0.0, 0.0001, 1e-05, 0.0, 5e-05, 0.0, 0.00026, 0.0, 1e-05, 9e-05, 0.00031, 9e-05, 0.0, 0.0, 0.0, 9e-05, 1e-05, 0.0002, 0.0, 3e-05, 8e-05, 0.00019, 0.00021, 0.0001, 0.00018, 8e-05, 0.0, 3e-05, 9e-05, 0.00016, 0.0, 9e-05, 9e-05, 0.0, 5e-05, 0.0, 0.0, 5e-05, 5e-05, 0.0, 5e-05, 0.00012, 0.0, 0.00031, 0.0, 0.0, 0.00012, 0.00052, 0.00409, 0.00034, 0.00014, 0.00072, 0.00091, 0.00011, 0.0, 0.00012, 0.00043, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00027, 0.00033, 0.0, 5e-05, 3e-05, 4e-05, 3e-05, 4e-05, 0.0, 0.00023, 3e-05, 5e-05, 0.00041, 0.0, 0.0, 0.00017, 0.00611, 0.00012, 0.00021, 0.00031, 0.0, 6e-05, 0.0, 0.00024, 0.0, 4e-05, 0.00024, 0.00024, 0.00012, 6e-05, 2e-05, 0.00184, 0.00023, 0.0, 2e-05, 0.00029, 0.0, 0.0001, 0.0001, 0.0, 0.0, 0.0, 0.00015, 0.00018, 0.00014, 0.00013, 0.00011, 0.00133, 0.0, 0.00012, 0.0, 0.00087, 0.00011, 0.0, 0.00022, 0.0008, 0.00014, 0.00013, 0.00013, 0.0, 0.0, 0.0, 0.00031, 7e-05, 0.00012, 7e-05, 0.0, 0.00059, 0.0, 0.00024, 1e-05, 0.00042, 0.00029, 0.00017, 0.0, 7e-05, 0.00012, 0.00043, 0.0, 0.0, 0.00015, 6e-05, 0.00012, 7e-05, 0.00031, 0.0, 0.00018, 0.0, 0.0008, 0.00052, 0.00043, 0.00036, 1e-05, 3e-05, 0.0, 0.00027, 0.0, 0.0, 0.0, 0.0, 0.00014, 7e-05, 1e-05, 0.00012, 0.00014, 0.0, 0.0, 0.00012, 0.0, 9e-05, 0.00047, 0.0, 9e-05, 0.0, 0.00027, 0.00046, 0.00027, 0.0002, 0.00015, 0.00022, 0.0, 8e-05, 0.00019, 0.00017, 8e-05, 0.0, 1e-05, 0.00048, 1e-05, 0.00028, 0.0, 0.00141, 0.0, 0.0, 0.00025, 0.00016, 4e-05, 0.00208, 0.00073, 0.0, 0.00025, 0.00014, 4e-05, 0.00016, 0.00174, 0.00053, 0.0002, 0.0, 0.0, 0.00049, 0.00026, 0.00026, 0.0, 0.00011, 0.0, 0.00018, 1e-05, 0.00016, 0.0, 0.00011, 0.00023, 0.00016, 0.00062, 1e-05, 0.00037, 0.0001, 6e-05, 0.00045, 0.00017, 6e-05, 0.0001, 0.00042, 0.00058, 0.00027, 0.0003, 0.00049, 0.0002, 0.0, 4e-05, 0.0, 4e-05, 1e-05, 3e-05, 5e-05, 0.00089, 0.0, 0.0, 4e-05, 0.0, 0.0, 0.00014, 0.0, 0.0, 9e-05, 0.00027, 0.0, 0.0002, 0.0, 0.0, 9e-05, 0.0, 0.00021, 0.00014, 0.0, 3e-05, 0.0, 0.00024, 0.00013, 0.0003, 0.00016, 3e-05, 0.0, 0.0, 0.00031, 6e-05, 2e-05, 0.0, 0.00039, 5e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00159, 0.00012, 3e-05, 0.00026, 0.00087, 0.0, 1e-05, 9e-05, 0.00077, 0.00015, 0.0, 0.00018, 0.00094, 0.0, 0.0002, 0.0004, 0.00028, 0.0, 0.0, 0.00028, 0.0, 0.0, 0.0, 0.0002, 0.0, 0.0, 0.00033, 0.0, 0.0, 3e-05, 0.00015, 0.00028, 0.00028, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00044, 0.0, 0.00011, 0.00022, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00156, 0.00155, 0.0, 0.00038, 0.0, 0.0, 5e-05, 1e-05, 0.00014, 0.0, 7e-05, 0.00028, 8e-05, 0.0, 0.00011, 0.00023, 0.0, 0.00013, 0.0, 0.00019, 7e-05, 0.0, 3e-05, 0.00056, 0.0, 4e-05, 0.0, 0.00053, 0.00021, 0.00034, 0.00053, 0.00058, 0.00034, 0.00021, 0.00058, 0.00102, 1e-05, 0.00014, 0.00102, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00037, 0.00037, 0.00021, 0.00012, 5e-05, 0.0, 0.00037, 0.0, 0.0, 5e-05, 0.00024, 0.00028, 0.00037, 0.00037, 0.00013, 0.00022, 0.00011, 1e-05, 0.0, 0.00021, 0.0, 0.0, 0.00011, 0.00013, 8e-05, 0.0, 1e-05, 0.00029, 0.0, 8e-05, 0.0, 0.0, 0.0001, 0.00043, 0.00018, 5e-05, 9e-05, 3e-05, 0.0001, 0.0, 0.00041, 0.00012, 0.0, 0.0001, 9e-05, 0.00035, 0.00032, 0.00027, 0.00059, 1e-05, 6e-05, 0.0, 0.00024, 6e-05, 0.0, 0.0001, 0.00036, 0.0, 0.0, 0.0001, 0.00013, 0.0, 0.0, 0.00016, 0.00012, 3e-05, 7e-05, 0.0, 0.00011, 6e-05, 5e-05, 5e-05, 0.00058, 0.0, 8e-05, 0.0, 0.0004, 2e-05, 1e-05, 0.0001, 0.00043, 0.00011, 0.0, 0.0, 0.00031, 0.0, 3e-05, 0.00032, 0.0, 0.0, 1e-05, 0.0002, 3e-05, 0.0, 0.00023, 0.0, 0.0, 0.0, 0.0, 0.00037, 0.00028, 3e-05, 0.0, 0.0, 1e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00091, 0.0, 3e-05, 8e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00102, 0.00091, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00351, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.42262, 0.0, 0.19471, 0.0, 0.8064, 0.0, 0.57953, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.72255, 0.0, 0.61733, 0.56765, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.25836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.26103, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.48452, 0.00018, 7e-05, 0.0, 2e-05, 6e-05, 0.0, 0.0002, 0.0, 0.00056, 0.0, 5e-05, 0.0, 0.00025, 3e-05, 0.0, 0.0003, 8e-05, 0.0, 3e-05, 0.00014, 0.00024, 0.00042, 0.0003, 6e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.28441, 0.0, 0.0, 0.0, 0.07122, 0.0, 0.0, 0.0, 0.36139, 0.0, 0.0, 0.0, 0.00067, 0.00072, 0.00012, 0.00431, 0.0, 0.0, 0.00505, 0.0, 0.0, 0.0004, 0.00379, 0.0, 0.0, 0.00437, 0.0, 0.0, 0.00017, 0.00169, 0.00027, 0.00025, 0.0005, 2e-05, 0.00016, 0.0, 0.00051, 0.0, 0.0, 0.00014, 0.0, 0.0, 0.00015, 0.0002, 0.0, 0.00034, 0.00027, 0.0, 8e-05, 0.00016, 0.0, 6e-05, 0.0, 0.0001, 1e-05, 0.00015, 0.0, 8e-05, 0.0, 2e-05, 0.00013, 8e-05, 0.0, 0.0, 0.00014, 0.0, 0.0, 2e-05, 0.00053, 0.0, 0.0, 5e-05, 0.0, 5e-05, 0.0, 0.00013, 4e-05, 0.0, 0.00037, 0.0, 0.0, 6e-05, 0.00011, 0.0, 4e-05, 0.00034, 0.0, 0.0, 0.0, 0.00015, 0.00021, 0.00017, 0.00036, 0.00015, 6e-05, 7e-05, 9e-05, 0.0, 1e-05, 6e-05, 0.0, 0.0, 0.00011, 0.00012, 5e-05, 0.00059, 4e-05, 0.00029, 0.00059, 0.00055, 0.00029, 4e-05, 0.00055, 0.00048, 0.00037, 7e-05, 0.00039, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.35497, 0.10255, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.00343, 0.0, 0.0, 1.00343, 0.0, 0.0, 0.0, 0.0, 1.79398, 0.45751, 0.0, 2.48969, 0.0, 0.0, 0.0, 0.0, 0.2536, 0.0, 0.0, 0.0, 0.58887, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00105, 0.0, 0.0, 0.0, 0.00092, 0.0, 0.0, 0.0, 0.00212, 0.0, 0.0, 0.0, 0.00064, 0.00028, 0.00014, 0.00065, 0.0004, 0.00014, 0.00028, 0.0004, 0.00087, 0.00041, 0.00017, 0.00044, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.14893, 0.0, 0.0, 0.0, 0.56032, 0.0, 0.0, 0.0, 0.0, 0.00051, 0.00048, 0.0, 0.0, 0.00048, 0.00051, 0.0, 0.0, 0.00105, 0.00092, 0.00045, 0.00023, 0.0001, 0.0, 0.00031, 6e-05, 3e-05, 0.00011, 0.00021, 0.0, 0.00012, 3e-05, 8e-05, 8e-05, 3e-05, 2e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00172, 0.00023, 0.0002, 0.00015, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.65411, 0.0, 0.0, 0.83803, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.58306, 0.0, 0.42915, 0.0, 0.0, 0.0, 0.0, 0.0, 1.86157, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.51166, 0.0, 0.0, 0.0, 0.0, 0.0, 0.51166, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.01221, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0006, 0.0, 0.0, 0.0, 0.00052, 0.0, 0.0, 0.0, 0.0015, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.14893, 0.03192, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0025, 0.0, 0.0, 0.0, 0.00182, 0.0, 0.0, 0.00032, 0.00263, 0.0, 0.0, 0.00024, 0.00736, 0.0, 0.0, 0.0, 2e-05, 0.0, 0.0, 0.0, 0.0, 0.00015, 2e-05, 6e-05, 0.0, 0.0, 0.0, 0.00015, 0.0, 6e-05, 0.00366, 0.0, 0.0, 0.0, 0.00213, 0.00288, 0.0]))),
   LayerError(circuit=<qiskit.circuit.quantumcircuit.QuantumCircuit object at 0x169b1da90>, qubits=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62, 64, 65, 66, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155], error=PauliLindbladError(generators=['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...', ...], rates=[...]))),
   LayerError(circuit=<qiskit.circuit.quantumcircuit.QuantumCircuit object at 0x1681dd610>, qubits=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62, 64, 65, 66, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155], error=PauliLindbladError(generators=['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII...', ...], rates=[...]))]},
 'version': 2}
```

El objeto `PubResult` tiene metadatos de resiliencia adicionales sobre los modelos de ruido aprendidos utilizados en la mitigación.

```python
# Print learned layer noise metadata
for field, value in pub_result.metadata["resilience"]["layer_noise"].items():
    print(f"{field}: {value}")
```

```text
noise_overhead: Infinity
total_mitigated_layers: 18
unique_mitigated_layers: 3
unique_mitigated_layers_noise_overhead: [1.4100369479435003e+44, 3.407263868699073e+112, 3.500660129782563e+37]
```

```python
# Exact data computed using the methods described in the original reference
# Y. Kim et al. "Evidence for the utility of quantum computing before fault tolerance" (Nature 618, 500–505 (2023))
# Directly used here for brevity
exact_data = np.array(
    [
        1,
        0.9899,
        0.9531,
        0.8809,
        0.7536,
        0.5677,
        0.3545,
        0.1607,
        0.0539,
        0.0103,
        0.0012,
        0.0,
    ]
)
```

### Graficar los resultados de la simulación de Trotter

El siguiente código crea una gráfica para comparar los resultados crudos y mitigados del experimento contra la solución exacta.

```python
"""Result visualization functions"""

def plot_trotter_results(
    pub_result: PubResult,
    angles: Sequence[float],
    plot_noise_factors: Sequence[float] | None = None,
    plot_extrapolator: Sequence[str] | None = None,
    exact: np.ndarray = None,
    close: bool = True,
):
    """Plot average magnetization from ZNE result data.
    Args:
        pub_result: The Estimator PubResult for the PEA experiment.
        angles: The Rx angle values for the experiment.
        plot_raw: If provided plot the unextrapolated data for the noise factors.
        plot_extrapolator: If provided plot all extrapolators, if False only plot
            the Automatic method.
        exact: Optional, the exact values to include in the plot. Should be a 1D
            array-like where the values represent exact magnetization.
        close: Close the Matplotlib figure before returning.
    Returns:
        The figure.
    """
    data = pub_result.data

    evs = data.evs
    num_qubits = evs.shape[0]
    num_params = evs.shape[1]
    angles = np.asarray(angles).ravel()
    if angles.shape != (num_params,):
        raise ValueError(
            f"Incorrect number of angles for input data {angles.size} != {num_params}"
        )

    # Take average magnetization of qubits and its standard error
    x_vals = angles / np.pi
    y_vals = np.mean(evs, axis=0)
    y_errs = np.std(evs, axis=0) / np.sqrt(num_qubits)

    fig, _ = plt.subplots(1, 1)

    # Plot auto method
    plt.errorbar(x_vals, y_vals, y_errs, fmt="o-", label="ZNE (automatic)")

    # Plot individual extrapolator results
    if plot_extrapolator:
        y_vals_extrap = np.mean(data.evs_extrapolated, axis=0)
        y_errs_extrap = np.std(data.evs_extrapolated, axis=0) / np.sqrt(
            num_qubits
        )
        for i, extrap in enumerate(plot_extrapolator):
            plt.errorbar(
                x_vals,
                y_vals_extrap[:, i, 0],
                y_errs_extrap[:, i, 0],
                fmt="s-.",
                alpha=0.5,
                label=f"ZNE ({extrap})",
            )

    # Plot raw results
    if plot_noise_factors:
        y_vals_raw = np.mean(data.evs_noise_factors, axis=0)
        y_errs_raw = np.std(data.evs_noise_factors, axis=0) / np.sqrt(
            num_qubits
        )
        for i, nf in enumerate(plot_noise_factors):
            plt.errorbar(
                x_vals,
                y_vals_raw[:, i],
                y_errs_raw[:, i],
                fmt="d:",
                alpha=0.5,
                label=f"Raw (nf={nf:.1f})",
            )

    # Plot exact data
    if exact is not None:
        plt.plot(x_vals, exact, "--", color="black", alpha=0.5, label="Exact")

    plt.ylim(-0.1, 1.2)
    plt.xlabel("θ/π")
    plt.ylabel(r"$\overline{\langle Z \rangle}$")
    plt.legend()
    plt.title(
        f"Error Mitigated Average Magnetization for Rx(θ) [{num_qubits}-qubit]"
    )
    if close:
        plt.close(fig)
    return fig
```

```python
zne_metadata = primitive_result.metadata["resilience"]["zne"]
# Plot Trotter simulation results
fig = plot_trotter_results(
    pub_result,
    parameter_values,
    plot_extrapolator=zne_metadata["extrapolator"],
    plot_noise_factors=zne_metadata["noise_factors"],
    exact=exact_data,
)
display(fig)
```

![Output of the previous code cell](/docs/images/tutorials/probabilistic-error-amplification/extracted-outputs/2e0f0e84-32ba-4655-91c1-8445016bbeb2-0.avif)

Mientras que los valores ruidosos (factor de ruido `nf=1.0`) muestran una alta desviación respecto a los valores exactos, los valores mitigados se encuentran cercanos a los valores exactos, lo que demuestra la utilidad de la técnica de mitigación basada en PEA.
### Graficar los resultados de extrapolación para qubits individuales

Finalmente, el siguiente código crea una gráfica para mostrar las curvas de extrapolación para diferentes valores de theta en un qubit específico.

```python
def plot_qubit_zne_data(
    pub_result: PubResult,
    angles: Sequence[float],
    qubit: int,
    noise_factors: Sequence[float],
    extrapolator: Sequence[str] | None = None,
    extrapolated_noise_factors: Sequence[float] | None = None,
    num_cols: int | None = None,
    close: bool = True,
):
    """Plot ZNE extrapolation data for specific virtual qubit
    Args:
        pub_result: The Estimator PubResult for the PEA experiment.
        angles: The Rx theta angles used for the experiment.
        qubit: The virtual qubit index to plot.
        noise_factors: the raw noise factors.
        extrapolator: The extrapolator metadata for multiple extrapolators.
        extrapolated_noise_factors: The noise factors used for extrapolation.
        num_cols: The number of columns for the generated subplots.
        close: Close the Matplotlib figure before returning.
    Returns:
        The Matplotlib figure.
    """
    data = pub_result.data

    evs_auto = data.evs[qubit]
    stds_auto = data.stds[qubit]
    evs_extrap = data.evs_extrapolated[qubit]
    stds_extrap = data.stds_extrapolated[qubit]
    evs_raw = data.evs_noise_factors[qubit]
    stds_raw = data.stds_noise_factors[qubit]

    num_params = evs_auto.shape[0]
    angles = np.asarray(angles).ravel()
    if angles.shape != (num_params,):
        raise ValueError(
            f"Incorrect number of angles for input data {angles.size} != {num_params}"
        )

    # Make a square subplot
    num_cols = num_cols or int(np.ceil(np.sqrt(num_params)))
    num_rows = int(np.ceil(num_params / num_cols))
    fig, axes = plt.subplots(
        num_rows, num_cols, sharex=True, sharey=True, figsize=(12, 5)
    )
    fig.suptitle(f"ZNE data for virtual qubit {qubit}")

    for pidx, ax in zip(range(num_params), axes.flat):
        # Plot auto extrapolated
        ax.errorbar(
            0,
            evs_auto[pidx],
            stds_auto[pidx],
            fmt="o",
            label="PEA (automatic)",
        )

        # Plot extrapolators
        if (
            extrapolator is not None
            and extrapolated_noise_factors is not None
        ):
            for i, method in enumerate(extrapolator):
                ax.errorbar(
                    extrapolated_noise_factors,
                    evs_extrap[pidx, i],
                    stds_extrap[pidx, i],
                    fmt="-",
                    alpha=0.5,
                    label=f"PEA ({method})",
                )

        # Plot raw
        ax.errorbar(
            noise_factors, evs_raw[pidx], stds_raw[pidx], fmt="d", label="Raw"
        )

        ax.set_yticks([0, 0.5, 1, 1.5, 2])
        ax.set_ylim(0, max(1, 1.1 * max(evs_auto)))

        ax.set_xticks([0, *noise_factors])
        ax.set_title(f"θ/π = {angles[pidx]/np.pi:.2f}")
        if pidx == 0:
            ax.set_ylabel(r"$\langle Z_{" + str(qubit) + r"} \rangle$")
        if pidx == num_params - 1:
            ax.set_xlabel("Noise Factor")
            ax.legend()
    if close:
        plt.close(fig)
    return fig
```

```python
virtual_qubit = 1
plot_qubit_zne_data(
    pub_result=pub_result,
    angles=parameter_values,
    qubit=virtual_qubit,
    noise_factors=zne_metadata["noise_factors"],
    extrapolator=zne_metadata["extrapolator"],
    extrapolated_noise_factors=zne_metadata["extrapolated_noise_factors"],
)
```

![Output of the previous code cell](/docs/images/tutorials/probabilistic-error-amplification/extracted-outputs/6948475c-bc15-493f-8af9-f8e66d0e467c-0.avif)

## Encuesta del tutorial

Por favor, tome esta breve encuesta para proporcionar comentarios sobre este tutorial. Sus opiniones nos ayudarán a mejorar nuestras ofertas de contenido y la experiencia del usuario.

[Enlace a la encuesta](https://your.feedback.ibm.com/jfe/form/SV_9z7nltLeb5cX9Cm)
