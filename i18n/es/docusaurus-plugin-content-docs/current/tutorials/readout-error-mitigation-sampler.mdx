---
title: "Mitigaci√≥n de errores de lectura para la primitiva Sampler utilizando M3"
sidebar_label: "Mitigaci√≥n de errores de lectura para la primitiva Sampler utilizando M3"
description: "Utiliza el complemento de mitigaci√≥n de lectura M3 con la primitiva Sampler"
notebook_path: "docs/tutorials/readout-error-mitigation-sampler.ipynb"
---
{/* doqumentation-source-hash: 5aeb81f3 */}

<OpenInLabBanner notebookPath="docs/tutorials/readout-error-mitigation-sampler.ipynb" />



{/* cspell:ignore braket, Zgrm, newcommand, probs, quasis, topten */}

*Estimaci√≥n de uso: menos de un minuto en un procesador Heron r2 (NOTA: Esta es solo una estimaci√≥n. Su tiempo de ejecuci√≥n puede variar.)*

## Antecedentes {#background}

A diferencia de la primitiva Estimator, la primitiva Sampler no tiene soporte integrado para la mitigaci√≥n de errores.
Varios de los m√©todos soportados por el Estimator est√°n dise√±ados espec√≠ficamente para valores esperados y, por lo tanto, no son aplicables a la primitiva Sampler. Una excepci√≥n es la mitigaci√≥n de errores de lectura, que es un m√©todo altamente efectivo y tambi√©n aplicable a la primitiva Sampler.

El [complemento M3 de Qiskit](https://qiskit.github.io/qiskit-addon-mthree/) implementa un m√©todo eficiente para la mitigaci√≥n de errores de lectura. Este tutorial explica c√≥mo utilizar el complemento M3 de Qiskit para mitigar errores de lectura con la primitiva Sampler.

### ¬øQu√© es el error de lectura? {#what-is-readout-error}

Inmediatamente antes de la medici√≥n, el estado de un registro de qubits se describe
mediante una superposici√≥n de estados base computacionales,
o mediante una matriz de densidad.
La medici√≥n del registro de qubits en un registro de bits cl√°sicos procede entonces en dos pasos.
Primero se realiza la medici√≥n cu√°ntica propiamente dicha.
Esto significa que el estado del registro de qubits
se proyecta sobre un √∫nico estado base que se caracteriza
por una cadena de $1$s y $0$s.
El segundo paso consiste en leer la cadena de bits que caracteriza este estado base
y escribirla en la memoria de la computadora cl√°sica.
Llamamos a este paso *lectura*.
Resulta que el segundo paso (lectura) incurre en m√°s error que el primer paso (proyecci√≥n sobre estados base).
Esto tiene sentido cuando se recuerda que la lectura requiere detectar un estado
cu√°ntico microsc√≥pico y amplificarlo al √°mbito macrosc√≥pico. Un resonador de lectura se acopla al
qubit (transmon), experimentando as√≠ un desplazamiento de frecuencia muy peque√±o. Un pulso de microondas
se hace rebotar en el resonador, experimentando a su vez peque√±os cambios en sus
caracter√≠sticas. El pulso reflejado se amplifica y analiza. Este es un proceso delicado
y est√° sujeto a una gran cantidad de errores.

El punto importante es que, aunque tanto la medici√≥n cu√°ntica como la lectura est√°n sujetas a error, la
√∫ltima incurre en el error dominante, llamado error de lectura, que es el enfoque de este tutorial.
### Antecedentes te√≥ricos {#theoretical-background}

Si la cadena de bits muestreada (almacenada en la memoria cl√°sica) difiere de la cadena de bits que caracteriza
el estado cu√°ntico proyectado, decimos que ha ocurrido un error de lectura.
Se observa que estos errores son aleatorios y no est√°n correlacionados de muestra a muestra.
Ha resultado √∫til modelar el error de lectura como un _canal cl√°sico ruidoso_.
Es decir, para cada par de
cadenas de bits $i$ y $j$, existe una probabilidad fija de que un valor verdadero de $j$ sea
le√≠do incorrectamente como $i$.

M√°s precisamente, para cada par de cadenas de bits $(i, j)$, existe una probabilidad (condicional) ${M}_{i,j}$
de que se lee $i$, dado que el valor verdadero es $j.$
Es decir,
$$
    {M}_{i,j} =  \Pr(\text{readout value is } i | \text{true value is } j)
    \text{ for } i,j \in (0,...,2^n - 1), \tag{1}
$$
donde $n$ es el n√∫mero de bits en el registro de lectura.
Para ser concretos, asumimos que $i$ es un entero decimal cuya representaci√≥n binaria es
la cadena de bits que etiqueta los estados base computacionales.
Llamamos a la matriz $2^n \times 2^n$ ${M}$ la _matriz de asignaci√≥n_.
Para un valor verdadero fijo $j$, la suma de la probabilidad sobre todos los resultados ruidosos $i$ debe dar $1$. Es decir,
$$
    \sum_{i=0}^{2^n - 1} {M}_{i,j} = 1 \text{ for all } j
$$
Una matriz sin entradas negativas que satisface (1) se denomina
_estoc√°stica por la izquierda_.
Una matriz estoc√°stica por la izquierda tambi√©n se denomina _estoc√°stica por columnas_ porque cada una de sus columnas suma $1$.
Determinamos experimentalmente valores aproximados para cada elemento ${M}_{i,j}$ mediante
la preparaci√≥n repetida de cada estado base $|j \rangle$ y luego el c√°lculo de las frecuencias
de ocurrencia de las cadenas de bits muestreadas.

Si un experimento implica estimar una distribuci√≥n de probabilidad sobre cadenas de bits de salida mediante muestreo repetido,
entonces podemos usar ${M}$ para mitigar el error de lectura a nivel de la distribuci√≥n.
El primer paso es repetir un circuito fijo de inter√©s muchas veces,
creando un histograma de cadenas de bits muestreadas.
El histograma normalizado es la distribuci√≥n de probabilidad medida sobre
las $2^n$ cadenas de bits posibles, que denotamos por ${\tilde{p}} \in \mathbb{R}^{2^n}$.
La probabilidad (estimada) ${{\tilde{p}}}_i$ de muestrear la cadena de bits $i$
es igual a la suma sobre todas las cadenas de bits verdaderas $j$, cada una ponderada por
la probabilidad de que sea confundida con $i$.
Esta afirmaci√≥n en forma matricial es
$$
    {\tilde{p}} = {M} {\vec{p}}, \tag{2},
$$
donde ${\vec{p}}$ es la distribuci√≥n verdadera. En palabras, el error de lectura tiene el efecto de multiplicar
la distribuci√≥n ideal sobre cadenas de bits ${\vec{p}}$ por la matriz de asignaci√≥n ${M}$ para
producir la distribuci√≥n observada ${\tilde{p}}$.
Hemos medido ${\tilde{p}}$ y ${M}$, pero no tenemos acceso directo a ${\vec{p}}$. En principio, obtendremos
la distribuci√≥n verdadera de cadenas de bits para nuestro circuito
resolviendo num√©ricamente la ecuaci√≥n (2) para ${\vec{p}}$.

Antes de continuar, vale la pena se√±alar algunas caracter√≠sticas importantes de este enfoque ingenuo.

- En la pr√°ctica, la ecuaci√≥n (2) no se resuelve invirtiendo ${M}$. Las rutinas de √°lgebra lineal
  en las bibliotecas de software emplean m√©todos que son m√°s estables, precisos y eficientes.
- Al estimar ${M}$, asumimos que solo ocurrieron errores de lectura. En particular,
  asumimos que no hubo errores de preparaci√≥n de estado ni de medici√≥n cu√°ntica,
  o al menos que fueron mitigados de otra manera.
  En la medida en que esta sea una buena suposici√≥n, ${M}$ realmente representa
  solo el error de lectura. Pero cuando _usamos_ ${M}$ para corregir una distribuci√≥n medida
  sobre cadenas de bits, no hacemos tal suposici√≥n. De hecho, esperamos que un circuito interesante
  introduce ruido, por ejemplo, errores de compuerta. La distribuci√≥n "verdadera"
  todav√≠a incluye efectos de cualquier error que no se haya mitigado de otra manera.

Este m√©todo, aunque √∫til en algunas circunstancias, tiene algunas limitaciones.

Los recursos de espacio y tiempo necesarios para estimar ${M}$ crecen exponencialmente en $n$:
- La estimaci√≥n de ${M}$ y ${\tilde{p}}$ est√° sujeta a error estad√≠stico debido al muestreo finito.
  Este ruido puede hacerse tan peque√±o como se desee
  a costa de m√°s disparos (hasta la escala temporal de los par√°metros de hardware que derivan
  y resultan en errores sistem√°ticos en ${M}$).
  Sin embargo, si no se hacen suposiciones sobre las cadenas de bits observadas
  al realizar la mitigaci√≥n, el n√∫mero de disparos requeridos para estimar ${M}$ crece
  al menos exponencialmente en $n$.
- ${M}$ es una matriz de $2^n \times 2^n$.
  Cuando $n>10$, la cantidad de memoria requerida para almacenar ${M}$ es
  mayor que la memoria disponible en una computadora port√°til potente.

Otras limitaciones son:

- La distribuci√≥n recuperada ${\vec{p}}$ puede tener una
  o m√°s probabilidades negativas (aunque sumen uno). Una soluci√≥n
  es minimizar $||{M} {\vec{p}} - {\tilde{p}}||^2$ sujeto a la restricci√≥n de que
  cada entrada en ${\vec{p}}$ sea no negativa. Sin embargo, el tiempo de ejecuci√≥n de tal
  m√©todo es √≥rdenes de magnitud m√°s largo que resolver directamente la ecuaci√≥n (2).
- Este procedimiento de mitigaci√≥n funciona a nivel de una distribuci√≥n de probabilidad
  sobre cadenas de bits. En particular, no puede corregir un error en una cadena de bits
  individual observada.
### Complemento M3 de Qiskit: Escalando a cadenas de bits m√°s largas {#qiskit-m3-addon-scaling-to-longer-bitstrings}

Resolver la ecuaci√≥n (2) usando rutinas est√°ndar de √°lgebra lineal num√©rica est√° limitado a cadenas de bits de no m√°s de aproximadamente 10 bits. M3, sin embargo, puede manejar cadenas de bits mucho m√°s largas. Dos propiedades clave de M3 que hacen esto posible son:
- Se asume que las correlaciones en el error de lectura de orden tres y superior entre colecciones de bits
  son despreciables y se ignoran. En principio, a costa de m√°s disparos,
  se podr√≠an estimar correlaciones de orden superior tambi√©n.
- En lugar de construir ${M}$ expl√≠citamente, usamos una matriz efectiva mucho m√°s peque√±a que registra
  probabilidades solo para las cadenas de bits recolectadas al construir ${\tilde{p}}$.

A un alto nivel, el procedimiento funciona de la siguiente manera.

Primero, construimos bloques a partir de los cuales podemos construir una descripci√≥n simplificada y efectiva de ${M}$.
Luego, ejecutamos repetidamente el circuito de inter√©s y recolectamos cadenas de bits que usamos para construir
tanto ${\tilde{p}}$ como, con la ayuda de los bloques, una ${M}$ efectiva.

M√°s precisamente,
- Se estiman matrices de asignaci√≥n de un solo qubit para cada qubit. Para hacer esto, preparamos repetidamente
  el registro de qubits en el estado de todos ceros $|0 ... 0 \rangle$ y luego en el estado de todos unos
  $|1 ... 1 \rangle$, y registramos la probabilidad para cada qubit de que sea le√≠do
  incorrectamente.
- Se asume que las correlaciones de orden tres y superior son despreciables y se ignoran.

  En su lugar, construimos un n√∫mero $n$ de matrices de asignaci√≥n de un solo qubit
  de $2 \times 2$, y un n√∫mero $n(n-1)/2$ de matrices de asignaci√≥n de dos qubits
  de $4 \times 4$. Estas matrices de asignaci√≥n de uno y dos qubits se almacenan para uso
  posterior.
- Despu√©s de muestrear repetidamente un circuito para construir ${\tilde{p}}$,
  construimos una aproximaci√≥n efectiva de ${M}$ usando solo
  las cadenas de bits que se muestrean al construir ${\tilde{p}}$. Esta matriz efectiva
  se construye usando las matrices de uno y dos qubits descritas en el elemento anterior.
  La dimensi√≥n lineal de esta matriz es a lo sumo del orden del n√∫mero
  de disparos utilizados en la construcci√≥n de ${\tilde{p}}$, que es mucho menor que
  la dimensi√≥n $2^n$ de la matriz de asignaci√≥n completa ${M}$.

Para detalles t√©cnicos sobre M3, puede consultar [*Scalable Mitigation of Measurement Errors on Quantum Computers*](https://journals.aps.org/prxquantum/abstract/10.1103/PRXQuantum.2.040326).
### Aplicaci√≥n de M3 a un algoritmo cu√°ntico {#application-of-m3-to-a-quantum-algorithm}
Aplicaremos la mitigaci√≥n de lectura de M3 al problema del desplazamiento oculto. El problema del desplazamiento oculto, y problemas estrechamente relacionados como el [problema del subgrupo oculto](https://en.wikipedia.org/wiki/Hidden_subgroup_problem), fueron concebidos originalmente en un entorno tolerante a fallos (m√°s precisamente, ¬°antes de que se demostrara que los QPU tolerantes a fallos eran posibles!). Pero tambi√©n se estudian con los procesadores disponibles. Un ejemplo de aceleraci√≥n exponencial algor√≠tmica obtenida para una variante del problema del desplazamiento oculto en QPU IBM&reg; de 127 qubits se puede encontrar en [este art√≠culo](https://journals.aps.org/prx/accepted/a9074K06A8e1590147da9c69f8c4b64c28247be5a) ([versi√≥n arXiv](https://arxiv.org/abs/2401.07934)).

En lo que sigue, toda la aritm√©tica es booleana.
Es decir, para $a, b \in \mathbb{Z}_2 = \{0, 1\}$, la suma, $a + b$ es la funci√≥n l√≥gica XOR.
Adem√°s, la multiplicaci√≥n $a \times b$ (o $a b$) es la funci√≥n l√≥gica AND. Para $x, y \in \{0, 1\}^n$,
$x + y$ se define por la aplicaci√≥n bit a bit de XOR.
El producto punto $\cdot: {\mathbb{Z}_2^n} \rightarrow \mathbb{Z}_2$ se define
por $x \cdot y = \sum_i x_i y_i$.
#### Operador de Hadamard y transformada de Fourier {#hadamard-operator-and-fourier-transform}

Al implementar algoritmos cu√°nticos, es muy com√∫n usar el operador de Hadamard como una transformada de Fourier.
Los estados base computacionales a veces se denominan _estados cl√°sicos_. Est√°n en
una relaci√≥n biun√≠voca con las cadenas de bits cl√°sicas.
El operador de Hadamard de $n$ qubits sobre estados cl√°sicos puede verse como una transformada de Fourier sobre el hipercubo booleano:
$$
H^{\otimes n} =  \frac{1}{\sqrt{2^n}} \sum_{x,y \in {\mathbb{Z}_2^n}} (-1)^{x \cdot y} {|{y}\rangle}{\langle{x}|}.
$$
Considera un estado ${|{s}\rangle}$ correspondiente a una cadena de bits fija $s$.
Aplicando $H^{\otimes n}$, y usando ${\langle {x}|{s}\rangle} = \delta_{x,s}$,
vemos que la transformada de Fourier de ${|{s}\rangle}$ puede escribirse como
$$
   H^{\otimes n} {|{s}\rangle} =  \frac{1}{\sqrt{2^n}} \sum_{y \in {\mathbb{Z}_2^n}} (-1)^{s \cdot y} {|{y}\rangle}.
$$

La Hadamard es su propia inversa, es decir,
 $H^{\otimes n} H^{\otimes n} = (H H)^{\otimes n} = I^{\otimes n}$.
As√≠, la transformada de Fourier inversa es el mismo operador, $H^{\otimes n}$.
Expl√≠citamente, tenemos,
$$
  {|{s}\rangle} =  H^{\otimes n} H^{\otimes n} {|{s}\rangle}  =  H^{\otimes n} \frac{1}{\sqrt{2^n}} \sum_{y \in {\mathbb{Z}_2^n}} (-1)^{s \cdot y} {|{y}\rangle}.
$$
#### El problema del desplazamiento oculto {#the-hidden-shift-problem}

Consideramos un ejemplo simple de un _problema de desplazamiento oculto_.
El problema consiste en identificar un desplazamiento constante en la entrada de una funci√≥n.
La funci√≥n que consideramos es el producto punto. Es el miembro m√°s simple
de una gran clase de funciones que admiten una aceleraci√≥n cu√°ntica para el problema de desplazamiento
oculto mediante t√©cnicas similares a las presentadas a continuaci√≥n.

Sean $x,y \in {\mathbb{Z}_2^m}$ cadenas de bits de longitud $m$.
Definimos ${f}: {\mathbb{Z}_2^m} \times {\mathbb{Z}_2^m} \rightarrow \{-1,1\}$ por
$$
  {f}(x, y) = (-1)^{x \cdot y}.
$$
  Sean $a,b \in {\mathbb{Z}_2^m}$ cadenas de bits fijas de longitud $m$.
  Adem√°s definimos $g: {\mathbb{Z}_2^m} \times {\mathbb{Z}_2^m} \rightarrow \{-1,1\}$ por
$$
  g(x, y) = {f}(x+a, y+b) = (-1)^{(x+a) \cdot (y+b)},
  $$
  donde $a$ y $b$ son par√°metros (ocultos).
  Se nos dan dos cajas negras, una que implementa $f$ y la otra $g$.
  Suponemos que sabemos que calculan las funciones definidas anteriormente, excepto que no conocemos
  ni $a$ ni $b$. El juego consiste en determinar las cadenas de bits (desplazamientos) ocultas
  $a$ y $b$ haciendo consultas a $f$ y $g$. Est√° claro que si jugamos el juego de forma cl√°sica,
  necesitamos $O(2m)$ consultas para determinar $a$ y $b$. Por ejemplo, podemos consultar $g$ con todos los pares de cadenas tales que un elemento del par sea todo ceros, y el otro elemento ten exactamente un elemento establecido en $1$.
  En cada consulta, aprendemos un elemento de $a$ o de $b$.
  Sin embargo, veremos que, si las cajas negras se implementan como circuitos cu√°nticos, podemos
  determinar $a$ y $b$ con una sola consulta a cada una de $f$ y $g$.

  En el contexto de la complejidad algor√≠tmica, una caja negra se denomina _or√°culo_.
  Adem√°s de ser opaco, un or√°culo tiene la propiedad de que consume la entrada y
  produce la salida instant√°neamente, sin agregar nada al presupuesto de complejidad del algoritmo
  en el que est√° integrado. De hecho, en el caso que nos ocupa, los or√°culos que implementan $f$ y
  $g$ resultar√°n ser eficientes.
#### Circuitos cu√°nticos para $f$ y $g$ {#quantum-circuits-for-f-and-g}

Necesitamos los siguientes ingredientes para implementar $f$ y $g$ como circuitos cu√°nticos.

Para estados cl√°sicos de un solo qubit ${|{x_1}\rangle}, {|{y_1}\rangle}$, con $x_1,y_1 \in \mathbb{Z}_2$,
la compuerta $Z$ controlada ${CZ}$ puede escribirse como
$$
{CZ} {|{x_1}\rangle}{|{y_1}\rangle}{x_1} = (-1)^{x_1 y_1} {|{x_1}\rangle}{x_1}{|{y_1}\rangle}.
$$
Operaremos con $m$ compuertas CZ, una sobre $(x_1, y_1)$, y una sobre $(x_2, y_2)$, y as√≠ sucesivamente, hasta $(x_m, y_m)$.
Llamamos a este operador ${CZ}_{x,y}$.

$U_f = {CZ}_{x,y}$ es una versi√≥n cu√°ntica de ${f} = {f}(x,y)$:
$$
%\CZ_{x,y} {|#1\rangle}{z} =
U_f {|{x}\rangle}{|{y}\rangle} = {CZ}_{x,y} {|{x}\rangle}{|{y}\rangle} = (-1)^{x \cdot y}  {|{x}\rangle}{|{y}\rangle}.
$$

Tambi√©n necesitamos implementar un desplazamiento de cadena de bits.
Denotamos el operador en el registro $x$ $X^{a_1}\cdots X^{a_m}$ por $X_a$
y de manera similar en el registro $y$ $X_b =  X^{b_1}\cdots X^{b_m}$.
Estos operadores aplican $X$ dondequiera que un bit individual sea $1$, y la identidad $I$ dondequiera que sea $0$.
Entonces tenemos
$$
 X_a X_b  {|{x}\rangle}{|{y}\rangle} = {|{x+a}\rangle}{|{y+b}\rangle}.
$$

La segunda caja negra $g$ se implementa mediante el unitario $U_g$, dado por
$$
%U_g {|{x}\rangle}{|{y}\rangle} = X_aX_b \CZ_{x,y} X_aX_b {|{x}\rangle}{|{y}\rangle}.
U_g = X_aX_b {CZ}_{x,y} X_aX_b.
$$
Para ver esto, aplicamos los operadores de derecha a izquierda al estado ${|{x}\rangle}{|{y}\rangle}$.
Primero

$$
 X_a X_b  {|{x}\rangle}{|{y}\rangle} = {|{x+a}\rangle}{|{y+b}\rangle}.
$$

Luego,
$$
  {CZ}_{x,y}  {|{x+a}\rangle}{|{y+b}\rangle} = (-1)^{(x+a)\cdot (y+b)} {|{x+a}\rangle}{|{y+b}\rangle}.
$$

Finalmente,

$$
  X^a X^b (-1)^{(x+a)\cdot (y+b)} {|{x+a}\rangle}{|{y+b}\rangle} = (-1)^{(x+a)\cdot (y+b)} {|{x}\rangle}{|{y}\rangle},
$$

que es efectivamente la versi√≥n cu√°ntica de $f(x+a, y+b)$.
#### El algoritmo de desplazamiento oculto {#the-hidden-shift-algorithm}

Ahora juntamos las piezas para resolver el problema de desplazamiento oculto.
Comenzamos aplicando Hadamards a los registros inicializados en el estado de todos ceros.
$$
H^{\otimes 2m} = H^{\otimes m} \otimes H^{\otimes m} {{|{0}\rangle}^{\otimes m}}{{|{0}\rangle}^{\otimes m}} = \frac{1}{\sqrt{2^{2m}}} \sum_{x, y \in {\mathbb{Z}_2^m}} (-1)^{x \cdot y} {|{x}\rangle}{|{y}\rangle}.
$$

A continuaci√≥n, consultamos el or√°culo $g$ para llegar a
$$
U_g H^{\otimes 2m} {{|{0}\rangle}^{\otimes m}}{{|{0}\rangle}^{\otimes m}}
= \frac{1}{\sqrt{2^{2m}}} \sum_{x, y \in {\mathbb{Z}_2^m}} (-1)^{(x+a) \cdot (y+b)} {|{x}\rangle}{|{y}\rangle}
$$
$$
\approx \frac{1}{\sqrt{2^{2m}}} \sum_{x, y \in {\mathbb{Z}_2^m}} (-1)^{x \cdot y + x \cdot b + y \cdot a} {|{x}\rangle}{|{y}\rangle}.
$$
En la √∫ltima l√≠nea, omitimos el factor de fase global constante $(-1)^{a \cdot b}$,
y denotamos la igualdad salvo una fase por $\approx$.
A continuaci√≥n, aplicar el or√°culo $f$ introduce otro factor de $(-1)^{x \cdot y}$, cancelando el que ya estaba
presente. Entonces tenemos:
$$
U_f U_g H^{\otimes 2m} {{|{0}\rangle}^{\otimes m}}{{|{0}\rangle}^{\otimes m}}
\approx \frac{1}{\sqrt{2^{2m}}} \sum_{x, y \in {\mathbb{Z}_2^m}} (-1)^{x \cdot b + y \cdot a} {|{x}\rangle}{|{y}\rangle}.
$$
El paso final es aplicar la transformada de Fourier inversa, $H^{\otimes 2m} = H^{\otimes m} \otimes H^{\otimes m}$,
resultando en
$$
H^{\otimes 2m} U_f U_g  H^{\otimes 2m} {{|{0}\rangle}^{\otimes m}}{{|{0}\rangle}^{\otimes m}}
\approx {|{b}\rangle}{|{a}\rangle}.
$$
El circuito est√° terminado. En ausencia de ruido, muestrear los registros cu√°nticos devolver√°
las cadenas de bits $b, a$ con probabilidad $1$.

El producto interno booleano es un ejemplo de las llamadas funciones bent.
No definiremos las funciones bent aqu√≠,
sino que simplemente notamos que
"son m√°ximamente resistentes contra ataques que buscan explotar una dependencia de
las salidas en alg√∫n subespacio lineal de las entradas."
Esta cita es del art√≠culo [_Quantum algorithms for highly non-linear Boolean functions_](https://arxiv.org/abs/0811.3208), que
ofrece algoritmos de desplazamiento oculto eficientes para varias clases de funciones bent.
El algoritmo de este tutorial aparece en la Secci√≥n 3.1 del art√≠culo.

En el caso m√°s general, el circuito para encontrar un desplazamiento oculto $s \in \mathbb{Z}^n$ es
$$
 H^{\otimes n} U_{\tilde{f}}  H^{\otimes n} U_g  H^{\otimes n} {|{0}\rangle}^{\otimes n} = {|{s}\rangle}.
$$
 En el caso general, $f$ y $g$ son funciones de una sola variable.
 Nuestro ejemplo del producto interno tiene esta forma si hacemos $f(x, y) \to f(z)$,
 con $z$ igual a la concatenaci√≥n de $x$ e $y$, y $s$ igual a la concatenaci√≥n
 de $a$ y $b$.
 El caso general requiere exactamente dos or√°culos: Un or√°culo para $g$ y uno para $\tilde{f}$,
 donde el √∫ltimo es una funci√≥n conocida como el _dual_ de la funci√≥n bent $f$.
 La funci√≥n de producto interno tiene la propiedad de auto-dualidad $\tilde{f}=f$.

 En nuestro circuito para el desplazamiento oculto sobre el producto interno omitimos la capa intermedia
 de Hadamards que aparece en el circuito para el caso general. Si bien en el caso general
 esta capa es necesaria, ahorramos un poco de profundidad al omitirla, a expensas de un poco
 de posprocesamiento porque la salida es ${|{b}\rangle}{|{a}\rangle}$ en lugar del deseado ${|{a}\rangle}{|{b}\rangle}$.
## Requisitos {#requirements}

Antes de comenzar este tutorial, aseg√∫rate de tener instalado lo siguiente:

- Qiskit SDK v2.1 o posterior, con soporte de [visualizaci√≥n](https://docs.quantum.ibm.com/api/qiskit/visualization)
- Qiskit Runtime v0.41 o posterior (`pip install qiskit-ibm-runtime`)
- Complemento M3 de Qiskit v3.0 (`pip install mthree`)
## Configuraci√≥n {#setup}

```python
# Added by doQumentation ‚Äî installs packages not in the Binder environment
%pip install -q mthree
```

```python
from collections.abc import Iterator, Sequence
from random import Random
from qiskit.circuit import (
    CircuitInstruction,
    QuantumCircuit,
    QuantumRegister,
    Qubit,
)
from qiskit.circuit.library import CZGate, HGate, XGate
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit_ibm_runtime import QiskitRuntimeService
import timeit
import matplotlib.pyplot as plt
from qiskit_ibm_runtime import SamplerV2 as Sampler
import mthree
```
## Paso 1: Mapear las entradas cl√°sicas a un problema cu√°ntico {#step-1-map-classical-inputs-to-a-quantum-problem}
Primero, escribimos las funciones para implementar el problema de desplazamiento oculto como un `QuantumCircuit`.

```python
def apply_hadamards(qubits: Sequence[Qubit]) -> Iterator[CircuitInstruction]:
    """Apply a Hadamard gate to every qubit."""
    for q in qubits:
        yield CircuitInstruction(HGate(), [q], [])

def apply_shift(
    qubits: Sequence[Qubit], shift: int
) -> Iterator[CircuitInstruction]:
    """Apply X gates where the bits of the shift are equal to 1."""
    for i, q in zip(range(shift.bit_length()), qubits):
        if shift >> i & 1:
            yield CircuitInstruction(XGate(), [q], [])

def oracle_f(qubits: Sequence[Qubit]) -> Iterator[CircuitInstruction]:
    """Apply the f oracle."""
    for i in range(0, len(qubits) - 1, 2):
        yield CircuitInstruction(CZGate(), [qubits[i], qubits[i + 1]])

def oracle_g(
    qubits: Sequence[Qubit], shift: int
) -> Iterator[CircuitInstruction]:
    """Apply the g oracle."""
    yield from apply_shift(qubits, shift)
    yield from oracle_f(qubits)
    yield from apply_shift(qubits, shift)

def determine_hidden_shift(
    qubits: Sequence[Qubit], shift: int
) -> Iterator[CircuitInstruction]:
    """Determine the hidden shift."""
    yield from apply_hadamards(qubits)
    yield from oracle_g(qubits, shift)
    # We omit this layer in exchange for post processing
    # yield from apply_hadamards(qubits)
    yield from oracle_f(qubits)
    yield from apply_hadamards(qubits)

def run_hidden_shift_circuit(n_qubits, rng):
    hidden_shift = rng.getrandbits(n_qubits)

    qubits = QuantumRegister(n_qubits, name="q")
    circuit = QuantumCircuit.from_instructions(
        determine_hidden_shift(qubits, hidden_shift), qubits=qubits
    )
    circuit.measure_all()
    # Format the hidden shift as a string.
    hidden_shift_string = format(hidden_shift, f"0{n_qubits}b")
    return (circuit, hidden_shift, hidden_shift_string)

def display_circuit(circuit):
    return circuit.remove_final_measurements(inplace=False).draw(
        "mpl", idle_wires=False, scale=0.5, fold=-1
    )
```

Comenzaremos con un ejemplo peque√±o:

```python
n_qubits = 6
random_seed = 12345
rng = Random(random_seed)
circuit, hidden_shift, hidden_shift_string = run_hidden_shift_circuit(
    n_qubits, rng
)

print(f"Hidden shift string {hidden_shift_string}")

display_circuit(circuit)
```

```text
Hidden shift string 011010
```

![Output of the previous code cell](/docs/images/tutorials/readout-error-mitigation-sampler/extracted-outputs/8297843e-00c3-4bb5-9d33-a7e558d1698c-1.avif)

## Paso 2: Optimizar los circuitos para la ejecuci√≥n en hardware cu√°ntico {#step-2-optimize-circuits-for-quantum-hardware-execution}

```python
job_tags = [
    f"shift {hidden_shift_string}",
    f"n_qubits {n_qubits}",
    f"seed = {random_seed}",
]
job_tags
```

```text
['shift 011010', 'n_qubits 6', 'seed = 12345']
```

```python
# Uncomment this to run the circuits on a quantum computer on IBMCloud.
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=100
)

# from qiskit_ibm_runtime.fake_provider import FakeMelbourneV2
# backend = FakeMelbourneV2()
# backend.refresh(service)

print(f"Using backend {backend.name}")

def get_isa_circuit(circuit, backend):
    pass_manager = generate_preset_pass_manager(
        optimization_level=3, backend=backend, seed_transpiler=1234
    )
    isa_circuit = pass_manager.run(circuit)
    return isa_circuit

isa_circuit = get_isa_circuit(circuit, backend)
display_circuit(isa_circuit)
```

```text
Using backend ibm_kingston
```

![Output of the previous code cell](/docs/images/tutorials/readout-error-mitigation-sampler/extracted-outputs/f2b77d93-c34a-43a4-b436-e7a25024a94a-1.avif)

## Paso 3: Ejecutar los circuitos utilizando primitivas de Qiskit {#step-3-execute-circuits-using-qiskit-primitives}

```python
# submit job for solving the hidden shift problem using the Sampler primitive
NUM_SHOTS = 50_000

def run_sampler(backend, isa_circuit, num_shots):
    sampler = Sampler(mode=backend)
    sampler.options.environment.job_tags
    pubs = [(isa_circuit, None, NUM_SHOTS)]
    job = sampler.run(pubs)
    return job

def setup_mthree_mitigation(isa_circuit, backend):
    # retrieve the final qubit mapping so mthree knows which qubits to calibrate
    qubit_mapping = mthree.utils.final_measurement_mapping(isa_circuit)

    # submit jobs for readout error calibration
    mit = mthree.M3Mitigation(backend)
    mit.cals_from_system(qubit_mapping, rep_delay=None)

    return mit, qubit_mapping
```

```python
job = run_sampler(backend, isa_circuit, NUM_SHOTS)
mit, qubit_mapping = setup_mthree_mitigation(isa_circuit, backend)
```
## Paso 4: Posprocesar y devolver los resultados en formato cl√°sico {#step-4-post-process-and-return-results-in-classical-format}

En la discusi√≥n te√≥rica anterior, determinamos que para la entrada $ab$, esperamos la salida $ba$.
Una complicaci√≥n adicional es que, para tener un circuito m√°s simple (antes de la transpilaci√≥n), insertamos las compuertas CZ requeridas entre
pares de qubits vecinos. Esto equivale a intercalar las cadenas de bits $a$ y $b$ como $a1 b1 a2 b2 \ldots$.
La cadena de salida $ba$ estar√° intercalada de manera similar: $b1 a1 b2 a2 \ldots$. La funci√≥n `unscramble` a continuaci√≥n
transforma la cadena de salida de $b1 a1 b2 a2 \ldots$ a $a1 b1 a2 b2 \ldots$ para que las cadenas de entrada y salida puedan compararse directamente.

```python
# retrieve bitstring counts
def get_bitstring_counts(job):
    result = job.result()
    pub_result = result[0]
    counts = pub_result.data.meas.get_counts()
    return counts, pub_result
```

```python
counts, pub_result = get_bitstring_counts(job)
```

La distancia de Hamming entre dos cadenas de bits es el n√∫mero de √≠ndices en los que los bits difieren.

```python
def hamming_distance(s1, s2):
    weight = 0
    for c1, c2 in zip(s1, s2):
        (c1, c2) = (int(c1), int(c2))
        if (c1 == 1 and c2 == 1) or (c1 == 0 and c2 == 0):
            weight += 1

    return weight
```

```python
# Replace string of form a1b1a2b2... with b1a1b2a1...
# That is, reverse order of successive pairs of bits.
def unscramble(bitstring):
    ps = [bitstring[i : i + 2][::-1] for i in range(0, len(bitstring), 2)]
    return "".join(ps)

def find_hidden_shift_bitstring(counts, hidden_shift_string):
    # convert counts to probabilities
    probs = {
        unscramble(bitstring): count / NUM_SHOTS
        for bitstring, count in counts.items()
    }

    # Retrieve the most probable bitstring.
    most_probable = max(probs, key=lambda x: probs[x])

    print(f"Expected hidden shift string: {hidden_shift_string}")
    if most_probable == hidden_shift_string:
        print("Most probable bitstring matches hidden shift üòä.")
    else:
        print("Most probable bitstring didn't match hidden shift ‚òπÔ∏è.")
    print("Top 10 bitstrings and their probabilities:")
    display(
        {
            k: (v, hamming_distance(hidden_shift_string, k))
            for k, v in sorted(
                probs.items(), key=lambda x: x[1], reverse=True
            )[:10]
        }
    )

    return probs, most_probable
```

```python
probs, most_probable = find_hidden_shift_bitstring(
    counts, hidden_shift_string
)
```

```text
Expected hidden shift string: 011010
Most probable bitstring matches hidden shift üòä.
Top 10 bitstrings and their probabilities:
```

```text
{'011010': (0.9743, 6),
 '001010': (0.00812, 5),
 '010010': (0.0063, 5),
 '011000': (0.00554, 5),
 '011011': (0.00492, 5),
 '011110': (0.00044, 5),
 '001000': (0.00012, 4),
 '010000': (8e-05, 4),
 '001011': (6e-05, 4),
 '000010': (6e-05, 4)}
```

Registremos la probabilidad de la cadena de bits m√°s probable antes de aplicar la mitigaci√≥n de errores de lectura con M3.

```python
max_probability_before_M3 = probs[most_probable]
max_probability_before_M3
```

```text
0.9743
```

Ahora aplicamos la correcci√≥n de lectura aprendida por M3 a los conteos.
La funci√≥n `apply_corrections` devuelve una distribuci√≥n de cuasi-probabilidad. Esta es una lista de objetos `float` que suman $1$. Pero algunos valores pueden ser negativos.

```python
def perform_mitigation(mit, counts, qubit_mapping):
    # mitigate readout error
    quasis = mit.apply_correction(counts, qubit_mapping)

    # print results
    most_probable_after_m3 = unscramble(max(quasis, key=lambda x: quasis[x]))

    is_hidden_shift_identified = most_probable_after_m3 == hidden_shift_string
    if is_hidden_shift_identified:
        print("Most probable bitstring matches hidden shift üòä.")
    else:
        print("Most probable bitstring didn't match hidden shift ‚òπÔ∏è.")
    print("Top 10 bitstrings and their quasi-probabilities:")
    topten = {
        unscramble(k): f"{v:.2e}"
        for k, v in sorted(quasis.items(), key=lambda x: x[1], reverse=True)[
            :10
        ]
    }
    max_probability_after_M3 = float(topten[most_probable_after_m3])
    display(topten)

    return max_probability_after_M3, is_hidden_shift_identified
```

```python
print(f"Expected hidden shift string: {hidden_shift_string}")
max_probability_after_M3, is_hidden_shift_identified = perform_mitigation(
    mit, counts, qubit_mapping
)
```

```text
Expected hidden shift string: 011010
Most probable bitstring matches hidden shift üòä.
Top 10 bitstrings and their quasi-probabilities:
```

```text
{'011010': '1.01e+00',
 '001010': '8.75e-04',
 '001000': '7.38e-05',
 '010000': '4.51e-05',
 '111000': '2.18e-05',
 '001011': '1.74e-05',
 '000010': '6.42e-06',
 '011001': '-7.18e-06',
 '011000': '-4.53e-04',
 '010010': '-1.28e-03'}
```

#### Comparar la identificaci√≥n de la cadena de bits de desplazamiento oculto antes y despu√©s de aplicar la correcci√≥n M3 {#compare-identifying-the-hidden-shift-string-before-and-after-applying-m3-correction}

```python
def compare_before_and_after_M3(
    max_probability_before_M3,
    max_probability_after_M3,
    is_hidden_shift_identified,
):
    is_probability_improved = (
        max_probability_after_M3 > max_probability_before_M3
    )
    print(f"Most probable probability before M3: {max_probability_before_M3}")
    print(f"Most probable probability after M3: {max_probability_after_M3}")
    if is_hidden_shift_identified and is_probability_improved:
        print("Readout error mitigation effective! üòä")
    else:
        print("Readout error mitigation not effective. ‚òπÔ∏è")
```

```python
compare_before_and_after_M3(
    max_probability_before_M3,
    max_probability_after_M3,
    is_hidden_shift_identified,
)
```

```text
Most probable probability before M3: 0.9743
Most probable probability after M3: 1.01
Readout error mitigation effective! üòä
```

### Gr√°fico de c√≥mo escala el tiempo de CPU requerido por M3 con los disparos {#plot-how-cpu-time-required-by-m3-scales-with-shots}

```python
# Collect samples for numbers of shots varying from 5000 to 25000.
shots_range = range(5000, NUM_SHOTS + 1, 2500)
times = []
for shots in shots_range:
    print(f"Applying M3 correction to {shots} shots...")
    t0 = timeit.default_timer()
    _ = mit.apply_correction(
        pub_result.data.meas.slice_shots(range(shots)).get_counts(),
        qubit_mapping,
    )
    t1 = timeit.default_timer()
    print(f"\tDone in {t1 - t0} seconds.")
    times.append(t1 - t0)

fig, ax = plt.subplots()
ax.plot(shots_range, times, "o--")
ax.set_xlabel("Shots")
ax.set_ylabel("Time (s)")
ax.set_title("Time to apply M3 correction")
```

```text
Applying M3 correction to 5000 shots...
	Done in 0.003321983851492405 seconds.
Applying M3 correction to 7500 shots...
	Done in 0.004425413906574249 seconds.
Applying M3 correction to 10000 shots...
	Done in 0.006366567220538855 seconds.
Applying M3 correction to 12500 shots...
	Done in 0.0071477219462394714 seconds.
Applying M3 correction to 15000 shots...
	Done in 0.00860048783943057 seconds.
Applying M3 correction to 17500 shots...
	Done in 0.010026784148067236 seconds.
Applying M3 correction to 20000 shots...
	Done in 0.011459112167358398 seconds.
Applying M3 correction to 22500 shots...
	Done in 0.012727141845971346 seconds.
Applying M3 correction to 25000 shots...
	Done in 0.01406092382967472 seconds.
Applying M3 correction to 27500 shots...
	Done in 0.01546052098274231 seconds.
Applying M3 correction to 30000 shots...
	Done in 0.016769016161561012 seconds.
Applying M3 correction to 32500 shots...
	Done in 0.019537431187927723 seconds.
Applying M3 correction to 35000 shots...
	Done in 0.019739801064133644 seconds.
Applying M3 correction to 37500 shots...
	Done in 0.021093040239065886 seconds.
Applying M3 correction to 40000 shots...
	Done in 0.022840639110654593 seconds.
Applying M3 correction to 42500 shots...
	Done in 0.023974396288394928 seconds.
Applying M3 correction to 45000 shots...
	Done in 0.026412792038172483 seconds.
Applying M3 correction to 47500 shots...
	Done in 0.026364430785179138 seconds.
Applying M3 correction to 50000 shots...
	Done in 0.02820305060595274 seconds.
```

```text
Text(0.5, 1.0, 'Time to apply M3 correction')
```

![Output of the previous code cell](/docs/images/tutorials/readout-error-mitigation-sampler/extracted-outputs/33addc38-f738-48ed-a29d-9790f446c036-2.avif)

#### Interpretaci√≥n del gr√°fico {#interpreting-the-plot}

El gr√°fico anterior muestra que el tiempo requerido para aplicar la correcci√≥n M3 escala linealmente con el n√∫mero de disparos.
## Escalando {#scaling-up}

```python
n_qubits = 80
rng = Random(12345)
circuit, hidden_shift, hidden_shift_string = run_hidden_shift_circuit(
    n_qubits, rng
)

print(f"Hidden shift string {hidden_shift_string}")
```

```text
Hidden shift string 00000010100110101011101110010001010000110011101001101010101001111001100110000111
```

```python
isa_circuit = get_isa_circuit(circuit, backend)
```

```python
job = run_sampler(backend, isa_circuit, NUM_SHOTS)
mit, qubit_mapping = setup_mthree_mitigation(isa_circuit, backend)
```

```python
counts, pub_result = get_bitstring_counts(job)
```

```python
probs, most_probable = find_hidden_shift_bitstring(
    counts, hidden_shift_string
)
```

```text
Expected hidden shift string: 00000010100110101011101110010001010000110011101001101010101001111001100110000111
Most probable bitstring matches hidden shift üòä.
Top 10 bitstrings and their probabilities:
```

```text
{'00000010100110101011101110010001010000110011101001101010101001111001100110000111': (0.50402,
  80),
 '00000010100110101011101110010001010000110011100001101010101001111001100110000111': (0.0396,
  79),
 '00000010100110101011101110010001010000110011101001101010101001111001100100000111': (0.0323,
  79),
 '00000010100110101011101110010001010000110011101001101010101001101001100110000111': (0.01936,
  79),
 '00000010100110101011101110010011010000110011101001101010101001111001100110000111': (0.01432,
  79),
 '00000010100110101011101110010001010000110011101001101010101001011001100110000111': (0.0101,
  79),
 '00000010100110101011101110010001010000110011101001101010101001110001100110000111': (0.00924,
  79),
 '00000010100110101011101110010001010000010011101001101010101001111001100110000111': (0.00908,
  79),
 '00000010100110101011100110010001010000110011101001101010101001111001100110000111': (0.00888,
  79),
 '00000010100110101011101110010001010000110011101001100010101001111001100110000111': (0.0082,
  79)}
```

Vemos que se encuentra la cadena de bits correcta del desplazamiento oculto. Adem√°s, las nueve cadenas de bits siguientes m√°s probables difieren en solo una posici√≥n.
Registremos la probabilidad m√°s alta:

```python
max_probability_before_M3 = probs[most_probable]
max_probability_before_M3
```

```text
0.50402
```

```python
print(f"Expected hidden shift string: {hidden_shift_string}")
max_probability_after_M3, is_hidden_shift_identified = perform_mitigation(
    mit, counts, qubit_mapping
)
```

```text
Expected hidden shift string: 00000010100110101011101110010001010000110011101001101010101001111001100110000111
Most probable bitstring matches hidden shift üòä.
Top 10 bitstrings and their quasi-probabilities:
```

```text
{'00000010100110101011101110010001010000110011101001101010101001111001100110000111': '9.85e-01',
 '00000010100110101011101110010001010000110011100001101010101001111001100110000111': '6.84e-03',
 '00000010100110101011100110010001010000110011101001101010101001111001100110000111': '3.87e-03',
 '00000010100110101011101110010011010000110011101001101010101001111001100110000111': '3.42e-03',
 '00000010100110101011101110010001010000110011101001101010101001111001100100000111': '3.30e-03',
 '00000010100110101011101110010001010000110011101001101010101001110001100110000111': '3.28e-03',
 '00000010100010101011101110010001010000110011101001101010101001111001100110000111': '2.62e-03',
 '00000010100110101011101110010001010000110011101001101010101001101001100110000111': '2.43e-03',
 '00000010100110101011101110010000010000110011101001101010101001111001100110000111': '1.73e-03',
 '00000010100110101011101110010001010000110011101001101010101001111001000110000111': '1.63e-03'}
```

```python
compare_before_and_after_M3(
    max_probability_before_M3,
    max_probability_after_M3,
    is_hidden_shift_identified,
)
```

```text
Most probable probability before M3: 0.54348
Most probable probability after M3: 0.99
Readout error mitigation effective! üòä
```
