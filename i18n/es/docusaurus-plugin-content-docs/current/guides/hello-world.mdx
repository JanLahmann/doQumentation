---
title: "Hello world"
sidebar_label: "Hello world"
description: "Comience a usar Qiskit con hardware cuántico de IBM en este ejemplo Hello World"
notebook_path: "docs/guides/hello-world.ipynb"
---

<OpenInLabBanner notebookPath="docs/guides/hello-world.ipynb" />



{/*
  DO NOT EDIT THIS CELL!!!
  This cell's content is generated automatically by a script. Anything you add
  here will be removed next time the notebook is run. To add new content, create
  a new cell before or after this one.
*/}

<details>
<summary><b>Versiones de paquetes</b></summary>

El código en esta página se desarrolló utilizando los siguientes requisitos.
Recomendamos usar estas versiones o versiones más recientes.

```
qiskit[all]~=2.3.0
qiskit-ibm-runtime~=0.43.1
```
</details>
Este ejemplo contiene dos partes. Primero creará un programa cuántico simple y lo ejecutará en una unidad de procesamiento cuántico (QPU). Debido a que la investigación cuántica real requiere programas mucho más robustos, en la segunda sección ([Escalar a grandes números de qubits](#scale-to-large-numbers-of-qubits)), escalará el programa simple hasta el nivel de utilidad.
## Instalar y autenticar {#install-and-authenticate}

1. Si aún no ha instalado Qiskit, encuentre instrucciones en la guía [Inicio rápido](/guides/quick-start).

    - Instale Qiskit Runtime para ejecutar trabajos en hardware cuántico:

        ```bash
        pip install qiskit-ibm-runtime
        ```

    - Configure un entorno para ejecutar notebooks de Jupyter localmente:

        ```bash
        pip install jupyter
        ```

2. Configure su autenticación para acceder al hardware cuántico a través del [Plan Abierto](/guides/plans-overview#open-plan) gratuito.

    (Si recibió una invitación por correo electrónico para unirse a una cuenta, siga los [pasos para usuarios invitados](/guides/cloud-setup-invited) en su lugar.)

    - Vaya a [IBM Quantum Platform](https://quantum.cloud.ibm.com/) para iniciar sesión o crear una cuenta.
         <Admonition type="note" title="Importante">
         Si se conecta a través de un servidor proxy, debe usar Qiskit Runtime v0.44.0 o posterior.
         </Admonition>
    - Genere su clave API (también llamada *token API*) en el [panel de control](https://quantum.cloud.ibm.com/), luego cópiela en una ubicación segura.
    - Vaya a la página de [Instancias](https://quantum.cloud.ibm.com/instances) y encuentre la instancia que desea usar. Coloque el cursor sobre su CRN y haga clic para copiarlo.

    - Guarde sus credenciales localmente con este código:

        ```python
        from qiskit_ibm_runtime import QiskitRuntimeService

        QiskitRuntimeService.save_account(
        token="<your-api-key>", # Use la clave API de 44 caracteres que creó y guardó del panel de control de IBM Quantum Platform
        instance="<CRN>", # Opcional
        )
        ```

3. Ahora puede usar este código Python cada vez que desee autenticarse en Qiskit Runtime Service:
    ```python
        from qiskit_ibm_runtime import QiskitRuntimeService

        # Ejecute cada vez que necesite el servicio
        service = QiskitRuntimeService()
    ```
<Admonition type="info" title="¿No está usando un entorno Python confiable?">
Si está usando una computadora pública u otro entorno no seguro, siga las [instrucciones de autenticación manual](/guides/cloud-setup-untrusted) en su lugar para mantener seguras sus credenciales de autenticación.
</Admonition>
## Crear y ejecutar un programa cuántico simple {#create-and-run-a-simple-quantum-program}
Los cuatro pasos para escribir un programa cuántico usando patrones de Qiskit son:

1.  Mapear el problema a un formato nativo cuántico.

2.  Optimizar los circuitos y operadores.

3.  Ejecutar usando una función primitiva cuántica.

4.  Analizar los resultados.

### Paso 1. Mapear el problema a un formato nativo cuántico {#step-1-map-the-problem-to-a-quantum-native-format}

En un programa cuántico, los *circuitos cuánticos* son el formato nativo para representar instrucciones cuánticas, y los *operadores* representan los observables que se medirán. Al crear un circuito, generalmente creará un nuevo objeto [`QuantumCircuit`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#quantumcircuit-class), luego le agregará instrucciones en secuencia.
La siguiente celda de código crea un circuito que produce un *estado de Bell*, que es un estado en el que dos qubits están completamente entrelazados entre sí.

<Admonition type="note" title="Nota: ordenamiento de bits">
  El SDK de Qiskit utiliza la numeración de bits LSb 0 donde el dígito $n^{th}$ tiene el valor $1 \ll n$ o $2^n$. Para más detalles, consulte el tema [Ordenamiento de bits en el SDK de Qiskit](/guides/bit-ordering).
</Admonition>

```python
from qiskit import QuantumCircuit
from qiskit.quantum_info import SparsePauliOp
from qiskit.transpiler import generate_preset_pass_manager
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_runtime import EstimatorOptions
from qiskit_ibm_runtime import EstimatorV2 as Estimator
from matplotlib import pyplot as plt
# Descomente la siguiente línea si desea usar un simulador:
# from qiskit_ibm_runtime.fake_provider import FakeBelemV2

# Crear un nuevo circuito con dos qubits
qc = QuantumCircuit(2)

# Agregar una compuerta Hadamard al qubit 0
qc.h(0)

# Realizar una compuerta X controlada en el qubit 1, controlada por el qubit 0
qc.cx(0, 1)

# Devolver un dibujo del circuito usando MatPlotLib ("mpl").
# Estas guías están escritas usando notebooks de Jupyter, que
# muestran la salida de la última línea de cada celda.
# Si está ejecutando esto en un script, use `print(qc.draw())` para
# imprimir un dibujo de texto.
qc.draw("mpl")
```

![Output of the previous code cell](/docs/images/guides/hello-world/extracted-outputs/930ca3b6-0.svg)

Consulte [`QuantumCircuit`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#quantumcircuit-class) en la documentación para todas las operaciones disponibles.
Al crear circuitos cuánticos, también debe considerar qué tipo de datos desea que se devuelvan después de la ejecución. Qiskit proporciona dos formas de devolver datos: puede obtener una distribución de probabilidad para un conjunto de qubits que elija medir, o puede obtener el valor esperado de un observable. Prepare su carga de trabajo para medir su circuito de una de estas dos formas con [primitivas de Qiskit](/guides/get-started-with-primitives) (explicadas en detalle en el [Paso 3](#step-3-execute-using-the-quantum-primitives)).

Este ejemplo mide valores esperados utilizando el submódulo `qiskit.quantum_info`, que se especifica mediante operadores (objetos matemáticos utilizados para representar una acción o proceso que cambia un estado cuántico). La siguiente celda de código crea seis operadores de Pauli de dos qubits: `IZ`, `IX`, `ZI`, `XI`, `ZZ` y `XX`.

```python
# Configurar seis observables diferentes.

observables_labels = ["IZ", "IX", "ZI", "XI", "ZZ", "XX"]
observables = [SparsePauliOp(label) for label in observables_labels]
```

<Admonition type="note" title="Notación de operadores">
Aquí, algo como el operador `ZZ` es una abreviatura del producto tensorial $Z\otimes Z$, lo que significa medir Z en el qubit 1 y Z en el qubit 0 juntos, y obtener información sobre la correlación entre el qubit 1 y el qubit 0. Los valores esperados como este también se escriben típicamente como $\langle Z_1 Z_0 \rangle$.

Si el estado está entrelazado, entonces la medición de $\langle Z_1 Z_0 \rangle$ debería ser diferente de la medición de $\langle I_1 \otimes Z_0 \rangle \langle Z_1 \otimes I_0 \rangle$. Para el estado entrelazado específico creado por nuestro circuito descrito anteriormente, la medición de $\langle Z_1 Z_0 \rangle$ debería ser 1 y la medición de $\langle I_1 \otimes Z_0 \rangle \langle Z_1 \otimes I_0 \rangle$ debería ser cero.
</Admonition>
<span id="optimize"></span>
### Paso 2. Optimizar los circuitos y operadores {#step-2-optimize-the-circuits-and-operators}

Al ejecutar circuitos en un dispositivo, es importante optimizar el conjunto de instrucciones que contiene el circuito y minimizar la profundidad general (aproximadamente el número de instrucciones) del circuito. Esto garantiza que obtenga los mejores resultados posibles al reducir los efectos del error y el ruido. Además, las instrucciones del circuito deben ajustarse a la [Arquitectura del conjunto de instrucciones (ISA)](/guides/transpile#instruction-set-architecture) del dispositivo backend y deben considerar las compuertas base y la conectividad de qubits del dispositivo.

El siguiente código instancia un dispositivo real para enviar un trabajo y transforma el circuito y los observables para que coincidan con la ISA de ese backend. Requiere que ya haya [guardado sus credenciales](/guides/cloud-setup)

```python
service = QiskitRuntimeService()

backend = service.least_busy(simulator=False, operational=True)

# Convertir a un circuito ISA y observables mapeados al layout.
pm = generate_preset_pass_manager(backend=backend, optimization_level=1)
isa_circuit = pm.run(qc)

isa_circuit.draw("mpl", idle_wires=False)
```

![Output of the previous code cell](/docs/images/guides/hello-world/extracted-outputs/9a901271-0.svg)

### Paso 3. Ejecutar usando las primitivas cuánticas {#step-3-execute-using-the-quantum-primitives}

Las computadoras cuánticas pueden producir resultados aleatorios, por lo que generalmente se recopila una muestra de las salidas ejecutando el circuito muchas veces. Puede estimar el valor del observable usando la clase `Estimator`. `Estimator` es una de dos [primitivas](/guides/get-started-with-primitives); la otra es `Sampler`, que se puede usar para obtener datos de una computadora cuántica. Estos objetos poseen un método `run()` que ejecuta la selección de circuitos, observables y parámetros (si corresponde), usando un [bloque unificado primitivo (PUB).](/guides/primitives#sampler)

```python
# Construir la instancia de Estimator.

estimator = Estimator(mode=backend)
estimator.options.resilience_level = 1
estimator.options.default_shots = 5000

mapped_observables = [
    observable.apply_layout(isa_circuit.layout) for observable in observables
]

# Un pub, con un circuito para ejecutar contra cinco observables diferentes.
job = estimator.run([(isa_circuit, mapped_observables)])

# Use el ID del trabajo para recuperar los datos de su trabajo más tarde
print(f">>> Job ID: {job.job_id()}")
```

```text
>>> Job ID: d5k96q4jt3vs73ds5tgg
```

Después de que se envía un trabajo, puede esperar hasta que se complete el trabajo dentro de su instancia de Python actual, o usar el `job_id` para recuperar los datos en un momento posterior. (Consulte la [sección sobre recuperación de trabajos](/guides/monitor-job#retrieve-job-results-at-a-later-time) para más detalles.)

Después de que se complete el trabajo, examine su salida a través del atributo `result()` del trabajo.

```python
# Este es el resultado de todo el envío. Envió un Pub,
# por lo que contiene un resultado interno (y algunos metadatos propios).
job_result = job.result()

# Este es el resultado de nuestro único pub, que tenía seis observables,
# por lo que contiene información sobre los seis.
pub_result = job.result()[0]
```

```python
# Verificar que hay seis observables.
# Si no, edite los comentarios en la celda anterior y actualice esta prueba.
assert len(pub_result.data.evs) == 6
```

<Admonition type="note" title="Alternativa: ejecutar el ejemplo usando un simulador">
  Cuando ejecuta su programa cuántico en un dispositivo real, su carga de trabajo debe esperar en una cola antes de ejecutarse. Para ahorrar tiempo, puede usar el siguiente código para ejecutar esta pequeña carga de trabajo en [`fake_provider`](../api/qiskit-ibm-runtime/fake-provider) con el modo de prueba local de Qiskit Runtime. Tenga en cuenta que esto solo es posible para un circuito pequeño. Cuando escale en la siguiente sección, necesitará usar un dispositivo real.

  ```python

  # Use el siguiente código en su lugar si desea ejecutar en un simulador:

  from qiskit_ibm_runtime.fake_provider import FakeBelemV2
  backend = FakeBelemV2()
  estimator = Estimator(backend)

  # Convertir a un circuito ISA y observables mapeados al layout.

  pm = generate_preset_pass_manager(backend=backend, optimization_level=1)
  isa_circuit = pm.run(qc)
  mapped_observables = [
      observable.apply_layout(isa_circuit.layout) for observable in observables
  ]

  job = estimator.run([(isa_circuit, mapped_observables)])
  result = job.result()

  # Este es el resultado de todo el envío. Envió un Pub,
  # por lo que contiene un resultado interno (y algunos metadatos propios).

  job_result = job.result()

  # Este es el resultado de nuestro único pub, que tenía cinco observables,
  # por lo que contiene información sobre los cinco.

  pub_result = job.result()[0]
  ```
</Admonition>
### Paso 4. Analizar los resultados {#step-4-analyze-the-results}

El paso de análisis es típicamente donde puede realizar un procesamiento posterior de sus resultados usando, por ejemplo, mitigación de errores de medición o extrapolación de ruido cero (ZNE). Puede alimentar estos resultados en otro flujo de trabajo para un análisis adicional o preparar un gráfico de los valores y datos clave. En general, este paso es específico de su problema. Para este ejemplo, grafique cada uno de los valores esperados que se midieron para nuestro circuito.

Los valores esperados y las desviaciones estándar para los observables que especificó a Estimator se acceden a través de los atributos `PubResult.data.evs` y `PubResult.data.stds` del resultado del trabajo. Para obtener los resultados de Sampler, use la función `PubResult.data.meas.get_counts()`, que devolverá un `dict` de mediciones en forma de cadenas de bits como claves y conteos como sus valores correspondientes. Para más información, consulte [Comenzar con Sampler.](/guides/get-started-with-primitives#get-started-with-sampler)

```python
# Graficar el resultado

values = pub_result.data.evs

errors = pub_result.data.stds

# graficando gráfico
plt.plot(observables_labels, values, "-o")
plt.xlabel("Observables")
plt.ylabel("Values")
plt.show()
```

![Output of the previous code cell](/docs/images/guides/hello-world/extracted-outputs/87143fcc-0.svg)

Observe que para los qubits 0 y 1, los valores esperados independientes de X y Z son 0, mientras que las correlaciones (`XX` y `ZZ`) son 1. Esta es una característica del entrelazamiento cuántico.

```python
# Asegúrese de que los resultados sigan la afirmación de la celda de markdown anterior.
# Esto puede suceder cuando el dispositivo ocasionalmente se comporta de manera extraña. Si esta celda
# falla, es posible que solo necesite ejecutar el notebook nuevamente.

_results = {obs: val for obs, val in zip(observables_labels, values)}
for _label in ["IZ", "IX", "ZI", "XI"]:
    assert abs(_results[_label]) < 0.2
for _label in ["XX", "ZZ"]:
    assert _results[_label] > 0.8
```

## Escalar a grandes números de qubits {#scale-to-large-numbers-of-qubits}

En computación cuántica, el trabajo a escala de utilidad es crucial para avanzar en el campo. Dicho trabajo requiere que los cálculos se realicen a una escala mucho mayor; trabajar con circuitos que podrían usar más de 100 qubits y más de 1000 compuertas. Este ejemplo demuestra cómo puede lograr un trabajo a escala de utilidad en QPUs de IBM&reg; creando y analizando un estado GHZ de 100 qubits. Utiliza el flujo de trabajo de patrones de Qiskit y termina midiendo el valor esperado $\langle Z_0 Z_i \rangle $ para cada qubit.

### Paso 1. Mapear el problema {#step-1-map-the-problem}

Escriba una función que devuelva un `QuantumCircuit` que prepare un estado GHZ de $n$ qubits (esencialmente un estado de Bell extendido), luego use esa función para preparar un estado GHZ de 100 qubits y recopilar los observables que se medirán.

```python
def get_qc_for_n_qubit_GHZ_state(n: int) -> QuantumCircuit:
    """Esta función creará un qiskit.QuantumCircuit (qc) para un estado GHZ de n qubits.

    Args:
        n (int): Número de qubits en el estado GHZ de n qubits

    Returns:
        QuantumCircuit: Circuito cuántico que genera el estado GHZ de n qubits, asumiendo que todos los qubits comienzan en el estado 0
    """
    if isinstance(n, int) and n >= 2:
        qc = QuantumCircuit(n)
        qc.h(0)
        for i in range(n - 1):
            qc.cx(i, i + 1)
    else:
        raise Exception("n is not a valid input")
    return qc

# Crear un nuevo circuito con dos qubits (primer argumento) y dos
# bits clásicos (segundo argumento)
n = 100
qc = get_qc_for_n_qubit_GHZ_state(n)
```

A continuación, mapee a los operadores de interés. Este ejemplo utiliza los operadores `ZZ` entre qubits para examinar el comportamiento a medida que se alejan más. Valores esperados cada vez más inexactos (corrompidos) entre qubits distantes revelarían el nivel de ruido presente.

```python
# ZZII...II, ZIZI...II, ... , ZIII...IZ
operator_strings = [
    "Z" + "I" * i + "Z" + "I" * (n - 2 - i) for i in range(n - 1)
]
print(operator_strings)
print(len(operator_strings))

operators = [SparsePauliOp(operator) for operator in operator_strings]
```

```text
['ZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZII', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZI', 'ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZ']
99
```

### Paso 2. Optimizar el problema para la ejecución en hardware cuántico {#step-2-optimize-the-problem-for-execution-on-quantum-hardware}

El siguiente código transforma el circuito y los observables para que coincidan con la ISA del backend. Requiere que ya haya [guardado sus credenciales](/guides/cloud-setup)

```python
service = QiskitRuntimeService()

backend = service.least_busy(
    simulator=False, operational=True, min_num_qubits=100
)
pm = generate_preset_pass_manager(optimization_level=1, backend=backend)

isa_circuit = pm.run(qc)
isa_operators_list = [op.apply_layout(isa_circuit.layout) for op in operators]
```

### Paso 3. Ejecutar en hardware {#step-3-execute-on-hardware}

Envíe el trabajo y habilite la supresión de errores utilizando una técnica para reducir errores llamada [desacoplamiento dinámico.](../api/qiskit-ibm-runtime/options-dynamical-decoupling-options) El nivel de resiliencia especifica cuánta resiliencia construir contra errores. Los niveles más altos generan resultados más precisos, a expensas de tiempos de procesamiento más largos. Para obtener más información sobre las opciones establecidas en el siguiente código, consulte [Configurar la mitigación de errores para Qiskit Runtime.](/guides/configure-error-mitigation)

```python
options = EstimatorOptions()
options.resilience_level = 1
options.dynamical_decoupling.enable = True
options.dynamical_decoupling.sequence_type = "XY4"

# Crear un objeto Estimator
estimator = Estimator(backend, options=options)
```

```python
# Enviar el circuito a Estimator
job = estimator.run([(isa_circuit, isa_operators_list)])
job_id = job.job_id()
print(job_id)
```

```text
d5k9mmqvcahs73a1ni3g
```

### Paso 4. Post-procesar resultados {#step-4-post-process-results}

Después de que se complete el trabajo, grafique los resultados y observe que $\langle Z_0 Z_i \rangle$ disminuye con el aumento de $i$, aunque en una simulación ideal todos los $\langle Z_0 Z_i \rangle$ deberían ser 1.

```python
# data
data = list(range(1, len(operators) + 1))  # Distancia entre los operadores Z
result = job.result()[0]
values = result.data.evs  # Valor esperado en cada operador Z.
values = [
    v / values[0] for v in values
]  # Normalizar los valores esperados para evaluar cómo decaen con la distancia.

# graficando gráfico
plt.plot(data, values, marker="o", label="100-qubit GHZ state")
plt.xlabel("Distance between qubits $i$")
plt.ylabel(r"$\langle Z_i Z_0 \rangle / \langle Z_1 Z_0 \rangle $")
plt.legend()
plt.show()
```

![Output of the previous code cell](/docs/images/guides/hello-world/extracted-outputs/de91ebd0-0.svg)

El gráfico anterior muestra que a medida que aumenta la distancia entre qubits, la señal decae debido a la presencia de ruido.
## Próximos pasos {#next-steps}

<Admonition type="tip" title="Recomendaciones">
  -   Pruebe uno de estos tutoriales:
      - [Estimación de energía del estado fundamental de la cadena de Heisenberg con VQE](/tutorials/spin-chain-vqe)
      - Resuelva problemas de optimización usando [QAOA](/tutorials/quantum-approximate-optimization-algorithm)
      - Entrene modelos de [kernel cuántico](/tutorials/quantum-kernel-training) para tareas de aprendizaje automático
  - Encuentre instrucciones de instalación detalladas en la guía [Instalar Qiskit](/guides/install-qiskit).
  - Si prefiere no instalar Qiskit localmente, lea sobre opciones para usar Qiskit en un [entorno de desarrollo en línea.](/guides/online-lab-environments)
  - Para guardar múltiples credenciales de cuenta o especificar otras opciones de cuenta, consulte instrucciones detalladas en la guía [Guardar sus credenciales de inicio de sesión](/guides/save-credentials#save-your-access-credentials).
</Admonition>
