---
title: "Visualizar circuitos"
sidebar_label: "Visualizar circuitos"
description: "Crear visualizaciones de circuitos y graficar datos de trabajos usando el módulo de visualización de Qiskit"
notebook_path: "docs/guides/visualize-circuits.ipynb"
---

<OpenInLabBanner notebookPath="docs/guides/visualize-circuits.ipynb" />



{/* cspell:ignore qcircuit mactex, backgroundcolor, lightgreen */}
{/*
  DO NOT EDIT THIS CELL!!!
  This cell's content is generated automatically by a script. Anything you add
  here will be removed next time the notebook is run. To add new content, create
  a new cell before or after this one.
*/}

<details>
<summary><b>Versiones de paquetes</b></summary>

El código en esta página se desarrolló utilizando los siguientes requisitos.
Recomendamos usar estas versiones o versiones más recientes.

```
qiskit[all]~=2.3.0
```
</details>
A menudo es útil ver los circuitos que está creando. Use las siguientes opciones para mostrar circuitos de Qiskit.

```python
from qiskit import QuantumCircuit
```

## Dibujar un circuito cuántico

La clase `QuantumCircuit` admite dibujar circuitos a través del método `draw()`, o imprimiendo el objeto de circuito. Por defecto, ambos representan una versión de arte ASCII del diagrama del circuito.

Tenga en cuenta que `print` devuelve `None` pero tiene el efecto secundario de imprimir el diagrama, mientras que `QuantumCircuit.draw` devuelve el diagrama sin efectos secundarios. Dado que los notebooks de Jupyter muestran la salida de la última línea de cada celda, parecen tener el mismo efecto.

```python
# Construir un circuito cuántico
circuit = QuantumCircuit(3, 3)
circuit.x(1)
circuit.h(range(3))
circuit.cx(0, 1)
circuit.measure(range(3), range(3));
```

```python
print(circuit)
```

```text
┌───┐          ┌─┐
q_0: ┤ H ├───────■──┤M├───
     ├───┤┌───┐┌─┴─┐└╥┘┌─┐
q_1: ┤ X ├┤ H ├┤ X ├─╫─┤M├
     ├───┤└┬─┬┘└───┘ ║ └╥┘
q_2: ┤ H ├─┤M├───────╫──╫─
     └───┘ └╥┘       ║  ║
c: 3/═══════╩════════╩══╩═
            2        0  1
```

```python
circuit.draw()
```

```text
┌───┐          ┌─┐
q_0: ┤ H ├───────■──┤M├───
     ├───┤┌───┐┌─┴─┐└╥┘┌─┐
q_1: ┤ X ├┤ H ├┤ X ├─╫─┤M├
     ├───┤└┬─┬┘└───┘ ║ └╥┘
q_2: ┤ H ├─┤M├───────╫──╫─
     └───┘ └╥┘       ║  ║
c: 3/═══════╩════════╩══╩═
            2        0  1
```

### Renderizadores alternativos

Una salida de texto es útil para ver rápidamente la salida mientras se desarrolla un circuito, pero no proporciona la mayor flexibilidad. Hay dos renderizadores de salida alternativos para el circuito cuántico. Uno usa [Matplotlib](https://matplotlib.org/) y el otro usa [LaTeX](https://www.latex-project.org/). El renderizador LaTeX requiere el [paquete qcircuit](https://github.com/CQuIC/qcircuit). Seleccione estos renderizadores estableciendo el argumento "output" en las cadenas `mpl` y `latex`.

<Admonition type="tip">
  Los usuarios de OSX pueden obtener los paquetes LaTeX requeridos a través del [paquete mactex](https://www.tug.org/mactex/).
</Admonition>

```python
# Dibujo de Matplotlib
circuit.draw(output="mpl")
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/3f9c61c9-58f9-4315-a639-455fa2e58450-0.svg)

```python
# Dibujo de Latex
circuit.draw(output="latex")
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/94948dab-57de-45f0-8dd7-5901ae69b70a-0.avif)

### Guardar la salida

Dibujar un circuito a gran escala en línea en un notebook de Jupyter puede ser lento o ilegible.
Puede guardar el diagrama directamente en un archivo, luego abrirlo en un visor de imágenes y hacer zoom según sea necesario.

```python
# Guardar como una imagen usando el dibujante de Matplotlib
circuit.draw(output="mpl", filename="circuit-mpl.jpeg")
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/17889caf-d953-4661-9188-00505c17064e-0.svg)

```python
# O guardar un renderizado de LaTeX
circuit.draw(output="latex", filename="circuit-latex.pdf")
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/a36d1aa9-fa0d-4e27-ac83-5deee43a20dd-0.avif)

### Controlar los dibujos de circuitos

Por defecto, el método `draw()` devuelve la imagen renderizada como un objeto y no produce ninguna salida. La clase exacta devuelta depende de la salida especificada: `'text'` (el valor predeterminado) devuelve un objeto `TextDrawer`, `'mpl'` devuelve un objeto `matplotlib.Figure`, y `latex` devuelve un objeto `PIL.Image`. Los notebooks de Jupyter entienden estos tipos de retorno y los renderizan correctamente, pero cuando se ejecuta fuera de Jupyter, las imágenes no se mostrarán automáticamente.

El método `draw()` tiene argumentos opcionales para mostrar o guardar la salida. Cuando se especifica, el kwarg `filename` toma una ruta a la que guarda la salida renderizada. Alternativamente, si está usando las salidas `mpl` o `latex`, puede usar el kwarg `interactive` para abrir la imagen en una nueva ventana (esto no siempre funcionará desde dentro de un notebook).
### Personalizar la salida

Dependiendo de la salida, también hay opciones para personalizar el diagrama del circuito.

#### Deshabilitar barreras de trazado y revertir el orden de bits
Las primeras dos opciones se comparten entre los tres backends. Le permiten configurar tanto los órdenes de bits como si dibuja o no barreras. Estos se pueden establecer mediante el kwarg `reverse_bits` y el kwarg `plot_barriers`, respectivamente. Los siguientes ejemplos funcionan con cualquier renderizador de salida; `mpl` se usa aquí por brevedad.

```python
from qiskit import QuantumRegister, ClassicalRegister

# Dibujar un nuevo circuito con barreras y más registros
q_a = QuantumRegister(3, name="a")
q_b = QuantumRegister(5, name="b")
c_a = ClassicalRegister(3)
c_b = ClassicalRegister(5)

circuit = QuantumCircuit(q_a, q_b, c_a, c_b)
circuit.x(q_a[1])
circuit.x(q_b[1])
circuit.x(q_b[2])
circuit.x(q_b[4])
circuit.barrier()
circuit.h(q_a)
circuit.barrier(q_a)
circuit.h(q_b)
circuit.cswap(q_b[0], q_b[1], q_b[2])
circuit.cswap(q_b[2], q_b[3], q_b[4])
circuit.cswap(q_b[3], q_b[4], q_b[0])
circuit.barrier(q_b)
circuit.measure(q_a, c_a)
circuit.measure(q_b, c_b);
```

```python
# Dibujar el circuito
circuit.draw(output="mpl")
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/8e57cd43-8a48-469d-8f69-8e7c936d4a1e-0.svg)

```python
# Dibujar el circuito con orden de bits invertido
circuit.draw(output="mpl", reverse_bits=True)
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/8e7a251a-0a4f-43e0-8cf5-48493df7bad9-0.svg)

```python
# Dibujar el circuito sin barreras
circuit.draw(output="mpl", plot_barriers=False)
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/b4a601ad-1c04-4b16-afbd-ac5a0ad42653-0.svg)

### Personalizaciones específicas del renderizador

Algunas opciones de personalización disponibles son específicas de un renderizador.

El argumento `fold` establece un ancho máximo para la salida. En el renderizador `text`, esto establece la longitud de las líneas del diagrama antes de que se envuelva a la siguiente línea. Al usar el renderizador 'mpl', este es el número de capas (visuales) antes de doblar a la siguiente línea.

El renderizador `mpl` tiene el kwarg `style`, que cambia los colores y los contornos. Consulte la [documentación de la API](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#draw) para más detalles.

La opción `scale` escala la salida de los renderizadores `mpl` y `latex`.

```python
circuit = QuantumCircuit(1)
for _ in range(10):
    circuit.h(0)
# limitar la longitud de línea a 40 caracteres
circuit.draw(output="text", fold=40)
```

```text
┌───┐┌───┐┌───┐┌───┐┌───┐┌───┐┌───┐»
q: ┤ H ├┤ H ├┤ H ├┤ H ├┤ H ├┤ H ├┤ H ├»
   └───┘└───┘└───┘└───┘└───┘└───┘└───┘»
«   ┌───┐┌───┐┌───┐
«q: ┤ H ├┤ H ├┤ H ├
«   └───┘└───┘└───┘
```

```python
# Cambiar el color de fondo en mpl

style = {"backgroundcolor": "lightgreen"}
circuit.draw(output="mpl", style=style)
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/decadf88-4866-45a0-9e2f-836c51491f9e-0.svg)

```python
# Escalar la salida mpl a 1/2 del tamaño normal
circuit.draw(output="mpl", scale=0.5)
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/ade9a653-3243-4ac9-bb0e-c8fb82f7a034-0.svg)

### Función independiente de dibujo de circuitos

Si tiene una aplicación donde prefiere dibujar un circuito con una función autónoma en lugar de como un método de un objeto de circuito, puede usar directamente la función `circuit_drawer()`, que es parte de la interfaz pública estable de `qiskit.visualization`. La función se comporta de manera idéntica al método `circuit.draw()`, excepto que toma un objeto de circuito como argumento requerido.

```python
from qiskit.visualization import circuit_drawer

circuit_drawer(circuit, output="mpl", plot_barriers=False)
```

![Output of the previous code cell](/docs/images/guides/visualize-circuits/extracted-outputs/256dd092-b2eb-47af-a025-0ecdf85c2d5a-0.svg)

## Próximos pasos

<Admonition type="tip" title="Recomendaciones">
  -  Vea un ejemplo de visualización de circuitos en el tutorial [Algoritmo de Grover](/tutorials/grovers-algorithm).
  -  Visualice circuitos simples usando [IBM Quantum Composer.](/guides/composer)
  -  [Visualice el tiempo de los circuitos.](/guides/visualize-circuit-timing)
  -  Revise la [documentación de la API de visualizaciones de Qiskit.](https://docs.quantum.ibm.com/api/qiskit/visualization)
</Admonition>
