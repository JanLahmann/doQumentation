---
title: "Comparar ajustes del transpilador"
sidebar_label: "Comparar ajustes del transpilador"
description: "En este tutorial, exploraremos la canalización (pipeline) de transpilación y te guiaremos a través del proceso completo de creación, transpilación y envío de circuitos."
notebook_path: "docs/guides/circuit-transpilation-settings.ipynb"
---
{/* doqumentation-source-hash: c75e13e8 */}

<OpenInLabBanner notebookPath="docs/guides/circuit-transpilation-settings.ipynb" />



*Estimación de uso: menos de un minuto en un procesador Eagle r3 (NOTA: Esto es solo una estimación. Tu tiempo de ejecución podría variar).*

## Contexto {#background}

Para garantizar resultados más rápidos y eficientes, a partir del 1 de marzo de 2024, los circuitos y observables necesitan transformarse para usar solo instrucciones soportadas por la QPU (Unidad de Procesamiento Cuántico) antes de enviarse a las primitivas de Qiskit Runtime. A estos los llamamos circuitos y observables de *arquitectura del conjunto de instrucciones* (ISA - Instruction Set Architecture). Una forma común de hacerlo es usar la función `generate_preset_pass_manager` del transpilador. Sin embargo, podrías elegir seguir un proceso más manual.

Por ejemplo, es posible que desees orientar o enfocarte en (target) un subconjunto específico de qubits en un dispositivo específico. Este tutorial prueba el rendimiento de diferentes configuraciones (settings) del transpilador al completar todo el proceso de creación, transpilación y envío de circuitos.
## Requisitos {#requirements}

Antes de comenzar, asegúrate de tener instalado lo siguiente:

* El SDK de Qiskit v1.2 o superior, con soporte de [visualización](https://docs.quantum.ibm.com/api/qiskit/visualization)
* Qiskit Runtime v0.28 o posterior (`pip install qiskit-ibm-runtime`)
## Configuración inicial (Setup) {#setup}

```python
# Create circuit to test transpiler on
from qiskit import QuantumCircuit
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit.circuit.library import GroverOperator, Diagonal

# Use Statevector object to calculate the ideal output
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_histogram
from qiskit.transpiler import PassManager

from qiskit.circuit.library import XGate
from qiskit.quantum_info import hellinger_fidelity

# Qiskit Runtime
from qiskit_ibm_runtime import (
    QiskitRuntimeService,
    Batch,
    SamplerV2 as Sampler,
)
from qiskit_ibm_runtime.transpiler.passes.scheduling import (
    ASAPScheduleAnalysis,
    PadDynamicalDecoupling,
)
```

## Paso 1: Mapear entradas clásicas a un problema cuántico {#step-1-map-classical-inputs-to-a-quantum-problem}

Crea un circuito pequeño para que el transpilador intente optimizar. Este ejemplo crea un circuito que lleva a cabo el algoritmo de Grover con un oráculo que marca el estado `111`. A continuación, simula la distribución ideal (lo que esperarías medir si ejecutaras esto en una computadora cuántica perfecta un número infinito de veces) para compararla más adelante.

```python
# To run on hardware, select the backend with the fewest number of jobs in the queue
service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False, min_num_qubits=127
)
backend.name
```

```text
'ibm_brisbanse'
```

```python
oracle = Diagonal([1] * 7 + [-1])
qc = QuantumCircuit(3)
qc.h([0, 1, 2])
qc = qc.compose(GroverOperator(oracle))

qc.draw(output="mpl", style="iqp")
```

![Output of the previous code cell](/docs/images/guides/circuit-transpilation-settings/extracted-outputs/7e7944c5-68ac-40cf-a0eb-5f4a44d53931-0.avif)

```python
ideal_distribution = Statevector.from_instruction(qc).probabilities_dict()

plot_histogram(ideal_distribution)
```

![Output of the previous code cell](/docs/images/guides/circuit-transpilation-settings/extracted-outputs/761afe09-b669-453f-8363-55070d6c8f57-0.avif)

## Paso 2: Optimizar el problema para la ejecución en hardware cuántico {#step-2-optimize-problem-for-quantum-hardware-execution}

A continuación, transpila los circuitos para la QPU. Compararás el rendimiento del transpilador con el `optimization_level` configurado en `0` (el más bajo) versus `3` (el más alto). El nivel de optimización más bajo hace el mínimo fundamental necesario para lograr que el circuito se ejecute en el dispositivo; mapea los qubits del circuito a los qubits del dispositivo y añade puertas de intercambio (swap gates) para permitir todas las operaciones de dos qubits. El nivel de optimización más alto es mucho más inteligente y usa muchos trucos para reducir el recuento total de puertas (gate count). Dado que las puertas de múltiples qubits tienen altas tasas de error y los qubits pierden coherencia (decohere) a lo largo del tiempo, los circuitos más cortos deberían dar resultados mejores.

La siguiente celda transpila `qc` para ambos valores de `optimization_level`, imprime la cantidad de puertas de dos qubits, e inserta (añade) los circuitos transpilados a una lista. Algunos de los algoritmos del transpilador son aleatorios, por lo que establece una semilla (seed) para fines de reproducibilidad.

```python
# Need to add measurements to the circuit
qc.measure_all()

# Find the correct two-qubit gate
twoQ_gates = set(["ecr", "cz", "cx"])
for gate in backend.basis_gates:
    if gate in twoQ_gates:
        twoQ_gate = gate

circuits = []
for optimization_level in [0, 3]:
    pm = generate_preset_pass_manager(
        optimization_level, backend=backend, seed_transpiler=0
    )
    t_qc = pm.run(qc)
    print(
        f"Two-qubit gates (optimization_level={optimization_level}): ",
        t_qc.count_ops()[twoQ_gate],
    )
    circuits.append(t_qc)
```

```text
Two-qubit gates (optimization_level=0):  21
Two-qubit gates (optimization_level=3):  14
```

Dado que las CNOT usualmente tienen una alta tasa de error, el circuito transpilado con `optimization_level=3` debería de rendir mucho mejor.

Otra forma en que puedes mejorar el rendimiento es mediante el [desacoplamiento dinámico (dynamic decoupling)](https://docs.quantum.ibm.com/api/qiskit/qiskit.transpiler.passes.PadDynamicalDecoupling), aplicando una secuencia de puertas a los qubits inactivos (o en ralentí, idling). Esto cancela algunas interacciones no deseadas con el ambiente o el entorno. La siguiente celda de código añade un desacoplamiento dinámico al circuito transpilado con `optimization_level=3` y lo agrega a la lista.

```python
# Get gate durations so the transpiler knows how long each operation takes
durations = backend.target.durations()

# This is the sequence we'll apply to idling qubits
dd_sequence = [XGate(), XGate()]

# Run scheduling and dynamic decoupling passes on circuit
pm = PassManager(
    [
        ASAPScheduleAnalysis(durations),
        PadDynamicalDecoupling(durations, dd_sequence),
    ]
)
circ_dd = pm.run(circuits[1])

# Add this new circuit to our list
circuits.append(circ_dd)
```

```python
circ_dd.draw(output="mpl", style="iqp", idle_wires=False)
```

![Output of the previous code cell](/docs/images/guides/circuit-transpilation-settings/extracted-outputs/4ada6498-b9d7-4d88-b8a9-ef1dc0a85bf7-0.avif)

## Paso 3: Ejecutar utilizando las primitivas de Qiskit {#step-3-execute-using-qiskit-primitives}

En este punto, posees y ya cuentas con una lista de circuitos lista y que se encuentran transpilados para la QPU que ha sido especificada (descrita). Como paso a continuación o próximamente, debes de ir a la y crear o declarar con una tu una instancia de lo que vendría en esencia la primitiva a modo y el que de tipo muestreador o llamado en esto como tipo una del tipo de es instanciado o instanciar una en tipo sampler de una (sampler su para su instancia o el modelo tu primitiva sampler) y también comienza el un de a lo lo lo y también y empieza un llamado en lo que seria trabajo o lo de la (batch) trabajo un enviando tu (job) agrupado por tipo llamado lote en a lo a lo y de (batched trabajo lote el agrupado lote modo tu en) a e y de. agrupándolos modo usando lo del tipo (batched esto de lote) usando agrupándolo lote (batched usa y agrupamiento el de y el modo por. job), usando el gestor en tipo de) e o u de o agrupado job) el usando contexto (context tipo modo el y job), u agrupado o. o el contexto de y de manager usando usando) el contexto gestor de utilizando o e `with de gestor (el) y de y) (el manager manager), contexto. de o. la de el el la `with` (, `with del u) gestor u del con o la contexto `with` `with el a el context context) contexto u en. `with, lo) context (que el (manager (,) contexto y. manager., de que el a o con) a `with e` que) abre (context (el el u o) context abre que (, el manager) e manager a que que el a que abre (que. contexto) de manager que. el. a `with que) `with o) que), (`with que:), (u ...:`), `with), `with. que de. (abre (, cual abre) cual el (, cual) o el) el ((abre) `with., la (: (`with y automáticamente `with automáticamente abre cual automáticamente u o. o, automáticamente el, o u que cual). que cual automáticamente). abre). automáticamente abre que abre cual y (abrir). que y automáticamente (,).). y (, abre. abre, cual que la) y abre u y a) abre que cual el automáticamente. automáticamente cierra) y abre automáticamente el a) la el (u cual). e). cierra otomatis automatiquement abre y este ((este (,). el) abre y otomatis). automatiquement el cual o el el). y automáticamente automáticamente abre u). o y o, cierra. el la, a de. cierra cual cual lote automáticamente abre el y lo que el. (batch o el abre. automáticamente y automatícale de ((el lote), el. batch (lote ((cierra (el, el a (lote) batch. (la lotes) batch ((y, y) (,). el. el lote cierra de (,).. lote. lote. el). el) y cierra). o automáticamente). (lote el, y cierra) cierra abre (o, u o). cierra lote) o. cierra. automáticamente. automáticamente).), abre.

Dentro del gestor de contexto (context manager), realiza el muestreo o sampleo a los circuitos y guarda en ese almacenamiento los resultantes a a hacia o el (guárdalos) e que u hacia u donde como. guárdalos hacía e guarda e a la) `result`.`result`.

```python
with Batch(backend=backend):
    sampler = Sampler()
    job = sampler.run(
        [(circuit) for circuit in circuits],  # sample all three circuits
        shots=8000,
    )
    result = job.result()
```

## Paso 4: Pos-procesar y retornar el resultado en el formato clásico deseado {#step-4-post-process-and-return-result-in-desired-classical-format}

Finalmente, grafica los resultados de las ejecuciones del dispositivo contra la distribución ideal (modelo idealmente concebido u idóneo). Podrás ir comprobando con que como ver que, podrás resultados con los (la o y los) a. de u `optimization_level=3` `optimization_level=3`. aquellos están u esto que `optimization_level=3` o. se y con o) de e (los este con estos los a resultados con y están estos con `optimization_level=3` resultados. la a a. a de están. están con a más e. más están más encuentran de e más a. más a,). cercanos a (cerca a) la.. cercanos están. más cerca a cercanos a de u la la. distribución a, o u más distribución distribución (a. cercanos más.) de distribución, la ideal. la a o la a u) debido de ideal e de ideal. ideal debido ideal e ideal, a u. u ideal ideal al, e el, debido u a debido). al. debido a). menos).,). el, la y debido. a o debido). y al ideal la e) el a e la a, menos).,). cuenta). al e cuenta). por la). menos). de. de). y cuenta por a o al de. a a). a),.) a u de o la a recuentos. el),), el. u o al de), (recuento), a de), de, de de cuenta). o, de u la. a) de) de) de y puertas el recuento o). (gate. o y) conteo conteo count u) o () o o count), el, (gate). de). u). (count la) e. la a a (la de) (count. a o el). la a (la. y. a (de), y) de puertas), puertas e o o u) de count, lower, (y. de el por) de la o de (menor o) el u (, puertas menor la) la que y menor) que (menor y a). y menor y más del o menor y la, o as de las. y) de) menor, menor), y,). la a e (el,) de, de a. a (esto y (, `optimization_level=3., o u (y `optimization_level=3`). a `optimization_level=3. que `optimization_level=3 as de). es `optimization_level=3, más e el) o la `optimization_level=3 es aún u, de es y la es y `optimization_level=3 la a de a. (de a es.` `optimization_level=3, +. +. aún u (`optimization_level=3 o (dd,). + `optimization_level=3 y aún `optimization_level=3. dd. o dd) o el). de, dd).). es). + a). aún aún y o a + es + aún de dd` dd es), a) de es, dd` más). `es. +). de. a + más aún. de la. o cerca. es a), la es. más). de. más a más u o u aún. dd`) de cerca + a) o. cercana la más más (la. a es o la), cercana cercana. (cercano cercana) más (cercana u o), cercado es o más, es e) de de u + cercana (,). debido) es debido o debido. o, debido). u de. e, `cercana debido. o) al. el. o más debido debido la a (debido) a). de. al la o y a (desacoplamiento. al la. a al a (desacoplamiento o o,).,, o). al a u e o y o e dinámico al. (dinámico dinámico).).

```python
binary_prob = [
    {
        k: v / res.data.meas.num_shots
        for k, v in res.data.meas.get_counts().items()
    }
    for res in result
]
plot_histogram(
    binary_prob + [ideal_distribution],
    bar_labels=False,
    legend=[
        "optimization_level=0",
        "optimization_level=3",
        "optimization_level=3 + dd",
        "ideal distribution",
    ],
)
```

![Output of the previous code cell](/docs/images/guides/circuit-transpilation-settings/extracted-outputs/525777ea-d438-4f3b-acb6-53e579f24a0e-0.avif)

Puedes confirmar esto calculando la [fidelidad de Hellinger (Hellinger fidelity)](https://docs.quantum.ibm.com/api/qiskit/quantum_info) entre cada conjunto de resultados y la distribución ideal (a mayor valor mejor o mayor resultado es el que resulta como el mejor y ser mejor calificado o resultando como su nota al valor de 1 es aquel que logra una o que una es como esto nos da cual 1 es la la y lo cual e la la y 1 y es el que y se el a fidelidad y que cual es la la e 1 a y que, perfecta y 1 fidelidad es la a que perfecta. e es de fidelidad 1 y indica s o señala 1 fidelidad o es perfecta.).

```python
for prob in binary_prob:
    print(f"{hellinger_fidelity(prob, ideal_distribution):.3f}")
```

```text
0.848
0.945
0.990
```

