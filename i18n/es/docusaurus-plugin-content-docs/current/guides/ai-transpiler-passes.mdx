---
title: "Pases de transpilador con IA"
sidebar_label: "Pases de transpilador con IA"
description: "Qué son los pases de transpilador con Inteligencia Artificial (IA) y cómo usarlos"
notebook_path: "docs/guides/ai-transpiler-passes.ipynb"
---
{/* doqumentation-source-hash: 04cb03ce */}

<OpenInLabBanner notebookPath="docs/guides/ai-transpiler-passes.ipynb" />



# Pases de transpilador con IA {#ai-transpiler-passes}

```python
# Added by doQumentation — installs packages not in the Binder environment
%pip install -q qiskit-ibm-transpiler
```

Los pases de transpilador impulsados por IA son pases que funcionan como un reemplazo directo de los pases "tradicionales" de Qiskit para algunas tareas de transpilación. Suelen producir mejores resultados que los algoritmos heurísticos existentes (como una profundidad y cantidad de CNOT menores), pero también son mucho más rápidos que los algoritmos de optimización como los solvers de satisfactibilidad booleana. Los pases de transpilador con IA pueden ejecutarse en tu entorno local o en la nube usando el Qiskit Transpiler Service si eres parte del Plan Premium, Plan Flex o Plan On-Prem (a través de la API de IBM Quantum Platform) de IBM Quantum&reg;.

<Admonition type="note">
    Los pases de transpilador impulsados por IA están en estado de versión beta, sujetos a cambios.
    Si tienes comentarios o quieres contactar al equipo de desarrollo, usa este [canal del Slack de Qiskit](https://qiskit.slack.com/archives/C06KF8YHUAU).
</Admonition>

Los siguientes pases están disponibles actualmente:

**Pases de enrutamiento (Routing)**
 - `AIRouting`: Selección del diseño (layout) y enrutamiento del circuito

**Pases de síntesis de circuitos**
 - `AICliffordSynthesis`: Síntesis de circuitos Clifford
 - `AILinearFunctionSynthesis`: Síntesis de circuitos de funciones lineales
 - `AIPermutationSynthesis`: Síntesis de circuitos de permutación
 - `AIPauliNetworkSynthesis`: Síntesis de circuitos de Redes de Pauli (Pauli Network)

Para usar los pases de transpilador con IA, primero [instala el paquete `qiskit-ibm-transpiler`](/guides/qiskit-transpiler-service#install-transpiler-service). Visita la [documentación de la API de qiskit-ibm-transpiler](https://docs.quantum.ibm.com/api/qiskit-ibm-transpiler) para obtener más información sobre las diferentes opciones disponibles.

## Ejecutar los pases de transpilador con IA localmente o en la nube {#run-the-ai-transpiler-passes-locally-or-on-the-cloud}

Si quieres usar los pases de transpilador impulsados por IA en tu entorno local de forma gratuita, instala `qiskit-ibm-transpiler` con algunas dependencias extra de la siguiente manera:

```sh
pip install qiskit-ibm-transpiler[ai-local-mode]
```

Sin estas dependencias adicionales, los pases de transpilador con IA se ejecutan en la nube a través del Qiskit Transpiler Service (disponible solo para usuarios del Plan Premium, Plan Flex o Plan On-Prem (a través de la API de IBM Quantum Platform) de IBM Quantum). Después de instalar las dependencias extra, el modo predeterminado para ejecutar los pases de transpilador con IA es usar tu máquina local.

## Pase de enrutamiento con IA {#ai-routing-pass}

El pase `AIRouting` actúa tanto como una etapa de diseño (layout) como una etapa de enrutamiento. Puede ser usado dentro de un `PassManager` de la siguiente manera:

```python
from qiskit.transpiler import PassManager
from qiskit.circuit.library import efficient_su2
from qiskit_ibm_transpiler.ai.routing import AIRouting
from qiskit_ibm_runtime import QiskitRuntimeService

backend = QiskitRuntimeService().backend("ibm_torino")
ai_passmanager = PassManager(
    [
        AIRouting(
            backend=backend,
            optimization_level=2,
            layout_mode="optimize",
            local_mode=True,
        )
    ]
)

circuit = efficient_su2(101, entanglement="circular", reps=1)

transpiled_circuit = ai_passmanager.run(circuit)
```

Aquí, el `backend` determina para qué mapa de acoplamiento enrutar, el `optimization_level` (nivel de optimización 1, 2 o 3) determina el esfuerzo computacional a gastar en el proceso (mayor usualmente da mejores resultados pero tarda más), y el `layout_mode` (modo de diseño) especifica cómo manejar la selección del layout.
El `layout_mode` incluye las siguientes opciones:

- `keep`: Respeta la distribución (layout) establecida por pases del transpilador anteriores (o usa la distribución trivial si no se ha establecido). Típicamente solo se usa cuando el circuito debe ejecutarse en qubits específicos del dispositivo. A menudo produce resultados peores porque tiene menos margen para optimización.
- `improve`: Esto usa el layout configurado por los pases del transpilador anteriores como un punto de partida. Es muy útil cuando tienes una buena estimación inicial para la distribución; por ejemplo, para circuitos que se construyen de una forma que sigue aproximadamente el mapa de acoplamiento del dispositivo. También es útil si quieres probar otros pases de layout específicos combinados con el pase `AIRouting`.
- `optimize`: Este es el modo predeterminado. Funciona mejor para circuitos generales donde quizás no tengas buenas aproximaciones de layout. Este modo ignora las selecciones de layout anteriores.
- `local_mode`: Esta bandera determina dónde se ejecuta el pase `AIRouting`. Si es `False`, `AIRouting` se ejecuta remotamente a través del Qiskit Transpiler Service. Si es `True`, el paquete intenta ejecutar el pase en tu entorno local con una alternativa al modo nube si no se encuentran las dependencias requeridas.

## Pases de síntesis de circuitos con IA {#ai-circuit-synthesis-passes}

Los pases de síntesis de circuitos impulsados por IA te permiten optimizar partes de diferentes tipos de circuitos ([Clifford](https://docs.quantum.ibm.com/api/qiskit/qiskit.quantum_info.Clifford), [Funciones Lineales](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.LinearFunction), [Permutación](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.Permutation#permutation), Redes de Pauli) resintetizándolos. Una forma típica de usar el pase de síntesis es la siguiente:

```python
from qiskit.transpiler import PassManager

from qiskit_ibm_transpiler.ai.routing import AIRouting
from qiskit_ibm_transpiler.ai.synthesis import AILinearFunctionSynthesis
from qiskit_ibm_transpiler.ai.collection import CollectLinearFunctions
from qiskit_ibm_transpiler.ai.synthesis import AIPauliNetworkSynthesis
from qiskit_ibm_transpiler.ai.collection import CollectPauliNetworks
from qiskit.circuit.library import efficient_su2

ibm_torino = QiskitRuntimeService().backend("ibm_torino")
ai_passmanager = PassManager(
    [
        AIRouting(
            backend=ibm_torino,
            optimization_level=3,
            layout_mode="optimize",
            local_mode=True,
        ),  # Route circuit
        CollectLinearFunctions(),  # Collect Linear Function blocks
        AILinearFunctionSynthesis(
            backend=ibm_torino, local_mode=True
        ),  # Re-synthesize Linear Function blocks
        CollectPauliNetworks(),  # Collect Pauli Networks blocks
        AIPauliNetworkSynthesis(
            backend=ibm_torino, local_mode=True
        ),  # Re-synthesize Pauli Network blocks.
    ]
)

circuit = efficient_su2(10, entanglement="full", reps=1)

transpiled_circuit = ai_passmanager.run(circuit)
```

La síntesis respeta el mapa de acoplamiento de los dispositivos: puede ejecutarse de forma segura después de otros pases de enrutamiento sin alterar el circuito, por lo tanto el circuito completo continuará siguiendo las restricciones del dispositivo. Por defecto, la síntesis reemplazará el sub-circuito original solo si el sub-circuito sintetizado mejora al original (actualmente solo verifica el recuento de compuertas CNOT), sin embargo, esto se puede forzar para reemplazar siempre el circuito estableciendo `replace_only_if_better=False`.

Los siguientes pases de síntesis están disponibles desde `qiskit_ibm_transpiler.ai.synthesis`:

- *AICliffordSynthesis*: Síntesis para circuitos [Clifford](https://docs.quantum.ibm.com/api/qiskit/qiskit.quantum_info.Clifford) (bloques de compuertas `H`, `S` y `CX`). Actualmente soporta bloques de hasta nueve qubits.
- *AILinearFunctionSynthesis*: Síntesis para circuitos de [Función Lineal (Linear Function)](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.LinearFunction) (bloques de puertas `CX` y `SWAP`). Actualmente soporta bloques de hasta nueve qubits.
- *AIPermutationSynthesis*: Síntesis para circuitos de [Permutación](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.Permutation#permutation) (bloques de puertas `SWAP`). Actualmente está disponible para bloques de 65, 33 y 27 qubits.
- *AIPauliNetworkSynthesis*: Síntesis para circuitos de Red de Pauli (Pauli Network) (bloques de puertas `H`, `S`, `SX`, `CX`, `RX`, `RY` y `RZ`). Actualmente soporta bloques de hasta seis qubits.

Esperamos aumentar gradualmente el tamaño de los bloques compatibles.

Todos los pases usan un pool de hilos para mandar diversas solicitudes en paralelo. De forma predeterminada, la cantidad máxima de hilos es la cantidad de núcleos más cuatro (valores predeterminados de la clase `ThreadPoolExecutor` en Python). A pesar de esto, tú puedes configurar tu propio valor usando el argumento `max_threads` cuando instancias el pase. Por ejemplo, el siguiente segmento muestra cómo crear una instancia del pase `AILinearFunctionSynthesis` para que use hasta un máximo de 20 hilos.

```python
AILinearFunctionSynthesis(backend=ibm_torino, max_threads=20)  # Re-synthesize Linear Function blocks using 20 threads max
```

Además de poder configurar la variable de entorno `AI_TRANSPILER_MAX_THREADS` con el límite deseado de subprocesos a ejecutar en paralelo, toma nota de que, si lo haces, cualquier otra instancia de transpilador será instanciada bajo este valor por defecto.

Para que los pases de síntesis con IA puedan sintetizar un subcircuito, este debe situarse en un subgrafo conexo del mapa de acoplamiento (una forma de conseguirlo es mediante un pase de enrutamiento previo a la agrupación de los bloques, si bien no es la única manera). Los pases de síntesis comprobarán de forma automática la compatibilidad con el subgrafo en particular y, en caso negativo, generarán una advertencia y dejarán intacto el subcircuito original.

Los siguientes pases de recolección personalizados para componentes Clifford, Funciones Lineales y Permutaciones se pueden extraer e importar desde `qiskit_ibm_transpiler.ai.collection` como medio extra a los pases de síntesis correspondientes:

- *CollectCliffords*: Recoge componentes Clifford y los organiza y configura para generar una `Instruction`, a su vez guarda el contenido sub-circuito original a modo comparativo una vez terminada la etapa final de síntesis en su lugar correspondiente.
- *CollectLinearFunctions*: Agrupa secciones contiguas de puertas de un conjunto de `SWAP` y de `CX` como `LinearFunction` originando su subcircuito original guardado que permitirá comparar resultados posteriormente al completar etapa post síntesis.
- *CollectPermutations*: Acumula estructuras y componentes que aplican múltiples redes con puertas `SWAP` al estilo del modelo en las `Permutations`.
- *CollectPauliNetworks*: Recoge bloques de redes de Pauli y guarda una versión original del sub-circuito del que provino para permitir comparar y contrastar luego tras terminarse de manera exitosa toda evaluación al cabo su etapa de trabajo.

Los pases de recolección acotan las proporciones a dimensiones óptimas asimilables por la síntesis operada y evaluada como recurso con Inteligencia Artificial. Entonces con estas dimensiones limitadas, aseguran optimizaciones de primera línea combinando la etapa posterior lograda por la síntesis.

## Transpilación híbrida del circuito mediante inteligencia heurística-IA {#hybrid-heuristic-ai-circuit-transpilation}

`qiskit-ibm-transpiler` le facilitará crear gestores con propiedades conjuntas de la heurística elaborada internamente y de algoritmos elaborados para el sistema integrando procesos por modelos basados con uso nativo en el proceso originario a base impulsada mediante Inteligencia Artificial, proporcionando compatibilidad en modelos ya probados internamente para una función conocida. La aproximación por código con diseño estructural es análoga de un similar estilo en la manera que ya lo elaboran por cuenta propia como ocurre del proceso interno originario a su equivalente método derivado llamado como `generate_pass_manager`.

```python
from qiskit_ibm_transpiler import generate_ai_pass_manager
from qiskit.circuit.library import efficient_su2
from qiskit_ibm_runtime import QiskitRuntimeService

backend = QiskitRuntimeService().backend("ibm_torino")
torino_coupling_map = backend.coupling_map

su2_circuit = efficient_su2(101, entanglement="circular", reps=1)

ai_transpiler_pass_manager = generate_ai_pass_manager(
    coupling_map=torino_coupling_map,
    ai_optimization_level=3,
    optimization_level=3,
    ai_layout_mode="optimize",
)

ai_su2_transpiled_circuit = ai_transpiler_pass_manager.run(su2_circuit)
```

Las siguientes opciones aparecen aquí expuestas empleando y abordando:
* `coupling_map` - Designará sobre cuál de aquellas asignaciones debe basar el transpilador.
* `ai_optimization_level` - Demarcará si requiere, bajo esta estructura a implementar, aquel modelo correspondiente optimizante por parte de aquellas integraciones aplicadas.
* `optimization_level` - Demarcará cuán riguroso deber ser aquel efecto logrado en optimizar el método analítico en conjunto con otras variantes componentes mediante métodos de trabajo empírico en cada variante heurística del administrador responsable a este cargo.
* `ai_layout_mode` - Precisa configuraciones respecto de lo concerniente por enrutamiento y como un proceso en la selección del modelo. Revise la sección [Pase de enrutamiento con IA](#ai-routing-pass) y así visualizar para cada posibilidad aplicable cuáles variaciones serán aptas a tener acceso para configurar como su equivalente al caso parámetro establecido `ai_layout_mode`.

## Límites {#limits}

Observa sobre cómo encontrar detalles referentes e indagando qué aplica respecto para casos particulares [Documentación sobre el uso por métodos transpiladores vía Servicios (Qiskit Transpiler Service)](./qiskit-transpiler-service#limits-of-the-qiskit-transpiler-service) donde los límites pueden o son aplicables referidos al uso que involucró aplicar Inteligencia Artificial con el modo para transpilar la versión respectiva de manera eficiente por el medio del código habilitado para acceder en estas herramientas e interfases.

## Citación {#citation}

Cuando o en caso aplique alguna forma correspondiente, citando aquellos rasgos que involucraron la asistencia mediante técnicas para modelos aplicadas junto a la Inteligencia Artificial mediante y por su equivalente en un flujo a originario gracias por ser derivado como resultado natural e integrado como recurso o un equivalente originariamente derivado utilizando el uso a [la referencia preferente y modo aconsejado que nos refiere su mención (Citation).](./qiskit-transpiler-service#citation)