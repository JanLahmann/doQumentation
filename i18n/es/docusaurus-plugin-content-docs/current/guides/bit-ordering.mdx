---
title: "Ordenamiento de bits en el SDK de Qiskit"
sidebar_label: "Ordenamiento de bits en el SDK de Qiskit"
description: "Aprenda sobre las convenciones de ordenamiento del SDK de Qiskit y por qué las elegimos"
notebook_path: "docs/guides/bit-ordering.ipynb"
---

<OpenInLabBanner notebookPath="docs/guides/bit-ordering.ipynb" />



{/* cspell:ignore leftrightarrow */}
{/*
  DO NOT EDIT THIS CELL!!!
  This cell's content is generated automatically by a script. Anything you add
  here will be removed next time the notebook is run. To add new content, create
  a new cell before or after this one.
*/}

<details>
<summary><b>Versiones de paquetes</b></summary>

El código en esta página se desarrolló utilizando los siguientes requisitos.
Recomendamos usar estas versiones o versiones más recientes.

```
qiskit[all]~=2.3.0
```
</details>
Si tiene un conjunto de $n$ bits (o qubits), generalmente etiquetará cada bit $0
\rightarrow n-1$. Diferentes softwares y recursos deben elegir cómo ordenar
estos bits tanto en la memoria del ordenador como cuando se muestran en pantalla.

## Convenciones de Qiskit

Así es como el SDK de Qiskit ordena los bits en diferentes escenarios.

### Circuitos cuánticos

La clase `QuantumCircuit` almacena sus qubits en una lista
(`QuantumCircuit.qubits`). El índice de un qubit en esta lista define la
etiqueta del qubit.

```python
from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit import Qubit

qc = QuantumCircuit(2)
qc.qubits[0]  # qubit "0"

Qubit(QuantumRegister(2, "q"), 0)
```

```text
<Qubit register=(2, "q"), index=0>
```

### Diagramas de circuitos

En un diagrama de circuito, el qubit $0$ es el qubit superior, y el qubit $n-1$ es el
qubit inferior. Puede cambiar esto con el argumento `reverse_bits` de
`QuantumCircuit.draw` (consulte [Cambiar el ordenamiento en
Qiskit](#change-ordering-in-qiskit)).

```python
qc.x(1)
qc.draw()
```

```text
q_0: ─────
     ┌───┐
q_1: ┤ X ├
     └───┘
```

### Enteros

Al interpretar bits como un número, el bit $0$ es el bit menos significativo, y
el bit $n-1$ el más significativo. Esto es útil al codificar porque cada bit tiene
el valor $2^\text{label}$ (siendo label el índice del qubit en
`QuantumCircuit.qubits`). Por ejemplo, la siguiente ejecución de circuito termina
con el bit $0$ siendo `0`, y el bit $1$ siendo `1`. Esto se interpreta como el
entero decimal `2` (medido con probabilidad `1.0`).

```python
from qiskit.primitives import StatevectorSampler as Sampler

qc.measure_all()

job = Sampler().run([qc])
result = job.result()
print(f" > Counts: {result[0].data.meas.get_counts()}")
```

```text
> Counts: {'10': 1024}
```

### Cadenas

Al mostrar o interpretar una lista de bits (o qubits) como una cadena, el bit
$n-1$ es el bit más a la izquierda, y el bit $0$ es el bit más a la derecha. Esto se debe a que
generalmente escribimos números con el dígito más significativo a la izquierda, y en
Qiskit, el bit $n-1$ se interpreta como el bit más significativo.

Por ejemplo, la siguiente celda define un `Statevector` a partir de una cadena de
estados de un solo qubit. En este caso, el qubit $0$ está en el estado $|+\rangle$, y
el qubit $1$ en el estado $|0\rangle$.

```python
from qiskit.quantum_info import Statevector

sv = Statevector.from_label("0+")
sv.probabilities_dict()
```

```text
{np.str_('00'): np.float64(0.4999999999999999),
 np.str_('01'): np.float64(0.4999999999999999)}
```

Esto ocasionalmente causa confusión al interpretar una cadena de bits, ya que
podría esperar que el bit más a la izquierda sea el bit $0$, mientras que generalmente representa el bit
$n-1$.

### Matrices de vectores de estado

Al representar un vector de estado como una lista de números complejos (amplitudes),
Qiskit ordena estas amplitudes de modo que la amplitud en el índice $x$ represente
el estado de la base computacional $|x\rangle$.

```python
print(sv[1])  # amplitud del estado |01>
print(sv[2])  # amplitud del estado |10>
```

```text
(0.7071067811865475+0j)
0j
```

### Compuertas

Cada compuerta en Qiskit puede interpretar una lista de qubits a su manera, pero
las compuertas controladas generalmente siguen la convención `(control, objetivo)`.

Por ejemplo, la siguiente celda agrega una compuerta X controlada donde el qubit $0$ es
el control y el qubit $1$ es el objetivo.

```python
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.cx(0, 1)
qc.draw()
```

```text
q_0: ──■──
     ┌─┴─┐
q_1: ┤ X ├
     └───┘
```

Siguiendo todas las convenciones mencionadas anteriormente en Qiskit, esta compuerta CX
realiza la transformación $|01\rangle \leftrightarrow |11\rangle$, por lo que tiene la
siguiente matriz.

$$
\begin{pmatrix}
 1 & 0 & 0 & 0 \\
 0 & 0 & 0 & 1 \\
 0 & 0 & 1 & 0 \\
 0 & 1 & 0 & 0 \\
\end{pmatrix}
$$

## Cambiar el ordenamiento en Qiskit

Para dibujar un circuito con los qubits en orden inverso (es decir, el qubit $0$ en la
parte inferior), use el argumento `reverse_bits`. Esto solo afecta al diagrama generado
y no afecta al circuito; la compuerta X aún actúa sobre el qubit $0$.

```python
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.x(0)
qc.draw(reverse_bits=True)
```

```text
q_1: ─────
     ┌───┐
q_0: ┤ X ├
     └───┘
```

Puede usar el método `reverse_bits` para devolver un nuevo circuito con las
etiquetas de los qubits invertidas (esto no muta el circuito original).

```python
qc.reverse_bits().draw()
```

```text
q_0: ─────
     ┌───┐
q_1: ┤ X ├
     └───┘
```

Tenga en cuenta que en este nuevo circuito, la compuerta X actúa sobre el qubit $1$.

## Próximos pasos

<Admonition type="tip" title="Recomendaciones">
  -  Vea un ejemplo de uso de circuitos en el tutorial [Algoritmo de Grover](/tutorials/grovers-algorithm).
  -  Explore la referencia de la API [QuantumCircuit](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#quantumcircuit-class).
</Admonition>
