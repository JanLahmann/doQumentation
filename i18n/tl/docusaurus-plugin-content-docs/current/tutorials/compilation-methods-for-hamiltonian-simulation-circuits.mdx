---
title: "Mga pamamaraan ng kompilasyon para sa mga Hamiltonian simulation circuit"
sidebar_label: "Mga pamamaraan ng kompilasyon para sa mga Hamiltonian simulation circuit"
description: "Ang tutorial na ito ay nagbibigay ng pangkalahatang pagsusuri sa tatlong pamamaraan ng kompilasyon sa Qiskit para sa mga Hamiltonian simulation workload."
notebook_path: "docs/tutorials/compilation-methods-for-hamiltonian-simulation-circuits.ipynb"
---

<OpenInLabBanner notebookPath="docs/tutorials/compilation-methods-for-hamiltonian-simulation-circuits.ipynb" />



Tinatayang paggamit ng QPU: walang execution na ginawa sa tutorial na ito dahil nakatuon ito sa proseso ng transpilation.

{/* cspell:ignore Rustiq, nshuffles, edgecolors, edgecolor, Hamlib, Benchpress, Brugière, Goubault, Martiel, Dubal, Lishman, Ivrii, fontweight, fontsize, textprops, wedgeprops, startangle, autopct */}
## Background {#background}

Ang quantum circuit compilation ay isang mahalagang hakbang sa quantum computing workflow. Ito ay nagsasangkot ng pagtransporma ng high-level quantum algorithm sa isang physical quantum circuit na sumusunod sa mga limitasyon ng target quantum hardware. Ang epektibong kompilasyon ay maaaring makaapekto nang malaki sa performance ng mga quantum algorithm sa pamamagitan ng pagbawas ng circuit depth, gate count, at execution time. Ang tutorial na ito ay sumasaliksik sa tatlong magkakaibang diskarte sa quantum circuit compilation sa Qiskit, na nagpapakita ng kanilang mga kalakasan at aplikasyon sa pamamagitan ng praktikal na mga halimbawa.

Ang layunin ng tutorial na ito ay turuan ang mga user kung paano mag-apply at mag-evaluate ng tatlong pamamaraan ng kompilasyon sa Qiskit: ang SABRE transpiler, ang AI-powered transpiler, at ang Rustiq plugin. Matututo ang mga user kung paano gamitin nang epektibo ang bawat pamamaraan at kung paano sukatin ang kanilang performance sa iba't ibang quantum circuit. Sa katapusan ng tutorial na ito, makakaya ng mga user na pumili at mag-adjust ng mga estratehiya ng kompilasyon batay sa mga partikular na layuning pag-optimize gaya ng pagbabawas ng circuit depth, pagpapaliit ng gate count, o pagpapabuti ng runtime.

### Ano ang iyong matututunan {#what-you-will-learn}
- **Kung paano gamitin ang Qiskit transpiler na may SABRE para sa layout at routing optimization.**
- **Kung paano gamitin ang AI transpiler para sa advanced, automated circuit optimization.**
- **Kung paano gumamit ng Rustiq plugin para sa mga circuit na nangangailangan ng tumpak na synthesis ng mga operasyon, lalo na sa mga Hamiltonian simulation task.**

Ang tutorial na ito ay gumagamit ng tatlong halimbawa ng circuit na sumusunod sa [Qiskit patterns](/guides/intro-to-patterns) workflow upang ipakita ang performance ng bawat pamamaraan ng kompilasyon. Sa katapusan ng tutorial na ito, ang mga user ay magiging handa na pumili ng naaangkop na estratehiya ng kompilasyon batay sa kanilang mga partikular na pangangailangan at limitasyon.

### Pangkalahatang-ideya ng mga pamamaraan ng kompilasyon {#compilation-methods-overview}

#### 1. **Qiskit transpiler na may SABRE** {#qiskit-transpiler-with-sabre}
Ang Qiskit transpiler ay gumagamit ng SABRE (SWAP-based BidiREctional heuristic search) algorithm upang i-optimize ang circuit layout at routing. Ang SABRE ay nakatuon sa pagpapaliit ng mga SWAP gate at ang kanilang epekto sa circuit depth habang sumusunod sa mga hardware connectivity constraint. Ang pamamaraang ito ay lubhang versatile at angkop para sa general-purpose circuit optimization, na nagbibigay ng balanse sa pagitan ng performance at computation time. Upang makinabang sa pinakabagong mga pagpapabuti sa SABRE, na detalyado sa [\[1\]](https://arxiv.org/abs/2409.08368), maaari mong dagdagan ang bilang ng mga trial (halimbawa, `layout_trials=400, swap_trials=400`). Para sa mga layunin ng tutorial na ito, gagamitin natin ang default na mga halaga para sa bilang ng mga trial upang ikumpara sa default transpiler ng Qiskit. Ang mga pakinabang at paggalugad ng parameter ng SABRE ay saklaw sa hiwalay na [deep-dive tutorial](/tutorials/transpilation-optimizations-with-sabre).

#### 2. **AI transpiler** {#ai-transpiler}

Ang AI-powered transpiler sa Qiskit ay gumagamit ng machine learning upang hulaan ang pinakamahusay na mga estratehiya ng transpilation sa pamamagitan ng pagsusuri ng mga pattern sa istruktura ng circuit at mga hardware constraint upang pumili ng pinakamahusay na pagkakasunud-sunod ng mga optimization para sa isang ibinigay na input. Ang pamamaraang ito ay partikular na epektibo para sa malalaking quantum circuit, na nag-aalok ng mataas na antas ng automation at kakayahang umangkop sa iba't ibang uri ng problema. Bilang karagdagan sa pangkalahatang circuit optimization, ang AI transpiler ay maaaring gamitin sa `AIPauliNetworkSynthesis` pass, na naglalayong sa mga Pauli network circuit — mga block na binubuo ng H, S, SX, CX, RX, RY, at RZ gate — at nag-apply ng reinforcement learning-based synthesis approach. Para sa higit pang impormasyon tungkol sa AI transpiler at sa mga estratehiya nito sa synthesis, tingnan ang [\[2\]](https://arxiv.org/abs/2405.13196) at [\[3\]](https://arxiv.org/abs/2503.14448).

#### 3. **Rustiq plugin** {#rustiq-plugin}
Ang Rustiq plugin ay nagpapakilala ng mga advanced synthesis technique na partikular para sa mga operasyon ng `PauliEvolutionGate`, na kumakatawan sa mga Pauli rotation na karaniwang ginagamit sa Trotterized dynamics. Ang plugin na ito ay mahalaga para sa mga circuit na nagpapatupad ng Hamiltonian simulation, gaya ng mga ginagamit sa quantum chemistry at physics problem, kung saan ang mga tumpak na Pauli rotation ay mahalaga para sa epektibong pagsisimula ng mga problem Hamiltonian. Ang Rustiq ay nag-aalok ng tumpak at low-depth circuit synthesis para sa mga espesyalisadong operasyong ito. Para sa higit pang mga detalye tungkol sa implementasyon at performance ng Rustiq, mangyaring sumangguni sa [\[4\]](https://arxiv.org/abs/2404.03280).

Sa pamamagitan ng paggalugad sa mga pamamaraang ito ng kompilasyon nang malalim, ang tutorial na ito ay nagbibigay sa mga user ng mga kasangkapan upang mapahusay ang performance ng kanilang mga quantum circuit, na nagbubukas ng daan para sa mas mahusay at praktikal na mga quantum computation.
## Mga Kinakailangan {#requirements}

Bago simulan ang tutorial na ito, siguraduhing mayroon ka ng sumusunod na naka-install:
- Qiskit SDK v1.3 o mas bago, na may [visualization](https://docs.quantum.ibm.com/api/qiskit/visualization) support
- Qiskit Runtime v0.28 o mas bago (`pip install qiskit-ibm-runtime`)
- Qiskit IBM Transpiler (`pip install qiskit-ibm-transpiler`)
- Qiskit AI Transpiler local mode (`pip install qiskit_ibm_ai_local_transpiler`)
- Networkx graph library (`pip install networkx`)
## Setup {#setup}

```python
# Added by doQumentation — installs packages not in the Binder environment
%pip install -q qiskit-ibm-transpiler
```

```python
from qiskit.circuit import QuantumCircuit
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit.circuit.library import (
    efficient_su2,
    PauliEvolutionGate,
)
from qiskit_ibm_transpiler import generate_ai_pass_manager
from qiskit.quantum_info import SparsePauliOp
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit.transpiler.passes.synthesis.high_level_synthesis import HLSConfig
from collections import Counter
from IPython.display import display
import time
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import json
import requests
import logging

# Suppress noisy loggers
logging.getLogger(
    "qiskit_ibm_transpiler.wrappers.ai_local_synthesis"
).setLevel(logging.ERROR)

seed = 42  # Seed for reproducibility
```

## Part 1: Efficient SU2 Circuit {#part-1-efficient-su2-circuit}

### Step 1: I-map ang mga classical input sa isang quantum problem {#step-1-map-classical-inputs-to-a-quantum-problem}

Sa seksyong ito, susuriin natin ang `efficient_su2` circuit, isang hardware-efficient ansatz na karaniwang ginagamit sa mga variational quantum algorithm (gaya ng VQE) at mga quantum machine-learning task. Ang circuit ay binubuo ng magpapaulitang mga layer ng single-qubit rotation at entangling gate na nakaayos sa circular pattern, na dinisenyo upang epektibong siyasatin ang quantum state space habang pinapanatili ang manageable na depth.

Magsisimula tayo sa pagbuo ng isang `efficient_su2` circuit upang ipakita kung paano ikumpara ang iba't ibang pamamaraan ng kompilasyon. Pagkatapos ng Part 1, palalakihin natin ang ating pagsusuri sa mas malaking hanay ng mga circuit, na magbibigay-daan sa komprehensibong benchmark para sa pagsusuri ng performance ng iba't ibang pamamaraan ng kompilasyon.

```python
qubit_size = list(range(10, 101, 10))
qc_su2_list = [
    efficient_su2(n, entanglement="circular", reps=1)
    .decompose()
    .copy(name=f"SU2_{n}")
    for n in qubit_size
]

# Draw the first circuit
qc_su2_list[0].draw(output="mpl")
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/f362cdac-94d8-4cc5-85f4-015c3d9eba3a-0.avif)

### Step 2: I-optimize ang problema para sa quantum hardware execution {#step-2-optimize-problem-for-quantum-hardware-execution}

Ang hakbang na ito ay ang pangunahing pokus ng tutorial. Dito, nilalayungan nating i-optimize ang mga quantum circuit para sa mahusay na execution sa tunay na quantum hardware. Ang ating pangunahing layunin ay bawasan ang circuit depth at gate count, na mga pangunahing salik sa pagpapabuti ng execution fidelity at pagpapaliit ng hardware noise.

- **SABRE transpiler**: Gumagamit ng default transpiler ng Qiskit na may SABRE layout at routing algorithm.
- **AI transpiler (local mode)**: Ang standard na AI-powered transpiler na gumagamit ng local inference at ang default na estratehiya ng synthesis.
- **Rustiq plugin**: Isang transpiler plugin na dinisenyo para sa low-depth compilation na iniayon para sa mga Hamiltonian simulation task.

Ang layunin ng hakbang na ito ay ikumpara ang mga resulta ng mga pamamaraang ito sa mga tuntunin ng depth at gate count ng transpiled circuit. Ang isa pang mahalagang sukatan na isinasaalang-alang natin ay ang transpilation runtime. Sa pamamagitan ng pagsusuri sa mga sukatan na ito, masusuri natin ang mga relatibong kalakasan ng bawat pamamaraan at matutukoy kung alin ang gumagawa ng pinaka-mahusay na circuit para sa execution sa napiling hardware.

Paalala: Para sa unang halimbawa ng SU2 circuit, ikukumpara lamang natin ang SABRE transpiler sa default AI transpiler. Gayunpaman, sa kasunod na benchmark gamit ang mga Hamlib circuit, ikukumpara natin ang tatlong pamamaraan ng transpilation.

```python
# QiskitRuntimeService.save_account(channel="ibm_quantum_platform", token="<YOUR-API-KEY>", overwrite=True, set_as_default=True)
service = QiskitRuntimeService(channel="ibm_quantum_platform")
backend = service.backend("ibm_torino")
print(f"Using backend: {backend}")
```

```text
qiskit_runtime_service._get_crn_from_instance_name:WARNING:2025-07-30 21:46:30,843: Multiple instances found. Using all matching instances.
```

```text
Using backend: <IBMBackend('ibm_torino')>
```

Qiskit transpiler na may SABRE:

```python
pm_sabre = generate_preset_pass_manager(
    optimization_level=3, backend=backend, seed_transpiler=seed
)
```

AI transpiler:

```python
# Standard AI transpiler pass manager, using the local mode
pm_ai = generate_ai_pass_manager(
    backend=backend, optimization_level=3, ai_optimization_level=3
)
```

Rustiq plugin:

```python
hls_config = HLSConfig(
    PauliEvolution=[
        (
            "rustiq",
            {
                "nshuffles": 400,
                "upto_phase": True,
                "fix_clifford": True,
                "preserve_order": False,
                "metric": "depth",
            },
        )
    ]
)
pm_rustiq = generate_preset_pass_manager(
    optimization_level=3,
    backend=backend,
    hls_config=hls_config,
    seed_transpiler=seed,
)
```

#### I-transpile at kunin ang mga sukatan {#transpile-and-capture-metrics}

Upang ikumpara ang performance ng mga pamamaraan ng kompilasyon, tinukoy natin ang isang function na nag-transpose ng input circuit at kumukuha ng mga kaugnay na sukatan sa pare-parehong paraan. Kabilang dito ang kabuuang circuit depth, pangkalahatang gate count, at transpilation time.

Bilang karagdagan sa mga karaniwang sukatan na ito, kinukuha rin natin ang 2-qubit gate depth, na partikular na mahalagang sukatan para sa pagsusuri ng execution sa quantum hardware. Hindi tulad ng kabuuang depth, na kasama ang lahat ng gate, ang 2-qubit depth ay mas tumpak na sumasalamin sa *aktwal na tagal ng execution* ng circuit sa hardware. Ito ay dahil ang mga 2-qubit gate ay karaniwang nangingibabaw sa oras at error budget sa karamihan ng mga quantum device. Kaya naman, ang pagpapaliit ng 2-qubit depth ay kritikal para sa pagpapabuti ng fidelity at pagbawas ng mga epekto ng decoherence sa panahon ng execution.

Gagamitin natin ang function na ito upang suriin ang performance ng iba't ibang pamamaraan ng kompilasyon sa maraming circuit.

```python
def capture_transpilation_metrics(
    results, pass_manager, circuits, method_name
):
    """
    Capture transpilation metrics for a list of circuits and stores the results in a DataFrame.

    Args:
        results (pd.DataFrame): DataFrame to store the results.
        pass_manager: Pass manager used for transpilation.
        circuits (list): List of quantum circuits to transpile.
        method_name (str): Name of the transpilation method.

    Returns:
        list: List of transpiled circuits.
    """
    transpiled_circuits = []

    for i, qc in enumerate(circuits):
        # Transpile the circuit
        start_time = time.time()
        transpiled_qc = pass_manager.run(qc)
        end_time = time.time()

        # Needed for AI transpiler to be consistent with other methods
        transpiled_qc = transpiled_qc.decompose(gates_to_decompose=["swap"])

        # Collect metrics
        transpilation_time = end_time - start_time
        circuit_depth = transpiled_qc.depth(
            lambda x: x.operation.num_qubits == 2
        )
        circuit_size = transpiled_qc.size()

        # Append results to DataFrame
        results.loc[len(results)] = {
            "method": method_name,
            "qc_name": qc.name,
            "qc_index": i,
            "num_qubits": qc.num_qubits,
            "ops": transpiled_qc.count_ops(),
            "depth": circuit_depth,
            "size": circuit_size,
            "runtime": transpilation_time,
        }
        transpiled_circuits.append(transpiled_qc)
        print(
            f"Transpiled circuit index {i} ({qc.name}) in {transpilation_time:.2f} seconds with method {method_name}, "
            f"depth {circuit_depth}, and size {circuit_size}."
        )

    return transpiled_circuits
```

```python
results_su2 = pd.DataFrame(
    columns=[
        "method",
        "qc_name",
        "qc_index",
        "num_qubits",
        "ops",
        "depth",
        "size",
        "runtime",
    ]
)

tqc_sabre = capture_transpilation_metrics(
    results_su2, pm_sabre, qc_su2_list, "sabre"
)
tqc_ai = capture_transpilation_metrics(results_su2, pm_ai, qc_su2_list, "ai")
```

```text
Transpiled circuit index 0 (SU2_10) in 0.06 seconds with method sabre, depth 13, and size 167.
Transpiled circuit index 1 (SU2_20) in 0.24 seconds with method sabre, depth 20, and size 299.
Transpiled circuit index 2 (SU2_30) in 10.72 seconds with method sabre, depth 72, and size 627.
Transpiled circuit index 3 (SU2_40) in 16.16 seconds with method sabre, depth 40, and size 599.
Transpiled circuit index 4 (SU2_50) in 76.89 seconds with method sabre, depth 77, and size 855.
Transpiled circuit index 5 (SU2_60) in 86.12 seconds with method sabre, depth 60, and size 899.
Transpiled circuit index 6 (SU2_70) in 94.46 seconds with method sabre, depth 79, and size 1085.
Transpiled circuit index 7 (SU2_80) in 69.05 seconds with method sabre, depth 80, and size 1199.
Transpiled circuit index 8 (SU2_90) in 88.25 seconds with method sabre, depth 105, and size 1420.
Transpiled circuit index 9 (SU2_100) in 83.80 seconds with method sabre, depth 100, and size 1499.
Transpiled circuit index 0 (SU2_10) in 0.17 seconds with method ai, depth 10, and size 168.
Transpiled circuit index 1 (SU2_20) in 0.29 seconds with method ai, depth 20, and size 299.
Transpiled circuit index 2 (SU2_30) in 13.56 seconds with method ai, depth 36, and size 548.
Transpiled circuit index 3 (SU2_40) in 15.95 seconds with method ai, depth 40, and size 599.
Transpiled circuit index 4 (SU2_50) in 80.70 seconds with method ai, depth 54, and size 823.
Transpiled circuit index 5 (SU2_60) in 75.99 seconds with method ai, depth 60, and size 899.
Transpiled circuit index 6 (SU2_70) in 64.96 seconds with method ai, depth 74, and size 1087.
Transpiled circuit index 7 (SU2_80) in 68.25 seconds with method ai, depth 80, and size 1199.
Transpiled circuit index 8 (SU2_90) in 75.07 seconds with method ai, depth 90, and size 1404.
Transpiled circuit index 9 (SU2_100) in 63.97 seconds with method ai, depth 100, and size 1499.
```

Ipakita ang mga transpiled result ng isa sa mga circuit.

```python
print("Sabre transpilation")
display(tqc_sabre[0].draw("mpl", fold=-1, idle_wires=False))
print("AI transpilation")
display(tqc_ai[0].draw("mpl", fold=-1, idle_wires=False))
```

```text
Sabre transpilation
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/37924fc2-8fb6-451a-b8f9-cd79573f2384-1.avif)

```text
AI transpilation
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/37924fc2-8fb6-451a-b8f9-cd79573f2384-3.avif)

Talahanayan ng mga resulta:

```python
summary_su2 = (
    results_su2.groupby("method")[["depth", "size", "runtime"]]
    .mean()
    .round(2)
)
print(summary_su2)

results_su2
```

```text
depth   size  runtime
method
ai       56.4  852.5    45.89
sabre    64.6  864.9    52.57
```

```text
method  qc_name  qc_index  num_qubits                                ops  \
0   sabre   SU2_10         0          10     {'rz': 81, 'sx': 70, 'cz': 16}
1   sabre   SU2_20         1          20   {'rz': 160, 'sx': 119, 'cz': 20}
2   sabre   SU2_30         2          30   {'sx': 295, 'rz': 242, 'cz': 90}
3   sabre   SU2_40         3          40   {'rz': 320, 'sx': 239, 'cz': 40}
4   sabre   SU2_50         4          50   {'rz': 402, 'sx': 367, 'cz': 86}
5   sabre   SU2_60         5          60   {'rz': 480, 'sx': 359, 'cz': 60}
6   sabre   SU2_70         6          70   {'rz': 562, 'sx': 441, 'cz': 82}
7   sabre   SU2_80         7          80   {'rz': 640, 'sx': 479, 'cz': 80}
8   sabre   SU2_90         8          90  {'rz': 721, 'sx': 585, 'cz': 114}
9   sabre  SU2_100         9         100  {'rz': 800, 'sx': 599, 'cz': 100}
10     ai   SU2_10         0          10     {'rz': 81, 'sx': 71, 'cz': 16}
11     ai   SU2_20         1          20   {'rz': 160, 'sx': 119, 'cz': 20}
12     ai   SU2_30         2          30   {'sx': 243, 'rz': 242, 'cz': 63}
13     ai   SU2_40         3          40   {'rz': 320, 'sx': 239, 'cz': 40}
14     ai   SU2_50         4          50   {'rz': 403, 'sx': 346, 'cz': 74}
15     ai   SU2_60         5          60   {'rz': 480, 'sx': 359, 'cz': 60}
16     ai   SU2_70         6          70   {'rz': 563, 'sx': 442, 'cz': 82}
17     ai   SU2_80         7          80   {'rz': 640, 'sx': 479, 'cz': 80}
18     ai   SU2_90         8          90  {'rz': 721, 'sx': 575, 'cz': 108}
19     ai  SU2_100         9         100  {'rz': 800, 'sx': 599, 'cz': 100}

    depth  size    runtime
0      13   167   0.058845
1      20   299   0.238217
2      72   627  10.723922
3      40   599  16.159262
4      77   855  76.886604
5      60   899  86.118255
6      79  1085  94.458287
7      80  1199  69.048184
8     105  1420  88.254809
9     100  1499  83.795482
10     10   168   0.171532
11     20   299   0.291691
12     36   548  13.555931
13     40   599  15.952733
14     54   823  80.702141
15     60   899  75.993404
16     74  1087  64.960162
17     80  1199  68.253280
18     90  1404  75.072412
19    100  1499  63.967446
```

#### Graph ng mga resulta {#results-graph}

Dahil tinukoy natin ang isang function upang pare-parehong kunin ang mga sukatan, tutukuyin din natin ang isa upang i-graph ang mga sukatan. Dito, i-plot natin ang two-qubit depth, gate count, at runtime para sa bawat pamamaraan ng kompilasyon sa mga circuit.

```python
def plot_transpilation_metrics(results, overall_title, x_axis="qc_index"):
    """
    Plots transpilation metrics (depth, size, runtime) for different transpilation methods.

    Parameters:
        results (DataFrame): Data containing columns ['num_qubits', 'method', 'depth', 'size', 'runtime']
        overall_title (str): The title of the overall figure.
        x_axis (str): The x-axis label, either 'num_qubits' or 'qc_index'.
    """

    fig, axs = plt.subplots(1, 3, figsize=(24, 6))
    metrics = ["depth", "size", "runtime"]
    titles = ["Circuit Depth", "Circuit Size", "Transpilation Runtime"]
    y_labels = ["Depth", "Size (Gate Count)", "Runtime (s)"]

    methods = results["method"].unique()
    colors = plt.colormaps["tab10"]
    markers = ["o", "^", "s", "D", "P", "*", "X", "v"]
    color_list = [colors(i % colors.N) for i in range(len(methods))]
    color_map = {method: color_list[i] for i, method in enumerate(methods)}
    marker_map = {
        method: markers[i % len(markers)] for i, method in enumerate(methods)
    }
    jitter_factor = 0.1  # Small x-axis jitter for visibility
    handles, labels = [], []  # Unique handles for legend

    # Plot each metric
    for i, metric in enumerate(metrics):
        for method in methods:
            method_data = results[results["method"] == method]

            # Introduce slight jitter to avoid exact overlap
            jitter = np.random.uniform(
                -jitter_factor, jitter_factor, len(method_data)
            )

            scatter = axs[i].scatter(
                method_data[x_axis] + jitter,
                method_data[metric],
                color=color_map[method],
                label=method,
                marker=marker_map[method],
                alpha=0.7,
                edgecolors="black",
                s=80,
            )

            if method not in labels:
                handles.append(scatter)
                labels.append(method)

        axs[i].set_title(titles[i])
        axs[i].set_xlabel(x_axis)
        axs[i].set_ylabel(y_labels[i])
        axs[i].grid(axis="y", linestyle="--", alpha=0.7)
        axs[i].tick_params(axis="x", rotation=45)
        axs[i].set_xticks(sorted(results[x_axis].unique()))

    fig.suptitle(overall_title, fontsize=16)
    fig.legend(
        handles=handles,
        labels=labels,
        loc="upper right",
        bbox_to_anchor=(1.05, 1),
    )

    plt.tight_layout()
    plt.show()
```

```python
plot_transpilation_metrics(
    results_su2, "Transpilation Metrics for SU2 Circuits", x_axis="num_qubits"
)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/7f7b502a-8ed6-45fa-a698-02977149e283-0.avif)

#### Pagsusuri ng mga resulta ng kompilasyon ng SU2 circuit {#analysis-of-su2-circuit-compilation-results}

Sa eksperimentong ito, ikinukumpara natin ang dalawang pamamaraan ng transpilation — ang SABRE transpiler ng Qiskit at ang AI-powered transpiler — sa isang hanay ng mga `efficient_su2` circuit. Dahil ang mga circuit na ito ay hindi nagsasama ng anumang operasyon ng `PauliEvolutionGate`, ang Rustiq plugin ay hindi kasama sa pagkukumparang ito.

Sa average, ang AI transpiler ay mas mahusay sa mga tuntunin ng circuit depth, na may higit sa 10% na pagpapabuti sa buong hanay ng mga SU2 circuit. Para sa gate count (circuit size) at transpilation runtime, ang parehong pamamaraan ay nagbibigay ng mga katulad na resulta sa pangkalahatan.

Gayunpaman, ang pagsusuri sa mga indibidwal na data point ay nagbubunyag ng mas malalim na pang-unawa:
- Para sa karamihan ng mga laki ng qubit, ang parehong SABRE at AI ay gumagawa ng halos magkaparehong resulta, na nagmumungkahi na sa maraming kaso, ang parehong pamamaraan ay nagsasama sa magkakatulad na mahusay na solusyon.
- Para sa ilang partikular na laki ng circuit, partikular sa 30, 50, 70, at 90 qubit, ang AI transpiler ay nakakahanap ng mas mababaw na circuit kaysa sa SABRE. Ito ay nagpapahiwatig na ang learning-based approach ng AI ay nakakadiskubre ng mas optimal na layout o routing path sa mga kasong hindi gumagawa ang heuristic ng SABRE.

Ang pag-uugaling ito ay nagbibigay-diin sa isang mahalagang aral:
> Bagama't ang SABRE at AI ay kadalasang gumagawa ng maihahambing na resulta, ang AI transpiler ay paminsan-minsan ay nakakadiskubre ng mas mahusay na solusyon, lalo na sa mga tuntunin ng depth, na maaaring humantong sa malaking pagpapabuti ng performance sa hardware.
## Part 2: Hamiltonian simulation circuit {#part-2-hamiltonian-simulation-circuit}

### Step 1: Siyasatin ang mga circuit na may `PauliEvolutionGate` {#step-1-investigate-circuits-with-paulievolutiongate}

Sa seksyong ito, sinusuri natin ang mga quantum circuit na binuo gamit ang `PauliEvolutionGate`, na nagbibigay-daan sa mahusay na simulation ng mga Hamiltonian. Susuriin natin kung paano i-optimize ng iba't ibang pamamaraan ng kompilasyon ang mga circuit na ito sa iba't ibang Hamiltonian.

#### Mga Hamiltonian na ginamit sa benchmark {#hamiltonians-used-in-the-benchmark}

Ang mga Hamiltonian na ginamit sa benchmark na ito ay naglalarawan ng pairwise interaction sa pagitan ng mga qubit, kasama ang mga terminong tulad ng $ZZ$, $XX$, at $YY$. Ang mga Hamiltonian na ito ay karaniwang ginagamit sa quantum chemistry, condensed matter physics, at materials science, kung saan sinisimula nila ang mga sistema ng mga nakikipag-ugnayan na particle.

Bilang sanggunian, maaaring tuklasin ng mga user ang mas malawak na hanay ng mga Hamiltonian sa papel na ito: [Efficient Hamiltonian Simulation on Noisy Quantum Devices](https://arxiv.org/pdf/2306.13126).

#### Pinagmumulan ng benchmark: Hamlib at Benchpress {#benchmark-source-hamlib-and-benchpress}

Ang mga circuit na ginamit sa benchmark na ito ay nakuha mula sa [Hamlib benchmark repository](https://github.com/SRI-International/QC-App-Oriented-Benchmarks/tree/master/hamlib), na naglalaman ng mga realistikong Hamiltonian simulation workload.

Ang mga parehong circuit na ito ay dating na-benchmark gamit ang [Benchpress](https://github.com/Qiskit/benchpress), isang open-source framework para sa pagsusuri ng performance ng quantum transpilation. Sa pamamagitan ng paggamit ng standardisadong hanay ng mga circuit na ito, maaari tayong direktang ikumpara ang kahusayan ng iba't ibang estratehiya ng kompilasyon sa mga kinatawang problema ng simulation.

Ang Hamiltonian simulation ay isang pundasyon na gawain sa quantum computing, na may mga aplikasyon sa molecular simulation, optimization problem, at quantum many-body physics. Ang pag-unawa kung paano i-optimize ng iba't ibang pamamaraan ng kompilasyon ang mga circuit na ito ay makakatulong sa mga user na mapabuti ang praktikal na execution ng mga naturang circuit sa near-term quantum device.

```python
# Obtain the Hamiltonian JSON from the benchpress repository
url = "https://raw.githubusercontent.com/Qiskit/benchpress/e7b29ef7be4cc0d70237b8fdc03edbd698908eff/benchpress/hamiltonian/hamlib/100_representative.json"
response = requests.get(url)
response.raise_for_status()  # Raise an error if download failed
ham_records = json.loads(response.text)
# Remove circuits that are too large for the backend
ham_records = [
    h for h in ham_records if h["ham_qubits"] <= backend.num_qubits
]
# Remove the circuits that are large to save transpilation time
ham_records = sorted(ham_records, key=lambda x: x["ham_terms"])[:35]

qc_ham_list = []
for h in ham_records:
    terms = h["ham_hamlib_hamiltonian_terms"]
    coeff = h["ham_hamlib_hamiltonian_coefficients"]
    num_qubits = h["ham_qubits"]
    name = h["ham_problem"]

    evo_gate = PauliEvolutionGate(SparsePauliOp(terms, coeff))

    qc_ham = QuantumCircuit(num_qubits)
    qc_ham.name = name

    qc_ham.append(evo_gate, range(num_qubits))
    qc_ham_list.append(qc_ham)
print(f"Number of Hamiltonian circuits: {len(qc_ham_list)}")

# Draw the first Hamiltonian circuit
qc_ham_list[0].draw("mpl", fold=-1)
```

```text
Number of Hamiltonian circuits: 35
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/66347c00-1607-4405-bb76-610690adf6b8-1.avif)

### Step 2: I-optimize ang problema para sa quantum hardware execution {#step-2-optimize-problem-for-quantum-hardware-execution-1}

Tulad ng sa nakaraang halimbawa, gagamitin natin ang parehong backend upang masiguro ang pare-pareho sa ating mga pagkukumpara. Dahil ang mga pass manager (`pm_sabre`, `pm_ai`, at `pm_rustiq`) ay naka-initialize na, maaari tayong direktang magpatuloy sa pag-transpose ng mga Hamiltonian circuit gamit ang bawat pamamaraan.

Ang hakbang na ito ay nakatuon lamang sa pagsasagawa ng transpilation at pag-record ng mga resultang sukatan ng circuit, kasama ang depth, gate count, at transpilation runtime. Sa pamamagitan ng pagsusuri sa mga resultang ito, nilalayungan nating matukoy ang kahusayan ng bawat pamamaraan ng transpilation para sa ganitong uri ng circuit.
I-transpile at kunin ang mga sukatan:

```python
results_ham = pd.DataFrame(
    columns=[
        "method",
        "qc_name",
        "qc_index",
        "num_qubits",
        "ops",
        "depth",
        "size",
        "runtime",
    ]
)

tqc_sabre = capture_transpilation_metrics(
    results_ham, pm_sabre, qc_ham_list, "sabre"
)
tqc_ai = capture_transpilation_metrics(results_ham, pm_ai, qc_ham_list, "ai")
tqc_rustiq = capture_transpilation_metrics(
    results_ham, pm_rustiq, qc_ham_list, "rustiq"
)
```

```text
Transpiled circuit index 0 (all-vib-o3) in 0.02 seconds with method sabre, depth 6, and size 58.
Transpiled circuit index 1 (all-vib-c2h) in 1.10 seconds with method sabre, depth 2, and size 39.
Transpiled circuit index 2 (all-vib-bh) in 0.01 seconds with method sabre, depth 3, and size 30.
Transpiled circuit index 3 (all-vib-c2h) in 0.03 seconds with method sabre, depth 18, and size 115.
Transpiled circuit index 4 (graph-gnp_k-2) in 0.02 seconds with method sabre, depth 24, and size 129.
Transpiled circuit index 5 (all-vib-fccf) in 0.05 seconds with method sabre, depth 14, and size 134.
Transpiled circuit index 6 (all-vib-hno) in 8.39 seconds with method sabre, depth 6, and size 174.
Transpiled circuit index 7 (all-vib-bhf2) in 3.92 seconds with method sabre, depth 22, and size 220.
Transpiled circuit index 8 (LiH) in 0.03 seconds with method sabre, depth 67, and size 290.
Transpiled circuit index 9 (uf20-ham) in 0.04 seconds with method sabre, depth 50, and size 340.
Transpiled circuit index 10 (all-vib-fccf) in 0.62 seconds with method sabre, depth 30, and size 286.
Transpiled circuit index 11 (all-vib-fccf) in 0.04 seconds with method sabre, depth 67, and size 339.
Transpiled circuit index 12 (all-vib-ch2) in 0.04 seconds with method sabre, depth 87, and size 421.
Transpiled circuit index 13 (tfim) in 0.05 seconds with method sabre, depth 36, and size 222.
Transpiled circuit index 14 (all-vib-cyclo_propene) in 9.51 seconds with method sabre, depth 22, and size 345.
Transpiled circuit index 15 (graph-gnp_k-4) in 0.05 seconds with method sabre, depth 128, and size 704.
Transpiled circuit index 16 (all-vib-hc3h2cn) in 13.83 seconds with method sabre, depth 2, and size 242.
Transpiled circuit index 17 (TSP_Ncity-4) in 0.05 seconds with method sabre, depth 106, and size 609.
Transpiled circuit index 18 (tfim) in 0.29 seconds with method sabre, depth 73, and size 399.
Transpiled circuit index 19 (all-vib-h2co) in 21.97 seconds with method sabre, depth 30, and size 572.
Transpiled circuit index 20 (Be2) in 0.09 seconds with method sabre, depth 324, and size 1555.
Transpiled circuit index 21 (graph-complete_bipart) in 0.12 seconds with method sabre, depth 250, and size 1394.
Transpiled circuit index 22 (all-vib-f2) in 0.07 seconds with method sabre, depth 215, and size 1027.
Transpiled circuit index 23 (all-vib-cyclo_propene) in 41.22 seconds with method sabre, depth 30, and size 1144.
Transpiled circuit index 24 (TSP_Ncity-5) in 1.89 seconds with method sabre, depth 175, and size 1933.
Transpiled circuit index 25 (H2) in 0.32 seconds with method sabre, depth 1237, and size 5502.
Transpiled circuit index 26 (uuf100-ham) in 0.20 seconds with method sabre, depth 385, and size 4303.
Transpiled circuit index 27 (ham-graph-gnp_k-5) in 0.20 seconds with method sabre, depth 311, and size 3654.
Transpiled circuit index 28 (tfim) in 0.15 seconds with method sabre, depth 276, and size 3213.
Transpiled circuit index 29 (uuf100-ham) in 0.21 seconds with method sabre, depth 520, and size 5250.
Transpiled circuit index 30 (flat100-ham) in 0.15 seconds with method sabre, depth 131, and size 3157.
Transpiled circuit index 31 (uf100-ham) in 0.24 seconds with method sabre, depth 624, and size 7378.
Transpiled circuit index 32 (OH) in 0.88 seconds with method sabre, depth 2175, and size 9808.
Transpiled circuit index 33 (HF) in 0.66 seconds with method sabre, depth 2206, and size 9417.
Transpiled circuit index 34 (BH) in 0.89 seconds with method sabre, depth 2177, and size 9802.
Transpiled circuit index 0 (all-vib-o3) in 0.02 seconds with method ai, depth 6, and size 58.
Transpiled circuit index 1 (all-vib-c2h) in 1.11 seconds with method ai, depth 2, and size 39.
Transpiled circuit index 2 (all-vib-bh) in 0.01 seconds with method ai, depth 3, and size 30.
Transpiled circuit index 3 (all-vib-c2h) in 0.11 seconds with method ai, depth 18, and size 94.
Transpiled circuit index 4 (graph-gnp_k-2) in 0.11 seconds with method ai, depth 22, and size 129.
Transpiled circuit index 5 (all-vib-fccf) in 0.06 seconds with method ai, depth 22, and size 177.
Transpiled circuit index 6 (all-vib-hno) in 8.62 seconds with method ai, depth 10, and size 198.
Transpiled circuit index 7 (all-vib-bhf2) in 3.71 seconds with method ai, depth 18, and size 195.
Transpiled circuit index 8 (LiH) in 0.19 seconds with method ai, depth 62, and size 267.
Transpiled circuit index 9 (uf20-ham) in 0.22 seconds with method ai, depth 47, and size 321.
Transpiled circuit index 10 (all-vib-fccf) in 0.71 seconds with method ai, depth 38, and size 369.
Transpiled circuit index 11 (all-vib-fccf) in 0.24 seconds with method ai, depth 65, and size 315.
Transpiled circuit index 12 (all-vib-ch2) in 0.24 seconds with method ai, depth 91, and size 430.
Transpiled circuit index 13 (tfim) in 0.15 seconds with method ai, depth 12, and size 251.
Transpiled circuit index 14 (all-vib-cyclo_propene) in 8.50 seconds with method ai, depth 18, and size 311.
Transpiled circuit index 15 (graph-gnp_k-4) in 0.25 seconds with method ai, depth 117, and size 659.
Transpiled circuit index 16 (all-vib-hc3h2cn) in 16.11 seconds with method ai, depth 2, and size 242.
Transpiled circuit index 17 (TSP_Ncity-4) in 0.39 seconds with method ai, depth 98, and size 564.
Transpiled circuit index 18 (tfim) in 0.38 seconds with method ai, depth 23, and size 437.
Transpiled circuit index 19 (all-vib-h2co) in 24.97 seconds with method ai, depth 38, and size 707.
Transpiled circuit index 20 (Be2) in 1.07 seconds with method ai, depth 293, and size 1392.
Transpiled circuit index 21 (graph-complete_bipart) in 0.61 seconds with method ai, depth 229, and size 1437.
Transpiled circuit index 22 (all-vib-f2) in 0.57 seconds with method ai, depth 178, and size 964.
Transpiled circuit index 23 (all-vib-cyclo_propene) in 50.89 seconds with method ai, depth 34, and size 1425.
Transpiled circuit index 24 (TSP_Ncity-5) in 1.61 seconds with method ai, depth 171, and size 2020.
Transpiled circuit index 25 (H2) in 6.39 seconds with method ai, depth 1148, and size 5208.
Transpiled circuit index 26 (uuf100-ham) in 3.97 seconds with method ai, depth 376, and size 5048.
Transpiled circuit index 27 (ham-graph-gnp_k-5) in 3.54 seconds with method ai, depth 357, and size 4451.
Transpiled circuit index 28 (tfim) in 1.72 seconds with method ai, depth 216, and size 3026.
Transpiled circuit index 29 (uuf100-ham) in 4.45 seconds with method ai, depth 426, and size 5399.
Transpiled circuit index 30 (flat100-ham) in 7.02 seconds with method ai, depth 86, and size 3108.
Transpiled circuit index 31 (uf100-ham) in 12.85 seconds with method ai, depth 623, and size 8354.
Transpiled circuit index 32 (OH) in 15.19 seconds with method ai, depth 2084, and size 9543.
Transpiled circuit index 33 (HF) in 17.51 seconds with method ai, depth 2063, and size 9446.
Transpiled circuit index 34 (BH) in 15.33 seconds with method ai, depth 2094, and size 9730.
Transpiled circuit index 0 (all-vib-o3) in 0.02 seconds with method rustiq, depth 13, and size 83.
Transpiled circuit index 1 (all-vib-c2h) in 1.11 seconds with method rustiq, depth 2, and size 39.
Transpiled circuit index 2 (all-vib-bh) in 0.01 seconds with method rustiq, depth 3, and size 30.
Transpiled circuit index 3 (all-vib-c2h) in 0.01 seconds with method rustiq, depth 13, and size 79.
Transpiled circuit index 4 (graph-gnp_k-2) in 0.02 seconds with method rustiq, depth 31, and size 131.
Transpiled circuit index 5 (all-vib-fccf) in 0.04 seconds with method rustiq, depth 50, and size 306.
Transpiled circuit index 6 (all-vib-hno) in 14.03 seconds with method rustiq, depth 22, and size 276.
Transpiled circuit index 7 (all-vib-bhf2) in 3.15 seconds with method rustiq, depth 13, and size 155.
Transpiled circuit index 8 (LiH) in 0.03 seconds with method rustiq, depth 54, and size 270.
Transpiled circuit index 9 (uf20-ham) in 0.04 seconds with method rustiq, depth 65, and size 398.
Transpiled circuit index 10 (all-vib-fccf) in 0.16 seconds with method rustiq, depth 41, and size 516.
Transpiled circuit index 11 (all-vib-fccf) in 0.02 seconds with method rustiq, depth 34, and size 189.
Transpiled circuit index 12 (all-vib-ch2) in 0.03 seconds with method rustiq, depth 49, and size 240.
Transpiled circuit index 13 (tfim) in 0.05 seconds with method rustiq, depth 20, and size 366.
Transpiled circuit index 14 (all-vib-cyclo_propene) in 9.08 seconds with method rustiq, depth 16, and size 277.
Transpiled circuit index 15 (graph-gnp_k-4) in 0.04 seconds with method rustiq, depth 116, and size 612.
Transpiled circuit index 16 (all-vib-hc3h2cn) in 13.89 seconds with method rustiq, depth 2, and size 257.
Transpiled circuit index 17 (TSP_Ncity-4) in 0.05 seconds with method rustiq, depth 133, and size 737.
Transpiled circuit index 18 (tfim) in 0.11 seconds with method rustiq, depth 25, and size 680.
Transpiled circuit index 19 (all-vib-h2co) in 27.19 seconds with method rustiq, depth 66, and size 983.
Transpiled circuit index 20 (Be2) in 0.07 seconds with method rustiq, depth 215, and size 1030.
Transpiled circuit index 21 (graph-complete_bipart) in 0.14 seconds with method rustiq, depth 328, and size 1918.
Transpiled circuit index 22 (all-vib-f2) in 0.05 seconds with method rustiq, depth 114, and size 692.
Transpiled circuit index 23 (all-vib-cyclo_propene) in 62.25 seconds with method rustiq, depth 74, and size 2348.
Transpiled circuit index 24 (TSP_Ncity-5) in 0.20 seconds with method rustiq, depth 436, and size 3605.
Transpiled circuit index 25 (H2) in 0.21 seconds with method rustiq, depth 643, and size 3476.
Transpiled circuit index 26 (uuf100-ham) in 0.24 seconds with method rustiq, depth 678, and size 6120.
Transpiled circuit index 27 (ham-graph-gnp_k-5) in 0.22 seconds with method rustiq, depth 588, and size 5241.
Transpiled circuit index 28 (tfim) in 0.34 seconds with method rustiq, depth 340, and size 5901.
Transpiled circuit index 29 (uuf100-ham) in 0.33 seconds with method rustiq, depth 881, and size 7667.
Transpiled circuit index 30 (flat100-ham) in 0.31 seconds with method rustiq, depth 279, and size 4910.
Transpiled circuit index 31 (uf100-ham) in 0.38 seconds with method rustiq, depth 1138, and size 10607.
Transpiled circuit index 32 (OH) in 0.38 seconds with method rustiq, depth 1148, and size 6512.
Transpiled circuit index 33 (HF) in 0.37 seconds with method rustiq, depth 1090, and size 6256.
Transpiled circuit index 34 (BH) in 0.37 seconds with method rustiq, depth 1148, and size 6501.
```

Talahanayan ng mga resulta (nilaktawan ang visualization dahil ang mga output circuit ay napakalalaki):

```python
summary_ham = (
    results_ham.groupby("method")[["depth", "size", "runtime"]]
    .mean()
    .round(2)
)
print(summary_ham)

results_ham
```

```text
depth     size  runtime
method
ai      316.86  2181.26     5.97
rustiq  281.94  2268.80     3.86
sabre   337.97  2120.14     3.07
```

```text
method        qc_name  qc_index  num_qubits  \
0     sabre     all-vib-o3         0           4
1     sabre    all-vib-c2h         1           4
2     sabre     all-vib-bh         2           2
3     sabre    all-vib-c2h         3           3
4     sabre  graph-gnp_k-2         4           4
..      ...            ...       ...         ...
100  rustiq    flat100-ham        30          90
101  rustiq      uf100-ham        31          46
102  rustiq             OH        32          10
103  rustiq             HF        33          10
104  rustiq             BH        34          10

                                               ops  depth   size   runtime
0                    {'rz': 28, 'sx': 24, 'cz': 6}      6     58  0.016597
1            {'rz': 17, 'sx': 16, 'cz': 4, 'x': 2}      2     39  1.102089
2                    {'sx': 14, 'rz': 13, 'cz': 3}      3     30  0.011042
3           {'sx': 46, 'rz': 45, 'cz': 18, 'x': 6}     18    115  0.025816
4           {'sx': 49, 'rz': 47, 'cz': 24, 'x': 9}     24    129  0.023077
..                                             ...    ...    ...       ...
100    {'sx': 2709, 'cz': 1379, 'rz': 817, 'x': 5}    279   4910  0.309448
101   {'sx': 6180, 'cz': 3120, 'rz': 1303, 'x': 4}   1138  10607  0.380977
102  {'sx': 3330, 'cz': 1704, 'rz': 1455, 'x': 23}   1148   6512  0.383564
103  {'sx': 3213, 'cz': 1620, 'rz': 1406, 'x': 17}   1090   6256  0.368578
104  {'sx': 3331, 'cz': 1704, 'rz': 1447, 'x': 19}   1148   6501  0.374822

[105 rows x 8 columns]
```

I-visualize ang performance batay sa circuit index:

```python
plot_transpilation_metrics(
    results_ham, "Transpilation Metrics for Hamiltonian Circuits"
)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/4c6b810d-a4cf-4de3-aae6-c6c1cdd83d8f-0.avif)

I-visualize ang porsyento ng mga circuit kung saan ang bawat pamamaraan ay pinakamahusay.

```python
def analyze_and_plot_best_methods(results, metric):
    """
    Analyze the best-performing methods for a given metric and plot a pie chart.

    Parameters:
        results (DataFrame): The input DataFrame containing method performance data.
        metric (str): The metric to evaluate ("depth" or "size").
    """
    method_counts = Counter()
    for qc_idx, group in results.groupby("qc_index"):
        min_value = group[metric].min()

        # Find all methods that achieved this minimum value
        best_methods = group[group[metric] == min_value]["method"]
        # Update counts for all best methods (handling ties)
        method_counts.update(best_methods)
    best_method_counts = dict(
        sorted(method_counts.items(), key=lambda x: x[1], reverse=True)
    )

    # Print summary
    print(f"Best-performing methods based on {metric}:")
    for method, count in best_method_counts.items():
        print(f"    {method}: {count} circuit(s)")

    # Plot pie chart
    num_methods = len(best_method_counts)
    colors = plt.cm.viridis_r(range(0, 256, 256 // num_methods))
    plt.figure(figsize=(5, 5))
    plt.pie(
        best_method_counts.values(),
        labels=best_method_counts.keys(),
        autopct="%1.1f%%",
        startangle=140,
        wedgeprops={"edgecolor": "black"},
        textprops={"fontsize": 10},
        colors=colors,
    )
    plt.title(
        f"Percentage of Circuits Method Performed Best for {metric.capitalize()}",
        fontsize=12,
        fontweight="bold",
    )
    plt.show()

analyze_and_plot_best_methods(results_ham, "depth")
analyze_and_plot_best_methods(results_ham, "size")
```

```text
Best-performing methods based on depth:
    ai: 16 circuit(s)
    rustiq: 16 circuit(s)
    sabre: 10 circuit(s)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/01b4644e-ac91-483c-944b-924f8b41718d-1.avif)

```text
Best-performing methods based on size:
    sabre: 18 circuit(s)
    rustiq: 14 circuit(s)
    ai: 10 circuit(s)
```

![Output of the previous code cell](/docs/images/tutorials/compilation-methods-for-hamiltonian-simulation-circuits/extracted-outputs/01b4644e-ac91-483c-944b-924f8b41718d-3.avif)

#### Pagsusuri ng mga resulta ng kompilasyon ng Hamiltonian circuit {#analysis-of-hamiltonian-circuit-compilation-results}

Sa seksyong ito, sinusuri natin ang performance ng tatlong pamamaraan ng transpilation — SABRE, ang AI-powered transpiler, at Rustiq — sa mga quantum circuit na binuo na may `PauliEvolutionGate`, na karaniwang ginagamit sa mga Hamiltonian simulation task.

**Ang Rustiq ay pinakamahusay sa average sa mga tuntunin ng circuit depth**, na nakakamit ng humigit-kumulang 20% na mas mababang depth kaysa sa SABRE. Ito ay inaasahan, dahil ang Rustiq ay partikular na dinisenyo upang i-synthesize ang mga operasyon ng `PauliEvolutionGate` na may mga pinag-optimize, low-depth decomposition strategy. Higit pa rito, ang depth plot ay nagpapakita na habang lumalaki ang mga circuit sa laki at pagiging kumplikado, ang Rustiq ay pinaka-epektibo sa pag-scale, na nagpapanatili ng makabuluhang mas mababang depth kaysa sa AI at SABRE sa mga mas malalaking circuit.

Ang **AI transpiler** ay nagpakita ng malakas at pare-parehong performance para sa circuit depth, na pare-parehong lumalampas sa SABRE sa karamihan ng mga circuit. Gayunpaman, ito ay nagkaroon ng pinakamataas na runtime, lalo na sa mas malalaking circuit, na maaaring limitahan ang praktikal na paggamit nito sa time-sensitive na workload. Ang scalability nito sa runtime ay nananatiling pangunahing limitasyon, kahit nag-aalok ito ng solidong pagpapabuti sa depth.

Ang **SABRE**, habang gumagawa ng pinakamataas na average depth, ay nakakamit ng pinakamababang average gate count, na sinusundan nang malapit ng AI transpiler. Ito ay tumutugma sa disenyo ng heuristic ng SABRE, na umuuna sa pagpapaliit ng gate count nang direkta. Ang Rustiq, sa kabila ng kalakasan nito sa pagpapababa ng depth, ay may pinakamataas na average gate count, na isang kapansin-pansing trade-off na dapat isaalang-alang sa mga aplikasyon kung saan ang laki ng circuit ay mas mahalaga kaysa sa tagal ng circuit.

### Buod {#summary}

Bagama't ang AI transpiler ay karaniwang nagbibigay ng mas mahusay na resulta kaysa sa SABRE, lalo na sa circuit depth, ang aral ay hindi dapat lamang na "laging gamitin ang AI transpiler." Mayroong mga mahalagang nuance na dapat isaalang-alang:

- Ang **AI transpiler** ay karaniwang maaasahan at nagbibigay ng depth-optimized na mga circuit, ngunit ito ay may kaakibat na trade-off sa runtime, at mayroon ding ibang limitasyon, kasama ang mga suportadong coupling map at kakayahan sa synthesis. Ang mga ito ay detalyado sa [dokumentasyon ng Qiskit Transpiler Service](/guides/qiskit-transpiler-service).

- Sa ilang kaso, lalo na sa napakalalaki o hardware-specific na mga circuit, ang AI transpiler ay maaaring hindi kasing-epektibo. Sa mga kasong ito, ang default na SABRE transpiler ay nananatiling lubhang maaasahan at maaaring higit pang i-optimize sa pamamagitan ng pag-adjust ng mga parameter nito (tingnan ang [SABRE optimization tutorial](/tutorials/transpilation-optimizations-with-sabre)).

- Mahalaga ring isaalang-alang ang istruktura ng circuit kapag pumipili ng pamamaraan. Halimbawa, ang `rustiq` ay partikular na ginawa para sa mga circuit na may `PauliEvolutionGate` at madalas na nagbibigay ng pinakamahusay na performance para sa mga problema ng Hamiltonian simulation.

**Rekomendasyon:**
> Walang one-size-fits-all na estratehiya ng transpilation. Hinihikayat ang mga user na maunawaan ang istruktura ng kanilang circuit at subukan ang maraming pamamaraan ng transpilation — kasama ang AI, SABRE, at mga espesyalisadong kasangkapan tulad ng Rustiq — upang mahanap ang pinaka-mahusay na solusyon para sa kanilang partikular na problema at mga limitasyon ng hardware.
### Step 3: I-execute gamit ang Qiskit primitives {#step-3-execute-using-qiskit-primitives}
Dahil ang tutorial na ito ay nakatuon sa transpilation, walang eksperimentong nai-execute sa isang quantum device. Ang layunin ay gamitin ang mga optimization mula sa Step 2 upang makakuha ng transpiled circuit na may nabawasang depth at gate count.
### Step 4: I-post-process at ibalik ang resulta sa ninanais na classical format {#step-4-post-process-and-return-result-in-desired-classical-format}
Dahil walang execution para sa notebook na ito, walang mga resultang i-post-process.
## Mga Sanggunian {#references}

[1] "LightSABRE: A Lightweight and Enhanced SABRE Algorithm". H. Zou, M. Treinish, K. Hartman, A. Ivrii, J. Lishman et al. https://arxiv.org/abs/2409.08368

[2] "Practical and efficient quantum circuit synthesis and transpiling with Reinforcement Learning". D. Kremer, V. Villar, H. Paik, I. Duran, I. Faro, J. Cruz-Benito et al. https://arxiv.org/abs/2405.13196

[3] "Pauli Network Circuit Synthesis with Reinforcement Learning". A. Dubal,  D. Kremer, S. Martiel, V. Villar, D. Wang, J. Cruz-Benito et al. https://arxiv.org/abs/2503.14448

[4] "Faster and shorter synthesis of Hamiltonian simulation circuits". T. Goubault de Brugière, S. Martiel et al. https://arxiv.org/abs/2404.03280
