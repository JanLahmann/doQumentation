---
title: "Hybrid quantum-enhanced ensemble classification (daloy ng grid stability workflow)"
sidebar_label: "Hybrid quantum-enhanced ensemble classification (daloy ng grid stability workflow)"
description: "Bumuo at suriin ang hybrid quantum–classical ensemble para sa klasipikasyon ng katatagan ng grid sa IBM QPU gamit ang Singularity Qiskit Function ng Multiverse Computing."
notebook_path: "docs/tutorials/sml-classification.ipynb"
---

<OpenInLabBanner notebookPath="docs/tutorials/sml-classification.ipynb" />



{/* cspell:ignore QEEC interpretability hyperparameters overfitting sublinear preds prec */}

*Pagtatantya ng paggamit: 20 minuto sa QPU time para sa bawat gawain sa isang Eagle r3 processor. (PAALALA: Ito ay pagtatantya lamang. Maaaring mag-iba ang inyong runtime.)*
## Background {#background}

Ang tutorial na ito ay nagpapakita ng hybrid quantum–classical workflow na nagpapahusay sa isang klasikal na ensemble gamit ang quantum optimization step. Ginagamit ang "Singularity Machine Learning – Classification" ng Multiverse Computing (isang Qiskit Function), magsasanay tayo ng grupo ng konbensyonal na mga learner (halimbawa, decision trees, k-NN, logistic regression) at pagkatapos ay pahusayin ang grupong iyon gamit ang quantum layer upang mapabuti ang diversity at generalization. Ang layunin ay praktikal: sa isang tunay na gawain ng paghula ng katatagan ng grid, ihahambing natin ang malakas na klasikal na baseline sa isang quantum-optimized na alternatibo sa ilalim ng parehong data splits, upang makita ninyo kung saan nakakatulong ang quantum step at ano ang gastos nito.

Bakit ito mahalaga: ang pagpili ng magandang subset mula sa maraming mahinang learner ay isang kombinatoryal na problema na mabilis na lumalaki sa laki ng ensemble. Ang mga klasikal na heuristic tulad ng boosting, bagging, at stacking ay mahusay sa katamtamang sukat ngunit maaaring mahirapan na tuklasin nang epektibo ang malalaking, redundant na mga library ng mga modelo. Ang function ay nagsasama ng mga quantum algorithm - partikular ang QAOA (at opsyonal na VQE sa ibang mga configuration) - upang mas epektibong magsaliksik sa espasyong iyon pagkatapos masanay ang mga klasikal na learner, na nagpapataas ng pagkakataon na makahanap ng compact, diverse na subset na mas mahusay sa generalization.

Mahalagang tandaan, ang sukat ng data ay hindi limitado ng mga qubit. Ang mabigat na gawain sa data — preprocessing, pagsasanay ng learner pool, at evaluation — ay nananatiling klasikal at kayang humawak ng milyun-milyong halimbawa. Ang mga qubit ay tumutukoy lamang ng laki ng ensemble na ginagamit sa quantum selection step. Ang paghihiwalayan na ito ang nagpapahintulot ng approach sa kasalukuyang hardware: pinapanatili ninyo ang pamilyar na scikit-learn workflow para sa data at model training habang tinatawag ang quantum step sa pamamagitan ng malinis na action interface sa Qiskit Functions.

Sa praktis, bagaman maaaring magbigay ng iba't ibang uri ng learner sa ensemble (hal., decision trees, logistic regression, o k-NN), ang Decision Trees ay karaniwang pinakamahusay. Ang optimizer ay patuloy na pumipili ng mas malakas na miyembro ng ensemble—kapag ibinigay ang heterogeneous na mga learner, ang mas mahinang mga modelo tulad ng linear regressors ay karaniwang tinatanggal pabor sa mas expressive na mga ito tulad ng Decision Trees.

Ang inyong gagawin dito: maghanda at balansehin ang grid-stability dataset; magtatag ng klasikal na AdaBoost baseline; magpatakbo ng ilang quantum configuration na nag-iiba ng ensemble width at regularization; magsagawa sa IBM&reg; simulator o QPU sa pamamagitan ng Qiskit Serverless; at ihambing ang accuracy, precision, recall, at F1 sa lahat ng runs. Sa daan, gagamitin ninyo ang action pattern ng function (`create`, `fit`, `predict`, `fit_predict`, `create_fit_predict`) at mga pangunahing control:
- Mga uri ng regularization: `onsite` (λ) para sa direktang sparsity at `alpha` para sa ratio-based trade-off sa pagitan ng interaction at onsite terms
- Auto-regularization: itakda ang `regularization="auto"` na may target selection ratio upang awtomatikong umangkop ang sparsity
- Mga opsyon ng optimizer: simulator kontra QPU, mga pag-uulit, klasikal na optimizer at mga opsyon nito, lalim ng transpilation, at mga setting ng runtime sampler/estimator

Ang mga benchmark sa dokumentasyon ay nagpapakita na ang accuracy ay bumubuti habang tumataas ang bilang ng mga learner (qubit) sa mahihirap na problema, at ang quantum classifier ay tumutugma o lumalampas sa maihahambing na klasikal na ensemble. Sa tutorial na ito, uulitin ninyo ang workflow mula simula hanggang dulo at susuriin kung kailan ang pagtaas ng ensemble width o paglipat sa adaptive regularization ay nagbubunga ng mas magandang F1 sa makatwirang paggamit ng resources. Ang resulta ay isang makatotohanang pananaw kung paano ang quantum optimization step ay maaaring kumplemento, sa halip na palitan, ang klasikal na ensemble learning sa tunay na mga aplikasyon.
## Requirements {#requirements}

Bago magsimula sa tutorial na ito, tiyaking naka-install sa inyong Python environment ang sumusunod na mga package:

- `qiskit[visualization]~=2.1.0`
- `qiskit-serverless~=0.24.0`
- `qiskit-ibm-runtime v0.40.1`
- `qiskit-ibm-catalog~=0.8.0`
- `scikit-learn==1.5.2`
- `pandas>=2.0.0,<3.0.0`
- `imbalanced-learn~=0.12.3`
## Setup {#setup}

Sa seksyong ito, magsisimula tayo ng Qiskit Serverless client at ikakarga ang Singularity Machine Learning – Classification function na ibinigay ng Multiverse Computing.
Sa Qiskit Serverless, maaari ninyong patakbuhin ang hybrid quantum–classical workflow sa IBM managed cloud infrastructure nang hindi nag-aalala sa resource management.
Kakailanganin ninyo ng IBM Quantum Platform API key at inyong cloud resource name (CRN) upang mag-authenticate at ma-access ang Qiskit Functions.
### Download the dataset {#download-the-dataset}

Upang patakbuhin ang tutorial na ito, gagamitin natin ang pre-processed na **grid stability classification dataset** na naglalaman ng mga naka-label na sensor reading ng power system.
Ang sumusunod na cell ay awtomatikong lumilikha ng kinakailangang folder structure at dini-download ang parehong training at test file nang direkta sa inyong environment gamit ang `wget`.
Kung mayroon na kayong mga file na ito locally, ang hakbang na ito ay ligtas na mag-overwrite sa kanila upang matiyak ang version consistency.

```python
# Added by doQumentation — installs packages not in the Binder environment
%pip install -q imbalanced-learn scikit-learn
```

```python
## Download dataset for Grid Stability Classification

# Create data directory if it doesn't exist
!mkdir -p data_tutorial/grid_stability

# Download the training and test sets from the official Qiskit documentation repo
!wget -q --show-progress -O data_tutorial/grid_stability/train.csv \
  https://raw.githubusercontent.com/Qiskit/documentation/main/datasets/tutorials/grid_stability/train.csv

!wget -q --show-progress -O data_tutorial/grid_stability/test.csv \
  https://raw.githubusercontent.com/Qiskit/documentation/main/datasets/tutorials/grid_stability/test.csv

# Check the files have been downloaded
!echo "Dataset files downloaded:"
!ls -lh data_tutorial/grid_stability/*.csv
```

```text
data_tutorial/grid_ 100%[===================>] 612.94K  --.-KB/s    in 0.01s
data_tutorial/grid_ 100%[===================>] 108.19K  --.-KB/s    in 0.006s
Dataset files downloaded:
-rw-r--r-- 1 coder coder 109K Nov  8 18:50 data_tutorial/grid_stability/test.csv
-rw-r--r-- 1 coder coder 613K Nov  8 18:50 data_tutorial/grid_stability/train.csv
```

### Import required packages {#import-required-packages}

Sa seksyong ito, iai-import natin ang lahat ng Python package at Qiskit module na gagamitin sa buong tutorial.
Kasama dito ang mga pangunahing siyentipikong library para sa data handling at model evaluation - tulad ng `NumPy`, `pandas`, at `scikit-learn` - kasama ang mga visualization tool at Qiskit component para sa pagpapatakbo ng quantum-enhanced model.
Iai-import din natin ang `QiskitRuntimeService` at `QiskitFunctionsCatalog` upang kumonekta sa IBM Quantum&reg; services at ma-access ang Singularity Machine Learning function.

```python
from typing import Tuple
import warnings

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from imblearn.over_sampling import RandomOverSampler
from qiskit_ibm_catalog import QiskitFunctionsCatalog
from qiskit_ibm_runtime import QiskitRuntimeService
from sklearn.ensemble import AdaBoostClassifier
from sklearn.metrics import (
    accuracy_score,
    f1_score,
    precision_score,
    recall_score,
)
from sklearn.model_selection import train_test_split

warnings.filterwarnings("ignore")
```

### Set constant variables {#set-constant-variables}

```python
IBM_TOKEN = ""
IBM_INSTANCE_TEST = ""
IBM_INSTANCE_QUANTUM = ""
FUNCTION_NAME = "multiverse/singularity"
RANDOM_STATE: int = 123
TRAIN_PATH = "data_tutorial/grid_stability/train.csv"
TEST_PATH = "data_tutorial/grid_stability/test.csv"
```

### Connect to IBM Quantum and load the Singularity function {#connect-to-ibm-quantum-and-load-the-singularity-function}

Susunod, mag-authenticate tayo sa IBM Quantum services at ika-karga ang Singularity Machine Learning – Classification function mula sa Qiskit Functions Catalog.
Ang `QiskitRuntimeService` ay nagtatatag ng secure na koneksyon sa IBM Quantum Platform gamit ang inyong API token at instance CRN, na nagbibigay ng access sa quantum backend.
Ang `QiskitFunctionsCatalog` ay ginagamit pagkatapos upang kunin ang Singularity function sa pamamagitan ng pangalan (`"multiverse/singularity"`), na nagbibigay-daan sa atin na tawagin ito mamaya para sa hybrid quantum–classical computation.
Kung matagumpay ang setup, makikita ninyo ang mensahe ng kumpirmasyon na nagsasabing ang function ay na-load nang tama.

```python
service = QiskitRuntimeService(
    token=IBM_TOKEN,
    channel="ibm_quantum_platform",
    instance=IBM_INSTANCE_QUANTUM,
)

backend = service.least_busy()
catalog = QiskitFunctionsCatalog(
    token=IBM_TOKEN,
    instance=IBM_INSTANCE_TEST,
    channel="ibm_quantum_platform",
)
singularity = catalog.load(FUNCTION_NAME)
print(
    "Successfully connected to IBM Qiskit Serverless and loaded the Singularity function."
)
print("Catalog:", catalog)
print("Singularity function:", singularity)
```

```text
Successfully connected to IBM Qiskit Serverless and loaded the Singularity function.
Catalog: <QiskitFunctionsCatalog>
Singularity function: QiskitFunction(multiverse/singularity)
```

### Define helper functions {#define-helper-functions}

Bago patakbuhin ang mga pangunahing eksperimento, magtutukoy tayo ng ilang maliliit na utility function na nagpapasimple ng data loading at model evaluation.
- Ang `load_data()` ay nagbabasa ng mga input CSV file sa NumPy array, na naghihiwalay ng mga feature at label para sa compatibility sa `scikit-learn` at quantum workflow.
- Ang `evaluate_predictions()` ay kinukumputa ang mga pangunahing performance metric - accuracy, precision, recall, at F1-score - at opsyonal na nag-uulat ng runtime kung ibinigay ang timing information.

Ang mga helper function na ito ay nagpapasimple ng paulit-ulit na operasyon mamaya sa notebook at nagsisiguro ng pare-parehong metric reporting sa parehong klasikal at quantum classifier.

```python
def load_data(data_path: str) -> Tuple[np.ndarray, np.ndarray]:
    """Load data from the given path to X and y arrays."""
    df: pd.DataFrame = pd.read_csv(data_path)
    return df.iloc[:, :-1].values, df.iloc[:, -1].values

def evaluate_predictions(predictions, y_true):
    """Compute and print accuracy, precision, recall, and F1 score."""
    accuracy = accuracy_score(y_true, predictions)
    precision = precision_score(y_true, predictions)
    recall = recall_score(y_true, predictions)
    f1 = f1_score(y_true, predictions)
    print("Accuracy:", accuracy)
    print("Precision:", precision)
    print("Recall:", recall)
    print("F1:", f1)
    return accuracy, precision, recall, f1
```

## Step 1: Map classical inputs to a quantum problem {#step-1-map-classical-inputs-to-a-quantum-problem}

Magsisimula tayo sa pamamagitan ng paghahanda ng dataset para sa hybrid quantum–classical experimentation. Ang layunin ng hakbang na ito ay i-convert ang raw grid-stability data sa balanced training, validation, at test split na maaaring gamitin nang pare-pareho ng parehong klasikal at quantum workflow. Ang pagpapanatili ng magkaparehong split ay nagsisiguro na ang mga paghahambing ng performance sa susunod ay patas at maiuulit.
### Data loading and preprocessing {#data-loading-and-preprocessing}

Una, ika-karga natin ang training at test CSV file, lumikha ng validation split, at balansehin ang dataset gamit ang random over-sampling. Ang pagbabalanse ay pumipigil sa bias tungo sa majority class at nagbibigay ng mas matatag na learning signal para sa parehong klasikal at quantum ensemble model.

```python
# Load and upload the data
X_train, y_train = load_data(TRAIN_PATH)
X_test, y_test = load_data(TEST_PATH)
X_train, X_val, y_train, y_val = train_test_split(
    X_train, y_train, test_size=0.2, random_state=RANDOM_STATE
)

# Balance the dataset through over-sampling of the positive class
ros = RandomOverSampler(random_state=RANDOM_STATE)
X_train_bal, y_train_bal = ros.fit_resample(X_train, y_train)

print("Shapes:")
print("  X_train_bal:", X_train_bal.shape)
print("  y_train_bal:", y_train_bal.shape)
print("  X_val:", X_val.shape)
print("  y_val:", y_val.shape)
print("  X_test:", X_test.shape)
print("  y_test:", y_test.shape)
```

```text
Shapes:
  X_train_bal: (5104, 12)
  y_train_bal: (5104,)
  X_val: (850, 12)
  y_val: (850,)
  X_test: (750, 12)
  y_test: (750,)
```

### Classical baseline: AdaBoost reference {#classical-baseline-adaboost-reference}

Bago magpatakbo ng anumang quantum optimization, magsasanay tayo ng malakas na klasikal na baseline - isang karaniwang AdaBoost classifier - sa parehong balanced data. Nagbibigay ito ng maiuulit na reference point para sa paghahambing sa susunod, na tumutulong na sukatin kung ang quantum optimization ay nagpapabuti ng generalization o kahusayan lampas sa mahusay na na-tune na klasikal na ensemble.

```python
# ----- Classical baseline: AdaBoost -----
baseline = AdaBoostClassifier(n_estimators=60, random_state=RANDOM_STATE)
baseline.fit(X_train_bal, y_train_bal)
baseline_pred = baseline.predict(X_test)
print("Classical AdaBoost baseline:")
_ = evaluate_predictions(baseline_pred, y_test)
```

```text
Classical AdaBoost baseline:
Accuracy: 0.7893333333333333
Precision: 1.0
Recall: 0.7893333333333333
F1: 0.8822652757078987
```

## Step 2: Optimize problem for quantum hardware execution {#step-2-optimize-problem-for-quantum-hardware-execution}

Ang gawain ng ensemble selection ay ginagawang kombinatoryal na optimization problem kung saan ang bawat mahinang learner ay isang binary decision variable, at ang layunin ay nagbabalanse ng accuracy sa sparsity sa pamamagitan ng regularization term. Ang `QuantumEnhancedEnsembleClassifier` ay nalulutas ito gamit ang QAOA sa IBM hardware, habang pinapayagan pa rin ang simulator-based exploration. Ang `optimizer_options` ay kumokontrol sa hybrid loop: ang `simulator=False` ay nagdidirekta ng mga circuit sa napiling QPU, ang `num_solutions` ay nagpapataas ng search breadth, at ang `classical_optimizer_options` (para sa panloob na klasikal na optimizer) ay namamahala sa convergence; ang mga value na malapit sa 60 iteration ay magandang balanse para sa kalidad at runtime. Ang mga runtime option - tulad ng katamtamang circuit depth (`reps`) at karaniwang transpilation effort - ay tumutulong na masiguro ang matatag na performance sa iba't ibang device. Ang configuration sa ibaba ay ang "best-results" profile na gagamitin natin para sa hardware run; maaari din kayong lumikha ng purong simulated variant sa pamamagitan ng pagpalit sa `simulator=True` upang mag-dry-run ng workflow nang hindi gumagamit ng QPU time.

```python
# QAOA / runtime configuration for best results on hardware
optimizer_options = {
    "simulator": False,  # set True to test locally without QPU
    "num_solutions": 100_000,  # broaden search over candidate ensembles
    "reps": 3,  # QAOA depth (circuit layers)
    "optimization_level": 3,  # transpilation effort
    "num_transpiler_runs": 30,  # explore multiple layouts
    "classical_optimizer": "COBYLA",  # robust default for this landscape
    "classical_optimizer_options": {
        "maxiter": 60  # practical convergence budget
    },
    # You can pass backend-specific options; leaving None uses least-busy routing
    "estimator_options": None,
    "sampler_options": None,
}

print("Configured hardware optimization profile:")
for key, value in optimizer_options.items():
    print(f"  {key}: {value}")
```

```text
Configured hardware optimization profile:
  simulator: False
  num_solutions: 100000
  reps: 3
  optimization_level: 3
  num_transpiler_runs: 30
  classical_optimizer: COBYLA
  classical_optimizer_options: {'maxiter': 60}
  estimator_options: None
  sampler_options: None
```

## Step 3: Execute using Qiskit primitives {#step-3-execute-using-qiskit-primitives}

Ngayon ay isasagawa natin ang buong workflow gamit ang `create_fit_predict` action ng Singularity function upang magsanay, mag-optimize, at suriin ang `QuantumEnhancedEnsembleClassifier` mula simula hanggang dulo sa IBM infrastructure. Ang function ay bumubuo ng ensemble, naglalapat ng quantum optimization sa pamamagitan ng Qiskit primitive, at nagbabalik ng parehong mga prediction at job metadata (kasama ang runtime at resource usage). Ang klasikal na data split mula sa Step 1 ay muling ginagamit para sa reproducibility, na may validation data na ipinasa sa pamamagitan ng `fit_params` upang ang optimization ay makapag-tune ng mga hyperparameter sa loob habang pinapanatiling hindi nagagalaw ang held-out test set.

Sa hakbang na ito, tutuklasin natin ang ilang configuration ng quantum ensemble upang maunawaan kung paano ang mga pangunahing parameter - partikular na `num_learners` at `regularization` - ay nakakaapekto sa parehong kalidad ng resulta at paggamit ng QPU.
- Ang `num_learners` ay tumutukoy ng ensemble width (at implicitly, ang bilang ng mga qubit), na nakakaimpluwensya sa kapasidad ng modelo at computational cost.
- Ang `regularization` ay kumokontrol ng sparsity at overfitting, na humuhubog kung gaano karaming learner ang nananatiling aktibo pagkatapos ng optimization.

Sa pamamagitan ng pag-iba-iba ng mga parameter na ito, makikita natin kung paano nakikipag-ugnayan ang ensemble width at regularization: ang pagtaas ng width ay karaniwang nagpapabuti ng F1 ngunit mas mahal sa QPU time, habang ang mas malakas o adaptive regularization ay maaaring magpabuti ng generalization sa halos parehong hardware footprint. Ang susunod na mga subsection ay dumadaan sa tatlong representative configuration upang ipakita ang mga epektong ito.
### Baseline {#baseline}

Ang configuration na ito ay gumagamit ng `num_learners = 10` at `regularization = 7`.

- Ang `num_learners` ay kumokontrol ng ensemble width — epektibo ang bilang ng mga mahinang learner na pinagsama at, sa quantum hardware, ang **bilang ng mga qubit na kailangan**. Ang mas malaking value ay nagpapalawig ng combinatorial search space at maaaring magpabuti ng accuracy at recall, ngunit nagpapataas din ng circuit width, compilation time, at pangkalahatang paggamit ng QPU.
- Ang `regularization` ay nagtatakda ng penalty strength para sa pagsasama ng karagdagang mga learner. Sa default na "onsite" regularization, ang mas mataas na value ay nagpapatibay ng mas malakas na sparsity (mas kaunting learner na pinapanatili), habang ang mas mababang value ay nagpapahintulot ng mas kumplikadong ensemble.

Ang setup na ito ay nagbibigay ng low-cost baseline, na nagpapakita kung paano kumikilos ang isang maliit na ensemble bago palawakin ang width o mag-tune ng sparsity.

```python
# Problem scale and regularization
NUM_LEARNERS = 10
REGULARIZATION = 7
```

```python
# ----- Quantum-enhanced ensemble on IBM hardware -----
print("\n-- Submitting quantum-enhanced ensemble job --")
job_1 = singularity.run(
    action="create_fit_predict",
    name="grid_stability_qeec",
    quantum_classifier="QuantumEnhancedEnsembleClassifier",
    num_learners=NUM_LEARNERS,
    regularization=REGULARIZATION,
    optimizer_options=optimizer_options,  # from Step 2
    backend_name=backend,  # least-busy compatible backend
    instance=IBM_INSTANCE_QUANTUM,
    random_state=RANDOM_STATE,
    X_train=X_train_bal,
    y_train=y_train_bal,
    X_test=X_test,
    fit_params={"validation_data": (X_val, y_val)},
    options={"save": False},
)
result_1 = job_1.result()
print("Action status:", result_1.get("status"))
print("Action message:", result_1.get("message"))
print("Metadata:", result_1.get("metadata"))
qeec_pred_job_1 = np.array(result_1["data"]["predictions"])
_ = evaluate_predictions(qeec_pred_job_1, y_test)
```

```text
-- Submitting quantum-enhanced ensemble job --
Action status: ok
Action message: Classifier created, fitted, and predicted.
Metadata: {'resource_usage': {'RUNNING: MAPPING': {'CPU_TIME': 267.05158376693726}, 'RUNNING: WAITING_QPU': {'CPU_TIME': 3336.8785166740417}, 'RUNNING: POST_PROCESSING': {'CPU_TIME': 152.4274561405182}, 'RUNNING: EXECUTING_QPU': {'QPU_TIME': 1550.1889700889587}}}
Accuracy: 0.868
Precision: 1.0
Recall: 0.868
F1: 0.9293361884368309
```

```python
status_1 = job_1.status()
print("\nQuantum job status:", status_1)
```

```text
Quantum job status: DONE
```

### Increase the number of learners {#increase-the-number-of-learners}

Dito ay dinadagdagan natin ang `num_learners` mula 10 → 30 habang pinapanatili ang `regularization = 7`.

- Ang mas maraming learner ay nagpapalawig ng hypothesis space, na nagpapahintulot sa modelo na makuha ang mas banayad na pattern, na maaaring bahagyang magtaas ng F1.
- Sa karamihan ng mga kaso, ang pagkakaiba ng runtime sa pagitan ng 10 at 30 learner ay hindi gaanong malaki, na nagsasaad na ang karagdagang circuit width ay hindi lubhang nagpapataas ng execution cost.
- Ang pagpapabuti ng kalidad ay sumusunod pa rin sa *diminishing-returns curve*: ang mga unang pakinabang ay lumalabas habang lumalaki ang ensemble, ngunit nag-plateau ang mga ito habang ang karagdagang mga learner ay nag-aambag ng mas kaunting bagong impormasyon.

Ang eksperimentong ito ay nag-highlight ng quality–efficiency trade-off — ang pagtaas ng ensemble width ay maaaring mag-alok ng maliliit na accuracy gain nang walang malaking runtime penalty, depende sa backend at transpilation condition.

```python
# Problem scale and regularization
NUM_LEARNERS = 30
REGULARIZATION = 7
```

```python
# ----- Quantum-enhanced ensemble on IBM hardware -----
print("\n-- Submitting quantum-enhanced ensemble job --")
job_2 = singularity.run(
    action="create_fit_predict",
    name="grid_stability_qeec",
    quantum_classifier="QuantumEnhancedEnsembleClassifier",
    num_learners=NUM_LEARNERS,
    regularization=REGULARIZATION,
    optimizer_options=optimizer_options,  # from Step 2
    backend_name=backend,  # least-busy compatible backend
    instance=IBM_INSTANCE_QUANTUM,
    random_state=RANDOM_STATE,
    X_train=X_train_bal,
    y_train=y_train_bal,
    X_test=X_test,
    fit_params={"validation_data": (X_val, y_val)},
    options={"save": False},
)
result_2 = job_2.result()
print("Action status:", result_2.get("status"))
print("Action message:", result_2.get("message"))
print("QPU Time:", result_2.get("metadata"))
qeec_pred_job_2 = np.array(result_2["data"]["predictions"])
_ = evaluate_predictions(qeec_pred_job_2, y_test)
```

```text
-- Submitting quantum-enhanced ensemble job --
Action status: ok
Action message: Classifier created, fitted, and predicted.
QPU Time: {'resource_usage': {'RUNNING: MAPPING': {'CPU_TIME': 680.2116754055023}, 'RUNNING: WAITING_QPU': {'CPU_TIME': 80.80395102500916}, 'RUNNING: POST_PROCESSING': {'CPU_TIME': 154.4466371536255}, 'RUNNING: EXECUTING_QPU': {'QPU_TIME': 1095.822762966156}}}
Accuracy: 0.8946666666666667
Precision: 1.0
Recall: 0.8946666666666667
F1: 0.944405348346235
```

```python
status_2 = job_2.status()
print("\nQuantum job status:", status_2)
```

```text
Quantum job status: DONE
```

### Regularization {#regularization}

Sa configuration na ito, dinadagdagan natin sa `num_learners = 60` at nagpapakilala ng adaptive regularization upang mas intuitive na pamahalaan ang sparsity.

- Sa `regularization = "auto"`, ang optimizer ay awtomatikong nakakakita ng angkop na regularization strength na pumipili ng humigit-kumulang `regularization_ratio * num_learners` na mahinang learner para sa huling ensemble, sa halip na manually na pag-fix ng penalty. Nagbibigay ito ng mas maginhawang interface para sa pamamahala ng balanse sa pagitan ng sparsity at laki ng ensemble.
- Ang `regularization_type = "alpha"` ay tumutukoy kung paano inilalapat ang penalty. Hindi katulad ng `onsite`, na walang hangganan `[0, ∞]`, ang `alpha` ay may hangganan sa pagitan ng `[0, 1]`, na ginagawang mas madaling i-tune at maintindihan. Ang parameter ay kumokontrol ng trade-off sa pagitan ng indibidwal at pairwise penalty, na nag-aalok ng mas maayos na configuration range.
- Ang `regularization_desired_ratio ≈ 0.82` ay tumutukoy ng target proportion ng mga learner na panatilihing aktibo pagkatapos ng regularization — dito, humigit-kumulang 82% ng mga learner ay napapanatili, na awtomatikong tinatanggal ang pinakamahina na 18%.

Bagaman ang adaptive regularization ay nagpapasimple ng configuration at tumutulong na mapanatili ang balanseng ensemble, hindi ito kinakailangang gumagarantiya ng mas maganda o mas matatag na performance. Ang aktwal na kalidad ay nakadepende sa pagpili ng angkop na regularization parameter, at ang fine-tuning nito sa pamamagitan ng cross-validation ay maaaring magastos sa computational. Ang pangunahing bentahe ay nakasalalay sa pinabuting usability at interpretability sa halip na direktang accuracy gain.

```python
# Problem scale and regularization
NUM_LEARNERS = 60
REGULARIZATION = "auto"
REGULARIZATION_TYPE = "alpha"
REGULARIZATION_RATIO = 0.82
```

```python
# ----- Quantum-enhanced ensemble on IBM hardware -----
print("\n-- Submitting quantum-enhanced ensemble job --")
job_3 = singularity.run(
    action="create_fit_predict",
    name="grid_stability_qeec",
    quantum_classifier="QuantumEnhancedEnsembleClassifier",
    num_learners=NUM_LEARNERS,
    regularization=REGULARIZATION,
    regularization_type=REGULARIZATION_TYPE,
    regularization_desired_ratio=REGULARIZATION_RATIO,
    optimizer_options=optimizer_options,  # from Step 2
    backend_name=backend,  # least-busy compatible backend
    instance=IBM_INSTANCE_QUANTUM,
    random_state=RANDOM_STATE,
    X_train=X_train_bal,
    y_train=y_train_bal,
    X_test=X_test,
    fit_params={"validation_data": (X_val, y_val)},
    options={"save": False},
)
result_3 = job_3.result()
print("Action status:", result_3.get("status"))
print("Action message:", result_3.get("message"))
print("Metadata:", result_3.get("metadata"))
qeec_pred_job_3 = np.array(result_3["data"]["predictions"])
_ = evaluate_predictions(qeec_pred_job_3, y_test)
```

```text
-- Submitting quantum-enhanced ensemble job --
Action status: ok
Action message: Classifier created, fitted, and predicted.
Metadata: {'resource_usage': {'RUNNING: MAPPING': {'CPU_TIME': 1387.7451872825623}, 'RUNNING: WAITING_QPU': {'CPU_TIME': 95.41597843170166}, 'RUNNING: POST_PROCESSING': {'CPU_TIME': 171.78878355026245}, 'RUNNING: EXECUTING_QPU': {'QPU_TIME': 1146.5584812164307}}}
Accuracy: 0.908
Precision: 1.0
Recall: 0.908
F1: 0.9517819706498952
```

```python
status_3 = job_3.status()
print("\nQuantum job status:", status_3)
```

```text
Quantum job status: DONE
```

## Step 4: Post-process and return result in desired classical format {#step-4-post-process-and-return-result-in-desired-classical-format}

Ngayon ay i-post-process natin ang mga output mula sa parehong klasikal at quantum run, na kino-convert ang mga ito sa pare-parehong format para sa downstream evaluation. Ang hakbang na ito ay naghahambing ng predictive quality gamit ang karaniwang mga metric - accuracy, precision, recall, at F1 - at sinusuri kung paano ang ensemble width (`num_learners`) at sparsity control (`regularization`) ay nakakaimpluwensya sa parehong performance at computational behavior.

Ang klasikal na AdaBoost baseline ay nagbibigay ng compact at matatag na reference para sa small-scale learning. Mahusay ito sa limitadong ensemble at negligible compute overhead, na sumasalamin sa lakas ng tradisyonal na boosting kapag ang hypothesis space ay tractable pa rin. Ang mga quantum configuration (`qeec_pred_job_1`, `qeec_pred_job_2`, at `qeec_pred_job_3`) ay pinalawig ang baseline na ito sa pamamagitan ng pag-embed ng ensemble-selection process sa loob ng variational quantum optimization loop. Binibigyang-daan nito ang system na tuklasin ang eksponensiyal na malalaking subset ng mga learner nang sabay-sabay sa superposition, na tumutugon sa kombinatoryal na katangian ng ensemble selection nang mas epektibo habang tumataas ang sukat.

Ang mga resulta ay nagpapakita na ang pagtaas ng `num_learners` mula 10 hanggang 30 ay nagpapabuti ng recall at F1, na nagkukumpirma na ang mas malawak na ensemble ay kumukuha ng mas mayamang interaction sa mga mahinang learner. Ang pakinabang ay sublinear sa kasalukuyang hardware - ang bawat karagdagang learner ay nagbubunga ng mas maliit na accuracy increment - ngunit ang pinagbabatayan ng scaling behavior ay nananatiling pabor dahil ang quantum optimizer ay maaaring magsaliksik ng mas malawak na configuration space nang walang eksponensiyal na pagsabog na tipikal sa klasikal na subset selection. Ang regularization ay nagpapakilala ng karagdagang nuance: ang fixed na λ=7 ay nagpapatibay ng pare-parehong sparsity at nag-stabilize ng convergence, samantalang ang adaptive na α-regularization ay awtomatikong nag-tune ng sparsity batay sa correlation sa pagitan ng mga learner. Ang dynamic pruning na ito ay madalas na nakakamit ng bahagyang mas mataas na F1 para sa parehong qubit width, na binabalanse ang model complexity at generalization.

Kapag direktang inihambing sa AdaBoost baseline, ang pinakamaliit na quantum configuration (L=10) ay muling gumagawa ng katulad na accuracy, na nagpapatunay sa katumpakan ng hybrid pipeline. Sa mas malalaking width, ang mga quantum variant - lalo na sa auto-regularization - ay nagsisimulang lampasan ang klasikal na baseline nang bahagya, na nagpapakita ng pinabuting recall at F1 nang walang linear growth sa computational cost. Ang mga pagpapabuting ito ay hindi nagsasaad ng agarang "quantum advantage" kundi **scaling efficiency**: ang quantum optimizer ay nagpapanatili ng tractable performance habang lumalawak ang ensemble, kung saan ang klasikal na approach ay haharapin ang eksponensiyal na paglaki sa subset-selection complexity.

Sa praktis:
- Gamitin ang **klasikal na baseline** para sa mabilis na validation at benchmarking sa maliliit na dataset.
- Ilapat ang **quantum ensemble** kapag lumalaki ang model width o feature complexity—ang QAOA-based search ay mas graceful na nag-scale sa mga regimen na iyon.
- Gamitin ang **adaptive α-regularization** upang mapanatili ang sparsity at generalization nang hindi dinaragdagan ang circuit width.
- Subaybayan ang QPU time at depth upang balansehin ang quality gain laban sa near-term hardware constraint.

Sama-sama, ang mga eksperimentong ito ay nagpapakita na ang quantum-optimized ensemble ay kumukumplemento sa mga klasikal na pamamaraan: muling ginagawa nila ang baseline accuracy sa maliliit na sukat habang nag-aalok ng landas sa epektibong scaling sa mas malalaki, kombinatoryal na learning problem. Habang bumubuti ang hardware, ang mga scaling advantage na ito ay inaasahang mag-compound, na nagpapalawig ng feasible na laki at lalim ng ensemble-based model lampas sa klasikal na praktikal.
### Evaluate metrics for each configuration {#evaluate-metrics-for-each-configuration}

Ngayon ay susuriing lahat ang mga configuration - ang klasikal na AdaBoost baseline at ang tatlong quantum ensemble - gamit ang `evaluate_predictions` helper upang makompute ang accuracy, precision, recall, at F1 sa parehong test set. Ang paghahambing na ito ay naglilinaw kung paano ang quantum optimization ay nag-scale kumpara sa klasikal na approach: sa maliliit na width, pareho silang gumaganap ng katulad; habang lumalaki ang mga ensemble, ang quantum method ay maaaring mas epektibong tuklasin ang mas malalaking hypothesis space. Ang resultang talahanayan ay kumukuha ng mga trend na ito sa pare-pareho, quantitative na anyo.

```python
results = []

# Classical baseline
acc_b, prec_b, rec_b, f1_b = evaluate_predictions(baseline_pred, y_test)
results.append(
    {
        "Config": "AdaBoost (Classical)",
        "Accuracy": acc_b,
        "Precision": prec_b,
        "Recall": rec_b,
        "F1": f1_b,
    }
)

# Quantum runs
for label, preds in [
    ("QEEC L=10, reg=7", qeec_pred_job_1),
    ("QEEC L=30, reg=7", qeec_pred_job_2),
    (f"QEEC L=60, reg=auto (α={REGULARIZATION_RATIO})", qeec_pred_job_3),
]:
    acc, prec, rec, f1 = evaluate_predictions(preds, y_test)
    results.append(
        {
            "Config": label,
            "Accuracy": acc,
            "Precision": prec,
            "Recall": rec,
            "F1": f1,
        }
    )

df_results = pd.DataFrame(results)
df_results
```

```text
Accuracy: 0.7893333333333333
Precision: 1.0
Recall: 0.7893333333333333
F1: 0.8822652757078987
Accuracy: 0.868
Precision: 1.0
Recall: 0.868
F1: 0.9293361884368309
Accuracy: 0.8946666666666667
Precision: 1.0
Recall: 0.8946666666666667
F1: 0.944405348346235
Accuracy: 0.908
Precision: 1.0
Recall: 0.908
F1: 0.9517819706498952
```

```text
Config  Accuracy  Precision    Recall        F1
0          AdaBoost (Classical)  0.789333        1.0  0.789333  0.882265
1              QEEC L=10, reg=7  0.868000        1.0  0.868000  0.929336
2              QEEC L=30, reg=7  0.894667        1.0  0.894667  0.944405
3  QEEC L=60, reg=auto (α=0.82)  0.908000        1.0  0.908000  0.951782
```

### Visualize quality trends across configurations {#visualize-quality-trends-across-configurations}

Ang grouped bar chart sa ibaba ay naghahambing ng **Accuracy** at **F1** sa klasikal na baseline at mga quantum ensemble (`L=10`, `L=30`, at `L=60 auto-α`). Ipinapakita nito kung paano nag-stabilize ang accuracy habang unti-unting bumubuti ang F1 habang tumataas ang quantum ensemble width, na nagpapakita na ang hybrid method ay nagpapanatili ng performance scaling nang walang eksponensiyal na cost growth na tipikal sa klasikal na subset selection.

```python
x = np.arange(len(df_results))
width = 0.35
plt.figure(figsize=(7.6, 4.6))
plt.bar(x - width / 2, df_results["Accuracy"], width=width, label="Accuracy")
plt.bar(x + width / 2, df_results["F1"], width=width, label="F1")
plt.xticks(x, df_results["Config"], rotation=10)
plt.ylabel("Score")
plt.title("Classical vs Quantum ensemble performance")
plt.legend()
plt.ylim(0, 1.0)
plt.tight_layout()
plt.show()
```

![Output of the previous code cell](/docs/images/tutorials/sml-classification/extracted-outputs/0f15c5fb-2450-4671-9bc2-471043414df2-0.avif)

### Interpretation {#interpretation}

Ang plot ay nagkukumpirma ng inaasahang scaling pattern. Ang klasikal na AdaBoost ay mahusay sa mas maliliit na ensemble ngunit nagiging lalong mahal na i-scale habang lumalaki ang bilang ng mga mahinang learner, dahil ang subset-selection problem nito ay lumalaki nang kombinatoryal. Ang mga quantum-enhanced model ay muling ginagawa ang klasikal na accuracy sa mababang width at nagsisimulang lampasan ito habang tumataas ang laki ng ensemble, lalo na sa ilalim ng adaptive α-regularization. Sumasalamin ito sa kakayahan ng quantum optimizer na mag-sample at magsuri ng maraming kandidatong subset nang parallel sa pamamagitan ng superposition, na nagpapanatili ng tractable search kahit sa mas mataas na width. Bagaman ang kasalukuyang hardware overhead ay nag-offset ng ilan sa teoretikal na pakinabang, ang trend ay nag-illustrate ng scaling efficiency advantage ng quantum formulation. Sa praktikal na mga termino, ang klasikal na pamamaraan ay nananatiling mas kanais-nais para sa magaan na benchmark, habang ang quantum-enhanced ensemble ay nagiging kapaki-pakinabang habang lumalaki ang model dimensionality at laki ng ensemble, na nag-aalok ng mas magandang trade-off sa pagitan ng accuracy, generalization, at computational growth.
## Appendix: Scaling benefits and enhancements {#appendix-scaling-benefits-and-enhancements}

Ang scalability advantage ng `QuantumEnhancedEnsembleClassifier` ay nagmumula sa kung paano ang ensemble-selection process ay nag-map sa quantum optimization.
Ang mga klasikal na ensemble learning method, tulad ng AdaBoost o random forest, ay nagiging mahal sa computational habang tumataas ang bilang ng mga mahinang learner dahil ang pagpili ng optimal subset ay isang kombinatoryal na problema na nag-scale nang eksponensiyal.

Sa kabaligtaran, ang quantum formulation — na ipinatupad dito sa pamamagitan ng Quantum Approximate Optimization Algorithm (QAOA) — ay maaaring mas epektibong tuklasin ang mga eksponensiyal na malaking search space sa pamamagitan ng pagsusuri ng maraming configuration sa superposition.
Bilang resulta, ang training time ay hindi lubhang lumalaki sa bilang ng mga learner, na nagpapahintulot sa modelo na manatiling epektibo kahit habang tumataas ang ensemble width.

Bagaman ang kasalukuyang hardware ay nagpapakilala ng ilang ingay at limitasyon sa lalim, ang workflow na ito ay nagpapakita ng near-term hybrid approach kung saan nakikipagtulungan ang klasikal at quantum component: ang quantum optimizer ay nagbibigay ng mas magandang initialization landscape para sa klasikal na loop, na nagpapabuti ng convergence at huling kalidad ng modelo.
Habang umuunlad ang mga quantum processor, ang mga scalability benefit na ito ay inaasahang lalawak sa mas malalaking dataset, mas malawak na ensemble, at mas malalim na circuit depth.
## References {#references}

1. [Introduction to Qiskit Functions](/guides/functions)
2. [Multiverse Computing Singularity Machine Learning](/guides/multiverse-computing-singularity)
## Tutorial survey {#tutorial-survey}

Mangyaring maglaan po ng isang minuto upang magbigay ng feedback sa tutorial na ito. Ang inyong mga insight ay makakatulong sa amin na mapabuti ang aming mga alok na nilalaman at karanasan ng user.

[Link to survey](https://your.feedback.ibm.com/jfe/form/SV_3BLFkNVEuh0QBWm)
