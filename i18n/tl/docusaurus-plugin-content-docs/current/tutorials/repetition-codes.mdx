---
title: "Repetition codes"
sidebar_label: "Repetition codes"
description: "Ipinapakita ng tutorial na ito kung paano bumuo ng mga pangunahing repetition code gamit ang IBM dynamic circuits, isang halimbawa ng pangunahing quantum error correction (QEC)."
notebook_path: "docs/tutorials/repetition-codes.ipynb"
---

<OpenInLabBanner notebookPath="docs/tutorials/repetition-codes.ipynb" />



*Tinatayang paggamit: mas mababa sa 1 minuto sa isang Heron processor (TANDAAN: Ito ay isang tantiya lamang. Maaaring mag-iba ang inyong runtime.)*

## Background {#background}

Upang makapaggamit ng real-time quantum error correction (QEC), kailangan ninyong magkaroon ng kakayahang dinamikong kontrolin ang quantum program flow sa panahon ng execution upang ang mga quantum gate ay maaaring kondisyunin batay sa mga resulta ng pagsukat. Ang tutorial na ito ay nagpapatakbo ng bit-flip code, na isang napakasimpleng anyo ng QEC. Ipinapakita nito ang isang dynamic quantum circuit na makakaprotekta sa isang encoded qubit mula sa isang bit-flip error, at pagkatapos ay sinusuri ang pagganap ng bit-flip code.

Maaari ninyong samantalahin ang mga karagdagang ancilla qubit at entanglement upang sukatin ang mga *stabilizer* na hindi nagbabago ng encoded quantum information, habang nagbibigay pa rin sa inyo ng impormasyon tungkol sa ilang uri ng mga error na maaaring naganap. Ang isang quantum stabilizer code ay nag-encode ng $k$ logical qubit sa $n$ physical qubit. Ang mga stabilizer code ay nakatuon sa pagwawasto ng isang discrete error set na may suporta mula sa Pauli group $\Pi^n$.

Para sa karagdagang impormasyon tungkol sa QEC, mangyaring tingnan ang [Quantum Error Correction for Beginners.](https://arxiv.org/abs/0905.2794)
## Requirements {#requirements}

Bago magsimula sa tutorial na ito, siguraduhing mayroon kayong mga sumusunod na naka-install:

- Qiskit SDK v2.0 o mas bago, na may suportang [visualization](https://docs.quantum.ibm.com/api/qiskit/visualization)
- Qiskit Runtime v0.40 o mas bago (`pip install qiskit-ibm-runtime`)
## Setup {#setup}

```python
# Qiskit imports
from qiskit import (
    QuantumCircuit,
    QuantumRegister,
    ClassicalRegister,
)

# Qiskit Runtime
from qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler

from qiskit_ibm_runtime.circuit import MidCircuitMeasure

service = QiskitRuntimeService()
```

## Step 1. Map classical inputs to a quantum problem {#step-1-map-classical-inputs-to-a-quantum-problem}
### Build a bit-flip stabilizer circuit {#build-a-bit-flip-stabilizer-circuit}

Ang bit-flip code ay isa sa pinakasimpleng mga halimbawa ng stabilizer code. Pinoprotektahan nito ang estado laban sa isang bit-flip (X) error sa alinman sa mga encoding qubit. Isaalang-alang ang aksyon ng bit-flip error $X$, na nagmamapa ng $|0\rangle \rightarrow |1\rangle$ at $|1\rangle \rightarrow |0\rangle$ sa alinman sa ating mga qubit, kung gayon mayroon tayong $\epsilon = \{E_0, E_1, E_2 \} = \{IIX, IXI, XII\}$. Ang code ay nangangailangan ng limang qubit: tatlo ang ginagamit upang i-encode ang protektadong estado, at ang natitirang dalawa ay ginagamit bilang mga stabilizer measurement ancilla.

```python
# Choose the least busy backend that supports `measure_2`.

backend = service.least_busy(
    filters=lambda b: "measure_2" in b.supported_instructions,
    operational=True,
    simulator=False,
    dynamic_circuits=True,
)
```

```python
qreg_data = QuantumRegister(3)
qreg_measure = QuantumRegister(2)
creg_data = ClassicalRegister(3, name="data")
creg_syndrome = ClassicalRegister(2, name="syndrome")
state_data = qreg_data[0]
ancillas_data = qreg_data[1:]

def build_qc():
    """Build a typical error correction circuit"""
    return QuantumCircuit(qreg_data, qreg_measure, creg_data, creg_syndrome)

def initialize_qubits(circuit: QuantumCircuit):
    """Initialize qubit to |1>"""
    circuit.x(qreg_data[0])
    circuit.barrier(qreg_data)
    return circuit

def encode_bit_flip(circuit, state, ancillas) -> QuantumCircuit:
    """Encode bit-flip. This is done by simply adding a cx"""
    for ancilla in ancillas:
        circuit.cx(state, ancilla)
    circuit.barrier(state, *ancillas)
    return circuit

def measure_syndrome_bit(circuit, qreg_data, qreg_measure, creg_measure):
    """
    Measure the syndrome by measuring the parity.
    We reset our ancilla qubits after measuring the stabilizer
    so we can reuse them for repeated stabilizer measurements.
    Because we have already observed the state of the qubit,
    we can write the conditional reset protocol directly to
    avoid another round of qubit measurement if we used
    the `reset` instruction.
    """
    circuit.cx(qreg_data[0], qreg_measure[0])
    circuit.cx(qreg_data[1], qreg_measure[0])
    circuit.cx(qreg_data[0], qreg_measure[1])
    circuit.cx(qreg_data[2], qreg_measure[1])
    circuit.barrier(*qreg_data, *qreg_measure)
    circuit.append(MidCircuitMeasure(), [qreg_measure[0]], [creg_measure[0]])
    circuit.append(MidCircuitMeasure(), [qreg_measure[1]], [creg_measure[1]])

    with circuit.if_test((creg_measure[0], 1)):
        circuit.x(qreg_measure[0])
    with circuit.if_test((creg_measure[1], 1)):
        circuit.x(qreg_measure[1])
    circuit.barrier(*qreg_data, *qreg_measure)
    return circuit

def apply_correction_bit(circuit, qreg_data, creg_syndrome):
    """We can detect where an error occurred and correct our state"""
    with circuit.if_test((creg_syndrome, 3)):
        circuit.x(qreg_data[0])
    with circuit.if_test((creg_syndrome, 1)):
        circuit.x(qreg_data[1])
    with circuit.if_test((creg_syndrome, 2)):
        circuit.x(qreg_data[2])
    circuit.barrier(qreg_data)
    return circuit

def apply_final_readout(circuit, qreg_data, creg_data):
    """Read out the final measurements"""
    circuit.barrier(qreg_data)
    circuit.measure(qreg_data, creg_data)
    return circuit
```

```python
def build_error_correction_sequence(apply_correction: bool) -> QuantumCircuit:
    circuit = build_qc()
    circuit = initialize_qubits(circuit)
    circuit = encode_bit_flip(circuit, state_data, ancillas_data)
    circuit = measure_syndrome_bit(
        circuit, qreg_data, qreg_measure, creg_syndrome
    )

    if apply_correction:
        circuit = apply_correction_bit(circuit, qreg_data, creg_syndrome)

    circuit = apply_final_readout(circuit, qreg_data, creg_data)
    return circuit

circuit = build_error_correction_sequence(apply_correction=True)
circuit.draw(output="mpl", style="iqp", cregbundle=False)
```

![Output of the previous code cell](/docs/images/tutorials/repetition-codes/extracted-outputs/dbe02949-0.avif)

![Output of the previous code cell](/docs/images/tutorials/repetition-codes/extracted-outputs/dbe02949-1.avif)

## Step 2. Optimize the problem for quantum execution {#step-2-optimize-the-problem-for-quantum-execution}

Upang mabawasan ang kabuuang oras ng pagpapatupad ng trabaho, ang mga Qiskit primitive ay tumatanggap lamang ng mga circuit at observable na sumusunod sa mga tagubilin at koneksyon na sinusuportahan ng target system (tinutukoy bilang instruction set architecture (ISA) circuit at observable).  [Matuto pa tungkol sa transpilation.](/guides/transpile)
### Generate ISA circuits {#generate-isa-circuits}

```python
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

pm = generate_preset_pass_manager(backend=backend, optimization_level=1)
isa_circuit = pm.run(circuit)

isa_circuit.draw("mpl", style="iqp", idle_wires=False)
```

![Output of the previous code cell](/docs/images/tutorials/repetition-codes/extracted-outputs/67b55eef-0.avif)

![Output of the previous code cell](/docs/images/tutorials/repetition-codes/extracted-outputs/67b55eef-1.avif)

```python
no_correction_circuit = build_error_correction_sequence(
    apply_correction=False
)

isa_no_correction_circuit = pm.run(no_correction_circuit)
```

## Step 3. Execute using Qiskit primitives {#step-3-execute-using-qiskit-primitives}
Patakbuhin ang bersyon na may correction at ang isa na walang correction.

```python
sampler_no_correction = Sampler(backend)
job_no_correction = sampler_no_correction.run(
    [isa_no_correction_circuit], shots=1000
)
result_no_correction = job_no_correction.result()[0]
```

```python
sampler_with_correction = Sampler(backend)

job_with_correction = sampler_with_correction.run([isa_circuit], shots=1000)
result_with_correction = job_with_correction.result()[0]
```

```python
print(f"Data (no correction):\n{result_no_correction.data.data.get_counts()}")
print(
    f"Syndrome (no correction):\n{result_no_correction.data.syndrome.get_counts()}"
)
```

```text
Data (no correction):
{'111': 878, '011': 42, '110': 35, '101': 40, '100': 1, '001': 2, '000': 2}
Syndrome (no correction):
{'00': 942, '10': 33, '01': 22, '11': 3}
```

```python
print(f"Data (corrected):\n{result_with_correction.data.data.get_counts()}")
print(
    f"Syndrome (corrected):\n{result_with_correction.data.syndrome.get_counts()}"
)
```

```text
Data (corrected):
{'111': 889, '110': 25, '000': 11, '011': 45, '101': 17, '010': 10, '001': 2, '100': 1}
Syndrome (corrected):
{'00': 929, '01': 39, '10': 20, '11': 12}
```

## Step 4. Post-process, return result in classical format {#step-4-post-process-return-result-in-classical-format}

Makikita ninyo na ang bit flip code ay nakadetekta at nakapagwasto ng maraming error, na nagresulta sa mas kaunting error sa kabuuan.

```python
def decode_result(data_counts, syndrome_counts):
    shots = sum(data_counts.values())
    success_trials = data_counts.get("000", 0) + data_counts.get("111", 0)
    failed_trials = shots - success_trials
    error_correction_events = shots - syndrome_counts.get("00", 0)
    print(
        f"Bit flip errors were detected/corrected on {error_correction_events}/{shots} trials."
    )
    print(
        f"A final parity error was detected on {failed_trials}/{shots} trials."
    )
```

```python
# non-corrected marginalized results
data_result = result_no_correction.data.data.get_counts()
marginalized_syndrome_result = result_no_correction.data.syndrome.get_counts()

print(
    f"Completed bit code experiment data measurement counts (no correction): {data_result}"
)
print(
    f"Completed bit code experiment syndrome measurement counts (no correction): {marginalized_syndrome_result}"
)
decode_result(data_result, marginalized_syndrome_result)
```

```text
Completed bit code experiment data measurement counts (no correction): {'111': 878, '011': 42, '110': 35, '101': 40, '100': 1, '001': 2, '000': 2}
Completed bit code experiment syndrome measurement counts (no correction): {'00': 942, '10': 33, '01': 22, '11': 3}
Bit flip errors were detected/corrected on 58/1000 trials.
A final parity error was detected on 120/1000 trials.
```

```python
# corrected marginalized results
corrected_data_result = result_with_correction.data.data.get_counts()
corrected_syndrome_result = result_with_correction.data.syndrome.get_counts()

print(
    f"Completed bit code experiment data measurement counts (corrected): {corrected_data_result}"
)
print(
    f"Completed bit code experiment syndrome measurement counts (corrected): {corrected_syndrome_result}"
)
decode_result(corrected_data_result, corrected_syndrome_result)
```

```text
Completed bit code experiment data measurement counts (corrected): {'111': 889, '110': 25, '000': 11, '011': 45, '101': 17, '010': 10, '001': 2, '100': 1}
Completed bit code experiment syndrome measurement counts (corrected): {'00': 929, '01': 39, '10': 20, '11': 12}
Bit flip errors were detected/corrected on 71/1000 trials.
A final parity error was detected on 100/1000 trials.
```

## Tutorial survey {#tutorial-survey}

Mangyaring sagutin ang maikling survey na ito upang magbigay ng feedback sa tutorial na ito. Ang inyong mga pananaw ay makakatulong sa amin na mapabuti ang aming mga content offering at karanasan ng user.

[Link to survey](https://your.feedback.ibm.com/jfe/form/SV_5onAlfA2Y7ac1FA)
